[#] parse_declaration, is_constructor=False, meet line: 'bool\n      operator!=(const _Tp& __x, const _Tp& __y)\n      { return !(__x == __y); }\n# 98 "/usr/include/c++/7/bits/stl_relops.h" 3\n    template <class _Tp>\n      inline bool\n      operator>(const _Tp'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      operator>(const _Tp& __x, const _Tp& __y)\n      { return __y < __x; }\n# 111 "/usr/include/c++/7/bits/stl_relops.h" 3\n    template <class _Tp>\n      inline bool\n      operator<=(const _Tp& _'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      operator<=(const _Tp& __x, const _Tp& __y)\n      { return !(__y < __x); }\n# 124 "/usr/include/c++/7/bits/stl_relops.h" 3\n    template <class _Tp>\n      inline bool\n      operator>=(const _T'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      operator>=(const _Tp& __x, const _Tp& __y)\n      { return !(__x < __y); }\n\n \n  }\n\n}\n# 70 "/usr/include/c++/7/utility" 2 3\n# 1 "/usr/include/c++/7/bits/stl_pair.h" 1 3\n# 59 "/usr/include/c++'
[#] parse_declaration, is_constructor=False, meet line: '_Tp*\n    __addressof(_Tp& __r) noexcept\n    { return __builtin_addressof(__r); }\n\n\n}\n\n\n# 1 "/usr/include/c++/7/type_traits" 1 3\n# 32 "/usr/include/c++/7/type_traits" 3\n       \n# 33 "/usr/include/c++/7'
[#] parse_declaration, is_constructor=False, meet line: '_Tp value = __v;\n      typedef _Tp value_type;\n      typedef integral_constant<_Tp, __v> type;\n      constexpr operator value_type() const noexcept { return value; }\n\n\n\n\n      constexpr value_type ope'
[#] parse_declaration, is_constructor=False, meet line: 'operator value_type() const noexcept { return value; }\n\n\n\n\n      constexpr value_type operator()() const noexcept { return value; }\n\n    };\n\n  template<typename _Tp, _Tp __v>\n    constexpr _Tp integra'
[#] parse_declaration, is_constructor=False, meet line: 'value_type operator()() const noexcept { return value; }\n\n    };\n\n  template<typename _Tp, _Tp __v>\n    constexpr _Tp integral_constant<_Tp, __v>::value;\n\n\n  typedef integral_constant<bool, true> true'
[#] parse_declaration, is_constructor=False, meet line: '_Tp integral_constant<_Tp, __v>::value;\n\n\n  typedef integral_constant<bool, true> true_type;\n\n\n  typedef integral_constant<bool, false> false_type;\n\n  template<bool __v>\n    using __bool_constant = in'
[#] parse_declaration, is_constructor=False, meet line: 'add_rvalue_reference<_Tp>::type declval() noexcept;\n\n  template<typename, unsigned = 0>\n    struct extent;\n\n  template<typename>\n    struct remove_all_extents;\n\n  template<typename _Tp>\n    struct __i'
[#] parse_declaration, is_constructor=False, meet line: 'true_type __test(int);\n\n    template<typename>\n      static false_type __test(...);\n  };\n\n  template<typename _Tp>\n    struct __is_destructible_impl\n    : public __do_is_destructible_impl\n    {\n      '
[#] parse_declaration, is_constructor=False, meet line: 'false_type __test(...);\n  };\n\n  template<typename _Tp>\n    struct __is_destructible_impl\n    : public __do_is_destructible_impl\n    {\n      typedef decltype(__test<_Tp>(0)) type;\n    };\n\n  template<ty'
[#] parse_declaration, is_constructor=False, meet line: 'integral_constant<bool, noexcept(declval<_Tp&>().~_Tp())>\n        __test(int);\n\n    template<typename>\n      static false_type __test(...);\n  };\n\n  template<typename _Tp>\n    struct __is_nt_destructib'
[#] parse_declaration, is_constructor=False, meet line: 'false_type __test(...);\n  };\n\n  template<typename _Tp>\n    struct __is_nt_destructible_impl\n    : public __do_is_nt_destructible_impl\n    {\n      typedef decltype(__test<_Tp>(0)) type;\n    };\n\n  templ'
[#] parse_declaration, is_constructor=False, meet line: 'true_type __test(int);\n\n    template<typename>\n      static false_type __test(...);\n  };\n\n  template<typename _Tp>\n    struct __is_default_constructible_impl\n    : public __do_is_default_constructible'
[#] parse_declaration, is_constructor=False, meet line: 'false_type __test(...);\n  };\n\n  template<typename _Tp>\n    struct __is_default_constructible_impl\n    : public __do_is_default_constructible_impl\n    {\n      typedef decltype(__test<_Tp>(0)) type;\n   '
[#] parse_declaration, is_constructor=False, meet line: 'true_type __test(int);\n\n    template<typename, typename>\n      static false_type __test(...);\n  };\n\n  template<typename _From, typename _To>\n    struct __is_static_castable_impl\n    : public __do_is_s'
[#] parse_declaration, is_constructor=False, meet line: 'false_type __test(...);\n  };\n\n  template<typename _From, typename _To>\n    struct __is_static_castable_impl\n    : public __do_is_static_castable_impl\n    {\n      typedef decltype(__test<_From, _To>(0)'
[#] parse_declaration, is_constructor=False, meet line: 'true_type __test(int);\n\n    template<typename, typename>\n      static false_type __test(...);\n  };\n\n  template<typename _Tp, typename _Arg>\n    struct __is_direct_constructible_impl\n    : public __do_'
[#] parse_declaration, is_constructor=False, meet line: 'false_type __test(...);\n  };\n\n  template<typename _Tp, typename _Arg>\n    struct __is_direct_constructible_impl\n    : public __do_is_direct_constructible_impl\n    {\n      typedef decltype(__test<_Tp, '
[#] parse_declaration, is_constructor=False, meet line: 'bool value = type::value;\n    };\n\n  template<typename _From, typename _To>\n    struct __is_base_to_derived_ref<_From, _To, false>\n    : public false_type\n    { };\n\n  template<typename _From, typename '
[#] parse_declaration, is_constructor=False, meet line: 'bool value = type::value;\n    };\n\n  template<typename _From, typename _To>\n    struct __is_lvalue_to_rvalue_ref<_From, _To, false>\n    : public false_type\n    { };\n\n\n\n\n\n\n\n  template<typename _Tp, type'
[#] parse_declaration, is_constructor=False, meet line: 'true_type __test(int);\n\n    template<typename, typename...>\n      static false_type __test(...);\n  };\n\n  template<typename _Tp, typename... _Args>\n    struct __is_nary_constructible_impl\n    : public '
[#] parse_declaration, is_constructor=False, meet line: 'false_type __test(...);\n  };\n\n  template<typename _Tp, typename... _Args>\n    struct __is_nary_constructible_impl\n    : public __do_is_nary_constructible_impl\n    {\n      typedef decltype(__test<_Tp, '
[#] parse_declaration, is_constructor=False, meet line: 'true_type\n __test(int);\n\n      template<typename, typename>\n static false_type\n __test(...);\n\n    public:\n      typedef decltype(__test<_Tp, _Up>(0)) type;\n    };\n\n\n  template<typename _Tp, typename _'
[#] parse_declaration, is_constructor=False, meet line: 'false_type\n __test(...);\n\n    public:\n      typedef decltype(__test<_Tp, _Up>(0)) type;\n    };\n\n\n  template<typename _Tp, typename _Up>\n    struct is_assignable\n      : public __is_assignable_helper<_'
[#] parse_declaration, is_constructor=False, meet line: 'void __helper(const _Tp&);\n\n    template <typename _Tp>\n    static true_type __test(const _Tp&,\n                            decltype(__helper<const _Tp&>({}))* = 0);\n\n    static false_type __test(...)'
[#] parse_declaration, is_constructor=False, meet line: 'true_type __test(const _Tp&,\n                            decltype(__helper<const _Tp&>({}))* = 0);\n\n    static false_type __test(...);\n  };\n\n  template<typename _Tp>\n    struct __is_implicitly_default'
[#] parse_declaration, is_constructor=False, meet line: 'false_type __test(...);\n  };\n\n  template<typename _Tp>\n    struct __is_implicitly_default_constructible_impl\n      : public __do_is_implicitly_default_constructible_impl\n  {\n    typedef decltype(__tes'
[#] parse_declaration, is_constructor=False, meet line: 'void __test_aux(_To1);\n\n      template<typename _From1, typename _To1,\n        typename = decltype(__test_aux<_To1>(std::declval<_From1>()))>\n static true_type\n __test(int);\n\n      template<typename, '
[#] parse_declaration, is_constructor=False, meet line: 'true_type\n __test(int);\n\n      template<typename, typename>\n static false_type\n __test(...);\n\n    public:\n      typedef decltype(__test<_From, _To>(0)) type;\n    };\n\n\n\n  template<typename _From, typen'
[#] parse_declaration, is_constructor=False, meet line: 'false_type\n __test(...);\n\n    public:\n      typedef decltype(__test<_From, _To>(0)) type;\n    };\n\n\n\n  template<typename _From, typename _To>\n    struct is_convertible\n    : public __is_convertible_hel'
[#] parse_declaration, is_constructor=False, meet line: 'bool __b0 = sizeof(_Tp) <= sizeof(__smallest);\n      static const bool __b1 = sizeof(_Tp) <= sizeof(unsigned short);\n      static const bool __b2 = sizeof(_Tp) <= sizeof(unsigned int);\n      static co'
[#] parse_declaration, is_constructor=False, meet line: 'bool __b1 = sizeof(_Tp) <= sizeof(unsigned short);\n      static const bool __b2 = sizeof(_Tp) <= sizeof(unsigned int);\n      static const bool __b3 = sizeof(_Tp) <= sizeof(unsigned long);\n      typede'
[#] parse_declaration, is_constructor=False, meet line: 'bool __b2 = sizeof(_Tp) <= sizeof(unsigned int);\n      static const bool __b3 = sizeof(_Tp) <= sizeof(unsigned long);\n      typedef conditional<__b3, unsigned long, unsigned long long> __cond3;\n      '
[#] parse_declaration, is_constructor=False, meet line: 'bool __b3 = sizeof(_Tp) <= sizeof(unsigned long);\n      typedef conditional<__b3, unsigned long, unsigned long long> __cond3;\n      typedef typename __cond3::type __cond3_type;\n      typedef condition'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned char __data[_Len];\n struct __attribute__((__aligned__)) { } __align;\n      };\n    };\n# 2036 "/usr/include/c++/7/type_traits" 3\n  template<std::size_t _Len, std::size_t _Align =\n    __alignof_'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned char __data[_Len];\n struct __attribute__((__aligned__((_Align)))) { } __align;\n      };\n    };\n\n  template <typename... _Types>\n    struct __strictest_alignment\n    {\n      static const size_'
[#] parse_declaration, is_constructor=False, meet line: 'size_t _S_alignment = 0;\n      static const size_t _S_size = 0;\n    };\n\n  template <typename _Tp, typename... _Types>\n    struct __strictest_alignment<_Tp, _Types...>\n    {\n      static const size_t _'
[#] parse_declaration, is_constructor=False, meet line: 'size_t _S_size = 0;\n    };\n\n  template <typename _Tp, typename... _Types>\n    struct __strictest_alignment<_Tp, _Types...>\n    {\n      static const size_t _S_alignment =\n        alignof(_Tp) > __stric'
[#] parse_declaration, is_constructor=False, meet line: 'size_t _S_alignment =\n        alignof(_Tp) > __strictest_alignment<_Types...>::_S_alignment\n ? alignof(_Tp) : __strictest_alignment<_Types...>::_S_alignment;\n      static const size_t _S_size =\n      '
[#] parse_declaration, is_constructor=False, meet line: 'size_t _S_size =\n        sizeof(_Tp) > __strictest_alignment<_Types...>::_S_size\n ? sizeof(_Tp) : __strictest_alignment<_Types...>::_S_size;\n    };\n# 2075 "/usr/include/c++/7/type_traits" 3\n  template'
[#] parse_declaration, is_constructor=False, meet line: 'size_t _S_len = _Len > __strictest::_S_size\n ? _Len : __strictest::_S_size;\n    public:\n\n      static const size_t alignment_value = __strictest::_S_alignment;\n\n      typedef typename aligned_storage<'
[#] parse_declaration, is_constructor=False, meet line: 'size_t alignment_value = __strictest::_S_alignment;\n\n      typedef typename aligned_storage<_S_len, alignment_value>::type type;\n    };\n\n  template <size_t _Len, typename... _Types>\n    const size_t a'
[#] parse_declaration, is_constructor=False, meet line: 'size_t aligned_union<_Len, _Types...>::alignment_value;\n\n\n\n  template<typename _Up,\n    bool _IsArray = is_array<_Up>::value,\n    bool _IsFunction = is_function<_Up>::value>\n    struct __decay_selecto'
[#] parse_declaration, is_constructor=False, meet line: '__success_type<typename decay<decltype\n       (true ? std::declval<_Tp>()\n        : std::declval<_Up>())>::type> _S_test(int);\n\n    template<typename, typename>\n      static __failure_type _S_test(...'
[#] parse_declaration, is_constructor=False, meet line: '__failure_type _S_test(...);\n  };\n\n  template<typename _Tp, typename _Up>\n    struct __common_type_impl\n    : private __do_common_type_impl\n    {\n      typedef decltype(_S_test<_Tp, _Up>(0)) type;\n   '
[#] parse_declaration, is_constructor=False, meet line: '__success_type<typename _Tp::type> _S_test(int);\n\n    template<typename>\n      static __failure_type _S_test(...);\n  };\n\n  template<typename _Tp>\n    struct __member_type_wrapper\n    : private __do_me'
[#] parse_declaration, is_constructor=False, meet line: '__failure_type _S_test(...);\n  };\n\n  template<typename _Tp>\n    struct __member_type_wrapper\n    : private __do_member_type_wrapper\n    {\n      typedef decltype(_S_test<_Tp>(0)) type;\n    };\n\n  templa'
[#] parse_declaration, is_constructor=False, meet line: 'bool __stop = false;\n      static typename add_rvalue_reference<_Tp>::type __delegate();\n    };\n\n  template<typename _Tp>\n    inline typename add_rvalue_reference<_Tp>::type\n    declval() noexcept\n   '
[#] parse_declaration, is_constructor=False, meet line: 'add_rvalue_reference<_Tp>::type __delegate();\n    };\n\n  template<typename _Tp>\n    inline typename add_rvalue_reference<_Tp>::type\n    declval() noexcept\n    {\n      static_assert(__declval_protector<'
[#] parse_declaration, is_constructor=False, meet line: 'add_rvalue_reference<_Tp>::type\n    declval() noexcept\n    {\n      static_assert(__declval_protector<_Tp>::__stop,\n      "declval() must not be used!");\n      return __declval_protector<_Tp>::__delega'
[#] parse_declaration, is_constructor=False, meet line: '__result_of_success<decltype(\n      (std::declval<_Tp1>().*std::declval<_Fp>())(std::declval<_Args>()...)\n      ), __invoke_memfun_ref> _S_test(int);\n\n    template<typename...>\n      static __failure_'
[#] parse_declaration, is_constructor=False, meet line: '__failure_type _S_test(...);\n  };\n\n  template<typename _MemPtr, typename _Arg, typename... _Args>\n    struct __result_of_memfun_ref\n    : private __result_of_memfun_ref_impl\n    {\n      typedef declty'
[#] parse_declaration, is_constructor=False, meet line: '__result_of_success<decltype(\n      ((*std::declval<_Tp1>()).*std::declval<_Fp>())(std::declval<_Args>()...)\n      ), __invoke_memfun_deref> _S_test(int);\n\n    template<typename...>\n      static __fai'
[#] parse_declaration, is_constructor=False, meet line: '__failure_type _S_test(...);\n  };\n\n  template<typename _MemPtr, typename _Arg, typename... _Args>\n    struct __result_of_memfun_deref\n    : private __result_of_memfun_deref_impl\n    {\n      typedef de'
[#] parse_declaration, is_constructor=False, meet line: '__result_of_success<decltype(\n      std::declval<_Tp1>().*std::declval<_Fp>()\n      ), __invoke_memobj_ref> _S_test(int);\n\n    template<typename, typename>\n      static __failure_type _S_test(...);\n  '
[#] parse_declaration, is_constructor=False, meet line: '__failure_type _S_test(...);\n  };\n\n  template<typename _MemPtr, typename _Arg>\n    struct __result_of_memobj_ref\n    : private __result_of_memobj_ref_impl\n    {\n      typedef decltype(_S_test<_MemPtr,'
[#] parse_declaration, is_constructor=False, meet line: '__result_of_success<decltype(\n      (*std::declval<_Tp1>()).*std::declval<_Fp>()\n      ), __invoke_memobj_deref> _S_test(int);\n\n    template<typename, typename>\n      static __failure_type _S_test(...'
[#] parse_declaration, is_constructor=False, meet line: '__failure_type _S_test(...);\n  };\n\n  template<typename _MemPtr, typename _Arg>\n    struct __result_of_memobj_deref\n    : private __result_of_memobj_deref_impl\n    {\n      typedef decltype(_S_test<_Mem'
[#] parse_declaration, is_constructor=False, meet line: '__result_of_success<decltype(\n      std::declval<_Fn>()(std::declval<_Args>()...)\n      ), __invoke_other> _S_test(int);\n\n    template<typename...>\n      static __failure_type _S_test(...);\n  };\n\n  te'
[#] parse_declaration, is_constructor=False, meet line: '__failure_type _S_test(...);\n  };\n\n  template<typename _Functor, typename... _ArgTypes>\n    struct __result_of_impl<false, false, _Functor, _ArgTypes...>\n    : private __result_of_other_impl\n    {\n   '
[#] parse_declaration, is_constructor=False, meet line: 'enable_if<__and_<__not_<__is_tuple_like<_Tp>>,\n         is_move_constructible<_Tp>,\n         is_move_assignable<_Tp>>::value>::type\n    swap(_Tp&, _Tp&)\n    noexcept(__and_<is_nothrow_move_constructib'
[#] parse_declaration, is_constructor=False, meet line: 'enable_if<__is_swappable<_Tp>::value>::type\n    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])\n    noexcept(__is_nothrow_swappable<_Tp>::value);\n\n  namespace __swappable_details {\n    using std::swap;\n\n    st'
[#] parse_declaration, is_constructor=False, meet line: 'true_type __test(int);\n\n      template<typename>\n        static false_type __test(...);\n    };\n\n    struct __do_is_nothrow_swappable_impl\n    {\n      template<typename _Tp>\n        static __bool_const'
[#] parse_declaration, is_constructor=False, meet line: 'false_type __test(...);\n    };\n\n    struct __do_is_nothrow_swappable_impl\n    {\n      template<typename _Tp>\n        static __bool_constant<\n          noexcept(swap(std::declval<_Tp&>(), std::declval<'
[#] parse_declaration, is_constructor=False, meet line: '__bool_constant<\n          noexcept(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))\n        > __test(int);\n\n      template<typename>\n        static false_type __test(...);\n    };\n\n  }\n\n  template<ty'
[#] parse_declaration, is_constructor=False, meet line: 'false_type __test(...);\n    };\n\n  }\n\n  template<typename _Tp>\n    struct __is_swappable_impl\n    : public __swappable_details::__do_is_swappable_impl\n    {\n      typedef decltype(__test<_Tp>(0)) type;'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_swappable_v =\n      is_swappable<_Tp>::value;\n\n\n  template<typename _Tp>\n    constexpr bool is_nothrow_swappable_v =\n      is_nothrow_swappable<_Tp>::value;\n\n\n  namespace __swappable_with_deta'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_nothrow_swappable_v =\n      is_nothrow_swappable<_Tp>::value;\n\n\n  namespace __swappable_with_details {\n    using std::swap;\n\n    struct __do_is_swappable_with_impl\n    {\n      template<typenam'
[#] parse_declaration, is_constructor=False, meet line: 'true_type __test(int);\n\n      template<typename, typename>\n        static false_type __test(...);\n    };\n\n    struct __do_is_nothrow_swappable_with_impl\n    {\n      template<typename _Tp, typename _Up'
[#] parse_declaration, is_constructor=False, meet line: 'false_type __test(...);\n    };\n\n    struct __do_is_nothrow_swappable_with_impl\n    {\n      template<typename _Tp, typename _Up>\n        static __bool_constant<\n          noexcept(swap(std::declval<_Tp'
[#] parse_declaration, is_constructor=False, meet line: '__bool_constant<\n          noexcept(swap(std::declval<_Tp>(), std::declval<_Up>()))\n          &&\n          noexcept(swap(std::declval<_Up>(), std::declval<_Tp>()))\n        > __test(int);\n\n      templa'
[#] parse_declaration, is_constructor=False, meet line: 'false_type __test(...);\n    };\n\n  }\n\n  template<typename _Tp, typename _Up>\n    struct __is_swappable_with_impl\n    : public __swappable_with_details::__do_is_swappable_with_impl\n    {\n      typedef d'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_swappable_with_v =\n      is_swappable_with<_Tp, _Up>::value;\n\n\n  template<typename _Tp, typename _Up>\n    constexpr bool is_nothrow_swappable_with_v =\n      is_nothrow_swappable_with<_Tp, _Up>'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_nothrow_swappable_with_v =\n      is_nothrow_swappable_with<_Tp, _Up>::value;\n\n\n\n\n\n\n  template<typename _Result, typename _Ret, typename = void>\n    struct __is_invocable_impl : false_type { };'
[#] parse_declaration, is_constructor=False, meet line: 'bool __call_is_nt(__invoke_memfun_ref)\n    {\n      using _Up = typename __inv_unwrap<_Tp>::type;\n      return noexcept((std::declval<_Up>().*std::declval<_Fn>())(\n     std::declval<_Args>()...));\n    '
[#] parse_declaration, is_constructor=False, meet line: 'bool __call_is_nt(__invoke_memfun_deref)\n    {\n      return noexcept(((*std::declval<_Tp>()).*std::declval<_Fn>())(\n     std::declval<_Args>()...));\n    }\n\n  template<typename _Fn, typename _Tp>\n    c'
[#] parse_declaration, is_constructor=False, meet line: 'bool __call_is_nt(__invoke_memobj_ref)\n    {\n      using _Up = typename __inv_unwrap<_Tp>::type;\n      return noexcept(std::declval<_Up>().*std::declval<_Fn>());\n    }\n\n  template<typename _Fn, typena'
[#] parse_declaration, is_constructor=False, meet line: 'bool __call_is_nt(__invoke_memobj_deref)\n    {\n      return noexcept((*std::declval<_Tp>()).*std::declval<_Fn>());\n    }\n\n  template<typename _Fn, typename... _Args>\n    constexpr bool __call_is_nt(__'
[#] parse_declaration, is_constructor=False, meet line: 'bool __call_is_nt(__invoke_other)\n    {\n      return noexcept(std::declval<_Fn>()(std::declval<_Args>()...));\n    }\n\n  template<typename _Result, typename _Fn, typename... _Args>\n    struct __call_is_'
[#] parse_declaration, is_constructor=True, meet line: '__nonesuch() = delete;\n    ~__nonesuch() = delete;\n    __nonesuch(__nonesuch const&) = delete;\n    void operator=(__nonesuch const&) = delete;\n  };\n# 3108 "/usr/include/c++/7/type_traits" 3\n\n}\n# 55 "/'
[#] parse_declaration, is_constructor=True, meet line: '__nonesuch() = delete;\n    __nonesuch(__nonesuch const&) = delete;\n    void operator=(__nonesuch const&) = delete;\n  };\n# 3108 "/usr/include/c++/7/type_traits" 3\n\n}\n# 55 "/usr/include/c++/7/bits/move.'
[#] parse_declaration, is_constructor=True, meet line: '__nonesuch(__nonesuch const&) = delete;\n    void operator=(__nonesuch const&) = delete;\n  };\n# 3108 "/usr/include/c++/7/type_traits" 3\n\n}\n# 55 "/usr/include/c++/7/bits/move.h" 2 3\n\nnamespace std __att'
[#] parse_declaration, is_constructor=False, meet line: 'void operator=(__nonesuch const&) = delete;\n  };\n# 3108 "/usr/include/c++/7/type_traits" 3\n\n}\n# 55 "/usr/include/c++/7/bits/move.h" 2 3\n\nnamespace std __attribute__ ((__visibility__ ("default")))\n{\n\n#'
[#] parse_declaration, is_constructor=False, meet line: '_Tp&&\n    forward(typename std::remove_reference<_Tp>::type& __t) noexcept\n    { return static_cast<_Tp&&>(__t); }\n\n\n\n\n\n\n\n  template<typename _Tp>\n    constexpr _Tp&&\n    forward(typename std::remove_'
[#] parse_declaration, is_constructor=False, meet line: '_Tp&&\n    forward(typename std::remove_reference<_Tp>::type&& __t) noexcept\n    {\n      static_assert(!std::is_lvalue_reference<_Tp>::value, "template argument"\n      " substituting _Tp is an lvalue r'
[#] parse_declaration, is_constructor=False, meet line: 'std::remove_reference<_Tp>::type&&\n    move(_Tp&& __t) noexcept\n    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }\n\n\n  template<typename _Tp>\n    struct __move_if_noexcept_c'
[#] parse_declaration, is_constructor=False, meet line: 'conditional<__move_if_noexcept_cond<_Tp>::value, const _Tp&, _Tp&&>::type\n    move_if_noexcept(_Tp& __x) noexcept\n    { return std::move(__x); }\n# 135 "/usr/include/c++/7/bits/move.h" 3\n  template<typ'
[#] parse_declaration, is_constructor=False, meet line: '_Tp*\n    addressof(_Tp& __r) noexcept\n    { return std::__addressof(__r); }\n\n\n\n  template<typename _Tp>\n    const _Tp* addressof(const _Tp&&) = delete;\n\n\n  template <typename _Tp, typename _Up = _Tp>\n'
[#] parse_declaration, is_constructor=False, meet line: '_Tp* addressof(const _Tp&&) = delete;\n\n\n  template <typename _Tp, typename _Up = _Tp>\n    inline _Tp\n    __exchange(_Tp& __obj, _Up&& __new_val)\n    {\n      _Tp __old_val = std::move(__obj);\n      __o'
[#] parse_declaration, is_constructor=False, meet line: '_Tp\n    __exchange(_Tp& __obj, _Up&& __new_val)\n    {\n      _Tp __old_val = std::move(__obj);\n      __obj = std::forward<_Up>(__new_val);\n      return __old_val;\n    }\n\n\n\n}\n# 166 "/usr/include/c++/7/b'
[#] parse_declaration, is_constructor=False, meet line: 'enable_if<__and_<__not_<__is_tuple_like<_Tp>>,\n         is_move_constructible<_Tp>,\n         is_move_assignable<_Tp>>::value>::type\n    swap(_Tp& __a, _Tp& __b)\n    noexcept(__and_<is_nothrow_move_con'
[#] parse_declaration, is_constructor=False, meet line: 'enable_if<__is_swappable<_Tp>::value>::type\n    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])\n    noexcept(__is_nothrow_swappable<_Tp>::value)\n\n\n\n\n    {\n      for (size_t __n = 0; __n < _Nm; ++__n)\n swap(__a'
[#] parse_declaration, is_constructor=True, meet line: 'piecewise_construct_t() = default; };\n\n\n  constexpr piecewise_construct_t piecewise_construct =\n    piecewise_construct_t();\n\n\n  template<typename...>\n    class tuple;\n\n  template<std::size_t...>\n    '
[#] parse_declaration, is_constructor=False, meet line: 'piecewise_construct_t piecewise_construct =\n    piecewise_construct_t();\n\n\n  template<typename...>\n    class tuple;\n\n  template<std::size_t...>\n    struct _Index_tuple;\n\n\n\n\n\n\n  template <bool, typenam'
[#] parse_declaration, is_constructor=False, meet line: 'bool _ConstructiblePair()\n      {\n return __and_<is_constructible<_T1, const _U1&>,\n        is_constructible<_T2, const _U2&>>::value;\n      }\n\n      template <typename _U1, typename _U2>\n      static'
[#] parse_declaration, is_constructor=False, meet line: 'bool _ImplicitlyConvertiblePair()\n      {\n return __and_<is_convertible<const _U1&, _T1>,\n        is_convertible<const _U2&, _T2>>::value;\n      }\n\n      template <typename _U1, typename _U2>\n      st'
[#] parse_declaration, is_constructor=False, meet line: 'bool _MoveConstructiblePair()\n      {\n return __and_<is_constructible<_T1, _U1&&>,\n        is_constructible<_T2, _U2&&>>::value;\n      }\n\n      template <typename _U1, typename _U2>\n      static const'
[#] parse_declaration, is_constructor=False, meet line: 'bool _ImplicitlyMoveConvertiblePair()\n      {\n return __and_<is_convertible<_U1&&, _T1>,\n        is_convertible<_U2&&, _T2>>::value;\n      }\n\n      template <bool __implicit, typename _U1, typename _U'
[#] parse_declaration, is_constructor=False, meet line: 'bool _CopyMovePair()\n      {\n using __do_converts = __and_<is_convertible<const _U1&, _T1>,\n      is_convertible<_U2&&, _T2>>;\n using __converts = typename conditional<__implicit,\n           __do_conv'
[#] parse_declaration, is_constructor=False, meet line: 'bool _MoveCopyPair()\n      {\n using __do_converts = __and_<is_convertible<_U1&&, _T1>,\n      is_convertible<const _U2&, _T2>>;\n using __converts = typename conditional<__implicit,\n           __do_conv'
[#] parse_declaration, is_constructor=False, meet line: 'bool _ConstructiblePair()\n      {\n return false;\n      }\n\n      template <typename _U1, typename _U2>\n      static constexpr bool _ImplicitlyConvertiblePair()\n      {\n return false;\n      }\n\n      tem'
[#] parse_declaration, is_constructor=False, meet line: 'bool _ImplicitlyConvertiblePair()\n      {\n return false;\n      }\n\n      template <typename _U1, typename _U2>\n      static constexpr bool _MoveConstructiblePair()\n      {\n return false;\n      }\n\n     '
[#] parse_declaration, is_constructor=False, meet line: 'bool _MoveConstructiblePair()\n      {\n return false;\n      }\n\n      template <typename _U1, typename _U2>\n      static constexpr bool _ImplicitlyMoveConvertiblePair()\n      {\n return false;\n      }\n  '
[#] parse_declaration, is_constructor=False, meet line: 'bool _ImplicitlyMoveConvertiblePair()\n      {\n return false;\n      }\n  };\n\n\n\n\n  struct __nonesuch_no_braces : std::__nonesuch {\n    explicit __nonesuch_no_braces(const __nonesuch&) = delete;\n  };\n\n\n  '
[#] parse_declaration, is_constructor=True, meet line: '__nonesuch_no_braces(const __nonesuch&) = delete;\n  };\n\n\n  template<typename _U1, typename _U2> class __pair_base\n  {\n\n    template<typename _T1, typename _T2> friend struct pair;\n    __pair_base() = '
[#] parse_declaration, is_constructor=True, meet line: '__pair_base() = default;\n    ~__pair_base() = default;\n    __pair_base(const __pair_base&) = default;\n    __pair_base& operator=(const __pair_base&) = delete;\n\n  };\n\n\n\n\n\n\n\n  template<typename _T1, typ'
[#] parse_declaration, is_constructor=True, meet line: '__pair_base() = default;\n    __pair_base(const __pair_base&) = default;\n    __pair_base& operator=(const __pair_base&) = delete;\n\n  };\n\n\n\n\n\n\n\n  template<typename _T1, typename _T2>\n    struct pair\n   '
[#] parse_declaration, is_constructor=True, meet line: '__pair_base(const __pair_base&) = default;\n    __pair_base& operator=(const __pair_base&) = delete;\n\n  };\n\n\n\n\n\n\n\n  template<typename _T1, typename _T2>\n    struct pair\n    : private __pair_base<_T1, _'
[#] parse_declaration, is_constructor=True, meet line: '__pair_base& operator=(const __pair_base&) = delete;\n\n  };\n\n\n\n\n\n\n\n  template<typename _T1, typename _T2>\n    struct pair\n    : private __pair_base<_T1, _T2>\n    {\n      typedef _T1 first_type;\n      t'
[#] parse_declaration, is_constructor=False, meet line: '_T1 first;\n      _T2 second;\n\n\n\n\n\n\n      template <typename _U1 = _T1,\n                typename _U2 = _T2,\n                typename enable_if<__and_<\n                                     __is_implicit'
[#] parse_declaration, is_constructor=False, meet line: '_T2 second;\n\n\n\n\n\n\n      template <typename _U1 = _T1,\n                typename _U2 = _T2,\n                typename enable_if<__and_<\n                                     __is_implicitly_default_constr'
[#] parse_declaration, is_constructor=True, meet line: 'pair()\n      : first(), second() { }\n\n\n      template <typename _U1 = _T1,\n                typename _U2 = _T2,\n                typename enable_if<__and_<\n                       is_default_constructibl'
[#] parse_declaration, is_constructor=True, meet line: 'pair()\n      : first(), second() { }\n# 252 "/usr/include/c++/7/bits/stl_pair.h" 3\n      using _PCCP = _PCC<true, _T1, _T2>;\n\n      template<typename _U1 = _T1, typename _U2=_T2, typename\n        enabl'
[#] parse_declaration, is_constructor=True, meet line: 'pair(const _T1& __a, const _T2& __b)\n      : first(__a), second(__b) { }\n\n       template<typename _U1 = _T1, typename _U2=_T2, typename\n  enable_if<_PCCP::template\n       _ConstructiblePair<_U1, _U2>'
[#] parse_declaration, is_constructor=True, meet line: 'pair(const _T1& __a, const _T2& __b)\n      : first(__a), second(__b) { }\n# 280 "/usr/include/c++/7/bits/stl_pair.h" 3\n      template <typename _U1, typename _U2>\n        using _PCCFP = _PCC<!is_same<_'
[#] parse_declaration, is_constructor=True, meet line: 'pair(const pair<_U1, _U2>& __p)\n        : first(__p.first), second(__p.second) { }\n\n      template<typename _U1, typename _U2, typename\n        enable_if<_PCCFP<_U1, _U2>::template\n      _Constructibl'
[#] parse_declaration, is_constructor=True, meet line: 'pair(const pair<_U1, _U2>& __p)\n : first(__p.first), second(__p.second) { }\n\n      constexpr pair(const pair&) = default;\n      constexpr pair(pair&&) = default;\n\n\n      template<typename _U1, typenam'
[#] parse_declaration, is_constructor=True, meet line: 'pair(const pair&) = default;\n      constexpr pair(pair&&) = default;\n\n\n      template<typename _U1, typename\n        enable_if<_PCCP::template\n      _MoveCopyPair<true, _U1, _T2>(),\n                  '
[#] parse_declaration, is_constructor=True, meet line: 'pair(pair&&) = default;\n\n\n      template<typename _U1, typename\n        enable_if<_PCCP::template\n      _MoveCopyPair<true, _U1, _T2>(),\n                         bool>::type=true>\n       constexpr pai'
[#] parse_declaration, is_constructor=True, meet line: 'pair(_U1&& __x, const _T2& __y)\n       : first(std::forward<_U1>(__x)), second(__y) { }\n\n      template<typename _U1, typename\n        enable_if<_PCCP::template\n      _MoveCopyPair<false, _U1, _T2>(),'
[#] parse_declaration, is_constructor=True, meet line: 'pair(_U1&& __x, const _T2& __y)\n       : first(std::forward<_U1>(__x)), second(__y) { }\n\n      template<typename _U2, typename\n        enable_if<_PCCP::template\n      _CopyMovePair<true, _T1, _U2>(),\n'
[#] parse_declaration, is_constructor=True, meet line: 'pair(const _T1& __x, _U2&& __y)\n       : first(__x), second(std::forward<_U2>(__y)) { }\n\n      template<typename _U2, typename\n        enable_if<_PCCP::template\n      _CopyMovePair<false, _T1, _U2>(),'
[#] parse_declaration, is_constructor=True, meet line: 'pair(const _T1& __x, _U2&& __y)\n       : first(__x), second(std::forward<_U2>(__y)) { }\n\n      template<typename _U1, typename _U2, typename\n        enable_if<_PCCP::template\n      _MoveConstructibleP'
[#] parse_declaration, is_constructor=True, meet line: 'pair(_U1&& __x, _U2&& __y)\n : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }\n\n      template<typename _U1, typename _U2, typename\n        enable_if<_PCCP::template\n      _MoveConstr'
[#] parse_declaration, is_constructor=True, meet line: 'pair(_U1&& __x, _U2&& __y)\n : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }\n\n\n      template<typename _U1, typename _U2, typename\n        enable_if<_PCCFP<_U1, _U2>::template\n     '
[#] parse_declaration, is_constructor=True, meet line: 'pair(pair<_U1, _U2>&& __p)\n : first(std::forward<_U1>(__p.first)),\n   second(std::forward<_U2>(__p.second)) { }\n\n      template<typename _U1, typename _U2, typename\n        enable_if<_PCCFP<_U1, _U2>:'
[#] parse_declaration, is_constructor=True, meet line: 'pair(pair<_U1, _U2>&& __p)\n : first(std::forward<_U1>(__p.first)),\n   second(std::forward<_U2>(__p.second)) { }\n\n      template<typename... _Args1, typename... _Args2>\n        pair(piecewise_construct'
[#] parse_declaration, is_constructor=True, meet line: 'pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);\n\n      pair&\n      operator=(typename conditional<\n  __and_<is_copy_assignable<_T1>,\n         is_copy_assignable<_T2>>::value,\n  const '
[#] parse_declaration, is_constructor=True, meet line: 'pair&\n      operator=(typename conditional<\n  __and_<is_copy_assignable<_T1>,\n         is_copy_assignable<_T2>>::value,\n  const pair&, const __nonesuch_no_braces&>::type __p)\n      {\n first = __p.firs'
[#] parse_declaration, is_constructor=True, meet line: 'pair&\n      operator=(typename conditional<\n  __and_<is_move_assignable<_T1>,\n         is_move_assignable<_T2>>::value,\n  pair&&, __nonesuch_no_braces&&>::type __p)\n      noexcept(__and_<is_nothrow_mo'
[#] parse_declaration, is_constructor=False, meet line: 'enable_if<__and_<is_assignable<_T1&, const _U1&>,\n    is_assignable<_T2&, const _U2&>>::value,\n    pair&>::type\n operator=(const pair<_U1, _U2>& __p)\n {\n   first = __p.first;\n   second = __p.second;\n '
[#] parse_declaration, is_constructor=False, meet line: 'enable_if<__and_<is_assignable<_T1&, _U1&&>,\n    is_assignable<_T2&, _U2&&>>::value,\n    pair&>::type\n operator=(pair<_U1, _U2>&& __p)\n {\n   first = std::forward<_U1>(__p.first);\n   second = std::forw'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      swap(pair& __p)\n      noexcept(__and_<__is_nothrow_swappable<_T1>,\n                      __is_nothrow_swappable<_T2>>::value)\n      {\n using std::swap;\n swap(first, __p.first);\n swap(second'
[#] parse_declaration, is_constructor=True, meet line: 'pair(tuple<_Args1...>&, tuple<_Args2...>&,\n             _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);\n\n    };\n\n\n\n\n\n\n  template<typename _T1, typename _T2>\n    inline constexpr bool\n    oper'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)\n    { return __x.first == __y.first && __x.second == __y.second; }\n\n\n  template<typename _T1, typename _T2>\n    inline constex'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)\n    { return __x.first < __y.first\n      || (!(__y.first < __x.first) && __x.second < __y.second); }\n\n\n  template<typename _T1,'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)\n    { return !(__x == __y); }\n\n\n  template<typename _T1, typename _T2>\n    inline constexpr bool\n    operator>(const pair<_T1,'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)\n    { return __y < __x; }\n\n\n  template<typename _T1, typename _T2>\n    inline constexpr bool\n    operator<=(const pair<_T1, _T2'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)\n    { return !(__y < __x); }\n\n\n  template<typename _T1, typename _T2>\n    inline constexpr bool\n    operator>=(const pair<_T1,'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)\n    { return !(__x < __y); }\n\n\n\n\n\n  template<typename _T1, typename _T2>\n    inline\n\n\n    typename enable_if<__and_<__is_swapp'
[#] parse_declaration, is_constructor=False, meet line: 'enable_if<__and_<__is_swappable<_T1>,\n                              __is_swappable<_T2>>::value>::type\n\n\n\n    swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)\n    noexcept(noexcept(__x.swap(__y)))\n    {'
[#] parse_declaration, is_constructor=False, meet line: 'enable_if<!__and_<__is_swappable<_T1>,\n          __is_swappable<_T2>>::value>::type\n    swap(pair<_T1, _T2>&, pair<_T1, _T2>&) = delete;\n# 521 "/usr/include/c++/7/bits/stl_pair.h" 3\n  template<typenam'
[#] parse_declaration, is_constructor=False, meet line: 'pair<typename __decay_and_strip<_T1>::__type,\n                   typename __decay_and_strip<_T2>::__type>\n    make_pair(_T1&& __x, _T2&& __y)\n    {\n      typedef typename __decay_and_strip<_T1>::__typ'
[#] parse_declaration, is_constructor=False, meet line: 'iterator _M_array;\n      size_type _M_len;\n\n\n      constexpr initializer_list(const_iterator __a, size_type __l)\n      : _M_array(__a), _M_len(__l) { }\n\n    public:\n      constexpr initializer_list() '
[#] parse_declaration, is_constructor=False, meet line: 'size_type _M_len;\n\n\n      constexpr initializer_list(const_iterator __a, size_type __l)\n      : _M_array(__a), _M_len(__l) { }\n\n    public:\n      constexpr initializer_list() noexcept\n      : _M_array'
[#] parse_declaration, is_constructor=True, meet line: 'initializer_list(const_iterator __a, size_type __l)\n      : _M_array(__a), _M_len(__l) { }\n\n    public:\n      constexpr initializer_list() noexcept\n      : _M_array(0), _M_len(0) { }\n\n\n      constexpr'
[#] parse_declaration, is_constructor=True, meet line: 'initializer_list() noexcept\n      : _M_array(0), _M_len(0) { }\n\n\n      constexpr size_type\n      size() const noexcept { return _M_len; }\n\n\n      constexpr const_iterator\n      begin() const noexcept '
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      size() const noexcept { return _M_len; }\n\n\n      constexpr const_iterator\n      begin() const noexcept { return _M_array; }\n\n\n      constexpr const_iterator\n      end() const noexcept '
[#] parse_declaration, is_constructor=False, meet line: 'const_iterator\n      begin() const noexcept { return _M_array; }\n\n\n      constexpr const_iterator\n      end() const noexcept { return begin() + size(); }\n    };\n\n\n\n\n\n\n  template<class _Tp>\n    constex'
[#] parse_declaration, is_constructor=False, meet line: 'const_iterator\n      end() const noexcept { return begin() + size(); }\n    };\n\n\n\n\n\n\n  template<class _Tp>\n    constexpr const _Tp*\n    begin(initializer_list<_Tp> __ils) noexcept\n    { return __ils.be'
[#] parse_declaration, is_constructor=False, meet line: '_Tp*\n    begin(initializer_list<_Tp> __ils) noexcept\n    { return __ils.begin(); }\n\n\n\n\n\n\n  template<class _Tp>\n    constexpr const _Tp*\n    end(initializer_list<_Tp> __ils) noexcept\n    { return __ils'
[#] parse_declaration, is_constructor=False, meet line: '_Tp*\n    end(initializer_list<_Tp> __ils) noexcept\n    { return __ils.end(); }\n}\n\n#pragma GCC visibility pop\n# 77 "/usr/include/c++/7/utility" 2 3\n\nnamespace std __attribute__ ((__visibility__ ("defau'
[#] parse_declaration, is_constructor=False, meet line: '_Tp1&\n        __get(std::pair<_Tp1, _Tp2>& __pair) noexcept\n        { return __pair.first; }\n\n      template<typename _Tp1, typename _Tp2>\n        static constexpr _Tp1&&\n        __move_get(std::pair<'
[#] parse_declaration, is_constructor=False, meet line: '_Tp1&&\n        __move_get(std::pair<_Tp1, _Tp2>&& __pair) noexcept\n        { return std::forward<_Tp1>(__pair.first); }\n\n      template<typename _Tp1, typename _Tp2>\n        static constexpr const _Tp'
[#] parse_declaration, is_constructor=False, meet line: '_Tp1&\n        __const_get(const std::pair<_Tp1, _Tp2>& __pair) noexcept\n        { return __pair.first; }\n    };\n\n  template<>\n    struct __pair_get<1>\n    {\n      template<typename _Tp1, typename _Tp2'
[#] parse_declaration, is_constructor=False, meet line: '_Tp2&\n        __get(std::pair<_Tp1, _Tp2>& __pair) noexcept\n        { return __pair.second; }\n\n      template<typename _Tp1, typename _Tp2>\n        static constexpr _Tp2&&\n        __move_get(std::pair'
[#] parse_declaration, is_constructor=False, meet line: '_Tp2&&\n        __move_get(std::pair<_Tp1, _Tp2>&& __pair) noexcept\n        { return std::forward<_Tp2>(__pair.second); }\n\n      template<typename _Tp1, typename _Tp2>\n        static constexpr const _T'
[#] parse_declaration, is_constructor=False, meet line: '_Tp2&\n        __const_get(const std::pair<_Tp1, _Tp2>& __pair) noexcept\n        { return __pair.second; }\n    };\n\n  template<std::size_t _Int, class _Tp1, class _Tp2>\n    constexpr typename tuple_elem'
[#] parse_declaration, is_constructor=False, meet line: 'tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&\n    get(std::pair<_Tp1, _Tp2>& __in) noexcept\n    { return __pair_get<_Int>::__get(__in); }\n\n  template<std::size_t _Int, class _Tp1, class _Tp2>\n    '
[#] parse_declaration, is_constructor=False, meet line: 'tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&&\n    get(std::pair<_Tp1, _Tp2>&& __in) noexcept\n    { return __pair_get<_Int>::__move_get(std::move(__in)); }\n\n  template<std::size_t _Int, class _Tp1'
[#] parse_declaration, is_constructor=False, meet line: 'tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&\n    get(const std::pair<_Tp1, _Tp2>& __in) noexcept\n    { return __pair_get<_Int>::__const_get(__in); }\n\n\n\n\n\n  template <typename _Tp, typename _Up>\n '
[#] parse_declaration, is_constructor=False, meet line: '_Tp&\n    get(pair<_Tp, _Up>& __p) noexcept\n    { return __p.first; }\n\n  template <typename _Tp, typename _Up>\n    constexpr const _Tp&\n    get(const pair<_Tp, _Up>& __p) noexcept\n    { return __p.firs'
[#] parse_declaration, is_constructor=False, meet line: '_Tp&\n    get(const pair<_Tp, _Up>& __p) noexcept\n    { return __p.first; }\n\n  template <typename _Tp, typename _Up>\n    constexpr _Tp&&\n    get(pair<_Tp, _Up>&& __p) noexcept\n    { return std::move(__'
[#] parse_declaration, is_constructor=False, meet line: '_Tp&&\n    get(pair<_Tp, _Up>&& __p) noexcept\n    { return std::move(__p.first); }\n\n  template <typename _Tp, typename _Up>\n    constexpr _Tp&\n    get(pair<_Up, _Tp>& __p) noexcept\n    { return __p.sec'
[#] parse_declaration, is_constructor=False, meet line: '_Tp&\n    get(pair<_Up, _Tp>& __p) noexcept\n    { return __p.second; }\n\n  template <typename _Tp, typename _Up>\n    constexpr const _Tp&\n    get(const pair<_Up, _Tp>& __p) noexcept\n    { return __p.sec'
[#] parse_declaration, is_constructor=False, meet line: '_Tp&\n    get(const pair<_Up, _Tp>& __p) noexcept\n    { return __p.second; }\n\n  template <typename _Tp, typename _Up>\n    constexpr _Tp&&\n    get(pair<_Up, _Tp>&& __p) noexcept\n    { return std::move(_'
[#] parse_declaration, is_constructor=False, meet line: '_Tp&&\n    get(pair<_Up, _Tp>&& __p) noexcept\n    { return std::move(__p.second); }\n\n\n\n\n  template <typename _Tp, typename _Up = _Tp>\n    inline _Tp\n    exchange(_Tp& __obj, _Up&& __new_val)\n    { retu'
[#] parse_declaration, is_constructor=False, meet line: '_Tp\n    exchange(_Tp& __obj, _Up&& __new_val)\n    { return std::__exchange(__obj, std::forward<_Up>(__new_val)); }\n\n\n\n\n  template<size_t... _Indexes> struct _Index_tuple { };\n\n\n  template<typename _It'
[#] parse_declaration, is_constructor=False, meet line: 'size_t size() noexcept { return sizeof...(_Idx); }\n    };\n\n  template<typename _Tp, _Tp _Num,\n    typename _ISeq = typename _Build_index_tuple<_Num>::__type>\n    struct _Make_integer_sequence;\n\n  temp'
[#] parse_declaration, is_constructor=False, meet line: 'void\n  __throw_bad_exception(void) __attribute__((__noreturn__));\n\n\n  void\n  __throw_bad_alloc(void) __attribute__((__noreturn__));\n\n\n  void\n  __throw_bad_cast(void) __attribute__((__noreturn__));\n\n  '
[#] parse_declaration, is_constructor=False, meet line: 'void\n  __throw_bad_alloc(void) __attribute__((__noreturn__));\n\n\n  void\n  __throw_bad_cast(void) __attribute__((__noreturn__));\n\n  void\n  __throw_bad_typeid(void) __attribute__((__noreturn__));\n\n\n  voi'
[#] parse_declaration, is_constructor=False, meet line: 'void\n  __throw_bad_cast(void) __attribute__((__noreturn__));\n\n  void\n  __throw_bad_typeid(void) __attribute__((__noreturn__));\n\n\n  void\n  __throw_logic_error(const char*) __attribute__((__noreturn__))'
[#] parse_declaration, is_constructor=False, meet line: 'void\n  __throw_bad_typeid(void) __attribute__((__noreturn__));\n\n\n  void\n  __throw_logic_error(const char*) __attribute__((__noreturn__));\n\n  void\n  __throw_domain_error(const char*) __attribute__((__n'
[#] parse_declaration, is_constructor=False, meet line: 'void\n  __throw_logic_error(const char*) __attribute__((__noreturn__));\n\n  void\n  __throw_domain_error(const char*) __attribute__((__noreturn__));\n\n  void\n  __throw_invalid_argument(const char*) __attr'
[#] parse_declaration, is_constructor=False, meet line: 'void\n  __throw_domain_error(const char*) __attribute__((__noreturn__));\n\n  void\n  __throw_invalid_argument(const char*) __attribute__((__noreturn__));\n\n  void\n  __throw_length_error(const char*) __att'
[#] parse_declaration, is_constructor=False, meet line: 'void\n  __throw_invalid_argument(const char*) __attribute__((__noreturn__));\n\n  void\n  __throw_length_error(const char*) __attribute__((__noreturn__));\n\n  void\n  __throw_out_of_range(const char*) __att'
[#] parse_declaration, is_constructor=False, meet line: 'void\n  __throw_length_error(const char*) __attribute__((__noreturn__));\n\n  void\n  __throw_out_of_range(const char*) __attribute__((__noreturn__));\n\n  void\n  __throw_out_of_range_fmt(const char*, ...) '
[#] parse_declaration, is_constructor=False, meet line: 'void\n  __throw_out_of_range(const char*) __attribute__((__noreturn__));\n\n  void\n  __throw_out_of_range_fmt(const char*, ...) __attribute__((__noreturn__))\n    __attribute__((__format__(__gnu_printf__,'
[#] parse_declaration, is_constructor=False, meet line: 'void\n  __throw_out_of_range_fmt(const char*, ...) __attribute__((__noreturn__))\n    __attribute__((__format__(__gnu_printf__, 1, 2)));\n\n  void\n  __throw_runtime_error(const char*) __attribute__((__nor'
[#] parse_declaration, is_constructor=False, meet line: 'void\n  __throw_runtime_error(const char*) __attribute__((__noreturn__));\n\n  void\n  __throw_range_error(const char*) __attribute__((__noreturn__));\n\n  void\n  __throw_overflow_error(const char*) __attri'
[#] parse_declaration, is_constructor=False, meet line: 'void\n  __throw_range_error(const char*) __attribute__((__noreturn__));\n\n  void\n  __throw_overflow_error(const char*) __attribute__((__noreturn__));\n\n  void\n  __throw_underflow_error(const char*) __att'
[#] parse_declaration, is_constructor=False, meet line: 'void\n  __throw_overflow_error(const char*) __attribute__((__noreturn__));\n\n  void\n  __throw_underflow_error(const char*) __attribute__((__noreturn__));\n\n\n  void\n  __throw_ios_failure(const char*) __at'
[#] parse_declaration, is_constructor=False, meet line: 'void\n  __throw_underflow_error(const char*) __attribute__((__noreturn__));\n\n\n  void\n  __throw_ios_failure(const char*) __attribute__((__noreturn__));\n\n  void\n  __throw_system_error(int) __attribute__('
[#] parse_declaration, is_constructor=False, meet line: 'void\n  __throw_ios_failure(const char*) __attribute__((__noreturn__));\n\n  void\n  __throw_system_error(int) __attribute__((__noreturn__));\n\n  void\n  __throw_future_error(int) __attribute__((__noreturn_'
[#] parse_declaration, is_constructor=False, meet line: 'void\n  __throw_system_error(int) __attribute__((__noreturn__));\n\n  void\n  __throw_future_error(int) __attribute__((__noreturn__));\n\n\n  void\n  __throw_bad_function_call() __attribute__((__noreturn__));'
[#] parse_declaration, is_constructor=False, meet line: 'void\n  __throw_future_error(int) __attribute__((__noreturn__));\n\n\n  void\n  __throw_bad_function_call() __attribute__((__noreturn__));\n\n\n}\n# 61 "/usr/include/c++/7/bits/stl_algobase.h" 2 3\n# 1 "/usr/in'
[#] parse_declaration, is_constructor=False, meet line: 'void\n  __throw_bad_function_call() __attribute__((__noreturn__));\n\n\n}\n# 61 "/usr/include/c++/7/bits/stl_algobase.h" 2 3\n# 1 "/usr/include/c++/7/bits/cpp_type_traits.h" 1 3\n# 35 "/usr/include/c++/7/bit'
[#] parse_declaration, is_constructor=False, meet line: '_Iterator\n    __miter_base(_Iterator __it)\n    { return __it; }\n\n\n}\n}\n# 62 "/usr/include/c++/7/bits/stl_algobase.h" 2 3\n# 1 "/usr/include/c++/7/ext/type_traits.h" 1 3\n# 32 "/usr/include/c++/7/ext/type'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    __is_null_pointer(_Type* __ptr)\n    { return __ptr == 0; }\n\n  template<typename _Type>\n    inline bool\n    __is_null_pointer(_Type)\n    { return false; }\n\n\n  inline bool\n  __is_null_pointer(s'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    __is_null_pointer(_Type)\n    { return false; }\n\n\n  inline bool\n  __is_null_pointer(std::nullptr_t)\n  { return true; }\n\n\n\n  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>\n    s'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n  __is_null_pointer(std::nullptr_t)\n  { return true; }\n\n\n\n  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>\n    struct __promote\n    { typedef double __type; };\n\n\n\n\n  template<type'
[#] parse_declaration, is_constructor=False, meet line: '_Value __min = (((_Value)(-1) < 0) ? (_Value)1 << (sizeof(_Value) * 8 - ((_Value)(-1) < 0)) : (_Value)0);\n      static const _Value __max = (((_Value)(-1) < 0) ? (((((_Value)1 << ((sizeof(_Value) * 8 '
[#] parse_declaration, is_constructor=False, meet line: '_Value __max = (((_Value)(-1) < 0) ? (((((_Value)1 << ((sizeof(_Value) * 8 - ((_Value)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(_Value)0);\n\n\n\n      static const bool __is_signed = ((_Value)(-1) < 0);\n     '
[#] parse_declaration, is_constructor=False, meet line: 'bool __is_signed = ((_Value)(-1) < 0);\n      static const int __digits = (sizeof(_Value) * 8 - ((_Value)(-1) < 0));\n    };\n\n  template<typename _Value>\n    const _Value __numeric_traits_integer<_Value'
[#] parse_declaration, is_constructor=False, meet line: 'int __digits = (sizeof(_Value) * 8 - ((_Value)(-1) < 0));\n    };\n\n  template<typename _Value>\n    const _Value __numeric_traits_integer<_Value>::__min;\n\n  template<typename _Value>\n    const _Value __'
[#] parse_declaration, is_constructor=False, meet line: '_Value __numeric_traits_integer<_Value>::__min;\n\n  template<typename _Value>\n    const _Value __numeric_traits_integer<_Value>::__max;\n\n  template<typename _Value>\n    const bool __numeric_traits_inte'
[#] parse_declaration, is_constructor=False, meet line: '_Value __numeric_traits_integer<_Value>::__max;\n\n  template<typename _Value>\n    const bool __numeric_traits_integer<_Value>::__is_signed;\n\n  template<typename _Value>\n    const int __numeric_traits_i'
[#] parse_declaration, is_constructor=False, meet line: 'bool __numeric_traits_integer<_Value>::__is_signed;\n\n  template<typename _Value>\n    const int __numeric_traits_integer<_Value>::__digits;\n# 99 "/usr/include/c++/7/ext/numeric_traits.h" 3\n  template<t'
[#] parse_declaration, is_constructor=False, meet line: 'int __numeric_traits_integer<_Value>::__digits;\n# 99 "/usr/include/c++/7/ext/numeric_traits.h" 3\n  template<typename _Value>\n    struct __numeric_traits_floating\n    {\n\n      static const int __max_di'
[#] parse_declaration, is_constructor=False, meet line: 'int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 64) * 643L / 2136);\n\n\n      static const bool __is_signed = true;\n      static'
[#] parse_declaration, is_constructor=False, meet line: 'bool __is_signed = true;\n      static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 18);\n      static const int __max_exponent10'
[#] parse_declaration, is_constructor=False, meet line: 'int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 18);\n      static const int __max_exponent10 = (std::__are_same<_Value, float>::__value '
[#] parse_declaration, is_constructor=False, meet line: 'int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 4932);\n    };\n\n  template<typename _Value>\n    const int __numeric_traits_floati'
[#] parse_declaration, is_constructor=False, meet line: 'int __numeric_traits_floating<_Value>::__max_digits10;\n\n  template<typename _Value>\n    const bool __numeric_traits_floating<_Value>::__is_signed;\n\n  template<typename _Value>\n    const int __numeric_'
[#] parse_declaration, is_constructor=False, meet line: 'bool __numeric_traits_floating<_Value>::__is_signed;\n\n  template<typename _Value>\n    const int __numeric_traits_floating<_Value>::__digits10;\n\n  template<typename _Value>\n    const int __numeric_trai'
[#] parse_declaration, is_constructor=False, meet line: 'int __numeric_traits_floating<_Value>::__digits10;\n\n  template<typename _Value>\n    const int __numeric_traits_floating<_Value>::__max_exponent10;\n\n  template<typename _Value>\n    struct __numeric_tra'
[#] parse_declaration, is_constructor=False, meet line: 'int __numeric_traits_floating<_Value>::__max_exponent10;\n\n  template<typename _Value>\n    struct __numeric_traits\n    : public __conditional_type<std::__is_integer<_Value>::__value,\n    __numeric_trai'
[#] parse_declaration, is_constructor=False, meet line: 'iterator_traits<_Iter>::iterator_category\n    __iterator_category(const _Iter&)\n    { return typename iterator_traits<_Iter>::iterator_category(); }\n# 231 "/usr/include/c++/7/bits/stl_iterator_base_ty'
[#] parse_declaration, is_constructor=False, meet line: 'iterator_traits<_InputIterator>::difference_type\n    __distance(_InputIterator __first, _InputIterator __last,\n               input_iterator_tag)\n    {\n\n     \n\n      typename iterator_traits<_InputIte'
[#] parse_declaration, is_constructor=False, meet line: 'iterator_traits<_RandomAccessIterator>::difference_type\n    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,\n               random_access_iterator_tag)\n    {\n\n     \n\n      retur'
[#] parse_declaration, is_constructor=False, meet line: 'ptrdiff_t\n    __distance(std::_List_iterator<_Tp>,\n        std::_List_iterator<_Tp>,\n        input_iterator_tag);\n\n  template<typename _Tp>\n    ptrdiff_t\n    __distance(std::_List_const_iterator<_Tp>,'
[#] parse_declaration, is_constructor=False, meet line: 'ptrdiff_t\n    __distance(std::_List_const_iterator<_Tp>,\n        std::_List_const_iterator<_Tp>,\n        input_iterator_tag);\n# 135 "/usr/include/c++/7/bits/stl_iterator_base_funcs.h" 3\n  template<typ'
[#] parse_declaration, is_constructor=False, meet line: 'iterator_traits<_InputIterator>::difference_type\n    distance(_InputIterator __first, _InputIterator __last)\n    {\n\n      return std::__distance(__first, __last,\n        std::__iterator_category(__fir'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)\n    {\n\n     \n      ;\n      while (__n--)\n ++__i;\n    }\n\n  template<typename _BidirectionalIterator, typename _Distance>\n    i'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    __advance(_BidirectionalIterator& __i, _Distance __n,\n       bidirectional_iterator_tag)\n    {\n\n     \n\n      if (__n > 0)\n        while (__n--)\n   ++__i;\n      else\n        while (__n++)\n   -'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    __advance(_RandomAccessIterator& __i, _Distance __n,\n              random_access_iterator_tag)\n    {\n\n     \n\n      __i += __n;\n    }\n# 195 "/usr/include/c++/7/bits/stl_iterator_base_funcs.h" '
[#] parse_declaration, is_constructor=False, meet line: 'void\n    advance(_InputIterator& __i, _Distance __n)\n    {\n\n      typename iterator_traits<_InputIterator>::difference_type __d = __n;\n      std::__advance(__i, __d, std::__iterator_category(__i));\n  '
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n    next(_ForwardIterator __x, typename\n  iterator_traits<_ForwardIterator>::difference_type __n = 1)\n    {\n\n     \n\n      std::advance(__x, __n);\n      return __x;\n    }\n\n  template<t'
[#] parse_declaration, is_constructor=False, meet line: '_BidirectionalIterator\n    prev(_BidirectionalIterator __x, typename\n  iterator_traits<_BidirectionalIterator>::difference_type __n = 1)\n    {\n\n     \n\n      std::advance(__x, -__n);\n      return __x;\n'
[#] parse_declaration, is_constructor=False, meet line: '_Ptr\n      pointer_to(__make_not_void<element_type>& __e)\n      { return _Ptr::pointer_to(__e); }\n\n      static_assert(!is_same<element_type, __undefined>::value,\n   "pointer type defines element_type'
[#] parse_declaration, is_constructor=False, meet line: 'pointer\n      pointer_to(__make_not_void<element_type>& __r) noexcept\n      { return std::addressof(__r); }\n    };\n\n\n  template<typename _Ptr, typename _Tp>\n    using __ptr_rebind = typename pointer_t'
[#] parse_declaration, is_constructor=False, meet line: '_Iterator current;\n\n      typedef iterator_traits<_Iterator> __traits_type;\n\n    public:\n      typedef _Iterator iterator_type;\n      typedef typename __traits_type::difference_type difference_type;\n '
[#] parse_declaration, is_constructor=True, meet line: 'reverse_iterator() : current() { }\n\n\n\n\n      explicit\n      reverse_iterator(iterator_type __x) : current(__x) { }\n\n\n\n\n     \n      reverse_iterator(const reverse_iterator& __x)\n      : current(__x.cur'
[#] parse_declaration, is_constructor=True, meet line: 'reverse_iterator(iterator_type __x) : current(__x) { }\n\n\n\n\n     \n      reverse_iterator(const reverse_iterator& __x)\n      : current(__x.current) { }\n\n\n\n\n\n      template<typename _Iter>\n\n        rever'
[#] parse_declaration, is_constructor=True, meet line: 'reverse_iterator(const reverse_iterator& __x)\n      : current(__x.current) { }\n\n\n\n\n\n      template<typename _Iter>\n\n        reverse_iterator(const reverse_iterator<_Iter>& __x)\n : current(__x.base()) '
[#] parse_declaration, is_constructor=True, meet line: 'reverse_iterator(const reverse_iterator<_Iter>& __x)\n : current(__x.base()) { }\n\n\n\n\n      iterator_type\n      base() const\n      { return current; }\n# 168 "/usr/include/c++/7/bits/stl_iterator.h" 3\n  '
[#] parse_declaration, is_constructor=False, meet line: 'iterator_type\n      base() const\n      { return current; }\n# 168 "/usr/include/c++/7/bits/stl_iterator.h" 3\n      reference\n      operator*() const\n      {\n _Iterator __tmp = current;\n return *--__tmp'
[#] parse_declaration, is_constructor=False, meet line: 'reference\n      operator*() const\n      {\n _Iterator __tmp = current;\n return *--__tmp;\n      }\n# 182 "/usr/include/c++/7/bits/stl_iterator.h" 3\n      pointer\n      operator->() const\n      { return s'
[#] parse_declaration, is_constructor=False, meet line: 'pointer\n      operator->() const\n      { return std::__addressof(operator*()); }\n\n\n\n\n\n\n      reverse_iterator&\n      operator++()\n      {\n --current;\n return *this;\n      }\n\n\n\n\n\n\n      reverse_iterato'
[#] parse_declaration, is_constructor=True, meet line: 'reverse_iterator&\n      operator++()\n      {\n --current;\n return *this;\n      }\n\n\n\n\n\n\n      reverse_iterator\n      operator++(int)\n      {\n reverse_iterator __tmp = *this;\n --current;\n return __tmp;\n '
[#] parse_declaration, is_constructor=True, meet line: 'reverse_iterator\n      operator++(int)\n      {\n reverse_iterator __tmp = *this;\n --current;\n return __tmp;\n      }\n\n\n\n\n\n\n      reverse_iterator&\n      operator--()\n      {\n ++current;\n return *this;\n '
[#] parse_declaration, is_constructor=True, meet line: 'reverse_iterator&\n      operator--()\n      {\n ++current;\n return *this;\n      }\n\n\n\n\n\n\n      reverse_iterator\n      operator--(int)\n      {\n reverse_iterator __tmp = *this;\n ++current;\n return __tmp;\n '
[#] parse_declaration, is_constructor=True, meet line: 'reverse_iterator\n      operator--(int)\n      {\n reverse_iterator __tmp = *this;\n ++current;\n return __tmp;\n      }\n\n\n\n\n\n\n      reverse_iterator\n      operator+(difference_type __n) const\n      { retur'
[#] parse_declaration, is_constructor=True, meet line: 'reverse_iterator\n      operator+(difference_type __n) const\n      { return reverse_iterator(current - __n); }\n\n\n\n\n\n\n\n      reverse_iterator&\n      operator+=(difference_type __n)\n      {\n current -= _'
[#] parse_declaration, is_constructor=True, meet line: 'reverse_iterator&\n      operator+=(difference_type __n)\n      {\n current -= __n;\n return *this;\n      }\n\n\n\n\n\n\n      reverse_iterator\n      operator-(difference_type __n) const\n      { return reverse_i'
[#] parse_declaration, is_constructor=True, meet line: 'reverse_iterator\n      operator-(difference_type __n) const\n      { return reverse_iterator(current + __n); }\n\n\n\n\n\n\n\n      reverse_iterator&\n      operator-=(difference_type __n)\n      {\n current += _'
[#] parse_declaration, is_constructor=True, meet line: 'reverse_iterator&\n      operator-=(difference_type __n)\n      {\n current += __n;\n return *this;\n      }\n\n\n\n\n\n\n      reference\n      operator[](difference_type __n) const\n      { return *(*this + __n);'
[#] parse_declaration, is_constructor=False, meet line: 'reference\n      operator[](difference_type __n) const\n      { return *(*this + __n); }\n    };\n# 300 "/usr/include/c++/7/bits/stl_iterator.h" 3\n  template<typename _Iterator>\n    inline bool\n    operat'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator==(const reverse_iterator<_Iterator>& __x,\n        const reverse_iterator<_Iterator>& __y)\n    { return __x.base() == __y.base(); }\n\n  template<typename _Iterator>\n    inline bool\n   '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<(const reverse_iterator<_Iterator>& __x,\n       const reverse_iterator<_Iterator>& __y)\n    { return __y.base() < __x.base(); }\n\n  template<typename _Iterator>\n    inline bool\n    op'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator!=(const reverse_iterator<_Iterator>& __x,\n        const reverse_iterator<_Iterator>& __y)\n    { return !(__x == __y); }\n\n  template<typename _Iterator>\n    inline bool\n    operator>('
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>(const reverse_iterator<_Iterator>& __x,\n       const reverse_iterator<_Iterator>& __y)\n    { return __y < __x; }\n\n  template<typename _Iterator>\n    inline bool\n    operator<=(const'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<=(const reverse_iterator<_Iterator>& __x,\n        const reverse_iterator<_Iterator>& __y)\n    { return !(__y < __x); }\n\n  template<typename _Iterator>\n    inline bool\n    operator>=('
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>=(const reverse_iterator<_Iterator>& __x,\n        const reverse_iterator<_Iterator>& __y)\n    { return !(__x < __y); }\n\n\n\n  template<typename _IteratorL, typename _IteratorR>\n    inl'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator==(const reverse_iterator<_IteratorL>& __x,\n        const reverse_iterator<_IteratorR>& __y)\n    { return __x.base() == __y.base(); }\n\n  template<typename _IteratorL, typename _Iterat'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<(const reverse_iterator<_IteratorL>& __x,\n       const reverse_iterator<_IteratorR>& __y)\n    { return __y.base() < __x.base(); }\n\n  template<typename _IteratorL, typename _IteratorR'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator!=(const reverse_iterator<_IteratorL>& __x,\n        const reverse_iterator<_IteratorR>& __y)\n    { return !(__x == __y); }\n\n  template<typename _IteratorL, typename _IteratorR>\n    in'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>(const reverse_iterator<_IteratorL>& __x,\n       const reverse_iterator<_IteratorR>& __y)\n    { return __y < __x; }\n\n  template<typename _IteratorL, typename _IteratorR>\n    inline b'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<=(const reverse_iterator<_IteratorL>& __x,\n        const reverse_iterator<_IteratorR>& __y)\n    { return !(__y < __x); }\n\n  template<typename _IteratorL, typename _IteratorR>\n    inl'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>=(const reverse_iterator<_IteratorL>& __x,\n        const reverse_iterator<_IteratorR>& __y)\n    { return !(__x < __y); }\n# 390 "/usr/include/c++/7/bits/stl_iterator.h" 3\n  template<t'
[#] parse_declaration, is_constructor=False, meet line: 'auto\n    operator-(const reverse_iterator<_IteratorL>& __x,\n       const reverse_iterator<_IteratorR>& __y)\n    -> decltype(__y.base() - __x.base())\n    { return __y.base() - __x.base(); }\n\n\n  templat'
[#] parse_declaration, is_constructor=False, meet line: 'reverse_iterator<_Iterator>\n    operator+(typename reverse_iterator<_Iterator>::difference_type __n,\n       const reverse_iterator<_Iterator>& __x)\n    { return reverse_iterator<_Iterator>(__x.base() '
[#] parse_declaration, is_constructor=False, meet line: 'reverse_iterator<_Iterator>\n    __make_reverse_iterator(_Iterator __i)\n    { return reverse_iterator<_Iterator>(__i); }\n\n\n\n\n\n\n\n  template<typename _Iterator>\n    inline reverse_iterator<_Iterator>\n   '
[#] parse_declaration, is_constructor=False, meet line: 'reverse_iterator<_Iterator>\n    make_reverse_iterator(_Iterator __i)\n    { return reverse_iterator<_Iterator>(__i); }\n\n\n\n\n  template<typename _Iterator>\n    auto\n    __niter_base(reverse_iterator<_Ite'
[#] parse_declaration, is_constructor=False, meet line: 'auto\n    __niter_base(reverse_iterator<_Iterator> __it)\n    -> decltype(__make_reverse_iterator(__niter_base(__it.base())))\n    { return __make_reverse_iterator(__niter_base(__it.base())); }\n\n  templa'
[#] parse_declaration, is_constructor=False, meet line: 'auto\n    __miter_base(reverse_iterator<_Iterator> __it)\n    -> decltype(__make_reverse_iterator(__miter_base(__it.base())))\n    { return __make_reverse_iterator(__miter_base(__it.base())); }\n# 454 "/u'
[#] parse_declaration, is_constructor=False, meet line: '_Container* container;\n\n    public:\n\n      typedef _Container container_type;\n\n\n      explicit\n      back_insert_iterator(_Container& __x)\n      : container(std::__addressof(__x)) { }\n# 489 "/usr/incl'
[#] parse_declaration, is_constructor=True, meet line: 'back_insert_iterator(_Container& __x)\n      : container(std::__addressof(__x)) { }\n# 489 "/usr/include/c++/7/bits/stl_iterator.h" 3\n      back_insert_iterator&\n      operator=(const typename _Containe'
[#] parse_declaration, is_constructor=True, meet line: 'back_insert_iterator&\n      operator=(const typename _Container::value_type& __value)\n      {\n container->push_back(__value);\n return *this;\n      }\n\n      back_insert_iterator&\n      operator=(typena'
[#] parse_declaration, is_constructor=True, meet line: 'back_insert_iterator&\n      operator=(typename _Container::value_type&& __value)\n      {\n container->push_back(std::move(__value));\n return *this;\n      }\n\n\n\n      back_insert_iterator&\n      operator'
[#] parse_declaration, is_constructor=True, meet line: 'back_insert_iterator&\n      operator*()\n      { return *this; }\n\n\n      back_insert_iterator&\n      operator++()\n      { return *this; }\n\n\n      back_insert_iterator\n      operator++(int)\n      { retu'
[#] parse_declaration, is_constructor=True, meet line: 'back_insert_iterator&\n      operator++()\n      { return *this; }\n\n\n      back_insert_iterator\n      operator++(int)\n      { return *this; }\n    };\n# 531 "/usr/include/c++/7/bits/stl_iterator.h" 3\n  te'
[#] parse_declaration, is_constructor=True, meet line: 'back_insert_iterator\n      operator++(int)\n      { return *this; }\n    };\n# 531 "/usr/include/c++/7/bits/stl_iterator.h" 3\n  template<typename _Container>\n    inline back_insert_iterator<_Container>\n '
[#] parse_declaration, is_constructor=False, meet line: 'back_insert_iterator<_Container>\n    back_inserter(_Container& __x)\n    { return back_insert_iterator<_Container>(__x); }\n# 546 "/usr/include/c++/7/bits/stl_iterator.h" 3\n  template<typename _Containe'
[#] parse_declaration, is_constructor=False, meet line: '_Container* container;\n\n    public:\n\n      typedef _Container container_type;\n\n\n      explicit front_insert_iterator(_Container& __x)\n      : container(std::__addressof(__x)) { }\n# 580 "/usr/include/c'
[#] parse_declaration, is_constructor=True, meet line: 'front_insert_iterator(_Container& __x)\n      : container(std::__addressof(__x)) { }\n# 580 "/usr/include/c++/7/bits/stl_iterator.h" 3\n      front_insert_iterator&\n      operator=(const typename _Contai'
[#] parse_declaration, is_constructor=True, meet line: 'front_insert_iterator&\n      operator=(const typename _Container::value_type& __value)\n      {\n container->push_front(__value);\n return *this;\n      }\n\n      front_insert_iterator&\n      operator=(typ'
[#] parse_declaration, is_constructor=True, meet line: 'front_insert_iterator&\n      operator=(typename _Container::value_type&& __value)\n      {\n container->push_front(std::move(__value));\n return *this;\n      }\n\n\n\n      front_insert_iterator&\n      opera'
[#] parse_declaration, is_constructor=True, meet line: 'front_insert_iterator&\n      operator*()\n      { return *this; }\n\n\n      front_insert_iterator&\n      operator++()\n      { return *this; }\n\n\n      front_insert_iterator\n      operator++(int)\n      { r'
[#] parse_declaration, is_constructor=True, meet line: 'front_insert_iterator&\n      operator++()\n      { return *this; }\n\n\n      front_insert_iterator\n      operator++(int)\n      { return *this; }\n    };\n# 622 "/usr/include/c++/7/bits/stl_iterator.h" 3\n  '
[#] parse_declaration, is_constructor=True, meet line: 'front_insert_iterator\n      operator++(int)\n      { return *this; }\n    };\n# 622 "/usr/include/c++/7/bits/stl_iterator.h" 3\n  template<typename _Container>\n    inline front_insert_iterator<_Container>'
[#] parse_declaration, is_constructor=False, meet line: 'front_insert_iterator<_Container>\n    front_inserter(_Container& __x)\n    { return front_insert_iterator<_Container>(__x); }\n# 641 "/usr/include/c++/7/bits/stl_iterator.h" 3\n  template<typename _Conta'
[#] parse_declaration, is_constructor=False, meet line: '_Container* container;\n      typename _Container::iterator iter;\n\n    public:\n\n      typedef _Container container_type;\n\n\n\n\n\n      insert_iterator(_Container& __x, typename _Container::iterator __i)\n '
[#] parse_declaration, is_constructor=False, meet line: '_Container::iterator iter;\n\n    public:\n\n      typedef _Container container_type;\n\n\n\n\n\n      insert_iterator(_Container& __x, typename _Container::iterator __i)\n      : container(std::__addressof(__x)'
[#] parse_declaration, is_constructor=True, meet line: 'insert_iterator(_Container& __x, typename _Container::iterator __i)\n      : container(std::__addressof(__x)), iter(__i) {}\n# 692 "/usr/include/c++/7/bits/stl_iterator.h" 3\n      insert_iterator&\n     '
[#] parse_declaration, is_constructor=True, meet line: 'insert_iterator&\n      operator=(const typename _Container::value_type& __value)\n      {\n iter = container->insert(iter, __value);\n ++iter;\n return *this;\n      }\n\n      insert_iterator&\n      operato'
[#] parse_declaration, is_constructor=True, meet line: 'insert_iterator&\n      operator=(typename _Container::value_type&& __value)\n      {\n iter = container->insert(iter, std::move(__value));\n ++iter;\n return *this;\n      }\n\n\n\n      insert_iterator&\n     '
[#] parse_declaration, is_constructor=True, meet line: 'insert_iterator&\n      operator*()\n      { return *this; }\n\n\n      insert_iterator&\n      operator++()\n      { return *this; }\n\n\n      insert_iterator&\n      operator++(int)\n      { return *this; }\n  '
[#] parse_declaration, is_constructor=True, meet line: 'insert_iterator&\n      operator++()\n      { return *this; }\n\n\n      insert_iterator&\n      operator++(int)\n      { return *this; }\n    };\n# 736 "/usr/include/c++/7/bits/stl_iterator.h" 3\n  template<ty'
[#] parse_declaration, is_constructor=True, meet line: 'insert_iterator&\n      operator++(int)\n      { return *this; }\n    };\n# 736 "/usr/include/c++/7/bits/stl_iterator.h" 3\n  template<typename _Container, typename _Iterator>\n    inline insert_iterator<_C'
[#] parse_declaration, is_constructor=False, meet line: 'insert_iterator<_Container>\n    inserter(_Container& __x, _Iterator __i)\n    {\n      return insert_iterator<_Container>(__x,\n      typename _Container::iterator(__i));\n    }\n\n\n\n\n}\n\nnamespace __gnu_cxx'
[#] parse_declaration, is_constructor=False, meet line: '_Iterator _M_current;\n\n      typedef iterator_traits<_Iterator> __traits_type;\n\n    public:\n      typedef _Iterator iterator_type;\n      typedef typename __traits_type::iterator_category iterator_cate'
[#] parse_declaration, is_constructor=True, meet line: '__normal_iterator() noexcept\n      : _M_current(_Iterator()) { }\n\n      explicit\n      __normal_iterator(const _Iterator& __i) noexcept\n      : _M_current(__i) { }\n\n\n      template<typename _Iter>\n   '
[#] parse_declaration, is_constructor=True, meet line: '__normal_iterator(const _Iterator& __i) noexcept\n      : _M_current(__i) { }\n\n\n      template<typename _Iter>\n        __normal_iterator(const __normal_iterator<_Iter,\n     typename __enable_if<\n      '
[#] parse_declaration, is_constructor=True, meet line: '__normal_iterator(const __normal_iterator<_Iter,\n     typename __enable_if<\n              (std::__are_same<_Iter, typename _Container::pointer>::__value),\n        _Container>::__type>& __i) noexcept\n '
[#] parse_declaration, is_constructor=False, meet line: 'reference\n      operator*() const noexcept\n      { return *_M_current; }\n\n      pointer\n      operator->() const noexcept\n      { return _M_current; }\n\n      __normal_iterator&\n      operator++() noex'
[#] parse_declaration, is_constructor=False, meet line: 'pointer\n      operator->() const noexcept\n      { return _M_current; }\n\n      __normal_iterator&\n      operator++() noexcept\n      {\n ++_M_current;\n return *this;\n      }\n\n      __normal_iterator\n    '
[#] parse_declaration, is_constructor=True, meet line: '__normal_iterator&\n      operator++() noexcept\n      {\n ++_M_current;\n return *this;\n      }\n\n      __normal_iterator\n      operator++(int) noexcept\n      { return __normal_iterator(_M_current++); }\n\n'
[#] parse_declaration, is_constructor=True, meet line: '__normal_iterator\n      operator++(int) noexcept\n      { return __normal_iterator(_M_current++); }\n\n\n      __normal_iterator&\n      operator--() noexcept\n      {\n --_M_current;\n return *this;\n      }\n'
[#] parse_declaration, is_constructor=True, meet line: '__normal_iterator&\n      operator--() noexcept\n      {\n --_M_current;\n return *this;\n      }\n\n      __normal_iterator\n      operator--(int) noexcept\n      { return __normal_iterator(_M_current--); }\n\n'
[#] parse_declaration, is_constructor=True, meet line: '__normal_iterator\n      operator--(int) noexcept\n      { return __normal_iterator(_M_current--); }\n\n\n      reference\n      operator[](difference_type __n) const noexcept\n      { return _M_current[__n]'
[#] parse_declaration, is_constructor=False, meet line: 'reference\n      operator[](difference_type __n) const noexcept\n      { return _M_current[__n]; }\n\n      __normal_iterator&\n      operator+=(difference_type __n) noexcept\n      { _M_current += __n; ret'
[#] parse_declaration, is_constructor=True, meet line: '__normal_iterator&\n      operator+=(difference_type __n) noexcept\n      { _M_current += __n; return *this; }\n\n      __normal_iterator\n      operator+(difference_type __n) const noexcept\n      { return'
[#] parse_declaration, is_constructor=True, meet line: '__normal_iterator\n      operator+(difference_type __n) const noexcept\n      { return __normal_iterator(_M_current + __n); }\n\n      __normal_iterator&\n      operator-=(difference_type __n) noexcept\n   '
[#] parse_declaration, is_constructor=True, meet line: '__normal_iterator&\n      operator-=(difference_type __n) noexcept\n      { _M_current -= __n; return *this; }\n\n      __normal_iterator\n      operator-(difference_type __n) const noexcept\n      { return'
[#] parse_declaration, is_constructor=True, meet line: '__normal_iterator\n      operator-(difference_type __n) const noexcept\n      { return __normal_iterator(_M_current - __n); }\n\n      const _Iterator&\n      base() const noexcept\n      { return _M_curren'
[#] parse_declaration, is_constructor=False, meet line: '_Iterator&\n      base() const noexcept\n      { return _M_current; }\n    };\n# 860 "/usr/include/c++/7/bits/stl_iterator.h" 3\n  template<typename _IteratorL, typename _IteratorR, typename _Container>\n  '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,\n        const __normal_iterator<_IteratorR, _Container>& __rhs)\n    noexcept\n    { return __lhs.base() == __rhs.base(); }\n\n '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,\n        const __normal_iterator<_Iterator, _Container>& __rhs)\n    noexcept\n    { return __lhs.base() == __rhs.base(); }\n\n  t'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,\n        const __normal_iterator<_IteratorR, _Container>& __rhs)\n    noexcept\n    { return __lhs.base() != __rhs.base(); }\n\n '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,\n        const __normal_iterator<_Iterator, _Container>& __rhs)\n    noexcept\n    { return __lhs.base() != __rhs.base(); }\n\n\n  '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,\n       const __normal_iterator<_IteratorR, _Container>& __rhs)\n    noexcept\n    { return __lhs.base() < __rhs.base(); }\n\n  te'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,\n       const __normal_iterator<_Iterator, _Container>& __rhs)\n    noexcept\n    { return __lhs.base() < __rhs.base(); }\n\n  temp'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,\n       const __normal_iterator<_IteratorR, _Container>& __rhs)\n    noexcept\n    { return __lhs.base() > __rhs.base(); }\n\n  te'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,\n       const __normal_iterator<_Iterator, _Container>& __rhs)\n    noexcept\n    { return __lhs.base() > __rhs.base(); }\n\n  temp'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,\n        const __normal_iterator<_IteratorR, _Container>& __rhs)\n    noexcept\n    { return __lhs.base() <= __rhs.base(); }\n\n '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,\n        const __normal_iterator<_Iterator, _Container>& __rhs)\n    noexcept\n    { return __lhs.base() <= __rhs.base(); }\n\n  t'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,\n        const __normal_iterator<_IteratorR, _Container>& __rhs)\n    noexcept\n    { return __lhs.base() >= __rhs.base(); }\n\n '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,\n        const __normal_iterator<_Iterator, _Container>& __rhs)\n    noexcept\n    { return __lhs.base() >= __rhs.base(); }\n\n\n\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'auto\n    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,\n       const __normal_iterator<_IteratorR, _Container>& __rhs) noexcept\n    -> decltype(__lhs.base() - __rhs.base())\n\n\n\n\n\n   '
[#] parse_declaration, is_constructor=False, meet line: '__normal_iterator<_Iterator, _Container>::difference_type\n    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,\n       const __normal_iterator<_Iterator, _Container>& __rhs)\n    noexcep'
[#] parse_declaration, is_constructor=False, meet line: '__normal_iterator<_Iterator, _Container>\n    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type\n       __n, const __normal_iterator<_Iterator, _Container>& __i)\n    noexcept\n'
[#] parse_declaration, is_constructor=False, meet line: '_Iterator\n    __niter_base(__gnu_cxx::__normal_iterator<_Iterator, _Container> __it)\n    { return __it.base(); }\n\n\n}\n\n\n\nnamespace std __attribute__ ((__visibility__ ("default")))\n{\n\n# 1012 "/usr/inclu'
[#] parse_declaration, is_constructor=False, meet line: '_Iterator _M_current;\n\n      typedef iterator_traits<_Iterator> __traits_type;\n      typedef typename __traits_type::reference __base_ref;\n\n    public:\n      typedef _Iterator iterator_type;\n      typ'
[#] parse_declaration, is_constructor=True, meet line: 'move_iterator()\n      : _M_current() { }\n\n      explicit\n      move_iterator(iterator_type __i)\n      : _M_current(__i) { }\n\n      template<typename _Iter>\n\n move_iterator(const move_iterator<_Iter>& '
[#] parse_declaration, is_constructor=True, meet line: 'move_iterator(iterator_type __i)\n      : _M_current(__i) { }\n\n      template<typename _Iter>\n\n move_iterator(const move_iterator<_Iter>& __i)\n : _M_current(__i.base()) { }\n\n      iterator_type\n      b'
[#] parse_declaration, is_constructor=True, meet line: 'move_iterator(const move_iterator<_Iter>& __i)\n : _M_current(__i.base()) { }\n\n      iterator_type\n      base() const\n      { return _M_current; }\n\n      reference\n      operator*() const\n      { retur'
[#] parse_declaration, is_constructor=False, meet line: 'iterator_type\n      base() const\n      { return _M_current; }\n\n      reference\n      operator*() const\n      { return static_cast<reference>(*_M_current); }\n\n      pointer\n      operator->() const\n   '
[#] parse_declaration, is_constructor=False, meet line: 'reference\n      operator*() const\n      { return static_cast<reference>(*_M_current); }\n\n      pointer\n      operator->() const\n      { return _M_current; }\n\n      move_iterator&\n      operator++()\n  '
[#] parse_declaration, is_constructor=False, meet line: 'pointer\n      operator->() const\n      { return _M_current; }\n\n      move_iterator&\n      operator++()\n      {\n ++_M_current;\n return *this;\n      }\n\n      move_iterator\n      operator++(int)\n      {\n'
[#] parse_declaration, is_constructor=True, meet line: 'move_iterator&\n      operator++()\n      {\n ++_M_current;\n return *this;\n      }\n\n      move_iterator\n      operator++(int)\n      {\n move_iterator __tmp = *this;\n ++_M_current;\n return __tmp;\n      }\n\n'
[#] parse_declaration, is_constructor=True, meet line: 'move_iterator\n      operator++(int)\n      {\n move_iterator __tmp = *this;\n ++_M_current;\n return __tmp;\n      }\n\n      move_iterator&\n      operator--()\n      {\n --_M_current;\n return *this;\n      }\n\n'
[#] parse_declaration, is_constructor=True, meet line: 'move_iterator&\n      operator--()\n      {\n --_M_current;\n return *this;\n      }\n\n      move_iterator\n      operator--(int)\n      {\n move_iterator __tmp = *this;\n --_M_current;\n return __tmp;\n      }\n\n'
[#] parse_declaration, is_constructor=True, meet line: 'move_iterator\n      operator--(int)\n      {\n move_iterator __tmp = *this;\n --_M_current;\n return __tmp;\n      }\n\n      move_iterator\n      operator+(difference_type __n) const\n      { return move_iter'
[#] parse_declaration, is_constructor=True, meet line: 'move_iterator\n      operator+(difference_type __n) const\n      { return move_iterator(_M_current + __n); }\n\n      move_iterator&\n      operator+=(difference_type __n)\n      {\n _M_current += __n;\n retu'
[#] parse_declaration, is_constructor=True, meet line: 'move_iterator&\n      operator+=(difference_type __n)\n      {\n _M_current += __n;\n return *this;\n      }\n\n      move_iterator\n      operator-(difference_type __n) const\n      { return move_iterator(_M_'
[#] parse_declaration, is_constructor=True, meet line: 'move_iterator\n      operator-(difference_type __n) const\n      { return move_iterator(_M_current - __n); }\n\n      move_iterator&\n      operator-=(difference_type __n)\n      {\n _M_current -= __n;\n retu'
[#] parse_declaration, is_constructor=True, meet line: 'move_iterator&\n      operator-=(difference_type __n)\n      {\n _M_current -= __n;\n return *this;\n      }\n\n      reference\n      operator[](difference_type __n) const\n      { return std::move(_M_current'
[#] parse_declaration, is_constructor=False, meet line: 'reference\n      operator[](difference_type __n) const\n      { return std::move(_M_current[__n]); }\n    };\n\n\n\n\n  template<typename _IteratorL, typename _IteratorR>\n    inline bool\n    operator==(const '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator==(const move_iterator<_IteratorL>& __x,\n        const move_iterator<_IteratorR>& __y)\n    { return __x.base() == __y.base(); }\n\n  template<typename _Iterator>\n    inline bool\n    ope'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator==(const move_iterator<_Iterator>& __x,\n        const move_iterator<_Iterator>& __y)\n    { return __x.base() == __y.base(); }\n\n  template<typename _IteratorL, typename _IteratorR>\n   '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator!=(const move_iterator<_IteratorL>& __x,\n        const move_iterator<_IteratorR>& __y)\n    { return !(__x == __y); }\n\n  template<typename _Iterator>\n    inline bool\n    operator!=(con'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator!=(const move_iterator<_Iterator>& __x,\n        const move_iterator<_Iterator>& __y)\n    { return !(__x == __y); }\n\n  template<typename _IteratorL, typename _IteratorR>\n    inline boo'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<(const move_iterator<_IteratorL>& __x,\n       const move_iterator<_IteratorR>& __y)\n    { return __x.base() < __y.base(); }\n\n  template<typename _Iterator>\n    inline bool\n    operat'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<(const move_iterator<_Iterator>& __x,\n       const move_iterator<_Iterator>& __y)\n    { return __x.base() < __y.base(); }\n\n  template<typename _IteratorL, typename _IteratorR>\n    in'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<=(const move_iterator<_IteratorL>& __x,\n        const move_iterator<_IteratorR>& __y)\n    { return !(__y < __x); }\n\n  template<typename _Iterator>\n    inline bool\n    operator<=(cons'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<=(const move_iterator<_Iterator>& __x,\n        const move_iterator<_Iterator>& __y)\n    { return !(__y < __x); }\n\n  template<typename _IteratorL, typename _IteratorR>\n    inline bool'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>(const move_iterator<_IteratorL>& __x,\n       const move_iterator<_IteratorR>& __y)\n    { return __y < __x; }\n\n  template<typename _Iterator>\n    inline bool\n    operator>(const move'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>(const move_iterator<_Iterator>& __x,\n       const move_iterator<_Iterator>& __y)\n    { return __y < __x; }\n\n  template<typename _IteratorL, typename _IteratorR>\n    inline bool\n    '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>=(const move_iterator<_IteratorL>& __x,\n        const move_iterator<_IteratorR>& __y)\n    { return !(__x < __y); }\n\n  template<typename _Iterator>\n    inline bool\n    operator>=(cons'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>=(const move_iterator<_Iterator>& __x,\n        const move_iterator<_Iterator>& __y)\n    { return !(__x < __y); }\n\n\n  template<typename _IteratorL, typename _IteratorR>\n    inline aut'
[#] parse_declaration, is_constructor=False, meet line: 'auto\n    operator-(const move_iterator<_IteratorL>& __x,\n       const move_iterator<_IteratorR>& __y)\n    -> decltype(__x.base() - __y.base())\n    { return __x.base() - __y.base(); }\n\n  template<typen'
[#] parse_declaration, is_constructor=False, meet line: 'move_iterator<_Iterator>\n    operator+(typename move_iterator<_Iterator>::difference_type __n,\n       const move_iterator<_Iterator>& __x)\n    { return __x + __n; }\n\n  template<typename _Iterator>\n   '
[#] parse_declaration, is_constructor=False, meet line: 'move_iterator<_Iterator>\n    make_move_iterator(_Iterator __i)\n    { return move_iterator<_Iterator>(__i); }\n\n  template<typename _Iterator, typename _ReturnType\n    = typename conditional<__move_if_n'
[#] parse_declaration, is_constructor=False, meet line: '_ReturnType\n    __make_move_if_noexcept_iterator(_Iterator __i)\n    { return _ReturnType(__i); }\n\n\n\n  template<typename _Tp, typename _ReturnType\n    = typename conditional<__move_if_noexcept_cond<_Tp'
[#] parse_declaration, is_constructor=False, meet line: '_ReturnType\n    __make_move_if_noexcept_iterator(_Tp* __i)\n    { return _ReturnType(__i); }\n\n\n\n  template<typename _Iterator>\n    auto\n    __niter_base(move_iterator<_Iterator> __it)\n    -> decltype(m'
[#] parse_declaration, is_constructor=False, meet line: 'auto\n    __niter_base(move_iterator<_Iterator> __it)\n    -> decltype(make_move_iterator(__niter_base(__it.base())))\n    { return make_move_iterator(__niter_base(__it.base())); }\n\n  template<typename _'
[#] parse_declaration, is_constructor=False, meet line: 'auto\n    __miter_base(move_iterator<_Iterator> __it)\n    -> decltype(__miter_base(__it.base()))\n    { return __miter_base(__it.base()); }\n\n\n}\n# 68 "/usr/include/c++/7/bits/stl_algobase.h" 2 3\n\n# 1 "/u'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      operator()(_Iterator1 __it1, _Iterator2 __it2) const\n      { return *__it1 < *__it2; }\n  };\n\n  constexpr\n  inline _Iter_less_iter\n  __iter_less_iter()\n  { return _Iter_less_iter(); }\n\n  str'
[#] parse_declaration, is_constructor=False, meet line: '_Iter_less_iter\n  __iter_less_iter()\n  { return _Iter_less_iter(); }\n\n  struct _Iter_less_val\n  {\n\n    constexpr _Iter_less_val() = default;\n\n\n\n\n    explicit\n    _Iter_less_val(_Iter_less_iter) { }\n\n '
[#] parse_declaration, is_constructor=True, meet line: '_Iter_less_val() = default;\n\n\n\n\n    explicit\n    _Iter_less_val(_Iter_less_iter) { }\n\n    template<typename _Iterator, typename _Value>\n      bool\n      operator()(_Iterator __it, _Value& __val) const'
[#] parse_declaration, is_constructor=True, meet line: '_Iter_less_val(_Iter_less_iter) { }\n\n    template<typename _Iterator, typename _Value>\n      bool\n      operator()(_Iterator __it, _Value& __val) const\n      { return *__it < __val; }\n  };\n\n  inline _'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      operator()(_Iterator __it, _Value& __val) const\n      { return *__it < __val; }\n  };\n\n  inline _Iter_less_val\n  __iter_less_val()\n  { return _Iter_less_val(); }\n\n  inline _Iter_less_val\n  _'
[#] parse_declaration, is_constructor=False, meet line: '_Iter_less_val\n  __iter_less_val()\n  { return _Iter_less_val(); }\n\n  inline _Iter_less_val\n  __iter_comp_val(_Iter_less_iter)\n  { return _Iter_less_val(); }\n\n  struct _Val_less_iter\n  {\n\n    constexpr'
[#] parse_declaration, is_constructor=False, meet line: '_Iter_less_val\n  __iter_comp_val(_Iter_less_iter)\n  { return _Iter_less_val(); }\n\n  struct _Val_less_iter\n  {\n\n    constexpr _Val_less_iter() = default;\n\n\n\n\n    explicit\n    _Val_less_iter(_Iter_less_'
[#] parse_declaration, is_constructor=True, meet line: '_Val_less_iter() = default;\n\n\n\n\n    explicit\n    _Val_less_iter(_Iter_less_iter) { }\n\n    template<typename _Value, typename _Iterator>\n      bool\n      operator()(_Value& __val, _Iterator __it) const'
[#] parse_declaration, is_constructor=True, meet line: '_Val_less_iter(_Iter_less_iter) { }\n\n    template<typename _Value, typename _Iterator>\n      bool\n      operator()(_Value& __val, _Iterator __it) const\n      { return __val < *__it; }\n  };\n\n  inline _'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      operator()(_Value& __val, _Iterator __it) const\n      { return __val < *__it; }\n  };\n\n  inline _Val_less_iter\n  __val_less_iter()\n  { return _Val_less_iter(); }\n\n  inline _Val_less_iter\n  _'
[#] parse_declaration, is_constructor=False, meet line: '_Val_less_iter\n  __val_less_iter()\n  { return _Val_less_iter(); }\n\n  inline _Val_less_iter\n  __val_comp_iter(_Iter_less_iter)\n  { return _Val_less_iter(); }\n\n  struct _Iter_equal_to_iter\n  {\n    templ'
[#] parse_declaration, is_constructor=False, meet line: '_Val_less_iter\n  __val_comp_iter(_Iter_less_iter)\n  { return _Val_less_iter(); }\n\n  struct _Iter_equal_to_iter\n  {\n    template<typename _Iterator1, typename _Iterator2>\n      bool\n      operator()(_I'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      operator()(_Iterator1 __it1, _Iterator2 __it2) const\n      { return *__it1 == *__it2; }\n  };\n\n  inline _Iter_equal_to_iter\n  __iter_equal_to_iter()\n  { return _Iter_equal_to_iter(); }\n\n  st'
[#] parse_declaration, is_constructor=False, meet line: '_Iter_equal_to_iter\n  __iter_equal_to_iter()\n  { return _Iter_equal_to_iter(); }\n\n  struct _Iter_equal_to_val\n  {\n    template<typename _Iterator, typename _Value>\n      bool\n      operator()(_Iterato'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      operator()(_Iterator __it, _Value& __val) const\n      { return *__it == __val; }\n  };\n\n  inline _Iter_equal_to_val\n  __iter_equal_to_val()\n  { return _Iter_equal_to_val(); }\n\n  inline _Iter'
[#] parse_declaration, is_constructor=False, meet line: '_Iter_equal_to_val\n  __iter_equal_to_val()\n  { return _Iter_equal_to_val(); }\n\n  inline _Iter_equal_to_val\n  __iter_comp_val(_Iter_equal_to_iter)\n  { return _Iter_equal_to_val(); }\n\n  template<typenam'
[#] parse_declaration, is_constructor=False, meet line: '_Iter_equal_to_val\n  __iter_comp_val(_Iter_equal_to_iter)\n  { return _Iter_equal_to_val(); }\n\n  template<typename _Compare>\n    struct _Iter_comp_iter\n    {\n      _Compare _M_comp;\n\n      explicit con'
[#] parse_declaration, is_constructor=False, meet line: '_Compare _M_comp;\n\n      explicit constexpr\n      _Iter_comp_iter(_Compare __comp)\n : _M_comp(std::move(__comp))\n      { }\n\n      template<typename _Iterator1, typename _Iterator2>\n        constexpr\n '
[#] parse_declaration, is_constructor=True, meet line: '_Iter_comp_iter(_Compare __comp)\n : _M_comp(std::move(__comp))\n      { }\n\n      template<typename _Iterator1, typename _Iterator2>\n        constexpr\n        bool\n        operator()(_Iterator1 __it1, _'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n        operator()(_Iterator1 __it1, _Iterator2 __it2)\n        { return bool(_M_comp(*__it1, *__it2)); }\n    };\n\n  template<typename _Compare>\n    constexpr\n    inline _Iter_comp_iter<_Compare>\n '
[#] parse_declaration, is_constructor=False, meet line: '_Iter_comp_iter<_Compare>\n    __iter_comp_iter(_Compare __comp)\n    { return _Iter_comp_iter<_Compare>(std::move(__comp)); }\n\n  template<typename _Compare>\n    struct _Iter_comp_val\n    {\n      _Compa'
[#] parse_declaration, is_constructor=False, meet line: '_Compare _M_comp;\n\n      explicit\n      _Iter_comp_val(_Compare __comp)\n : _M_comp(std::move(__comp))\n      { }\n\n      explicit\n      _Iter_comp_val(const _Iter_comp_iter<_Compare>& __comp)\n : _M_comp'
[#] parse_declaration, is_constructor=True, meet line: '_Iter_comp_val(_Compare __comp)\n : _M_comp(std::move(__comp))\n      { }\n\n      explicit\n      _Iter_comp_val(const _Iter_comp_iter<_Compare>& __comp)\n : _M_comp(__comp._M_comp)\n      { }\n\n\n      expli'
[#] parse_declaration, is_constructor=True, meet line: '_Iter_comp_val(const _Iter_comp_iter<_Compare>& __comp)\n : _M_comp(__comp._M_comp)\n      { }\n\n\n      explicit\n      _Iter_comp_val(_Iter_comp_iter<_Compare>&& __comp)\n : _M_comp(std::move(__comp._M_co'
[#] parse_declaration, is_constructor=True, meet line: '_Iter_comp_val(_Iter_comp_iter<_Compare>&& __comp)\n : _M_comp(std::move(__comp._M_comp))\n      { }\n\n\n      template<typename _Iterator, typename _Value>\n bool\n operator()(_Iterator __it, _Value& __val'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n operator()(_Iterator __it, _Value& __val)\n { return bool(_M_comp(*__it, __val)); }\n    };\n\n  template<typename _Compare>\n   inline _Iter_comp_val<_Compare>\n    __iter_comp_val(_Compare __comp)\n '
[#] parse_declaration, is_constructor=False, meet line: '_Iter_comp_val<_Compare>\n    __iter_comp_val(_Compare __comp)\n    { return _Iter_comp_val<_Compare>(std::move(__comp)); }\n\n  template<typename _Compare>\n    inline _Iter_comp_val<_Compare>\n    __iter_'
[#] parse_declaration, is_constructor=False, meet line: '_Iter_comp_val<_Compare>\n    __iter_comp_val(_Iter_comp_iter<_Compare> __comp)\n    { return _Iter_comp_val<_Compare>(std::move(__comp)); }\n\n  template<typename _Compare>\n    struct _Val_comp_iter\n    '
[#] parse_declaration, is_constructor=False, meet line: '_Compare _M_comp;\n\n      explicit\n      _Val_comp_iter(_Compare __comp)\n : _M_comp(std::move(__comp))\n      { }\n\n      explicit\n      _Val_comp_iter(const _Iter_comp_iter<_Compare>& __comp)\n : _M_comp'
[#] parse_declaration, is_constructor=True, meet line: '_Val_comp_iter(_Compare __comp)\n : _M_comp(std::move(__comp))\n      { }\n\n      explicit\n      _Val_comp_iter(const _Iter_comp_iter<_Compare>& __comp)\n : _M_comp(__comp._M_comp)\n      { }\n\n\n      expli'
[#] parse_declaration, is_constructor=True, meet line: '_Val_comp_iter(const _Iter_comp_iter<_Compare>& __comp)\n : _M_comp(__comp._M_comp)\n      { }\n\n\n      explicit\n      _Val_comp_iter(_Iter_comp_iter<_Compare>&& __comp)\n : _M_comp(std::move(__comp._M_co'
[#] parse_declaration, is_constructor=True, meet line: '_Val_comp_iter(_Iter_comp_iter<_Compare>&& __comp)\n : _M_comp(std::move(__comp._M_comp))\n      { }\n\n\n      template<typename _Value, typename _Iterator>\n bool\n operator()(_Value& __val, _Iterator __it'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n operator()(_Value& __val, _Iterator __it)\n { return bool(_M_comp(__val, *__it)); }\n    };\n\n  template<typename _Compare>\n    inline _Val_comp_iter<_Compare>\n    __val_comp_iter(_Compare __comp)\n'
[#] parse_declaration, is_constructor=False, meet line: '_Val_comp_iter<_Compare>\n    __val_comp_iter(_Compare __comp)\n    { return _Val_comp_iter<_Compare>(std::move(__comp)); }\n\n  template<typename _Compare>\n    inline _Val_comp_iter<_Compare>\n    __val_c'
[#] parse_declaration, is_constructor=False, meet line: '_Val_comp_iter<_Compare>\n    __val_comp_iter(_Iter_comp_iter<_Compare> __comp)\n    { return _Val_comp_iter<_Compare>(std::move(__comp)); }\n\n  template<typename _Value>\n    struct _Iter_equals_val\n    '
[#] parse_declaration, is_constructor=False, meet line: '_Value& _M_value;\n\n      explicit\n      _Iter_equals_val(_Value& __value)\n : _M_value(__value)\n      { }\n\n      template<typename _Iterator>\n bool\n operator()(_Iterator __it)\n { return *__it == _M_val'
[#] parse_declaration, is_constructor=True, meet line: '_Iter_equals_val(_Value& __value)\n : _M_value(__value)\n      { }\n\n      template<typename _Iterator>\n bool\n operator()(_Iterator __it)\n { return *__it == _M_value; }\n    };\n\n  template<typename _Value'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n operator()(_Iterator __it)\n { return *__it == _M_value; }\n    };\n\n  template<typename _Value>\n    inline _Iter_equals_val<_Value>\n    __iter_equals_val(_Value& __val)\n    { return _Iter_equals_v'
[#] parse_declaration, is_constructor=False, meet line: '_Iter_equals_val<_Value>\n    __iter_equals_val(_Value& __val)\n    { return _Iter_equals_val<_Value>(__val); }\n\n  template<typename _Iterator1>\n    struct _Iter_equals_iter\n    {\n      _Iterator1 _M_it'
[#] parse_declaration, is_constructor=False, meet line: '_Iterator1 _M_it1;\n\n      explicit\n      _Iter_equals_iter(_Iterator1 __it1)\n : _M_it1(__it1)\n      { }\n\n      template<typename _Iterator2>\n bool\n operator()(_Iterator2 __it2)\n { return *__it2 == *_M'
[#] parse_declaration, is_constructor=True, meet line: '_Iter_equals_iter(_Iterator1 __it1)\n : _M_it1(__it1)\n      { }\n\n      template<typename _Iterator2>\n bool\n operator()(_Iterator2 __it2)\n { return *__it2 == *_M_it1; }\n    };\n\n  template<typename _Iter'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n operator()(_Iterator2 __it2)\n { return *__it2 == *_M_it1; }\n    };\n\n  template<typename _Iterator>\n    inline _Iter_equals_iter<_Iterator>\n    __iter_comp_iter(_Iter_equal_to_iter, _Iterator __i'
[#] parse_declaration, is_constructor=False, meet line: '_Iter_equals_iter<_Iterator>\n    __iter_comp_iter(_Iter_equal_to_iter, _Iterator __it)\n    { return _Iter_equals_iter<_Iterator>(__it); }\n\n  template<typename _Predicate>\n    struct _Iter_pred\n    {\n '
[#] parse_declaration, is_constructor=False, meet line: '_Predicate _M_pred;\n\n      explicit\n      _Iter_pred(_Predicate __pred)\n : _M_pred(std::move(__pred))\n      { }\n\n      template<typename _Iterator>\n bool\n operator()(_Iterator __it)\n { return bool(_M_'
[#] parse_declaration, is_constructor=True, meet line: '_Iter_pred(_Predicate __pred)\n : _M_pred(std::move(__pred))\n      { }\n\n      template<typename _Iterator>\n bool\n operator()(_Iterator __it)\n { return bool(_M_pred(*__it)); }\n    };\n\n  template<typenam'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n operator()(_Iterator __it)\n { return bool(_M_pred(*__it)); }\n    };\n\n  template<typename _Predicate>\n    inline _Iter_pred<_Predicate>\n    __pred_iter(_Predicate __pred)\n    { return _Iter_pred<'
[#] parse_declaration, is_constructor=False, meet line: '_Iter_pred<_Predicate>\n    __pred_iter(_Predicate __pred)\n    { return _Iter_pred<_Predicate>(std::move(__pred)); }\n\n  template<typename _Compare, typename _Value>\n    struct _Iter_comp_to_val\n    {\n '
[#] parse_declaration, is_constructor=False, meet line: '_Compare _M_comp;\n      _Value& _M_value;\n\n      _Iter_comp_to_val(_Compare __comp, _Value& __value)\n : _M_comp(std::move(__comp)), _M_value(__value)\n      { }\n\n      template<typename _Iterator>\n boo'
[#] parse_declaration, is_constructor=False, meet line: '_Value& _M_value;\n\n      _Iter_comp_to_val(_Compare __comp, _Value& __value)\n : _M_comp(std::move(__comp)), _M_value(__value)\n      { }\n\n      template<typename _Iterator>\n bool\n operator()(_Iterator '
[#] parse_declaration, is_constructor=True, meet line: '_Iter_comp_to_val(_Compare __comp, _Value& __value)\n : _M_comp(std::move(__comp)), _M_value(__value)\n      { }\n\n      template<typename _Iterator>\n bool\n operator()(_Iterator __it)\n { return bool(_M_c'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n operator()(_Iterator __it)\n { return bool(_M_comp(*__it, _M_value)); }\n    };\n\n  template<typename _Compare, typename _Value>\n    _Iter_comp_to_val<_Compare, _Value>\n    __iter_comp_val(_Compare'
[#] parse_declaration, is_constructor=False, meet line: '_Iter_comp_to_val<_Compare, _Value>\n    __iter_comp_val(_Compare __comp, _Value &__val)\n    {\n      return _Iter_comp_to_val<_Compare, _Value>(std::move(__comp), __val);\n    }\n\n  template<typename _Co'
[#] parse_declaration, is_constructor=False, meet line: '_Compare _M_comp;\n      _Iterator1 _M_it1;\n\n      _Iter_comp_to_iter(_Compare __comp, _Iterator1 __it1)\n : _M_comp(std::move(__comp)), _M_it1(__it1)\n      { }\n\n      template<typename _Iterator2>\n boo'
[#] parse_declaration, is_constructor=False, meet line: '_Iterator1 _M_it1;\n\n      _Iter_comp_to_iter(_Compare __comp, _Iterator1 __it1)\n : _M_comp(std::move(__comp)), _M_it1(__it1)\n      { }\n\n      template<typename _Iterator2>\n bool\n operator()(_Iterator2'
[#] parse_declaration, is_constructor=True, meet line: '_Iter_comp_to_iter(_Compare __comp, _Iterator1 __it1)\n : _M_comp(std::move(__comp)), _M_it1(__it1)\n      { }\n\n      template<typename _Iterator2>\n bool\n operator()(_Iterator2 __it2)\n { return bool(_M_'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n operator()(_Iterator2 __it2)\n { return bool(_M_comp(*__it2, *_M_it1)); }\n    };\n\n  template<typename _Compare, typename _Iterator>\n    inline _Iter_comp_to_iter<_Compare, _Iterator>\n    __iter_c'
[#] parse_declaration, is_constructor=False, meet line: '_Iter_comp_to_iter<_Compare, _Iterator>\n    __iter_comp_iter(_Iter_comp_iter<_Compare> __comp, _Iterator __it)\n    {\n      return _Iter_comp_to_iter<_Compare, _Iterator>(\n   std::move(__comp._M_comp),'
[#] parse_declaration, is_constructor=False, meet line: '_Predicate _M_pred;\n\n      explicit\n      _Iter_negate(_Predicate __pred)\n : _M_pred(std::move(__pred))\n      { }\n\n      template<typename _Iterator>\n bool\n operator()(_Iterator __it)\n { return !bool('
[#] parse_declaration, is_constructor=True, meet line: '_Iter_negate(_Predicate __pred)\n : _M_pred(std::move(__pred))\n      { }\n\n      template<typename _Iterator>\n bool\n operator()(_Iterator __it)\n { return !bool(_M_pred(*__it)); }\n    };\n\n  template<type'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n operator()(_Iterator __it)\n { return !bool(_M_pred(*__it)); }\n    };\n\n  template<typename _Predicate>\n    inline _Iter_negate<_Predicate>\n    __negate(_Iter_pred<_Predicate> __pred)\n    { return'
[#] parse_declaration, is_constructor=False, meet line: '_Iter_negate<_Predicate>\n    __negate(_Iter_pred<_Predicate> __pred)\n    { return _Iter_negate<_Predicate>(std::move(__pred._M_pred)); }\n\n}\n}\n# 72 "/usr/include/c++/7/bits/stl_algobase.h" 2 3\n\nnamespa'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)\n    {\n\n     \n\n     \n# 148 "/usr/include/c++/7/bits/stl_algobase.h" 3\n      swap(*__a, *__b);\n\n    }\n# 164 "/usr/include/c++/7/bits/stl_'
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator2\n    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n  _ForwardIterator2 __first2)\n    {\n\n     \n\n     \n\n      ;\n\n      for (; __first1 != __last1; ++__first1, (void'
[#] parse_declaration, is_constructor=False, meet line: '_Tp&\n    min(const _Tp& __a, const _Tp& __b)\n    {\n\n     \n\n      if (__b < __a)\n return __b;\n      return __a;\n    }\n# 216 "/usr/include/c++/7/bits/stl_algobase.h" 3\n  template<typename _Tp>\n    const'
[#] parse_declaration, is_constructor=False, meet line: '_Tp&\n    max(const _Tp& __a, const _Tp& __b)\n    {\n\n     \n\n      if (__a < __b)\n return __b;\n      return __a;\n    }\n# 240 "/usr/include/c++/7/bits/stl_algobase.h" 3\n  template<typename _Tp, typename '
[#] parse_declaration, is_constructor=False, meet line: '_Tp&\n    min(const _Tp& __a, const _Tp& __b, _Compare __comp)\n    {\n\n      if (__comp(__b, __a))\n return __b;\n      return __a;\n    }\n# 262 "/usr/include/c++/7/bits/stl_algobase.h" 3\n  template<typena'
[#] parse_declaration, is_constructor=False, meet line: '_Tp&\n    max(const _Tp& __a, const _Tp& __b, _Compare __comp)\n    {\n\n      if (__comp(__a, __b))\n return __b;\n      return __a;\n    }\n\n\n\n  template<typename _Iterator>\n    inline _Iterator\n    __niter'
[#] parse_declaration, is_constructor=False, meet line: '_Iterator\n    __niter_base(_Iterator __it)\n    { return __it; }\n\n\n\n\n\n\n\n  template<bool, bool, typename>\n    struct __copy_move\n    {\n      template<typename _II, typename _OI>\n        static _OI\n     '
[#] parse_declaration, is_constructor=False, meet line: '_OI\n        __copy_m(_II __first, _II __last, _OI __result)\n        {\n   for (; __first != __last; ++__result, (void)++__first)\n     *__result = *__first;\n   return __result;\n }\n    };\n\n\n  template<ty'
[#] parse_declaration, is_constructor=False, meet line: '_OI\n        __copy_m(_II __first, _II __last, _OI __result)\n        {\n   for (; __first != __last; ++__result, (void)++__first)\n     *__result = std::move(*__first);\n   return __result;\n }\n    };\n\n\n  '
[#] parse_declaration, is_constructor=False, meet line: '_OI\n        __copy_m(_II __first, _II __last, _OI __result)\n        {\n   typedef typename iterator_traits<_II>::difference_type _Distance;\n   for(_Distance __n = __last - __first; __n > 0; --__n)\n    '
[#] parse_declaration, is_constructor=False, meet line: '_OI\n        __copy_m(_II __first, _II __last, _OI __result)\n        {\n   typedef typename iterator_traits<_II>::difference_type _Distance;\n   for(_Distance __n = __last - __first; __n > 0; --__n)\n    '
[#] parse_declaration, is_constructor=False, meet line: '_Tp*\n        __copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)\n        {\n\n   using __assignable = conditional<_IsMove,\n        is_move_assignable<_Tp>,\n        is_copy_assignable<_Tp>>;\n\n'
[#] parse_declaration, is_constructor=False, meet line: '_OI\n    __copy_move_a(_II __first, _II __last, _OI __result)\n    {\n      typedef typename iterator_traits<_II>::value_type _ValueTypeI;\n      typedef typename iterator_traits<_OI>::value_type _ValueTy'
[#] parse_declaration, is_constructor=False, meet line: '__gnu_cxx::__enable_if<__is_char<_CharT>::__value,\n      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type\n    __copy_move_a2(_CharT*, _CharT*,\n     ostreambuf_iterator<_CharT, char_traits<_'
[#] parse_declaration, is_constructor=False, meet line: '__gnu_cxx::__enable_if<__is_char<_CharT>::__value,\n      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type\n    __copy_move_a2(const _CharT*, const _CharT*,\n     ostreambuf_iterator<_CharT, c'
[#] parse_declaration, is_constructor=False, meet line: '__gnu_cxx::__enable_if<__is_char<_CharT>::__value,\n        _CharT*>::__type\n    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,\n     istreambuf_iterator<_CharT, char_traits<_CharT> >'
[#] parse_declaration, is_constructor=False, meet line: '_OI\n    __copy_move_a2(_II __first, _II __last, _OI __result)\n    {\n      return _OI(std::__copy_move_a<_IsMove>(std::__niter_base(__first),\n          std::__niter_base(__last),\n          std::__niter'
[#] parse_declaration, is_constructor=False, meet line: '_OI\n    copy(_II __first, _II __last, _OI __result)\n    {\n\n     \n     \n\n      ;\n\n      return (std::__copy_move_a2<__is_move_iterator<_II>::__value>\n       (std::__miter_base(__first), std::__miter_ba'
[#] parse_declaration, is_constructor=False, meet line: '_OI\n    move(_II __first, _II __last, _OI __result)\n    {\n\n     \n     \n\n      ;\n\n      return std::__copy_move_a2<true>(std::__miter_base(__first),\n           std::__miter_base(__last), __result);\n   '
[#] parse_declaration, is_constructor=False, meet line: '_BI2\n        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)\n        {\n   while (__first != __last)\n     *--__result = *--__last;\n   return __result;\n }\n    };\n\n\n  template<typename _Category>'
[#] parse_declaration, is_constructor=False, meet line: '_BI2\n        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)\n        {\n   while (__first != __last)\n     *--__result = std::move(*--__last);\n   return __result;\n }\n    };\n\n\n  template<>\n    st'
[#] parse_declaration, is_constructor=False, meet line: '_BI2\n        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)\n        {\n   typename iterator_traits<_BI1>::difference_type __n;\n   for (__n = __last - __first; __n > 0; --__n)\n     *--__result '
[#] parse_declaration, is_constructor=False, meet line: '_BI2\n        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)\n        {\n   typename iterator_traits<_BI1>::difference_type __n;\n   for (__n = __last - __first; __n > 0; --__n)\n     *--__result '
[#] parse_declaration, is_constructor=False, meet line: '_Tp*\n        __copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)\n        {\n\n   using __assignable = conditional<_IsMove,\n        is_move_assignable<_Tp>,\n        is_copy_assignable<_Tp'
[#] parse_declaration, is_constructor=False, meet line: '_BI2\n    __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result)\n    {\n      typedef typename iterator_traits<_BI1>::value_type _ValueType1;\n      typedef typename iterator_traits<_BI2>::valu'
[#] parse_declaration, is_constructor=False, meet line: '_BI2\n    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)\n    {\n      return _BI2(std::__copy_move_backward_a<_IsMove>\n    (std::__niter_base(__first), std::__niter_base(__last),\n    '
[#] parse_declaration, is_constructor=False, meet line: '_BI2\n    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)\n    {\n\n     \n     \n     \n\n\n      ;\n\n      return (std::__copy_move_backward_a2<__is_move_iterator<_BI1>::__value>\n       (std::__miter_'
[#] parse_declaration, is_constructor=False, meet line: '_BI2\n    move_backward(_BI1 __first, _BI1 __last, _BI2 __result)\n    {\n\n     \n     \n     \n\n\n      ;\n\n      return std::__copy_move_backward_a2<true>(std::__miter_base(__first),\n      std::__miter_base'
[#] parse_declaration, is_constructor=False, meet line: '__gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type\n    __fill_a(_ForwardIterator __first, _ForwardIterator __last,\n       const _Tp& __value)\n    {\n      for (; __first != __last; ++__fi'
[#] parse_declaration, is_constructor=False, meet line: '__gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type\n    __fill_a(_ForwardIterator __first, _ForwardIterator __last,\n      const _Tp& __value)\n    {\n      const _Tp __tmp = __value;\n      f'
[#] parse_declaration, is_constructor=False, meet line: '__gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type\n    __fill_a(_Tp* __first, _Tp* __last, const _Tp& __c)\n    {\n      const _Tp __tmp = __c;\n      if (const size_t __len = __last - __first'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)\n    {\n\n     \n\n      ;\n\n      std::__fill_a(std::__niter_base(__first), std::__niter_base(__last),\n      __value);\n '
[#] parse_declaration, is_constructor=False, meet line: '__gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type\n    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)\n    {\n      for (__decltype(__n + 0) __niter = __n;\n '
[#] parse_declaration, is_constructor=False, meet line: '__gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type\n    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)\n    {\n      const _Tp __tmp = __value;\n      for (__de'
[#] parse_declaration, is_constructor=False, meet line: '__gnu_cxx::__enable_if<__is_byte<_Tp>::__value, _Tp*>::__type\n    __fill_n_a(_Tp* __first, _Size __n, const _Tp& __c)\n    {\n      std::__fill_a(__first, __first + __n, __c);\n      return __first + __n'
[#] parse_declaration, is_constructor=False, meet line: '_OI\n    fill_n(_OI __first, _Size __n, const _Tp& __value)\n    {\n\n     \n\n      return _OI(std::__fill_n_a(std::__niter_base(__first), __n, __value));\n    }\n\n  template<bool _BoolType>\n    struct __equ'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n        equal(_II1 __first1, _II1 __last1, _II2 __first2)\n        {\n   for (; __first1 != __last1; ++__first1, (void)++__first2)\n     if (!(*__first1 == *__first2))\n       return false;\n   return'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n        equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)\n        {\n   if (const size_t __len = (__last1 - __first1))\n     return !__builtin_memcmp(__first1, __first2, sizeof(_T'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)\n    {\n      typedef typename iterator_traits<_II1>::value_type _ValueType1;\n      typedef typename iterator_traits<_II2>::value_type _V'
[#] parse_declaration, is_constructor=False, meet line: '_II1\n        __newlast1(_II1, _II1 __last1, _II2, _II2)\n        { return __last1; }\n\n      template<typename _II>\n        static bool\n        __cnd2(_II __first, _II __last)\n        { return __first !'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n        __cnd2(_II __first, _II __last)\n        { return __first != __last; }\n    };\n\n  template<>\n    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>\n    {\n      template'
[#] parse_declaration, is_constructor=False, meet line: '_RAI1\n        __newlast1(_RAI1 __first1, _RAI1 __last1,\n     _RAI2 __first2, _RAI2 __last2)\n        {\n   const typename iterator_traits<_RAI1>::difference_type\n     __diff1 = __last1 - __first1;\n   co'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n        __cnd2(_RAI, _RAI)\n        { return true; }\n    };\n\n  template<typename _II1, typename _II2, typename _Compare>\n    bool\n    __lexicographical_compare_impl(_II1 __first1, _II1 __last1,\n  '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    __lexicographical_compare_impl(_II1 __first1, _II1 __last1,\n       _II2 __first2, _II2 __last2,\n       _Compare __comp)\n    {\n      typedef typename iterator_traits<_II1>::iterator_category _'
[#] parse_declaration, is_constructor=False, meet line: 'bool __lc(_II1, _II1, _II2, _II2);\n    };\n\n  template<bool _BoolType>\n    template<typename _II1, typename _II2>\n      bool\n      __lexicographical_compare<_BoolType>::\n      __lc(_II1 __first1, _II1 '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      __lexicographical_compare<_BoolType>::\n      __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)\n      {\n return std::__lexicographical_compare_impl(__first1, __last1,\n         _'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n        __lc(const _Tp* __first1, const _Tp* __last1,\n      const _Up* __first2, const _Up* __last2)\n {\n   const size_t __len1 = __last1 - __first1;\n   const size_t __len2 = __last2 - __first2;\n '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,\n      _II2 __first2, _II2 __last2)\n    {\n      typedef typename iterator_traits<_II1>::value_type _ValueType1;\n      typedef typenam'
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n    __lower_bound(_ForwardIterator __first, _ForwardIterator __last,\n    const _Tp& __val, _Compare __comp)\n    {\n      typedef typename iterator_traits<_ForwardIterator>::difference_'
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n    lower_bound(_ForwardIterator __first, _ForwardIterator __last,\n  const _Tp& __val)\n    {\n\n     \n     \n\n      ;\n\n      return std::__lower_bound(__first, __last, __val,\n    __gnu_c'
[#] parse_declaration, is_constructor=False, meet line: 'int\n  __lg(int __n)\n  { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }\n\n  inline constexpr unsigned\n  __lg(unsigned __n)\n  { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }\n\n  inline constexpr '
[#] parse_declaration, is_constructor=False, meet line: 'unsigned\n  __lg(unsigned __n)\n  { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }\n\n  inline constexpr long\n  __lg(long __n)\n  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }\n\n  inline conste'
[#] parse_declaration, is_constructor=False, meet line: 'long\n  __lg(long __n)\n  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }\n\n  inline constexpr unsigned long\n  __lg(unsigned long __n)\n  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }\n\n  i'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned long\n  __lg(unsigned long __n)\n  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }\n\n  inline constexpr long long\n  __lg(long long __n)\n  { return sizeof(long long) * 8 - 1 - __builtin_cl'
[#] parse_declaration, is_constructor=False, meet line: 'long long\n  __lg(long long __n)\n  { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }\n\n  inline constexpr unsigned long long\n  __lg(unsigned long long __n)\n  { return sizeof(long long) * 8 - '
[#] parse_declaration, is_constructor=False, meet line: 'unsigned long long\n  __lg(unsigned long long __n)\n  { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }\n\n\n\n\n# 1039 "/usr/include/c++/7/bits/stl_algobase.h" 3\n  template<typename _II1, typenam'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    equal(_II1 __first1, _II1 __last1, _II2 __first2)\n    {\n\n     \n     \n     \n\n\n      ;\n\n      return std::__equal_aux(std::__niter_base(__first1),\n         std::__niter_base(__last1),\n         '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    equal(_IIter1 __first1, _IIter1 __last1,\n   _IIter2 __first2, _BinaryPredicate __binary_pred)\n    {\n\n     \n     \n      ;\n\n      for (; __first1 != __last1; ++__first1, (void)++__first2)\n if ('
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    equal(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)\n    {\n\n     \n     \n     \n\n\n      ;\n      ;\n\n      using _RATag = random_access_iterator_tag;\n      using _Cat1 = typename itera'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    equal(_IIter1 __first1, _IIter1 __last1,\n   _IIter2 __first2, _IIter2 __last2, _BinaryPredicate __binary_pred)\n    {\n\n     \n     \n      ;\n      ;\n\n      using _RATag = random_access_iterator_'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    lexicographical_compare(_II1 __first1, _II1 __last1,\n       _II2 __first2, _II2 __last2)\n    {\n\n\n\n\n\n     \n     \n     \n     \n      ;\n      ;\n\n      return std::__lexicographical_compare_aux(st'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    lexicographical_compare(_II1 __first1, _II1 __last1,\n       _II2 __first2, _II2 __last2, _Compare __comp)\n    {\n\n     \n     \n      ;\n      ;\n\n      return std::__lexicographical_compare_impl\n'
[#] parse_declaration, is_constructor=False, meet line: 'pair<_InputIterator1, _InputIterator2>\n    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _BinaryPredicate __binary_pred)\n    {\n      while (__first1 !'
[#] parse_declaration, is_constructor=False, meet line: 'pair<_InputIterator1, _InputIterator2>\n    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n      _InputIterator2 __first2)\n    {\n\n     \n     \n     \n\n\n      ;\n\n      return std::__mismatch('
[#] parse_declaration, is_constructor=False, meet line: 'pair<_InputIterator1, _InputIterator2>\n    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n      _InputIterator2 __first2, _BinaryPredicate __binary_pred)\n    {\n\n     \n     \n      ;\n\n     '
[#] parse_declaration, is_constructor=False, meet line: 'pair<_InputIterator1, _InputIterator2>\n    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2,\n        _BinaryPredicate __binary_pr'
[#] parse_declaration, is_constructor=False, meet line: 'pair<_InputIterator1, _InputIterator2>\n    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n      _InputIterator2 __first2, _InputIterator2 __last2)\n    {\n\n     \n     \n     \n\n\n      ;\n     '
[#] parse_declaration, is_constructor=False, meet line: 'pair<_InputIterator1, _InputIterator2>\n    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n      _InputIterator2 __first2, _InputIterator2 __last2,\n      _BinaryPredicate __binary_pred)\n  '
[#] parse_declaration, is_constructor=False, meet line: 'size_t __ctype_get_mb_cur_max (void) throw () ;\n\n\n\nextern double atof (const char *__nptr)\n     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;\n\nextern int atoi (const char *__'
[#] parse_declaration, is_constructor=False, meet line: 'double atof (const char *__nptr)\n     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;\n\nextern int atoi (const char *__nptr)\n     throw () __attribute__ ((__pure__)) __attribute'
[#] parse_declaration, is_constructor=False, meet line: 'int atoi (const char *__nptr)\n     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;\n\nextern long int atol (const char *__nptr)\n     throw () __attribute__ ((__pure__)) __attribu'
[#] parse_declaration, is_constructor=False, meet line: 'long int atol (const char *__nptr)\n     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;\n\n\n\n__extension__ extern long long int atoll (const char *__nptr)\n     throw () __attribu'
[#] parse_declaration, is_constructor=False, meet line: 'long long int atoll (const char *__nptr)\n     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;\n\n\n\nextern double strtod (const char *__restrict __nptr,\n        char **__restrict '
[#] parse_declaration, is_constructor=False, meet line: 'double strtod (const char *__restrict __nptr,\n        char **__restrict __endptr)\n     throw () __attribute__ ((__nonnull__ (1)));\n\n\n\nextern float strtof (const char *__restrict __nptr,\n       char **'
[#] parse_declaration, is_constructor=False, meet line: 'float strtof (const char *__restrict __nptr,\n       char **__restrict __endptr) throw () __attribute__ ((__nonnull__ (1)));\n\nextern long double strtold (const char *__restrict __nptr,\n       char **__'
[#] parse_declaration, is_constructor=False, meet line: 'long double strtold (const char *__restrict __nptr,\n       char **__restrict __endptr)\n     throw () __attribute__ ((__nonnull__ (1)));\n# 140 "/usr/include/stdlib.h" 3 4\nextern _Float32 strtof32 (cons'
[#] parse_declaration, is_constructor=False, meet line: '_Float32 strtof32 (const char *__restrict __nptr,\n     char **__restrict __endptr)\n     throw () __attribute__ ((__nonnull__ (1)));\n\n\n\nextern _Float64 strtof64 (const char *__restrict __nptr,\n     cha'
[#] parse_declaration, is_constructor=False, meet line: '_Float64 strtof64 (const char *__restrict __nptr,\n     char **__restrict __endptr)\n     throw () __attribute__ ((__nonnull__ (1)));\n\n\n\nextern _Float128 strtof128 (const char *__restrict __nptr,\n      '
[#] parse_declaration, is_constructor=False, meet line: '_Float128 strtof128 (const char *__restrict __nptr,\n       char **__restrict __endptr)\n     throw () __attribute__ ((__nonnull__ (1)));\n\n\n\nextern _Float32x strtof32x (const char *__restrict __nptr,\n  '
[#] parse_declaration, is_constructor=False, meet line: '_Float32x strtof32x (const char *__restrict __nptr,\n       char **__restrict __endptr)\n     throw () __attribute__ ((__nonnull__ (1)));\n\n\n\nextern _Float64x strtof64x (const char *__restrict __nptr,\n  '
[#] parse_declaration, is_constructor=False, meet line: '_Float64x strtof64x (const char *__restrict __nptr,\n       char **__restrict __endptr)\n     throw () __attribute__ ((__nonnull__ (1)));\n# 176 "/usr/include/stdlib.h" 3 4\nextern long int strtol (const '
[#] parse_declaration, is_constructor=False, meet line: 'long int strtol (const char *__restrict __nptr,\n   char **__restrict __endptr, int __base)\n     throw () __attribute__ ((__nonnull__ (1)));\n\nextern unsigned long int strtoul (const char *__restrict __'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned long int strtoul (const char *__restrict __nptr,\n      char **__restrict __endptr, int __base)\n     throw () __attribute__ ((__nonnull__ (1)));\n\n\n\n__extension__\nextern long long int strtoq (c'
[#] parse_declaration, is_constructor=False, meet line: 'long long int strtoq (const char *__restrict __nptr,\n        char **__restrict __endptr, int __base)\n     throw () __attribute__ ((__nonnull__ (1)));\n\n__extension__\nextern unsigned long long int strto'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned long long int strtouq (const char *__restrict __nptr,\n           char **__restrict __endptr, int __base)\n     throw () __attribute__ ((__nonnull__ (1)));\n\n\n\n\n__extension__\nextern long long in'
[#] parse_declaration, is_constructor=False, meet line: 'long long int strtoll (const char *__restrict __nptr,\n         char **__restrict __endptr, int __base)\n     throw () __attribute__ ((__nonnull__ (1)));\n\n__extension__\nextern unsigned long long int str'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned long long int strtoull (const char *__restrict __nptr,\n     char **__restrict __endptr, int __base)\n     throw () __attribute__ ((__nonnull__ (1)));\n\n\n\n\nextern int strfromd (char *__dest, siz'
[#] parse_declaration, is_constructor=False, meet line: 'int strfromd (char *__dest, size_t __size, const char *__format,\n       double __f)\n     throw () __attribute__ ((__nonnull__ (3)));\n\nextern int strfromf (char *__dest, size_t __size, const char *__fo'
[#] parse_declaration, is_constructor=False, meet line: 'int strfromf (char *__dest, size_t __size, const char *__format,\n       float __f)\n     throw () __attribute__ ((__nonnull__ (3)));\n\nextern int strfroml (char *__dest, size_t __size, const char *__for'
[#] parse_declaration, is_constructor=False, meet line: 'int strfroml (char *__dest, size_t __size, const char *__format,\n       long double __f)\n     throw () __attribute__ ((__nonnull__ (3)));\n# 232 "/usr/include/stdlib.h" 3 4\nextern int strfromf32 (char '
[#] parse_declaration, is_constructor=False, meet line: 'int strfromf32 (char *__dest, size_t __size, const char * __format,\n         _Float32 __f)\n     throw () __attribute__ ((__nonnull__ (3)));\n\n\n\nextern int strfromf64 (char *__dest, size_t __size, const'
[#] parse_declaration, is_constructor=False, meet line: 'int strfromf64 (char *__dest, size_t __size, const char * __format,\n         _Float64 __f)\n     throw () __attribute__ ((__nonnull__ (3)));\n\n\n\nextern int strfromf128 (char *__dest, size_t __size, cons'
[#] parse_declaration, is_constructor=False, meet line: 'int strfromf128 (char *__dest, size_t __size, const char * __format,\n   _Float128 __f)\n     throw () __attribute__ ((__nonnull__ (3)));\n\n\n\nextern int strfromf32x (char *__dest, size_t __size, const ch'
[#] parse_declaration, is_constructor=False, meet line: 'int strfromf32x (char *__dest, size_t __size, const char * __format,\n   _Float32x __f)\n     throw () __attribute__ ((__nonnull__ (3)));\n\n\n\nextern int strfromf64x (char *__dest, size_t __size, const ch'
[#] parse_declaration, is_constructor=False, meet line: 'int strfromf64x (char *__dest, size_t __size, const char * __format,\n   _Float64x __f)\n     throw () __attribute__ ((__nonnull__ (3)));\n# 272 "/usr/include/stdlib.h" 3 4\n# 1 "/usr/include/x86_64-linux'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned short int *__ctype_b;\n  const int *__ctype_tolower;\n  const int *__ctype_toupper;\n\n\n  const char *__names[13];\n};\n\ntypedef struct __locale_struct *__locale_t;\n# 23 "/usr/include/x86_64-linux-'
[#] parse_declaration, is_constructor=False, meet line: 'int *__ctype_tolower;\n  const int *__ctype_toupper;\n\n\n  const char *__names[13];\n};\n\ntypedef struct __locale_struct *__locale_t;\n# 23 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 2 3 4\n\ntyped'
[#] parse_declaration, is_constructor=False, meet line: 'int *__ctype_toupper;\n\n\n  const char *__names[13];\n};\n\ntypedef struct __locale_struct *__locale_t;\n# 23 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 2 3 4\n\ntypedef __locale_t locale_t;\n# 273 '
[#] parse_declaration, is_constructor=False, meet line: 'char *__names[13];\n};\n\ntypedef struct __locale_struct *__locale_t;\n# 23 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 2 3 4\n\ntypedef __locale_t locale_t;\n# 273 "/usr/include/stdlib.h" 2 3 4\n\ne'
[#] parse_declaration, is_constructor=False, meet line: 'long int strtol_l (const char *__restrict __nptr,\n     char **__restrict __endptr, int __base,\n     locale_t __loc) throw () __attribute__ ((__nonnull__ (1, 4)));\n\nextern unsigned long int strtoul_l ('
[#] parse_declaration, is_constructor=False, meet line: 'unsigned long int strtoul_l (const char *__restrict __nptr,\n        char **__restrict __endptr,\n        int __base, locale_t __loc)\n     throw () __attribute__ ((__nonnull__ (1, 4)));\n\n__extension__\ne'
[#] parse_declaration, is_constructor=False, meet line: 'long long int strtoll_l (const char *__restrict __nptr,\n    char **__restrict __endptr, int __base,\n    locale_t __loc)\n     throw () __attribute__ ((__nonnull__ (1, 4)));\n\n__extension__\nextern unsign'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned long long int strtoull_l (const char *__restrict __nptr,\n       char **__restrict __endptr,\n       int __base, locale_t __loc)\n     throw () __attribute__ ((__nonnull__ (1, 4)));\n\nextern doub'
[#] parse_declaration, is_constructor=False, meet line: 'double strtod_l (const char *__restrict __nptr,\n   char **__restrict __endptr, locale_t __loc)\n     throw () __attribute__ ((__nonnull__ (1, 3)));\n\nextern float strtof_l (const char *__restrict __nptr'
[#] parse_declaration, is_constructor=False, meet line: 'float strtof_l (const char *__restrict __nptr,\n         char **__restrict __endptr, locale_t __loc)\n     throw () __attribute__ ((__nonnull__ (1, 3)));\n\nextern long double strtold_l (const char *__res'
[#] parse_declaration, is_constructor=False, meet line: 'long double strtold_l (const char *__restrict __nptr,\n         char **__restrict __endptr,\n         locale_t __loc)\n     throw () __attribute__ ((__nonnull__ (1, 3)));\n# 316 "/usr/include/stdlib.h" 3 '
[#] parse_declaration, is_constructor=False, meet line: '_Float32 strtof32_l (const char *__restrict __nptr,\n       char **__restrict __endptr,\n       locale_t __loc)\n     throw () __attribute__ ((__nonnull__ (1, 3)));\n\n\n\nextern _Float64 strtof64_l (const c'
[#] parse_declaration, is_constructor=False, meet line: '_Float64 strtof64_l (const char *__restrict __nptr,\n       char **__restrict __endptr,\n       locale_t __loc)\n     throw () __attribute__ ((__nonnull__ (1, 3)));\n\n\n\nextern _Float128 strtof128_l (const'
[#] parse_declaration, is_constructor=False, meet line: '_Float128 strtof128_l (const char *__restrict __nptr,\n         char **__restrict __endptr,\n         locale_t __loc)\n     throw () __attribute__ ((__nonnull__ (1, 3)));\n\n\n\nextern _Float32x strtof32x_l '
[#] parse_declaration, is_constructor=False, meet line: '_Float32x strtof32x_l (const char *__restrict __nptr,\n         char **__restrict __endptr,\n         locale_t __loc)\n     throw () __attribute__ ((__nonnull__ (1, 3)));\n\n\n\nextern _Float64x strtof64x_l '
[#] parse_declaration, is_constructor=False, meet line: '_Float64x strtof64x_l (const char *__restrict __nptr,\n         char **__restrict __endptr,\n         locale_t __loc)\n     throw () __attribute__ ((__nonnull__ (1, 3)));\n# 385 "/usr/include/stdlib.h" 3 '
[#] parse_declaration, is_constructor=False, meet line: 'char *l64a (long int __n) throw () ;\n\n\nextern long int a64l (const char *__s)\n     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;\n\n\n\n\n# 1 "/usr/include/x86_64-linux-gnu/sys/ty'
[#] parse_declaration, is_constructor=False, meet line: 'long int a64l (const char *__s)\n     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;\n\n\n\n\n# 1 "/usr/include/x86_64-linux-gnu/sys/types.h" 1 3 4\n# 27 "/usr/include/x86_64-linux-g'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned int\n__bswap_32 (unsigned int __bsx)\n{\n  return __builtin_bswap32 (__bsx);\n}\n# 108 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4\nstatic __inline __uint64_t\n__bswap_64 (__uint64_t __bsx)\n'
[#] parse_declaration, is_constructor=False, meet line: '__uint64_t\n__bswap_64 (__uint64_t __bsx)\n{\n  return __builtin_bswap64 (__bsx);\n}\n# 61 "/usr/include/endian.h" 2 3 4\n# 1 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 1 3 4\n# 32 "/usr/include/x'
[#] parse_declaration, is_constructor=False, meet line: '__uint16_t\n__uint16_identity (__uint16_t __x)\n{\n  return __x;\n}\n\nstatic __inline __uint32_t\n__uint32_identity (__uint32_t __x)\n{\n  return __x;\n}\n\nstatic __inline __uint64_t\n__uint64_identity (__uint64'
[#] parse_declaration, is_constructor=False, meet line: '__uint32_t\n__uint32_identity (__uint32_t __x)\n{\n  return __x;\n}\n\nstatic __inline __uint64_t\n__uint64_identity (__uint64_t __x)\n{\n  return __x;\n}\n# 62 "/usr/include/endian.h" 2 3 4\n# 195 "/usr/include/'
[#] parse_declaration, is_constructor=False, meet line: '__uint64_t\n__uint64_identity (__uint64_t __x)\n{\n  return __x;\n}\n# 62 "/usr/include/endian.h" 2 3 4\n# 195 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4\n\n\n# 1 "/usr/include/x86_64-linux-gnu/sys/sele'
[#] parse_declaration, is_constructor=False, meet line: '__time_t tv_sec;\n  __suseconds_t tv_usec;\n};\n# 38 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4\n\n# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 1 3 4\n\n\n\n\n\n\n\nstruct timespec\n{\n  '
[#] parse_declaration, is_constructor=False, meet line: '__suseconds_t tv_usec;\n};\n# 38 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4\n\n# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 1 3 4\n\n\n\n\n\n\n\nstruct timespec\n{\n  __time_t tv_sec;\n  '
[#] parse_declaration, is_constructor=False, meet line: '__time_t tv_sec;\n  __syscall_slong_t tv_nsec;\n};\n# 40 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4\n# 49 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4\ntypedef long int __fd_mask;\n# 59 "/usr/in'
[#] parse_declaration, is_constructor=False, meet line: '__syscall_slong_t tv_nsec;\n};\n# 40 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4\n# 49 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4\ntypedef long int __fd_mask;\n# 59 "/usr/include/x86_64-linux-'
[#] parse_declaration, is_constructor=False, meet line: 'int select (int __nfds, fd_set *__restrict __readfds,\n     fd_set *__restrict __writefds,\n     fd_set *__restrict __exceptfds,\n     struct timeval *__restrict __timeout);\n# 113 "/usr/include/x86_64-li'
[#] parse_declaration, is_constructor=False, meet line: 'int pselect (int __nfds, fd_set *__restrict __readfds,\n      fd_set *__restrict __writefds,\n      fd_set *__restrict __exceptfds,\n      const struct timespec *__restrict __timeout,\n      const __sigse'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned int gnu_dev_major (__dev_t __dev) throw () __attribute__ ((__const__));\nextern unsigned int gnu_dev_minor (__dev_t __dev) throw () __attribute__ ((__const__));\nextern __dev_t gnu_dev_makedev '
[#] parse_declaration, is_constructor=False, meet line: 'unsigned int gnu_dev_minor (__dev_t __dev) throw () __attribute__ ((__const__));\nextern __dev_t gnu_dev_makedev (unsigned int __major, unsigned int __minor) throw () __attribute__ ((__const__));\n# 85 '
[#] parse_declaration, is_constructor=False, meet line: '__dev_t gnu_dev_makedev (unsigned int __major, unsigned int __minor) throw () __attribute__ ((__const__));\n# 85 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 3 4\n}\n# 206 "/usr/include/x86_64-linux-g'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned int __readers;\n  unsigned int __writers;\n  unsigned int __wrphase_futex;\n  unsigned int __writers_futex;\n  unsigned int __pad3;\n  unsigned int __pad4;\n\n  int __cur_writer;\n  int __shared;\n  s'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned int __writers;\n  unsigned int __wrphase_futex;\n  unsigned int __writers_futex;\n  unsigned int __pad3;\n  unsigned int __pad4;\n\n  int __cur_writer;\n  int __shared;\n  signed char __rwelision;\n\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned int __wrphase_futex;\n  unsigned int __writers_futex;\n  unsigned int __pad3;\n  unsigned int __pad4;\n\n  int __cur_writer;\n  int __shared;\n  signed char __rwelision;\n\n\n\n\n  unsigned char __pad1[7'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned int __writers_futex;\n  unsigned int __pad3;\n  unsigned int __pad4;\n\n  int __cur_writer;\n  int __shared;\n  signed char __rwelision;\n\n\n\n\n  unsigned char __pad1[7];\n\n\n  unsigned long int __pad2;'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned int __pad3;\n  unsigned int __pad4;\n\n  int __cur_writer;\n  int __shared;\n  signed char __rwelision;\n\n\n\n\n  unsigned char __pad1[7];\n\n\n  unsigned long int __pad2;\n\n\n  unsigned int __flags;\n# 99 '
[#] parse_declaration, is_constructor=False, meet line: 'unsigned int __pad4;\n\n  int __cur_writer;\n  int __shared;\n  signed char __rwelision;\n\n\n\n\n  unsigned char __pad1[7];\n\n\n  unsigned long int __pad2;\n\n\n  unsigned int __flags;\n# 99 "/usr/include/x86_64-li'
[#] parse_declaration, is_constructor=False, meet line: 'int __cur_writer;\n  int __shared;\n  signed char __rwelision;\n\n\n\n\n  unsigned char __pad1[7];\n\n\n  unsigned long int __pad2;\n\n\n  unsigned int __flags;\n# 99 "/usr/include/x86_64-linux-gnu/bits/pthreadtype'
[#] parse_declaration, is_constructor=False, meet line: 'int __shared;\n  signed char __rwelision;\n\n\n\n\n  unsigned char __pad1[7];\n\n\n  unsigned long int __pad2;\n\n\n  unsigned int __flags;\n# 99 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4\n};\n# 7'
[#] parse_declaration, is_constructor=False, meet line: 'signed char __rwelision;\n\n\n\n\n  unsigned char __pad1[7];\n\n\n  unsigned long int __pad2;\n\n\n  unsigned int __flags;\n# 99 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4\n};\n# 78 "/usr/include/'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned char __pad1[7];\n\n\n  unsigned long int __pad2;\n\n\n  unsigned int __flags;\n# 99 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4\n};\n# 78 "/usr/include/x86_64-linux-gnu/bits/thread-sh'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned long int __pad2;\n\n\n  unsigned int __flags;\n# 99 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4\n};\n# 78 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4\n\n\n\n\ntyped'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned int __flags;\n# 99 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4\n};\n# 78 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4\n\n\n\n\ntypedef struct __pthread_internal_l'
[#] parse_declaration, is_constructor=False, meet line: 'int __lock ;\n  unsigned int __count;\n  int __owner;\n\n  unsigned int __nusers;\n\n\n\n  int __kind;\n \n\n\n\n\n  short __spins; short __elision;\n  __pthread_list_t __list;\n# 145 "/usr/include/x86_64-linux-gnu/b'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned int __count;\n  int __owner;\n\n  unsigned int __nusers;\n\n\n\n  int __kind;\n \n\n\n\n\n  short __spins; short __elision;\n  __pthread_list_t __list;\n# 145 "/usr/include/x86_64-linux-gnu/bits/thread-shar'
[#] parse_declaration, is_constructor=False, meet line: 'int __owner;\n\n  unsigned int __nusers;\n\n\n\n  int __kind;\n \n\n\n\n\n  short __spins; short __elision;\n  __pthread_list_t __list;\n# 145 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4\n \n};\n\n\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned int __nusers;\n\n\n\n  int __kind;\n \n\n\n\n\n  short __spins; short __elision;\n  __pthread_list_t __list;\n# 145 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4\n \n};\n\n\n\n\nstruct __pthrea'
[#] parse_declaration, is_constructor=False, meet line: 'int __kind;\n \n\n\n\n\n  short __spins; short __elision;\n  __pthread_list_t __list;\n# 145 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4\n \n};\n\n\n\n\nstruct __pthread_cond_s\n{\n  __extension__ u'
[#] parse_declaration, is_constructor=False, meet line: 'short __spins; short __elision;\n  __pthread_list_t __list;\n# 145 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4\n \n};\n\n\n\n\nstruct __pthread_cond_s\n{\n  __extension__ union\n  {\n    __exten'
[#] parse_declaration, is_constructor=False, meet line: 'short __elision;\n  __pthread_list_t __list;\n# 145 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4\n \n};\n\n\n\n\nstruct __pthread_cond_s\n{\n  __extension__ union\n  {\n    __extension__ unsigned'
[#] parse_declaration, is_constructor=False, meet line: '__pthread_list_t __list;\n# 145 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4\n \n};\n\n\n\n\nstruct __pthread_cond_s\n{\n  __extension__ union\n  {\n    __extension__ unsigned long long int __ws'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned long long int __wseq;\n    struct\n    {\n      unsigned int __low;\n      unsigned int __high;\n    } __wseq32;\n  };\n  __extension__ union\n  {\n    __extension__ unsigned long long int __g1_start;'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned int __low;\n      unsigned int __high;\n    } __wseq32;\n  };\n  __extension__ union\n  {\n    __extension__ unsigned long long int __g1_start;\n    struct\n    {\n      unsigned int __low;\n      unsi'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned int __high;\n    } __wseq32;\n  };\n  __extension__ union\n  {\n    __extension__ unsigned long long int __g1_start;\n    struct\n    {\n      unsigned int __low;\n      unsigned int __high;\n    } __g'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned long long int __g1_start;\n    struct\n    {\n      unsigned int __low;\n      unsigned int __high;\n    } __g1_start32;\n  };\n  unsigned int __g_refs[2] ;\n  unsigned int __g_size[2];\n  unsigned in'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned int __low;\n      unsigned int __high;\n    } __g1_start32;\n  };\n  unsigned int __g_refs[2] ;\n  unsigned int __g_size[2];\n  unsigned int __g1_orig_size;\n  unsigned int __wrefs;\n  unsigned int _'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned int __high;\n    } __g1_start32;\n  };\n  unsigned int __g_refs[2] ;\n  unsigned int __g_size[2];\n  unsigned int __g1_orig_size;\n  unsigned int __wrefs;\n  unsigned int __g_signals[2];\n};\n# 24 "/u'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned int __g_refs[2] ;\n  unsigned int __g_size[2];\n  unsigned int __g1_orig_size;\n  unsigned int __wrefs;\n  unsigned int __g_signals[2];\n};\n# 24 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned int __g_size[2];\n  unsigned int __g1_orig_size;\n  unsigned int __wrefs;\n  unsigned int __g_signals[2];\n};\n# 24 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 2 3 4\n\n\n\ntypedef unsigned lo'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned int __g1_orig_size;\n  unsigned int __wrefs;\n  unsigned int __g_signals[2];\n};\n# 24 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 2 3 4\n\n\n\ntypedef unsigned long int pthread_t;\n\n\n\n\ntypede'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned int __wrefs;\n  unsigned int __g_signals[2];\n};\n# 24 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 2 3 4\n\n\n\ntypedef unsigned long int pthread_t;\n\n\n\n\ntypedef union\n{\n  char __size[4];\n  i'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned int __g_signals[2];\n};\n# 24 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 2 3 4\n\n\n\ntypedef unsigned long int pthread_t;\n\n\n\n\ntypedef union\n{\n  char __size[4];\n  int __align;\n} pthread_mu'
[#] parse_declaration, is_constructor=False, meet line: 'char __size[56];\n  long int __align;\n};\n\ntypedef union pthread_attr_t pthread_attr_t;\n\n\n\n\ntypedef union\n{\n  struct __pthread_mutex_s __data;\n  char __size[40];\n  long int __align;\n} pthread_mutex_t;\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'long int __align;\n};\n\ntypedef union pthread_attr_t pthread_attr_t;\n\n\n\n\ntypedef union\n{\n  struct __pthread_mutex_s __data;\n  char __size[40];\n  long int __align;\n} pthread_mutex_t;\n\n\ntypedef union\n{\n  '
[#] parse_declaration, is_constructor=False, meet line: 'long int random (void) throw ();\n\n\nextern void srandom (unsigned int __seed) throw ();\n\n\n\n\n\nextern char *initstate (unsigned int __seed, char *__statebuf,\n   size_t __statelen) throw () __attribute__ '
[#] parse_declaration, is_constructor=False, meet line: 'void srandom (unsigned int __seed) throw ();\n\n\n\n\n\nextern char *initstate (unsigned int __seed, char *__statebuf,\n   size_t __statelen) throw () __attribute__ ((__nonnull__ (2)));\n\n\n\nextern char *setst'
[#] parse_declaration, is_constructor=False, meet line: 'char *initstate (unsigned int __seed, char *__statebuf,\n   size_t __statelen) throw () __attribute__ ((__nonnull__ (2)));\n\n\n\nextern char *setstate (char *__statebuf) throw () __attribute__ ((__nonnull'
[#] parse_declaration, is_constructor=False, meet line: 'char *setstate (char *__statebuf) throw () __attribute__ ((__nonnull__ (1)));\n\n\n\n\n\n\n\nstruct random_data\n  {\n    int32_t *fptr;\n    int32_t *rptr;\n    int32_t *state;\n    int rand_type;\n    int rand_de'
[#] parse_declaration, is_constructor=False, meet line: 'int32_t *fptr;\n    int32_t *rptr;\n    int32_t *state;\n    int rand_type;\n    int rand_deg;\n    int rand_sep;\n    int32_t *end_ptr;\n  };\n\nextern int random_r (struct random_data *__restrict __buf,\n    '
[#] parse_declaration, is_constructor=False, meet line: 'int32_t *rptr;\n    int32_t *state;\n    int rand_type;\n    int rand_deg;\n    int rand_sep;\n    int32_t *end_ptr;\n  };\n\nextern int random_r (struct random_data *__restrict __buf,\n       int32_t *__restr'
[#] parse_declaration, is_constructor=False, meet line: 'int32_t *state;\n    int rand_type;\n    int rand_deg;\n    int rand_sep;\n    int32_t *end_ptr;\n  };\n\nextern int random_r (struct random_data *__restrict __buf,\n       int32_t *__restrict __result) throw'
[#] parse_declaration, is_constructor=False, meet line: 'int rand_type;\n    int rand_deg;\n    int rand_sep;\n    int32_t *end_ptr;\n  };\n\nextern int random_r (struct random_data *__restrict __buf,\n       int32_t *__restrict __result) throw () __attribute__ (('
[#] parse_declaration, is_constructor=False, meet line: 'int rand_deg;\n    int rand_sep;\n    int32_t *end_ptr;\n  };\n\nextern int random_r (struct random_data *__restrict __buf,\n       int32_t *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2))'
[#] parse_declaration, is_constructor=False, meet line: 'int rand_sep;\n    int32_t *end_ptr;\n  };\n\nextern int random_r (struct random_data *__restrict __buf,\n       int32_t *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));\n\nextern int sra'
[#] parse_declaration, is_constructor=False, meet line: 'int32_t *end_ptr;\n  };\n\nextern int random_r (struct random_data *__restrict __buf,\n       int32_t *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));\n\nextern int srandom_r (unsigned i'
[#] parse_declaration, is_constructor=False, meet line: 'int random_r (struct random_data *__restrict __buf,\n       int32_t *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));\n\nextern int srandom_r (unsigned int __seed, struct random_data *'
[#] parse_declaration, is_constructor=False, meet line: 'int srandom_r (unsigned int __seed, struct random_data *__buf)\n     throw () __attribute__ ((__nonnull__ (2)));\n\nextern int initstate_r (unsigned int __seed, char *__restrict __statebuf,\n   size_t __s'
[#] parse_declaration, is_constructor=False, meet line: 'int initstate_r (unsigned int __seed, char *__restrict __statebuf,\n   size_t __statelen,\n   struct random_data *__restrict __buf)\n     throw () __attribute__ ((__nonnull__ (2, 4)));\n\nextern int setsta'
[#] parse_declaration, is_constructor=False, meet line: 'int setstate_r (char *__restrict __statebuf,\n         struct random_data *__restrict __buf)\n     throw () __attribute__ ((__nonnull__ (1, 2)));\n\n\n\n\n\nextern int rand (void) throw ();\n\nextern void srand'
[#] parse_declaration, is_constructor=False, meet line: 'int rand (void) throw ();\n\nextern void srand (unsigned int __seed) throw ();\n\n\n\nextern int rand_r (unsigned int *__seed) throw ();\n\n\n\n\n\n\n\nextern double drand48 (void) throw ();\nextern double erand48 ('
[#] parse_declaration, is_constructor=False, meet line: 'void srand (unsigned int __seed) throw ();\n\n\n\nextern int rand_r (unsigned int *__seed) throw ();\n\n\n\n\n\n\n\nextern double drand48 (void) throw ();\nextern double erand48 (unsigned short int __xsubi[3]) thr'
[#] parse_declaration, is_constructor=False, meet line: 'int rand_r (unsigned int *__seed) throw ();\n\n\n\n\n\n\n\nextern double drand48 (void) throw ();\nextern double erand48 (unsigned short int __xsubi[3]) throw () __attribute__ ((__nonnull__ (1)));\n\n\nextern lon'
[#] parse_declaration, is_constructor=False, meet line: 'double drand48 (void) throw ();\nextern double erand48 (unsigned short int __xsubi[3]) throw () __attribute__ ((__nonnull__ (1)));\n\n\nextern long int lrand48 (void) throw ();\nextern long int nrand48 (un'
[#] parse_declaration, is_constructor=False, meet line: 'double erand48 (unsigned short int __xsubi[3]) throw () __attribute__ ((__nonnull__ (1)));\n\n\nextern long int lrand48 (void) throw ();\nextern long int nrand48 (unsigned short int __xsubi[3])\n     throw'
[#] parse_declaration, is_constructor=False, meet line: 'long int lrand48 (void) throw ();\nextern long int nrand48 (unsigned short int __xsubi[3])\n     throw () __attribute__ ((__nonnull__ (1)));\n\n\nextern long int mrand48 (void) throw ();\nextern long int jr'
[#] parse_declaration, is_constructor=False, meet line: 'long int nrand48 (unsigned short int __xsubi[3])\n     throw () __attribute__ ((__nonnull__ (1)));\n\n\nextern long int mrand48 (void) throw ();\nextern long int jrand48 (unsigned short int __xsubi[3])\n   '
[#] parse_declaration, is_constructor=False, meet line: 'long int mrand48 (void) throw ();\nextern long int jrand48 (unsigned short int __xsubi[3])\n     throw () __attribute__ ((__nonnull__ (1)));\n\n\nextern void srand48 (long int __seedval) throw ();\nextern u'
[#] parse_declaration, is_constructor=False, meet line: 'long int jrand48 (unsigned short int __xsubi[3])\n     throw () __attribute__ ((__nonnull__ (1)));\n\n\nextern void srand48 (long int __seedval) throw ();\nextern unsigned short int *seed48 (unsigned short'
[#] parse_declaration, is_constructor=False, meet line: 'void srand48 (long int __seedval) throw ();\nextern unsigned short int *seed48 (unsigned short int __seed16v[3])\n     throw () __attribute__ ((__nonnull__ (1)));\nextern void lcong48 (unsigned short int'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned short int *seed48 (unsigned short int __seed16v[3])\n     throw () __attribute__ ((__nonnull__ (1)));\nextern void lcong48 (unsigned short int __param[7]) throw () __attribute__ ((__nonnull__ ('
[#] parse_declaration, is_constructor=False, meet line: 'void lcong48 (unsigned short int __param[7]) throw () __attribute__ ((__nonnull__ (1)));\n\n\n\n\n\nstruct drand48_data\n  {\n    unsigned short int __x[3];\n    unsigned short int __old_x[3];\n    unsigned sho'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned short int __x[3];\n    unsigned short int __old_x[3];\n    unsigned short int __c;\n    unsigned short int __init;\n    __extension__ unsigned long long int __a;\n\n  };\n\n\nextern int drand48_r (str'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned short int __old_x[3];\n    unsigned short int __c;\n    unsigned short int __init;\n    __extension__ unsigned long long int __a;\n\n  };\n\n\nextern int drand48_r (struct drand48_data *__restrict __'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned short int __c;\n    unsigned short int __init;\n    __extension__ unsigned long long int __a;\n\n  };\n\n\nextern int drand48_r (struct drand48_data *__restrict __buffer,\n        double *__restrict '
[#] parse_declaration, is_constructor=False, meet line: 'unsigned short int __init;\n    __extension__ unsigned long long int __a;\n\n  };\n\n\nextern int drand48_r (struct drand48_data *__restrict __buffer,\n        double *__restrict __result) throw () __attribu'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned long long int __a;\n\n  };\n\n\nextern int drand48_r (struct drand48_data *__restrict __buffer,\n        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));\nextern int erand'
[#] parse_declaration, is_constructor=False, meet line: 'int drand48_r (struct drand48_data *__restrict __buffer,\n        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));\nextern int erand48_r (unsigned short int __xsubi[3],\n      '
[#] parse_declaration, is_constructor=False, meet line: 'int erand48_r (unsigned short int __xsubi[3],\n        struct drand48_data *__restrict __buffer,\n        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));\n\n\nextern int lrand48'
[#] parse_declaration, is_constructor=False, meet line: 'int lrand48_r (struct drand48_data *__restrict __buffer,\n        long int *__restrict __result)\n     throw () __attribute__ ((__nonnull__ (1, 2)));\nextern int nrand48_r (unsigned short int __xsubi[3],'
[#] parse_declaration, is_constructor=False, meet line: 'int nrand48_r (unsigned short int __xsubi[3],\n        struct drand48_data *__restrict __buffer,\n        long int *__restrict __result)\n     throw () __attribute__ ((__nonnull__ (1, 2)));\n\n\nextern int '
[#] parse_declaration, is_constructor=False, meet line: 'int mrand48_r (struct drand48_data *__restrict __buffer,\n        long int *__restrict __result)\n     throw () __attribute__ ((__nonnull__ (1, 2)));\nextern int jrand48_r (unsigned short int __xsubi[3],'
[#] parse_declaration, is_constructor=False, meet line: 'int jrand48_r (unsigned short int __xsubi[3],\n        struct drand48_data *__restrict __buffer,\n        long int *__restrict __result)\n     throw () __attribute__ ((__nonnull__ (1, 2)));\n\n\nextern int '
[#] parse_declaration, is_constructor=False, meet line: 'int srand48_r (long int __seedval, struct drand48_data *__buffer)\n     throw () __attribute__ ((__nonnull__ (2)));\n\nextern int seed48_r (unsigned short int __seed16v[3],\n       struct drand48_data *__'
[#] parse_declaration, is_constructor=False, meet line: 'int seed48_r (unsigned short int __seed16v[3],\n       struct drand48_data *__buffer) throw () __attribute__ ((__nonnull__ (1, 2)));\n\nextern int lcong48_r (unsigned short int __param[7],\n        struct'
[#] parse_declaration, is_constructor=False, meet line: 'int lcong48_r (unsigned short int __param[7],\n        struct drand48_data *__buffer)\n     throw () __attribute__ ((__nonnull__ (1, 2)));\n\n\n\n\nextern void *malloc (size_t __size) throw () __attribute__ '
[#] parse_declaration, is_constructor=False, meet line: 'void *malloc (size_t __size) throw () __attribute__ ((__malloc__)) ;\n\nextern void *calloc (size_t __nmemb, size_t __size)\n     throw () __attribute__ ((__malloc__)) ;\n\n\n\n\n\n\nextern void *realloc (void '
[#] parse_declaration, is_constructor=False, meet line: 'void *calloc (size_t __nmemb, size_t __size)\n     throw () __attribute__ ((__malloc__)) ;\n\n\n\n\n\n\nextern void *realloc (void *__ptr, size_t __size)\n     throw () __attribute__ ((__warn_unused_result__))'
[#] parse_declaration, is_constructor=False, meet line: 'void *realloc (void *__ptr, size_t __size)\n     throw () __attribute__ ((__warn_unused_result__));\n\n\n\n\n\n\n\nextern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)\n     throw () __attribu'
[#] parse_declaration, is_constructor=False, meet line: 'void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)\n     throw () __attribute__ ((__warn_unused_result__));\n\n\n\nextern void free (void *__ptr) throw ();\n\n\n# 1 "/usr/include/alloca.h" 1 3 4\n'
[#] parse_declaration, is_constructor=False, meet line: 'void free (void *__ptr) throw ();\n\n\n# 1 "/usr/include/alloca.h" 1 3 4\n# 24 "/usr/include/alloca.h" 3 4\n# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4\n# 25 "/usr/include/alloca.h" 2 3 4\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'void *alloca (size_t __size) throw ();\n\n\n\n\n\n}\n# 567 "/usr/include/stdlib.h" 2 3 4\n\n\n\n\n\nextern void *valloc (size_t __size) throw () __attribute__ ((__malloc__)) ;\n\n\n\n\nextern int posix_memalign (void *'
[#] parse_declaration, is_constructor=False, meet line: 'void *valloc (size_t __size) throw () __attribute__ ((__malloc__)) ;\n\n\n\n\nextern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)\n     throw () __attribute__ ((__nonnull__ (1))) '
[#] parse_declaration, is_constructor=False, meet line: 'int posix_memalign (void **__memptr, size_t __alignment, size_t __size)\n     throw () __attribute__ ((__nonnull__ (1))) ;\n\n\n\n\nextern void *aligned_alloc (size_t __alignment, size_t __size)\n     throw '
[#] parse_declaration, is_constructor=False, meet line: 'void *aligned_alloc (size_t __alignment, size_t __size)\n     throw () __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (2))) ;\n\n\n\nextern void abort (void) throw () __attribute__ ((__noretur'
[#] parse_declaration, is_constructor=False, meet line: 'void abort (void) throw () __attribute__ ((__noreturn__));\n\n\n\nextern int atexit (void (*__func) (void)) throw () __attribute__ ((__nonnull__ (1)));\n\n\n\n\nextern "C++" int at_quick_exit (void (*__func) ('
[#] parse_declaration, is_constructor=False, meet line: 'int atexit (void (*__func) (void)) throw () __attribute__ ((__nonnull__ (1)));\n\n\n\n\nextern "C++" int at_quick_exit (void (*__func) (void))\n     throw () __asm ("at_quick_exit") __attribute__ ((__nonnul'
[#] parse_declaration, is_constructor=False, meet line: ' int at_quick_exit (void (*__func) (void))\n     throw () __asm ("at_quick_exit") __attribute__ ((__nonnull__ (1)));\n# 607 "/usr/include/stdlib.h" 3 4\nextern int on_exit (void (*__func) (int __status, '
[#] parse_declaration, is_constructor=False, meet line: 'int on_exit (void (*__func) (int __status, void *__arg), void *__arg)\n     throw () __attribute__ ((__nonnull__ (1)));\n\n\n\n\n\nextern void exit (int __status) throw () __attribute__ ((__noreturn__));\n\n\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'void exit (int __status) throw () __attribute__ ((__noreturn__));\n\n\n\n\n\nextern void quick_exit (int __status) throw () __attribute__ ((__noreturn__));\n\n\n\n\n\nextern void _Exit (int __status) throw () __a'
[#] parse_declaration, is_constructor=False, meet line: 'void quick_exit (int __status) throw () __attribute__ ((__noreturn__));\n\n\n\n\n\nextern void _Exit (int __status) throw () __attribute__ ((__noreturn__));\n\n\n\n\nextern char *getenv (const char *__name) thro'
[#] parse_declaration, is_constructor=False, meet line: 'void _Exit (int __status) throw () __attribute__ ((__noreturn__));\n\n\n\n\nextern char *getenv (const char *__name) throw () __attribute__ ((__nonnull__ (1))) ;\n\n\n\n\nextern char *secure_getenv (const char '
[#] parse_declaration, is_constructor=False, meet line: 'char *getenv (const char *__name) throw () __attribute__ ((__nonnull__ (1))) ;\n\n\n\n\nextern char *secure_getenv (const char *__name)\n     throw () __attribute__ ((__nonnull__ (1))) ;\n\n\n\n\n\n\nextern int pu'
[#] parse_declaration, is_constructor=False, meet line: 'char *secure_getenv (const char *__name)\n     throw () __attribute__ ((__nonnull__ (1))) ;\n\n\n\n\n\n\nextern int putenv (char *__string) throw () __attribute__ ((__nonnull__ (1)));\n\n\n\n\n\nextern int setenv ('
[#] parse_declaration, is_constructor=False, meet line: 'int putenv (char *__string) throw () __attribute__ ((__nonnull__ (1)));\n\n\n\n\n\nextern int setenv (const char *__name, const char *__value, int __replace)\n     throw () __attribute__ ((__nonnull__ (2)));'
[#] parse_declaration, is_constructor=False, meet line: 'int setenv (const char *__name, const char *__value, int __replace)\n     throw () __attribute__ ((__nonnull__ (2)));\n\n\nextern int unsetenv (const char *__name) throw () __attribute__ ((__nonnull__ (1)'
[#] parse_declaration, is_constructor=False, meet line: 'int unsetenv (const char *__name) throw () __attribute__ ((__nonnull__ (1)));\n\n\n\n\n\n\nextern int clearenv (void) throw ();\n# 672 "/usr/include/stdlib.h" 3 4\nextern char *mktemp (char *__template) throw '
[#] parse_declaration, is_constructor=False, meet line: 'int clearenv (void) throw ();\n# 672 "/usr/include/stdlib.h" 3 4\nextern char *mktemp (char *__template) throw () __attribute__ ((__nonnull__ (1)));\n# 685 "/usr/include/stdlib.h" 3 4\nextern int mkstemp '
[#] parse_declaration, is_constructor=False, meet line: 'char *mktemp (char *__template) throw () __attribute__ ((__nonnull__ (1)));\n# 685 "/usr/include/stdlib.h" 3 4\nextern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;\n# 695 "/usr/incl'
[#] parse_declaration, is_constructor=False, meet line: 'int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;\n# 695 "/usr/include/stdlib.h" 3 4\nextern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;\n# 707 "/usr/include/std'
[#] parse_declaration, is_constructor=False, meet line: 'int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;\n# 707 "/usr/include/stdlib.h" 3 4\nextern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;\n# 717'
[#] parse_declaration, is_constructor=False, meet line: 'int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;\n# 717 "/usr/include/stdlib.h" 3 4\nextern int mkstemps64 (char *__template, int __suffixlen)\n     __attribute__ ((__'
[#] parse_declaration, is_constructor=False, meet line: 'int mkstemps64 (char *__template, int __suffixlen)\n     __attribute__ ((__nonnull__ (1))) ;\n# 728 "/usr/include/stdlib.h" 3 4\nextern char *mkdtemp (char *__template) throw () __attribute__ ((__nonnull'
[#] parse_declaration, is_constructor=False, meet line: 'char *mkdtemp (char *__template) throw () __attribute__ ((__nonnull__ (1))) ;\n# 739 "/usr/include/stdlib.h" 3 4\nextern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;\n'
[#] parse_declaration, is_constructor=False, meet line: 'int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;\n# 749 "/usr/include/stdlib.h" 3 4\nextern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1)'
[#] parse_declaration, is_constructor=False, meet line: 'int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;\n# 759 "/usr/include/stdlib.h" 3 4\nextern int mkostemps (char *__template, int __suffixlen, int __flags)\n     __attrib'
[#] parse_declaration, is_constructor=False, meet line: 'int mkostemps (char *__template, int __suffixlen, int __flags)\n     __attribute__ ((__nonnull__ (1))) ;\n# 771 "/usr/include/stdlib.h" 3 4\nextern int mkostemps64 (char *__template, int __suffixlen, int'
[#] parse_declaration, is_constructor=False, meet line: 'int mkostemps64 (char *__template, int __suffixlen, int __flags)\n     __attribute__ ((__nonnull__ (1))) ;\n# 781 "/usr/include/stdlib.h" 3 4\nextern int system (const char *__command) ;\n\n\n\n\n\nextern char'
[#] parse_declaration, is_constructor=False, meet line: 'int system (const char *__command) ;\n\n\n\n\n\nextern char *canonicalize_file_name (const char *__name)\n     throw () __attribute__ ((__nonnull__ (1))) ;\n# 797 "/usr/include/stdlib.h" 3 4\nextern char *real'
[#] parse_declaration, is_constructor=False, meet line: 'char *canonicalize_file_name (const char *__name)\n     throw () __attribute__ ((__nonnull__ (1))) ;\n# 797 "/usr/include/stdlib.h" 3 4\nextern char *realpath (const char *__restrict __name,\n         cha'
[#] parse_declaration, is_constructor=False, meet line: 'char *realpath (const char *__restrict __name,\n         char *__restrict __resolved) throw () ;\n\n\n\n\n\n\ntypedef int (*__compar_fn_t) (const void *, const void *);\n\n\ntypedef __compar_fn_t comparison_fn_t'
[#] parse_declaration, is_constructor=False, meet line: 'void *bsearch (const void *__key, const void *__base,\n        size_t __nmemb, size_t __size, __compar_fn_t __compar)\n     __attribute__ ((__nonnull__ (1, 2, 5))) ;\n\n\n\n\n\n\n\nextern void qsort (void *__ba'
[#] parse_declaration, is_constructor=False, meet line: 'void qsort (void *__base, size_t __nmemb, size_t __size,\n     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));\n\nextern void qsort_r (void *__base, size_t __nmemb, size_t __size,\n       __'
[#] parse_declaration, is_constructor=False, meet line: 'void qsort_r (void *__base, size_t __nmemb, size_t __size,\n       __compar_d_fn_t __compar, void *__arg)\n  __attribute__ ((__nonnull__ (1, 4)));\n\n\n\n\nextern int abs (int __x) throw () __attribute__ ((_'
[#] parse_declaration, is_constructor=False, meet line: 'int abs (int __x) throw () __attribute__ ((__const__)) ;\nextern long int labs (long int __x) throw () __attribute__ ((__const__)) ;\n\n\n__extension__ extern long long int llabs (long long int __x)\n     '
[#] parse_declaration, is_constructor=False, meet line: 'long int labs (long int __x) throw () __attribute__ ((__const__)) ;\n\n\n__extension__ extern long long int llabs (long long int __x)\n     throw () __attribute__ ((__const__)) ;\n\n\n\n\n\n\nextern div_t div (i'
[#] parse_declaration, is_constructor=False, meet line: 'long long int llabs (long long int __x)\n     throw () __attribute__ ((__const__)) ;\n\n\n\n\n\n\nextern div_t div (int __numer, int __denom)\n     throw () __attribute__ ((__const__)) ;\nextern ldiv_t ldiv (lo'
[#] parse_declaration, is_constructor=False, meet line: 'div_t div (int __numer, int __denom)\n     throw () __attribute__ ((__const__)) ;\nextern ldiv_t ldiv (long int __numer, long int __denom)\n     throw () __attribute__ ((__const__)) ;\n\n\n__extension__ ext'
[#] parse_declaration, is_constructor=False, meet line: 'ldiv_t ldiv (long int __numer, long int __denom)\n     throw () __attribute__ ((__const__)) ;\n\n\n__extension__ extern lldiv_t lldiv (long long int __numer,\n        long long int __denom)\n     throw () _'
[#] parse_declaration, is_constructor=False, meet line: 'lldiv_t lldiv (long long int __numer,\n        long long int __denom)\n     throw () __attribute__ ((__const__)) ;\n# 869 "/usr/include/stdlib.h" 3 4\nextern char *ecvt (double __value, int __ndigit, int '
[#] parse_declaration, is_constructor=False, meet line: 'char *ecvt (double __value, int __ndigit, int *__restrict __decpt,\n     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;\n\n\n\n\nextern char *fcvt (double __value, int __ndigit, int'
[#] parse_declaration, is_constructor=False, meet line: 'char *fcvt (double __value, int __ndigit, int *__restrict __decpt,\n     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;\n\n\n\n\nextern char *gcvt (double __value, int __ndigit, cha'
[#] parse_declaration, is_constructor=False, meet line: 'char *gcvt (double __value, int __ndigit, char *__buf)\n     throw () __attribute__ ((__nonnull__ (3))) ;\n\n\n\n\nextern char *qecvt (long double __value, int __ndigit,\n      int *__restrict __decpt, int *'
[#] parse_declaration, is_constructor=False, meet line: 'char *qecvt (long double __value, int __ndigit,\n      int *__restrict __decpt, int *__restrict __sign)\n     throw () __attribute__ ((__nonnull__ (3, 4))) ;\nextern char *qfcvt (long double __value, int'
[#] parse_declaration, is_constructor=False, meet line: 'char *qfcvt (long double __value, int __ndigit,\n      int *__restrict __decpt, int *__restrict __sign)\n     throw () __attribute__ ((__nonnull__ (3, 4))) ;\nextern char *qgcvt (long double __value, int'
[#] parse_declaration, is_constructor=False, meet line: 'char *qgcvt (long double __value, int __ndigit, char *__buf)\n     throw () __attribute__ ((__nonnull__ (3))) ;\n\n\n\n\nextern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,\n     int *_'
[#] parse_declaration, is_constructor=False, meet line: 'int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,\n     int *__restrict __sign, char *__restrict __buf,\n     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));\nextern int '
[#] parse_declaration, is_constructor=False, meet line: 'int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,\n     int *__restrict __sign, char *__restrict __buf,\n     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));\n\nextern int'
[#] parse_declaration, is_constructor=False, meet line: 'int qecvt_r (long double __value, int __ndigit,\n      int *__restrict __decpt, int *__restrict __sign,\n      char *__restrict __buf, size_t __len)\n     throw () __attribute__ ((__nonnull__ (3, 4, 5)))'
[#] parse_declaration, is_constructor=False, meet line: 'int qfcvt_r (long double __value, int __ndigit,\n      int *__restrict __decpt, int *__restrict __sign,\n      char *__restrict __buf, size_t __len)\n     throw () __attribute__ ((__nonnull__ (3, 4, 5)))'
[#] parse_declaration, is_constructor=False, meet line: 'int mblen (const char *__s, size_t __n) throw ();\n\n\nextern int mbtowc (wchar_t *__restrict __pwc,\n     const char *__restrict __s, size_t __n) throw ();\n\n\nextern int wctomb (char *__s, wchar_t __wchar'
[#] parse_declaration, is_constructor=False, meet line: 'int mbtowc (wchar_t *__restrict __pwc,\n     const char *__restrict __s, size_t __n) throw ();\n\n\nextern int wctomb (char *__s, wchar_t __wchar) throw ();\n\n\n\nextern size_t mbstowcs (wchar_t *__restrict '
[#] parse_declaration, is_constructor=False, meet line: 'int wctomb (char *__s, wchar_t __wchar) throw ();\n\n\n\nextern size_t mbstowcs (wchar_t *__restrict __pwcs,\n   const char *__restrict __s, size_t __n) throw ();\n\nextern size_t wcstombs (char *__restrict '
[#] parse_declaration, is_constructor=False, meet line: 'size_t mbstowcs (wchar_t *__restrict __pwcs,\n   const char *__restrict __s, size_t __n) throw ();\n\nextern size_t wcstombs (char *__restrict __s,\n   const wchar_t *__restrict __pwcs, size_t __n)\n     t'
[#] parse_declaration, is_constructor=False, meet line: 'size_t wcstombs (char *__restrict __s,\n   const wchar_t *__restrict __pwcs, size_t __n)\n     throw ();\n\n\n\n\n\n\n\nextern int rpmatch (const char *__response) throw () __attribute__ ((__nonnull__ (1))) ;\n#'
[#] parse_declaration, is_constructor=False, meet line: 'int rpmatch (const char *__response) throw () __attribute__ ((__nonnull__ (1))) ;\n# 954 "/usr/include/stdlib.h" 3 4\nextern int getsubopt (char **__restrict __optionp,\n        char *const *__restrict _'
[#] parse_declaration, is_constructor=False, meet line: 'int getsubopt (char **__restrict __optionp,\n        char *const *__restrict __tokens,\n        char **__restrict __valuep)\n     throw () __attribute__ ((__nonnull__ (1, 2, 3))) ;\n\n\n\n\n\nextern void setke'
[#] parse_declaration, is_constructor=False, meet line: 'void setkey (const char *__key) throw () __attribute__ ((__nonnull__ (1)));\n\n\n\n\n\n\n\nextern int posix_openpt (int __oflag) ;\n\n\n\n\n\n\n\nextern int grantpt (int __fd) throw ();\n\n\n\nextern int unlockpt (int __'
[#] parse_declaration, is_constructor=False, meet line: 'int posix_openpt (int __oflag) ;\n\n\n\n\n\n\n\nextern int grantpt (int __fd) throw ();\n\n\n\nextern int unlockpt (int __fd) throw ();\n\n\n\n\nextern char *ptsname (int __fd) throw () ;\n\n\n\n\n\n\nextern int ptsname_r (i'
[#] parse_declaration, is_constructor=False, meet line: 'int grantpt (int __fd) throw ();\n\n\n\nextern int unlockpt (int __fd) throw ();\n\n\n\n\nextern char *ptsname (int __fd) throw () ;\n\n\n\n\n\n\nextern int ptsname_r (int __fd, char *__buf, size_t __buflen)\n     thr'
[#] parse_declaration, is_constructor=False, meet line: 'int unlockpt (int __fd) throw ();\n\n\n\n\nextern char *ptsname (int __fd) throw () ;\n\n\n\n\n\n\nextern int ptsname_r (int __fd, char *__buf, size_t __buflen)\n     throw () __attribute__ ((__nonnull__ (2)));\n\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'char *ptsname (int __fd) throw () ;\n\n\n\n\n\n\nextern int ptsname_r (int __fd, char *__buf, size_t __buflen)\n     throw () __attribute__ ((__nonnull__ (2)));\n\n\nextern int getpt (void);\n\n\n\n\n\n\nextern int get'
[#] parse_declaration, is_constructor=False, meet line: 'int ptsname_r (int __fd, char *__buf, size_t __buflen)\n     throw () __attribute__ ((__nonnull__ (2)));\n\n\nextern int getpt (void);\n\n\n\n\n\n\nextern int getloadavg (double __loadavg[], int __nelem)\n     th'
[#] parse_declaration, is_constructor=False, meet line: 'int getpt (void);\n\n\n\n\n\n\nextern int getloadavg (double __loadavg[], int __nelem)\n     throw () __attribute__ ((__nonnull__ (1)));\n# 1016 "/usr/include/stdlib.h" 3 4\n# 1 "/usr/include/x86_64-linux-gnu/b'
[#] parse_declaration, is_constructor=False, meet line: 'int getloadavg (double __loadavg[], int __nelem)\n     throw () __attribute__ ((__nonnull__ (1)));\n# 1016 "/usr/include/stdlib.h" 3 4\n# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 1 3 4\n# 101'
[#] parse_declaration, is_constructor=False, meet line: 'long\n  abs(long __i) { return __builtin_labs(__i); }\n\n\n\n  inline long long\n  abs(long long __x) { return __builtin_llabs (__x); }\n\n\n\n\n\n\n\n  inline constexpr double\n  abs(double __x)\n  { return __builti'
[#] parse_declaration, is_constructor=False, meet line: 'long long\n  abs(long long __x) { return __builtin_llabs (__x); }\n\n\n\n\n\n\n\n  inline constexpr double\n  abs(double __x)\n  { return __builtin_fabs(__x); }\n\n  inline constexpr float\n  abs(float __x)\n  { ret'
[#] parse_declaration, is_constructor=False, meet line: 'double\n  abs(double __x)\n  { return __builtin_fabs(__x); }\n\n  inline constexpr float\n  abs(float __x)\n  { return __builtin_fabsf(__x); }\n\n  inline constexpr long double\n  abs(long double __x)\n  { retu'
[#] parse_declaration, is_constructor=False, meet line: 'float\n  abs(float __x)\n  { return __builtin_fabsf(__x); }\n\n  inline constexpr long double\n  abs(long double __x)\n  { return __builtin_fabsl(__x); }\n\n\n\n  inline constexpr __int128\n  abs(__int128 __x) {'
[#] parse_declaration, is_constructor=False, meet line: 'long double\n  abs(long double __x)\n  { return __builtin_fabsl(__x); }\n\n\n\n  inline constexpr __int128\n  abs(__int128 __x) { return __x >= 0 ? __x : -__x; }\n# 100 "/usr/include/c++/7/bits/std_abs.h" 3\n '
[#] parse_declaration, is_constructor=False, meet line: '__int128\n  abs(__int128 __x) { return __x >= 0 ? __x : -__x; }\n# 100 "/usr/include/c++/7/bits/std_abs.h" 3\n  inline constexpr\n  __float128\n  abs(__float128 __x)\n  { return __x < 0 ? -__x : __x; }\n\n\n\n}'
[#] parse_declaration, is_constructor=False, meet line: '__float128\n  abs(__float128 __x)\n  { return __x < 0 ? -__x : __x; }\n\n\n\n}\n}\n# 78 "/usr/include/c++/7/cstdlib" 2 3\n# 121 "/usr/include/c++/7/cstdlib" 3\nextern "C++"\n{\nnamespace std __attribute__ ((__vis'
[#] parse_declaration, is_constructor=False, meet line: 'ldiv_t\n  div(long __i, long __j) { return ldiv(__i, __j); }\n\n\n\n\n}\n# 195 "/usr/include/c++/7/cstdlib" 3\nnamespace __gnu_cxx __attribute__ ((__visibility__ ("default")))\n{\n\n\n\n  using ::lldiv_t;\n\n\n\n\n\n  u'
[#] parse_declaration, is_constructor=False, meet line: 'lldiv_t\n  div(long long __n, long long __d)\n  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }\n\n  using ::lldiv;\n# 227 "/usr/include/c++/7/cstdlib" 3\n  using ::atoll;\n  using ::'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    all_of(_IIter, _IIter, _Predicate);\n\n  template<typename _IIter, typename _Predicate>\n    bool\n    any_of(_IIter, _IIter, _Predicate);\n\n\n  template<typename _FIter, typename _Tp>\n    bool\n   '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    any_of(_IIter, _IIter, _Predicate);\n\n\n  template<typename _FIter, typename _Tp>\n    bool\n    binary_search(_FIter, _FIter, const _Tp&);\n\n  template<typename _FIter, typename _Tp, typename _Co'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    binary_search(_FIter, _FIter, const _Tp&);\n\n  template<typename _FIter, typename _Tp, typename _Compare>\n    bool\n    binary_search(_FIter, _FIter, const _Tp&, _Compare);\n# 224 "/usr/include/'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    binary_search(_FIter, _FIter, const _Tp&, _Compare);\n# 224 "/usr/include/c++/7/bits/algorithmfwd.h" 3\n  template<typename _IIter, typename _OIter>\n    _OIter\n    copy(_IIter, _IIter, _OIter);'
[#] parse_declaration, is_constructor=False, meet line: '_OIter\n    copy(_IIter, _IIter, _OIter);\n\n  template<typename _BIter1, typename _BIter2>\n    _BIter2\n    copy_backward(_BIter1, _BIter1, _BIter2);\n\n\n  template<typename _IIter, typename _OIter, typena'
[#] parse_declaration, is_constructor=False, meet line: '_BIter2\n    copy_backward(_BIter1, _BIter1, _BIter2);\n\n\n  template<typename _IIter, typename _OIter, typename _Predicate>\n    _OIter\n    copy_if(_IIter, _IIter, _OIter, _Predicate);\n\n  template<typena'
[#] parse_declaration, is_constructor=False, meet line: '_OIter\n    copy_if(_IIter, _IIter, _OIter, _Predicate);\n\n  template<typename _IIter, typename _Size, typename _OIter>\n    _OIter\n    copy_n(_IIter, _Size, _OIter);\n\n\n\n\n\n  template<typename _FIter, typ'
[#] parse_declaration, is_constructor=False, meet line: '_OIter\n    copy_n(_IIter, _Size, _OIter);\n\n\n\n\n\n  template<typename _FIter, typename _Tp>\n    pair<_FIter, _FIter>\n    equal_range(_FIter, _FIter, const _Tp&);\n\n  template<typename _FIter, typename _Tp'
[#] parse_declaration, is_constructor=False, meet line: 'pair<_FIter, _FIter>\n    equal_range(_FIter, _FIter, const _Tp&);\n\n  template<typename _FIter, typename _Tp, typename _Compare>\n    pair<_FIter, _FIter>\n    equal_range(_FIter, _FIter, const _Tp&, _Co'
[#] parse_declaration, is_constructor=False, meet line: 'pair<_FIter, _FIter>\n    equal_range(_FIter, _FIter, const _Tp&, _Compare);\n\n  template<typename _FIter, typename _Tp>\n    void\n    fill(_FIter, _FIter, const _Tp&);\n\n  template<typename _OIter, typen'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    fill(_FIter, _FIter, const _Tp&);\n\n  template<typename _OIter, typename _Size, typename _Tp>\n    _OIter\n    fill_n(_OIter, _Size, const _Tp&);\n\n\n\n  template<typename _FIter1, typename _FIter2'
[#] parse_declaration, is_constructor=False, meet line: '_OIter\n    fill_n(_OIter, _Size, const _Tp&);\n\n\n\n  template<typename _FIter1, typename _FIter2>\n    _FIter1\n    find_end(_FIter1, _FIter1, _FIter2, _FIter2);\n\n  template<typename _FIter1, typename _FI'
[#] parse_declaration, is_constructor=False, meet line: '_FIter1\n    find_end(_FIter1, _FIter1, _FIter2, _FIter2);\n\n  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>\n    _FIter1\n    find_end(_FIter1, _FIter1, _FIter2, _FIter2, _Binar'
[#] parse_declaration, is_constructor=False, meet line: '_FIter1\n    find_end(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);\n\n\n\n\n\n  template<typename _IIter, typename _Predicate>\n    _IIter\n    find_if_not(_IIter, _IIter, _Predicate);\n\n\n\n\n\n\n  templa'
[#] parse_declaration, is_constructor=False, meet line: '_IIter\n    find_if_not(_IIter, _IIter, _Predicate);\n\n\n\n\n\n\n  template<typename _IIter1, typename _IIter2>\n    bool\n    includes(_IIter1, _IIter1, _IIter2, _IIter2);\n\n  template<typename _IIter1, typena'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    includes(_IIter1, _IIter1, _IIter2, _IIter2);\n\n  template<typename _IIter1, typename _IIter2, typename _Compare>\n    bool\n    includes(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);\n\n  templa'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    includes(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);\n\n  template<typename _BIter>\n    void\n    inplace_merge(_BIter, _BIter, _BIter);\n\n  template<typename _BIter, typename _Compare>\n    vo'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    inplace_merge(_BIter, _BIter, _BIter);\n\n  template<typename _BIter, typename _Compare>\n    void\n    inplace_merge(_BIter, _BIter, _BIter, _Compare);\n\n\n  template<typename _RAIter>\n    bool\n  '
[#] parse_declaration, is_constructor=False, meet line: 'void\n    inplace_merge(_BIter, _BIter, _BIter, _Compare);\n\n\n  template<typename _RAIter>\n    bool\n    is_heap(_RAIter, _RAIter);\n\n  template<typename _RAIter, typename _Compare>\n    bool\n    is_heap(_'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    is_heap(_RAIter, _RAIter);\n\n  template<typename _RAIter, typename _Compare>\n    bool\n    is_heap(_RAIter, _RAIter, _Compare);\n\n  template<typename _RAIter>\n    _RAIter\n    is_heap_until(_RAIt'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    is_heap(_RAIter, _RAIter, _Compare);\n\n  template<typename _RAIter>\n    _RAIter\n    is_heap_until(_RAIter, _RAIter);\n\n  template<typename _RAIter, typename _Compare>\n    _RAIter\n    is_heap_un'
[#] parse_declaration, is_constructor=False, meet line: '_RAIter\n    is_heap_until(_RAIter, _RAIter);\n\n  template<typename _RAIter, typename _Compare>\n    _RAIter\n    is_heap_until(_RAIter, _RAIter, _Compare);\n\n  template<typename _IIter, typename _Predicat'
[#] parse_declaration, is_constructor=False, meet line: '_RAIter\n    is_heap_until(_RAIter, _RAIter, _Compare);\n\n  template<typename _IIter, typename _Predicate>\n    bool\n    is_partitioned(_IIter, _IIter, _Predicate);\n\n  template<typename _FIter1, typename'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    is_partitioned(_IIter, _IIter, _Predicate);\n\n  template<typename _FIter1, typename _FIter2>\n    bool\n    is_permutation(_FIter1, _FIter1, _FIter2);\n\n  template<typename _FIter1, typename _FIt'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    is_permutation(_FIter1, _FIter1, _FIter2);\n\n  template<typename _FIter1, typename _FIter2,\n    typename _BinaryPredicate>\n    bool\n    is_permutation(_FIter1, _FIter1, _FIter2, _BinaryPredica'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    is_permutation(_FIter1, _FIter1, _FIter2, _BinaryPredicate);\n\n  template<typename _FIter>\n    bool\n    is_sorted(_FIter, _FIter);\n\n  template<typename _FIter, typename _Compare>\n    bool\n    '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    is_sorted(_FIter, _FIter);\n\n  template<typename _FIter, typename _Compare>\n    bool\n    is_sorted(_FIter, _FIter, _Compare);\n\n  template<typename _FIter>\n    _FIter\n    is_sorted_until(_FIter'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    is_sorted(_FIter, _FIter, _Compare);\n\n  template<typename _FIter>\n    _FIter\n    is_sorted_until(_FIter, _FIter);\n\n  template<typename _FIter, typename _Compare>\n    _FIter\n    is_sorted_unti'
[#] parse_declaration, is_constructor=False, meet line: '_FIter\n    is_sorted_until(_FIter, _FIter);\n\n  template<typename _FIter, typename _Compare>\n    _FIter\n    is_sorted_until(_FIter, _FIter, _Compare);\n\n\n  template<typename _FIter1, typename _FIter2>\n '
[#] parse_declaration, is_constructor=False, meet line: '_FIter\n    is_sorted_until(_FIter, _FIter, _Compare);\n\n\n  template<typename _FIter1, typename _FIter2>\n    void\n    iter_swap(_FIter1, _FIter2);\n\n  template<typename _FIter, typename _Tp>\n    _FIter\n '
[#] parse_declaration, is_constructor=False, meet line: 'void\n    iter_swap(_FIter1, _FIter2);\n\n  template<typename _FIter, typename _Tp>\n    _FIter\n    lower_bound(_FIter, _FIter, const _Tp&);\n\n  template<typename _FIter, typename _Tp, typename _Compare>\n '
[#] parse_declaration, is_constructor=False, meet line: '_FIter\n    lower_bound(_FIter, _FIter, const _Tp&);\n\n  template<typename _FIter, typename _Tp, typename _Compare>\n    _FIter\n    lower_bound(_FIter, _FIter, const _Tp&, _Compare);\n\n  template<typename'
[#] parse_declaration, is_constructor=False, meet line: '_FIter\n    lower_bound(_FIter, _FIter, const _Tp&, _Compare);\n\n  template<typename _RAIter>\n    void\n    make_heap(_RAIter, _RAIter);\n\n  template<typename _RAIter, typename _Compare>\n    void\n    make'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    make_heap(_RAIter, _RAIter);\n\n  template<typename _RAIter, typename _Compare>\n    void\n    make_heap(_RAIter, _RAIter, _Compare);\n\n  template<typename _Tp>\n    constexpr\n    const _Tp&\n    ma'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    make_heap(_RAIter, _RAIter, _Compare);\n\n  template<typename _Tp>\n    constexpr\n    const _Tp&\n    max(const _Tp&, const _Tp&);\n\n  template<typename _Tp, typename _Compare>\n    constexpr\n    c'
[#] parse_declaration, is_constructor=False, meet line: '_Tp&\n    max(const _Tp&, const _Tp&);\n\n  template<typename _Tp, typename _Compare>\n    constexpr\n    const _Tp&\n    max(const _Tp&, const _Tp&, _Compare);\n\n\n\n\n  template<typename _Tp>\n    constexpr\n  '
[#] parse_declaration, is_constructor=False, meet line: '_Tp&\n    max(const _Tp&, const _Tp&, _Compare);\n\n\n\n\n  template<typename _Tp>\n    constexpr\n    const _Tp&\n    min(const _Tp&, const _Tp&);\n\n  template<typename _Tp, typename _Compare>\n    constexpr\n  '
[#] parse_declaration, is_constructor=False, meet line: '_Tp&\n    min(const _Tp&, const _Tp&);\n\n  template<typename _Tp, typename _Compare>\n    constexpr\n    const _Tp&\n    min(const _Tp&, const _Tp&, _Compare);\n\n\n\n\n  template<typename _Tp>\n    constexpr\n  '
[#] parse_declaration, is_constructor=False, meet line: '_Tp&\n    min(const _Tp&, const _Tp&, _Compare);\n\n\n\n\n  template<typename _Tp>\n    constexpr\n    pair<const _Tp&, const _Tp&>\n    minmax(const _Tp&, const _Tp&);\n\n  template<typename _Tp, typename _Comp'
[#] parse_declaration, is_constructor=False, meet line: 'pair<const _Tp&, const _Tp&>\n    minmax(const _Tp&, const _Tp&);\n\n  template<typename _Tp, typename _Compare>\n    constexpr\n    pair<const _Tp&, const _Tp&>\n    minmax(const _Tp&, const _Tp&, _Compare'
[#] parse_declaration, is_constructor=False, meet line: 'pair<const _Tp&, const _Tp&>\n    minmax(const _Tp&, const _Tp&, _Compare);\n\n  template<typename _FIter>\n    constexpr\n    pair<_FIter, _FIter>\n    minmax_element(_FIter, _FIter);\n\n  template<typename '
[#] parse_declaration, is_constructor=False, meet line: 'pair<_FIter, _FIter>\n    minmax_element(_FIter, _FIter);\n\n  template<typename _FIter, typename _Compare>\n    constexpr\n    pair<_FIter, _FIter>\n    minmax_element(_FIter, _FIter, _Compare);\n\n  templat'
[#] parse_declaration, is_constructor=False, meet line: 'pair<_FIter, _FIter>\n    minmax_element(_FIter, _FIter, _Compare);\n\n  template<typename _Tp>\n    constexpr\n    _Tp\n    min(initializer_list<_Tp>);\n\n  template<typename _Tp, typename _Compare>\n    cons'
[#] parse_declaration, is_constructor=False, meet line: '_Tp\n    min(initializer_list<_Tp>);\n\n  template<typename _Tp, typename _Compare>\n    constexpr\n    _Tp\n    min(initializer_list<_Tp>, _Compare);\n\n  template<typename _Tp>\n    constexpr\n    _Tp\n    max'
[#] parse_declaration, is_constructor=False, meet line: '_Tp\n    min(initializer_list<_Tp>, _Compare);\n\n  template<typename _Tp>\n    constexpr\n    _Tp\n    max(initializer_list<_Tp>);\n\n  template<typename _Tp, typename _Compare>\n    constexpr\n    _Tp\n    max'
[#] parse_declaration, is_constructor=False, meet line: '_Tp\n    max(initializer_list<_Tp>);\n\n  template<typename _Tp, typename _Compare>\n    constexpr\n    _Tp\n    max(initializer_list<_Tp>, _Compare);\n\n  template<typename _Tp>\n    constexpr\n    pair<_Tp, _'
[#] parse_declaration, is_constructor=False, meet line: '_Tp\n    max(initializer_list<_Tp>, _Compare);\n\n  template<typename _Tp>\n    constexpr\n    pair<_Tp, _Tp>\n    minmax(initializer_list<_Tp>);\n\n  template<typename _Tp, typename _Compare>\n    constexpr\n '
[#] parse_declaration, is_constructor=False, meet line: 'pair<_Tp, _Tp>\n    minmax(initializer_list<_Tp>);\n\n  template<typename _Tp, typename _Compare>\n    constexpr\n    pair<_Tp, _Tp>\n    minmax(initializer_list<_Tp>, _Compare);\n\n\n\n\n  template<typename _BI'
[#] parse_declaration, is_constructor=False, meet line: 'pair<_Tp, _Tp>\n    minmax(initializer_list<_Tp>, _Compare);\n\n\n\n\n  template<typename _BIter>\n    bool\n    next_permutation(_BIter, _BIter);\n\n  template<typename _BIter, typename _Compare>\n    bool\n    '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    next_permutation(_BIter, _BIter);\n\n  template<typename _BIter, typename _Compare>\n    bool\n    next_permutation(_BIter, _BIter, _Compare);\n\n\n  template<typename _IIter, typename _Predicate>\n '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    next_permutation(_BIter, _BIter, _Compare);\n\n\n  template<typename _IIter, typename _Predicate>\n    bool\n    none_of(_IIter, _IIter, _Predicate);\n\n\n\n\n\n  template<typename _IIter, typename _RAI'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    none_of(_IIter, _IIter, _Predicate);\n\n\n\n\n\n  template<typename _IIter, typename _RAIter>\n    _RAIter\n    partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter);\n\n  template<typename _IIter, typen'
[#] parse_declaration, is_constructor=False, meet line: '_RAIter\n    partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter);\n\n  template<typename _IIter, typename _RAIter, typename _Compare>\n    _RAIter\n    partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter, _'
[#] parse_declaration, is_constructor=False, meet line: '_RAIter\n    partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter, _Compare);\n\n\n\n\n  template<typename _IIter, typename _OIter1,\n    typename _OIter2, typename _Predicate>\n    pair<_OIter1, _OIter2>\n    p'
[#] parse_declaration, is_constructor=False, meet line: 'pair<_OIter1, _OIter2>\n    partition_copy(_IIter, _IIter, _OIter1, _OIter2, _Predicate);\n\n  template<typename _FIter, typename _Predicate>\n    _FIter\n    partition_point(_FIter, _FIter, _Predicate);\n\n'
[#] parse_declaration, is_constructor=False, meet line: '_FIter\n    partition_point(_FIter, _FIter, _Predicate);\n\n\n  template<typename _RAIter>\n    void\n    pop_heap(_RAIter, _RAIter);\n\n  template<typename _RAIter, typename _Compare>\n    void\n    pop_heap(_'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    pop_heap(_RAIter, _RAIter);\n\n  template<typename _RAIter, typename _Compare>\n    void\n    pop_heap(_RAIter, _RAIter, _Compare);\n\n  template<typename _BIter>\n    bool\n    prev_permutation(_BIt'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    pop_heap(_RAIter, _RAIter, _Compare);\n\n  template<typename _BIter>\n    bool\n    prev_permutation(_BIter, _BIter);\n\n  template<typename _BIter, typename _Compare>\n    bool\n    prev_permutation'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    prev_permutation(_BIter, _BIter);\n\n  template<typename _BIter, typename _Compare>\n    bool\n    prev_permutation(_BIter, _BIter, _Compare);\n\n  template<typename _RAIter>\n    void\n    push_heap'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    prev_permutation(_BIter, _BIter, _Compare);\n\n  template<typename _RAIter>\n    void\n    push_heap(_RAIter, _RAIter);\n\n  template<typename _RAIter, typename _Compare>\n    void\n    push_heap(_RA'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    push_heap(_RAIter, _RAIter);\n\n  template<typename _RAIter, typename _Compare>\n    void\n    push_heap(_RAIter, _RAIter, _Compare);\n\n\n\n  template<typename _FIter, typename _Tp>\n    _FIter\n    r'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    push_heap(_RAIter, _RAIter, _Compare);\n\n\n\n  template<typename _FIter, typename _Tp>\n    _FIter\n    remove(_FIter, _FIter, const _Tp&);\n\n  template<typename _FIter, typename _Predicate>\n    _F'
[#] parse_declaration, is_constructor=False, meet line: '_FIter\n    remove(_FIter, _FIter, const _Tp&);\n\n  template<typename _FIter, typename _Predicate>\n    _FIter\n    remove_if(_FIter, _FIter, _Predicate);\n\n  template<typename _IIter, typename _OIter, typ'
[#] parse_declaration, is_constructor=False, meet line: '_FIter\n    remove_if(_FIter, _FIter, _Predicate);\n\n  template<typename _IIter, typename _OIter, typename _Tp>\n    _OIter\n    remove_copy(_IIter, _IIter, _OIter, const _Tp&);\n\n  template<typename _IIte'
[#] parse_declaration, is_constructor=False, meet line: '_OIter\n    remove_copy(_IIter, _IIter, _OIter, const _Tp&);\n\n  template<typename _IIter, typename _OIter, typename _Predicate>\n    _OIter\n    remove_copy_if(_IIter, _IIter, _OIter, _Predicate);\n\n\n\n  t'
[#] parse_declaration, is_constructor=False, meet line: '_OIter\n    remove_copy_if(_IIter, _IIter, _OIter, _Predicate);\n\n\n\n  template<typename _IIter, typename _OIter, typename _Tp>\n    _OIter\n    replace_copy(_IIter, _IIter, _OIter, const _Tp&, const _Tp&)'
[#] parse_declaration, is_constructor=False, meet line: '_OIter\n    replace_copy(_IIter, _IIter, _OIter, const _Tp&, const _Tp&);\n\n  template<typename _Iter, typename _OIter, typename _Predicate, typename _Tp>\n    _OIter\n    replace_copy_if(_Iter, _Iter, _O'
[#] parse_declaration, is_constructor=False, meet line: '_OIter\n    replace_copy_if(_Iter, _Iter, _OIter, _Predicate, const _Tp&);\n\n\n\n  template<typename _BIter>\n    void\n    reverse(_BIter, _BIter);\n\n  template<typename _BIter, typename _OIter>\n    _OIter\n'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    reverse(_BIter, _BIter);\n\n  template<typename _BIter, typename _OIter>\n    _OIter\n    reverse_copy(_BIter, _BIter, _OIter);\n\n  inline namespace _V2\n  {\n    template<typename _FIter>\n      _FI'
[#] parse_declaration, is_constructor=False, meet line: '_OIter\n    reverse_copy(_BIter, _BIter, _OIter);\n\n  inline namespace _V2\n  {\n    template<typename _FIter>\n      _FIter\n      rotate(_FIter, _FIter, _FIter);\n  }\n\n  template<typename _FIter, typename '
[#] parse_declaration, is_constructor=False, meet line: '_FIter\n      rotate(_FIter, _FIter, _FIter);\n  }\n\n  template<typename _FIter, typename _OIter>\n    _OIter\n    rotate_copy(_FIter, _FIter, _FIter, _OIter);\n# 565 "/usr/include/c++/7/bits/algorithmfwd.h'
[#] parse_declaration, is_constructor=False, meet line: '_OIter\n    rotate_copy(_FIter, _FIter, _FIter, _OIter);\n# 565 "/usr/include/c++/7/bits/algorithmfwd.h" 3\n  template<typename _RAIter, typename _UGenerator>\n    void\n    shuffle(_RAIter, _RAIter, _UGen'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    shuffle(_RAIter, _RAIter, _UGenerator&&);\n\n\n  template<typename _RAIter>\n    void\n    sort_heap(_RAIter, _RAIter);\n\n  template<typename _RAIter, typename _Compare>\n    void\n    sort_heap(_RAI'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    sort_heap(_RAIter, _RAIter);\n\n  template<typename _RAIter, typename _Compare>\n    void\n    sort_heap(_RAIter, _RAIter, _Compare);\n\n  template<typename _BIter, typename _Predicate>\n    _BIter\n'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    sort_heap(_RAIter, _RAIter, _Compare);\n\n  template<typename _BIter, typename _Predicate>\n    _BIter\n    stable_partition(_BIter, _BIter, _Predicate);\n# 594 "/usr/include/c++/7/bits/algorithmf'
[#] parse_declaration, is_constructor=False, meet line: '_BIter\n    stable_partition(_BIter, _BIter, _Predicate);\n# 594 "/usr/include/c++/7/bits/algorithmfwd.h" 3\n  template<typename _FIter1, typename _FIter2>\n    _FIter2\n    swap_ranges(_FIter1, _FIter1, _'
[#] parse_declaration, is_constructor=False, meet line: '_FIter2\n    swap_ranges(_FIter1, _FIter1, _FIter2);\n\n\n\n  template<typename _FIter>\n    _FIter\n    unique(_FIter, _FIter);\n\n  template<typename _FIter, typename _BinaryPredicate>\n    _FIter\n    unique('
[#] parse_declaration, is_constructor=False, meet line: '_FIter\n    unique(_FIter, _FIter);\n\n  template<typename _FIter, typename _BinaryPredicate>\n    _FIter\n    unique(_FIter, _FIter, _BinaryPredicate);\n\n\n\n  template<typename _FIter, typename _Tp>\n    _FI'
[#] parse_declaration, is_constructor=False, meet line: '_FIter\n    unique(_FIter, _FIter, _BinaryPredicate);\n\n\n\n  template<typename _FIter, typename _Tp>\n    _FIter\n    upper_bound(_FIter, _FIter, const _Tp&);\n\n  template<typename _FIter, typename _Tp, typ'
[#] parse_declaration, is_constructor=False, meet line: '_FIter\n    upper_bound(_FIter, _FIter, const _Tp&);\n\n  template<typename _FIter, typename _Tp, typename _Compare>\n    _FIter\n    upper_bound(_FIter, _FIter, const _Tp&, _Compare);\n\n\n\n\n\n  template<type'
[#] parse_declaration, is_constructor=False, meet line: '_FIter\n    upper_bound(_FIter, _FIter, const _Tp&, _Compare);\n\n\n\n\n\n  template<typename _FIter>\n    _FIter\n    adjacent_find(_FIter, _FIter);\n\n  template<typename _FIter, typename _BinaryPredicate>\n   '
[#] parse_declaration, is_constructor=False, meet line: '_FIter\n    adjacent_find(_FIter, _FIter);\n\n  template<typename _FIter, typename _BinaryPredicate>\n    _FIter\n    adjacent_find(_FIter, _FIter, _BinaryPredicate);\n\n  template<typename _IIter, typename '
[#] parse_declaration, is_constructor=False, meet line: '_FIter\n    adjacent_find(_FIter, _FIter, _BinaryPredicate);\n\n  template<typename _IIter, typename _Tp>\n    typename iterator_traits<_IIter>::difference_type\n    count(_IIter, _IIter, const _Tp&);\n\n  t'
[#] parse_declaration, is_constructor=False, meet line: 'iterator_traits<_IIter>::difference_type\n    count(_IIter, _IIter, const _Tp&);\n\n  template<typename _IIter, typename _Predicate>\n    typename iterator_traits<_IIter>::difference_type\n    count_if(_II'
[#] parse_declaration, is_constructor=False, meet line: 'iterator_traits<_IIter>::difference_type\n    count_if(_IIter, _IIter, _Predicate);\n\n  template<typename _IIter1, typename _IIter2>\n    bool\n    equal(_IIter1, _IIter1, _IIter2);\n\n  template<typename _'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    equal(_IIter1, _IIter1, _IIter2);\n\n  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>\n    bool\n    equal(_IIter1, _IIter1, _IIter2, _BinaryPredicate);\n\n  template<typen'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    equal(_IIter1, _IIter1, _IIter2, _BinaryPredicate);\n\n  template<typename _IIter, typename _Tp>\n    _IIter\n    find(_IIter, _IIter, const _Tp&);\n\n  template<typename _FIter1, typename _FIter2>'
[#] parse_declaration, is_constructor=False, meet line: '_IIter\n    find(_IIter, _IIter, const _Tp&);\n\n  template<typename _FIter1, typename _FIter2>\n    _FIter1\n    find_first_of(_FIter1, _FIter1, _FIter2, _FIter2);\n\n  template<typename _FIter1, typename _'
[#] parse_declaration, is_constructor=False, meet line: '_FIter1\n    find_first_of(_FIter1, _FIter1, _FIter2, _FIter2);\n\n  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>\n    _FIter1\n    find_first_of(_FIter1, _FIter1, _FIter2, _FIte'
[#] parse_declaration, is_constructor=False, meet line: '_FIter1\n    find_first_of(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);\n\n  template<typename _IIter, typename _Predicate>\n    _IIter\n    find_if(_IIter, _IIter, _Predicate);\n\n  template<typen'
[#] parse_declaration, is_constructor=False, meet line: '_IIter\n    find_if(_IIter, _IIter, _Predicate);\n\n  template<typename _IIter, typename _Funct>\n    _Funct\n    for_each(_IIter, _IIter, _Funct);\n\n  template<typename _FIter, typename _Generator>\n    voi'
[#] parse_declaration, is_constructor=False, meet line: '_Funct\n    for_each(_IIter, _IIter, _Funct);\n\n  template<typename _FIter, typename _Generator>\n    void\n    generate(_FIter, _FIter, _Generator);\n\n  template<typename _OIter, typename _Size, typename '
[#] parse_declaration, is_constructor=False, meet line: 'void\n    generate(_FIter, _FIter, _Generator);\n\n  template<typename _OIter, typename _Size, typename _Generator>\n    _OIter\n    generate_n(_OIter, _Size, _Generator);\n\n  template<typename _IIter1, typ'
[#] parse_declaration, is_constructor=False, meet line: '_OIter\n    generate_n(_OIter, _Size, _Generator);\n\n  template<typename _IIter1, typename _IIter2>\n    bool\n    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2);\n\n  template<typename _IIter1'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2);\n\n  template<typename _IIter1, typename _IIter2, typename _Compare>\n    bool\n    lexicographical_compare(_IIter1, _IIter1, _IIter2,'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);\n\n  template<typename _FIter>\n    constexpr\n    _FIter\n    max_element(_FIter, _FIter);\n\n  template<typename _FIter, type'
[#] parse_declaration, is_constructor=False, meet line: '_FIter\n    max_element(_FIter, _FIter);\n\n  template<typename _FIter, typename _Compare>\n    constexpr\n    _FIter\n    max_element(_FIter, _FIter, _Compare);\n\n  template<typename _IIter1, typename _IIte'
[#] parse_declaration, is_constructor=False, meet line: '_FIter\n    max_element(_FIter, _FIter, _Compare);\n\n  template<typename _IIter1, typename _IIter2, typename _OIter>\n    _OIter\n    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);\n\n  template<typenam'
[#] parse_declaration, is_constructor=False, meet line: '_OIter\n    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);\n\n  template<typename _IIter1, typename _IIter2, typename _OIter,\n    typename _Compare>\n    _OIter\n    merge(_IIter1, _IIter1, _IIter2, _I'
[#] parse_declaration, is_constructor=False, meet line: '_OIter\n    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);\n\n  template<typename _FIter>\n    constexpr\n    _FIter\n    min_element(_FIter, _FIter);\n\n  template<typename _FIter, typename _Co'
[#] parse_declaration, is_constructor=False, meet line: '_FIter\n    min_element(_FIter, _FIter);\n\n  template<typename _FIter, typename _Compare>\n    constexpr\n    _FIter\n    min_element(_FIter, _FIter, _Compare);\n\n  template<typename _IIter1, typename _IIte'
[#] parse_declaration, is_constructor=False, meet line: '_FIter\n    min_element(_FIter, _FIter, _Compare);\n\n  template<typename _IIter1, typename _IIter2>\n    pair<_IIter1, _IIter2>\n    mismatch(_IIter1, _IIter1, _IIter2);\n\n  template<typename _IIter1, type'
[#] parse_declaration, is_constructor=False, meet line: 'pair<_IIter1, _IIter2>\n    mismatch(_IIter1, _IIter1, _IIter2);\n\n  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>\n    pair<_IIter1, _IIter2>\n    mismatch(_IIter1, _IIter1, _II'
[#] parse_declaration, is_constructor=False, meet line: 'pair<_IIter1, _IIter2>\n    mismatch(_IIter1, _IIter1, _IIter2, _BinaryPredicate);\n\n  template<typename _RAIter>\n    void\n    nth_element(_RAIter, _RAIter, _RAIter);\n\n  template<typename _RAIter, typen'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    nth_element(_RAIter, _RAIter, _RAIter);\n\n  template<typename _RAIter, typename _Compare>\n    void\n    nth_element(_RAIter, _RAIter, _RAIter, _Compare);\n\n  template<typename _RAIter>\n    void\n'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    nth_element(_RAIter, _RAIter, _RAIter, _Compare);\n\n  template<typename _RAIter>\n    void\n    partial_sort(_RAIter, _RAIter, _RAIter);\n\n  template<typename _RAIter, typename _Compare>\n    void'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    partial_sort(_RAIter, _RAIter, _RAIter);\n\n  template<typename _RAIter, typename _Compare>\n    void\n    partial_sort(_RAIter, _RAIter, _RAIter, _Compare);\n\n  template<typename _BIter, typename'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    partial_sort(_RAIter, _RAIter, _RAIter, _Compare);\n\n  template<typename _BIter, typename _Predicate>\n    _BIter\n    partition(_BIter, _BIter, _Predicate);\n\n  template<typename _RAIter>\n    vo'
[#] parse_declaration, is_constructor=False, meet line: '_BIter\n    partition(_BIter, _BIter, _Predicate);\n\n  template<typename _RAIter>\n    void\n    random_shuffle(_RAIter, _RAIter);\n\n  template<typename _RAIter, typename _Generator>\n    void\n    random_sh'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    random_shuffle(_RAIter, _RAIter);\n\n  template<typename _RAIter, typename _Generator>\n    void\n    random_shuffle(_RAIter, _RAIter,\n\n     _Generator&&);\n\n\n\n\n  template<typename _FIter, typenam'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    random_shuffle(_RAIter, _RAIter,\n\n     _Generator&&);\n\n\n\n\n  template<typename _FIter, typename _Tp>\n    void\n    replace(_FIter, _FIter, const _Tp&, const _Tp&);\n\n  template<typename _FIter, '
[#] parse_declaration, is_constructor=False, meet line: 'void\n    replace(_FIter, _FIter, const _Tp&, const _Tp&);\n\n  template<typename _FIter, typename _Predicate, typename _Tp>\n    void\n    replace_if(_FIter, _FIter, _Predicate, const _Tp&);\n\n  template<t'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    replace_if(_FIter, _FIter, _Predicate, const _Tp&);\n\n  template<typename _FIter1, typename _FIter2>\n    _FIter1\n    search(_FIter1, _FIter1, _FIter2, _FIter2);\n\n  template<typename _FIter1, t'
[#] parse_declaration, is_constructor=False, meet line: '_FIter1\n    search(_FIter1, _FIter1, _FIter2, _FIter2);\n\n  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>\n    _FIter1\n    search(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPre'
[#] parse_declaration, is_constructor=False, meet line: '_FIter1\n    search(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);\n\n  template<typename _FIter, typename _Size, typename _Tp>\n    _FIter\n    search_n(_FIter, _FIter, _Size, const _Tp&);\n\n  temp'
[#] parse_declaration, is_constructor=False, meet line: '_FIter\n    search_n(_FIter, _FIter, _Size, const _Tp&);\n\n  template<typename _FIter, typename _Size, typename _Tp,\n    typename _BinaryPredicate>\n    _FIter\n    search_n(_FIter, _FIter, _Size, const _'
[#] parse_declaration, is_constructor=False, meet line: '_FIter\n    search_n(_FIter, _FIter, _Size, const _Tp&, _BinaryPredicate);\n\n  template<typename _IIter1, typename _IIter2, typename _OIter>\n    _OIter\n    set_difference(_IIter1, _IIter1, _IIter2, _IIt'
[#] parse_declaration, is_constructor=False, meet line: '_OIter\n    set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);\n\n  template<typename _IIter1, typename _IIter2, typename _OIter,\n    typename _Compare>\n    _OIter\n    set_difference(_IIter1, _I'
[#] parse_declaration, is_constructor=False, meet line: '_OIter\n    set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);\n\n  template<typename _IIter1, typename _IIter2, typename _OIter>\n    _OIter\n    set_intersection(_IIter1, _IIter1, _IIt'
[#] parse_declaration, is_constructor=False, meet line: '_OIter\n    set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);\n\n  template<typename _IIter1, typename _IIter2, typename _OIter,\n    typename _Compare>\n    _OIter\n    set_intersection(_IIter1'
[#] parse_declaration, is_constructor=False, meet line: '_OIter\n    set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);\n\n  template<typename _IIter1, typename _IIter2, typename _OIter>\n    _OIter\n    set_symmetric_difference(_IIter1, _II'
[#] parse_declaration, is_constructor=False, meet line: '_OIter\n    set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);\n\n  template<typename _IIter1, typename _IIter2, typename _OIter,\n    typename _Compare>\n    _OIter\n    set_symmetric_di'
[#] parse_declaration, is_constructor=False, meet line: '_OIter\n    set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2,\n        _OIter, _Compare);\n\n  template<typename _IIter1, typename _IIter2, typename _OIter>\n    _OIter\n    set_union(_IIter1, _I'
[#] parse_declaration, is_constructor=False, meet line: '_OIter\n    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);\n\n  template<typename _IIter1, typename _IIter2, typename _OIter,\n    typename _Compare>\n    _OIter\n    set_union(_IIter1, _IIter1, _II'
[#] parse_declaration, is_constructor=False, meet line: '_OIter\n    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);\n\n  template<typename _RAIter>\n    void\n    sort(_RAIter, _RAIter);\n\n  template<typename _RAIter, typename _Compare>\n    void'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    sort(_RAIter, _RAIter);\n\n  template<typename _RAIter, typename _Compare>\n    void\n    sort(_RAIter, _RAIter, _Compare);\n\n  template<typename _RAIter>\n    void\n    stable_sort(_RAIter, _RAIter'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    sort(_RAIter, _RAIter, _Compare);\n\n  template<typename _RAIter>\n    void\n    stable_sort(_RAIter, _RAIter);\n\n  template<typename _RAIter, typename _Compare>\n    void\n    stable_sort(_RAIter, '
[#] parse_declaration, is_constructor=False, meet line: 'void\n    stable_sort(_RAIter, _RAIter);\n\n  template<typename _RAIter, typename _Compare>\n    void\n    stable_sort(_RAIter, _RAIter, _Compare);\n\n  template<typename _IIter, typename _OIter, typename _U'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    stable_sort(_RAIter, _RAIter, _Compare);\n\n  template<typename _IIter, typename _OIter, typename _UnaryOperation>\n    _OIter\n    transform(_IIter, _IIter, _OIter, _UnaryOperation);\n\n  template'
[#] parse_declaration, is_constructor=False, meet line: '_OIter\n    transform(_IIter, _IIter, _OIter, _UnaryOperation);\n\n  template<typename _IIter1, typename _IIter2, typename _OIter,\n    typename _BinaryOperation>\n    _OIter\n    transform(_IIter1, _IIter1'
[#] parse_declaration, is_constructor=False, meet line: '_OIter\n    transform(_IIter1, _IIter1, _IIter2, _OIter, _BinaryOperation);\n\n  template<typename _IIter, typename _OIter>\n    _OIter\n    unique_copy(_IIter, _IIter, _OIter);\n\n  template<typename _IIter'
[#] parse_declaration, is_constructor=False, meet line: '_OIter\n    unique_copy(_IIter, _IIter, _OIter);\n\n  template<typename _IIter, typename _OIter, typename _BinaryPredicate>\n    _OIter\n    unique_copy(_IIter, _IIter, _OIter, _BinaryPredicate);\n\n\n}\n# 61 '
[#] parse_declaration, is_constructor=False, meet line: '_OIter\n    unique_copy(_IIter, _IIter, _OIter, _BinaryPredicate);\n\n\n}\n# 61 "/usr/include/c++/7/bits/stl_algo.h" 2 3\n# 1 "/usr/include/c++/7/bits/stl_heap.h" 1 3\n# 62 "/usr/include/c++/7/bits/stl_heap.'
[#] parse_declaration, is_constructor=False, meet line: '_Distance\n    __is_heap_until(_RandomAccessIterator __first, _Distance __n,\n      _Compare& __comp)\n    {\n      _Distance __parent = 0;\n      for (_Distance __child = 1; __child < __n; ++__child)\n {\n '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    __is_heap(_RandomAccessIterator __first, _Distance __n)\n    {\n      __gnu_cxx::__ops::_Iter_less_iter __comp;\n      return std::__is_heap_until(__first, __n, __comp) == __n;\n    }\n\n  template'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    __is_heap(_RandomAccessIterator __first, _Compare __comp, _Distance __n)\n    {\n      typedef __decltype(__comp) _Cmp;\n      __gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));\n '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n    { return std::__is_heap(__first, std::distance(__first, __last)); }\n\n  template<typename _RandomAccessIterator, type'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,\n       _Compare __comp)\n    {\n      return std::__is_heap(__first, std::move(__comp),\n       std::distance(__first, __la'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    __push_heap(_RandomAccessIterator __first,\n  _Distance __holeIndex, _Distance __topIndex, _Tp __value,\n  _Compare& __comp)\n    {\n      _Distance __parent = (__holeIndex - 1) / 2;\n      while '
[#] parse_declaration, is_constructor=False, meet line: 'void\n    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n    {\n      typedef typename iterator_traits<_RandomAccessIterator>::value_type\n   _ValueType;\n      typedef typename it'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,\n       _Compare __comp)\n    {\n      typedef typename iterator_traits<_RandomAccessIterator>::value_type\n   _ValueType;\n '
[#] parse_declaration, is_constructor=False, meet line: 'void\n    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,\n    _Distance __len, _Tp __value, _Compare __comp)\n    {\n      const _Distance __topIndex = __holeIndex;\n      _Distance __'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,\n        _RandomAccessIterator __result, _Compare& __comp)\n    {\n      typedef typename iterator_traits<_RandomAccessIte'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n    {\n\n     \n\n     \n\n      ;\n      ;\n      ;\n      ;\n\n      if (__last - __first > 1)\n {\n   --__last;\n   __gnu_cxx::__ops'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    pop_heap(_RandomAccessIterator __first,\n      _RandomAccessIterator __last, _Compare __comp)\n    {\n\n     \n\n      ;\n      ;\n      ;\n      ;\n\n      if (__last - __first > 1)\n {\n   typedef __dec'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    __make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,\n  _Compare& __comp)\n    {\n      typedef typename iterator_traits<_RandomAccessIterator>::value_type\n   _ValueType;\n   '
[#] parse_declaration, is_constructor=False, meet line: 'void\n    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n    {\n\n     \n\n     \n\n      ;\n      ;\n\n      __gnu_cxx::__ops::_Iter_less_iter __comp;\n      std::__make_heap(__first, __'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,\n       _Compare __comp)\n    {\n\n     \n\n      ;\n      ;\n\n      typedef __decltype(__comp) _Cmp;\n      __gnu_cxx::__ops::_I'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    __sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,\n  _Compare& __comp)\n    {\n      while (__last - __first > 1)\n {\n   --__last;\n   std::__pop_heap(__first, __last, __las'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n    {\n\n     \n\n     \n\n      ;\n      ;\n      ;\n\n      __gnu_cxx::__ops::_Iter_less_iter __comp;\n      std::__sort_heap(__f'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,\n       _Compare __comp)\n    {\n\n     \n\n      ;\n      ;\n      ;\n\n      typedef __decltype(__comp) _Cmp;\n      __gnu_cxx::_'
[#] parse_declaration, is_constructor=False, meet line: '_RandomAccessIterator\n    is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last)\n    {\n\n     \n\n     \n\n      ;\n      ;\n\n      __gnu_cxx::__ops::_Iter_less_iter __comp;\n      return '
[#] parse_declaration, is_constructor=False, meet line: '_RandomAccessIterator\n    is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last,\n    _Compare __comp)\n    {\n\n     \n\n      ;\n      ;\n\n      typedef __decltype(__comp) _Cmp;\n      __'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n    { return std::is_heap_until(__first, __last) == __last; }\n# 540 "/usr/include/c++/7/bits/stl_heap.h" 3\n  template<type'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,\n     _Compare __comp)\n    {\n\n     \n\n      ;\n      ;\n\n      const auto __dist = std::distance(__first, __last);\n      typed'
[#] parse_declaration, is_constructor=True, meet line: 'exception() noexcept { }\n    virtual ~exception() noexcept;\n\n\n\n    virtual const char*\n    what() const noexcept;\n  };\n\n}\n\n}\n\n#pragma GCC visibility pop\n# 39 "/usr/include/c++/7/exception" 2 3\n\nextern'
[#] parse_declaration, is_constructor=True, meet line: 'exception() noexcept;\n\n\n\n    virtual const char*\n    what() const noexcept;\n  };\n\n}\n\n}\n\n#pragma GCC visibility pop\n# 39 "/usr/include/c++/7/exception" 2 3\n\nextern "C++" {\n\nnamespace std\n{\n\n\n  class ba'
[#] parse_declaration, is_constructor=False, meet line: 'char*\n    what() const noexcept;\n  };\n\n}\n\n}\n\n#pragma GCC visibility pop\n# 39 "/usr/include/c++/7/exception" 2 3\n\nextern "C++" {\n\nnamespace std\n{\n\n\n  class bad_exception : public exception\n  {\n  public'
[#] parse_declaration, is_constructor=True, meet line: 'bad_exception() noexcept { }\n\n\n\n    virtual ~bad_exception() noexcept;\n\n\n    virtual const char*\n    what() const noexcept;\n  };\n\n\n  typedef void (*terminate_handler) ();\n\n\n  typedef void (*unexpected'
[#] parse_declaration, is_constructor=True, meet line: 'bad_exception() noexcept;\n\n\n    virtual const char*\n    what() const noexcept;\n  };\n\n\n  typedef void (*terminate_handler) ();\n\n\n  typedef void (*unexpected_handler) ();\n\n\n  terminate_handler set_termi'
[#] parse_declaration, is_constructor=False, meet line: 'char*\n    what() const noexcept;\n  };\n\n\n  typedef void (*terminate_handler) ();\n\n\n  typedef void (*unexpected_handler) ();\n\n\n  terminate_handler set_terminate(terminate_handler) noexcept;\n\n\n\n  termina'
[#] parse_declaration, is_constructor=False, meet line: 'terminate_handler set_terminate(terminate_handler) noexcept;\n\n\n\n  terminate_handler get_terminate() noexcept;\n\n\n\n\n  void terminate() noexcept __attribute__ ((__noreturn__));\n\n\n  unexpected_handler set'
[#] parse_declaration, is_constructor=False, meet line: 'terminate_handler get_terminate() noexcept;\n\n\n\n\n  void terminate() noexcept __attribute__ ((__noreturn__));\n\n\n  unexpected_handler set_unexpected(unexpected_handler) noexcept;\n\n\n\n  unexpected_handler '
[#] parse_declaration, is_constructor=False, meet line: 'void terminate() noexcept __attribute__ ((__noreturn__));\n\n\n  unexpected_handler set_unexpected(unexpected_handler) noexcept;\n\n\n\n  unexpected_handler get_unexpected() noexcept;\n\n\n\n\n  void unexpected()'
[#] parse_declaration, is_constructor=False, meet line: 'unexpected_handler set_unexpected(unexpected_handler) noexcept;\n\n\n\n  unexpected_handler get_unexpected() noexcept;\n\n\n\n\n  void unexpected() __attribute__ ((__noreturn__));\n# 101 "/usr/include/c++/7/exc'
[#] parse_declaration, is_constructor=False, meet line: 'unexpected_handler get_unexpected() noexcept;\n\n\n\n\n  void unexpected() __attribute__ ((__noreturn__));\n# 101 "/usr/include/c++/7/exception" 3\n  bool uncaught_exception() noexcept __attribute__ ((__pure'
[#] parse_declaration, is_constructor=False, meet line: 'void unexpected() __attribute__ ((__noreturn__));\n# 101 "/usr/include/c++/7/exception" 3\n  bool uncaught_exception() noexcept __attribute__ ((__pure__));\n\n\n\n\n  int uncaught_exceptions() noexcept __att'
[#] parse_declaration, is_constructor=False, meet line: 'bool uncaught_exception() noexcept __attribute__ ((__pure__));\n\n\n\n\n  int uncaught_exceptions() noexcept __attribute__ ((__pure__));\n\n\n\n}\n\nnamespace __gnu_cxx\n{\n\n# 132 "/usr/include/c++/7/exception" 3\n'
[#] parse_declaration, is_constructor=False, meet line: 'int uncaught_exceptions() noexcept __attribute__ ((__pure__));\n\n\n\n}\n\nnamespace __gnu_cxx\n{\n\n# 132 "/usr/include/c++/7/exception" 3\n  void __verbose_terminate_handler();\n\n\n}\n\n}\n\n#pragma GCC visibility '
[#] parse_declaration, is_constructor=False, meet line: 'void __verbose_terminate_handler();\n\n\n}\n\n}\n\n#pragma GCC visibility pop\n\n\n# 1 "/usr/include/c++/7/bits/exception_ptr.h" 1 3\n# 34 "/usr/include/c++/7/bits/exception_ptr.h" 3\n#pragma GCC visibility push('
[#] parse_declaration, is_constructor=False, meet line: 'void*\n      __cxa_allocate_exception(size_t) noexcept;\n\n      void\n      __cxa_free_exception(void*) noexcept;\n\n\n      __cxa_refcounted_exception*\n      __cxa_init_primary_exception(void *object, std:'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      __cxa_free_exception(void*) noexcept;\n\n\n      __cxa_refcounted_exception*\n      __cxa_init_primary_exception(void *object, std::type_info *tinfo,\n                void ( *dest) (void *)) noe'
[#] parse_declaration, is_constructor=False, meet line: '__cxa_refcounted_exception*\n      __cxa_init_primary_exception(void *object, std::type_info *tinfo,\n                void ( *dest) (void *)) noexcept;\n\n    }\n}\n\n\n\n#pragma GCC visibility pop\n# 39 "/usr/'
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n  _Hash_bytes(const void* __ptr, size_t __len, size_t __seed);\n\n\n\n\n\n  size_t\n  _Fnv_hash_bytes(const void* __ptr, size_t __len, size_t __seed);\n\n\n}\n# 37 "/usr/include/c++/7/typeinfo" 2 3\n\n\n#pra'
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n  _Fnv_hash_bytes(const void* __ptr, size_t __len, size_t __seed);\n\n\n}\n# 37 "/usr/include/c++/7/typeinfo" 2 3\n\n\n#pragma GCC visibility push(default)\n\nextern "C++" {\n\nnamespace __cxxabiv1\n{\n  cl'
[#] parse_declaration, is_constructor=True, meet line: 'type_info();\n\n\n\n    const char* name() const noexcept\n    { return __name[0] == \'*\' ? __name + 1 : __name; }\n# 115 "/usr/include/c++/7/typeinfo" 3\n    bool before(const type_info& __arg) const noexcep'
[#] parse_declaration, is_constructor=False, meet line: 'char* name() const noexcept\n    { return __name[0] == \'*\' ? __name + 1 : __name; }\n# 115 "/usr/include/c++/7/typeinfo" 3\n    bool before(const type_info& __arg) const noexcept\n    { return (__name[0] '
[#] parse_declaration, is_constructor=False, meet line: "bool before(const type_info& __arg) const noexcept\n    { return (__name[0] == '*' && __arg.__name[0] == '*')\n ? __name < __arg.__name\n : __builtin_strcmp (__name, __arg.__name) < 0; }\n\n    bool operat"
[#] parse_declaration, is_constructor=False, meet line: 'bool operator==(const type_info& __arg) const noexcept\n    {\n      return ((__name == __arg.__name)\n       || (__name[0] != \'*\' &&\n    __builtin_strcmp (__name, __arg.__name) == 0));\n    }\n# 136 "/usr'
[#] parse_declaration, is_constructor=False, meet line: 'bool operator!=(const type_info& __arg) const noexcept\n    { return !operator==(__arg); }\n\n\n    size_t hash_code() const noexcept\n    {\n\n      return _Hash_bytes(name(), __builtin_strlen(name()),\n    '
[#] parse_declaration, is_constructor=False, meet line: 'size_t hash_code() const noexcept\n    {\n\n      return _Hash_bytes(name(), __builtin_strlen(name()),\n    static_cast<size_t>(0xc70f6907UL));\n\n\n\n    }\n\n\n\n    virtual bool __is_pointer_p() const;\n\n\n    v'
[#] parse_declaration, is_constructor=False, meet line: 'bool __is_pointer_p() const;\n\n\n    virtual bool __is_function_p() const;\n\n\n\n\n\n\n\n    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,\n       unsigned __outer) const;\n\n\n    virtual'
[#] parse_declaration, is_constructor=False, meet line: 'bool __is_function_p() const;\n\n\n\n\n\n\n\n    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,\n       unsigned __outer) const;\n\n\n    virtual bool __do_upcast(const __cxxabiv1::__class'
[#] parse_declaration, is_constructor=False, meet line: 'bool __do_catch(const type_info *__thr_type, void **__thr_obj,\n       unsigned __outer) const;\n\n\n    virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,\n        void **__obj_ptr) c'
[#] parse_declaration, is_constructor=False, meet line: 'bool __do_upcast(const __cxxabiv1::__class_type_info *__target,\n        void **__obj_ptr) const;\n\n  protected:\n    const char *__name;\n\n    explicit type_info(const char *__n): __name(__n) { }\n\n  priv'
[#] parse_declaration, is_constructor=False, meet line: 'char *__name;\n\n    explicit type_info(const char *__n): __name(__n) { }\n\n  private:\n\n    type_info& operator=(const type_info&);\n    type_info(const type_info&);\n  };\n\n\n\n\n\n\n\n  class bad_cast : public '
[#] parse_declaration, is_constructor=True, meet line: 'type_info(const char *__n): __name(__n) { }\n\n  private:\n\n    type_info& operator=(const type_info&);\n    type_info(const type_info&);\n  };\n\n\n\n\n\n\n\n  class bad_cast : public exception\n  {\n  public:\n    '
[#] parse_declaration, is_constructor=True, meet line: 'type_info& operator=(const type_info&);\n    type_info(const type_info&);\n  };\n\n\n\n\n\n\n\n  class bad_cast : public exception\n  {\n  public:\n    bad_cast() noexcept { }\n\n\n\n    virtual ~bad_cast() noexcept;\n'
[#] parse_declaration, is_constructor=True, meet line: 'type_info(const type_info&);\n  };\n\n\n\n\n\n\n\n  class bad_cast : public exception\n  {\n  public:\n    bad_cast() noexcept { }\n\n\n\n    virtual ~bad_cast() noexcept;\n\n\n    virtual const char* what() const noexc'
[#] parse_declaration, is_constructor=True, meet line: 'bad_cast() noexcept { }\n\n\n\n    virtual ~bad_cast() noexcept;\n\n\n    virtual const char* what() const noexcept;\n  };\n\n\n\n\n\n  class bad_typeid : public exception\n  {\n  public:\n    bad_typeid () noexcept {'
[#] parse_declaration, is_constructor=True, meet line: 'bad_cast() noexcept;\n\n\n    virtual const char* what() const noexcept;\n  };\n\n\n\n\n\n  class bad_typeid : public exception\n  {\n  public:\n    bad_typeid () noexcept { }\n\n\n\n    virtual ~bad_typeid() noexcept'
[#] parse_declaration, is_constructor=False, meet line: 'char* what() const noexcept;\n  };\n\n\n\n\n\n  class bad_typeid : public exception\n  {\n  public:\n    bad_typeid () noexcept { }\n\n\n\n    virtual ~bad_typeid() noexcept;\n\n\n    virtual const char* what() const '
[#] parse_declaration, is_constructor=True, meet line: 'bad_typeid () noexcept { }\n\n\n\n    virtual ~bad_typeid() noexcept;\n\n\n    virtual const char* what() const noexcept;\n  };\n}\n\n}\n\n#pragma GCC visibility pop\n# 40 "/usr/include/c++/7/bits/exception_ptr.h" '
[#] parse_declaration, is_constructor=True, meet line: 'bad_typeid() noexcept;\n\n\n    virtual const char* what() const noexcept;\n  };\n}\n\n}\n\n#pragma GCC visibility pop\n# 40 "/usr/include/c++/7/bits/exception_ptr.h" 2 3\n# 1 "/usr/include/c++/7/new" 1 3\n# 41 "'
[#] parse_declaration, is_constructor=False, meet line: 'char* what() const noexcept;\n  };\n}\n\n}\n\n#pragma GCC visibility pop\n# 40 "/usr/include/c++/7/bits/exception_ptr.h" 2 3\n# 1 "/usr/include/c++/7/new" 1 3\n# 41 "/usr/include/c++/7/bits/exception_ptr.h" 2 '
[#] parse_declaration, is_constructor=False, meet line: 'exception_ptr current_exception() noexcept;\n\n  template<typename _Ex>\n  exception_ptr make_exception_ptr(_Ex) noexcept;\n\n\n  void rethrow_exception(exception_ptr) __attribute__ ((__noreturn__));\n\n  nam'
[#] parse_declaration, is_constructor=False, meet line: 'exception_ptr make_exception_ptr(_Ex) noexcept;\n\n\n  void rethrow_exception(exception_ptr) __attribute__ ((__noreturn__));\n\n  namespace __exception_ptr\n  {\n    using std::rethrow_exception;\n\n\n\n\n\n    cl'
[#] parse_declaration, is_constructor=False, meet line: 'void rethrow_exception(exception_ptr) __attribute__ ((__noreturn__));\n\n  namespace __exception_ptr\n  {\n    using std::rethrow_exception;\n\n\n\n\n\n    class exception_ptr\n    {\n      void* _M_exception_obj'
[#] parse_declaration, is_constructor=False, meet line: 'void* _M_exception_object;\n\n      explicit exception_ptr(void* __e) noexcept;\n\n      void _M_addref() noexcept;\n      void _M_release() noexcept;\n\n      void *_M_get() const noexcept __attribute__ ((_'
[#] parse_declaration, is_constructor=True, meet line: 'exception_ptr(void* __e) noexcept;\n\n      void _M_addref() noexcept;\n      void _M_release() noexcept;\n\n      void *_M_get() const noexcept __attribute__ ((__pure__));\n\n      friend exception_ptr std:'
[#] parse_declaration, is_constructor=False, meet line: 'void _M_addref() noexcept;\n      void _M_release() noexcept;\n\n      void *_M_get() const noexcept __attribute__ ((__pure__));\n\n      friend exception_ptr std::current_exception() noexcept;\n      frien'
[#] parse_declaration, is_constructor=False, meet line: 'void _M_release() noexcept;\n\n      void *_M_get() const noexcept __attribute__ ((__pure__));\n\n      friend exception_ptr std::current_exception() noexcept;\n      friend void std::rethrow_exception(exc'
[#] parse_declaration, is_constructor=False, meet line: 'void *_M_get() const noexcept __attribute__ ((__pure__));\n\n      friend exception_ptr std::current_exception() noexcept;\n      friend void std::rethrow_exception(exception_ptr);\n      template<typenam'
[#] parse_declaration, is_constructor=True, meet line: 'exception_ptr std::current_exception() noexcept;\n      friend void std::rethrow_exception(exception_ptr);\n      template<typename _Ex>\n      friend exception_ptr std::make_exception_ptr(_Ex) noexcept;'
[#] parse_declaration, is_constructor=False, meet line: 'void std::rethrow_exception(exception_ptr);\n      template<typename _Ex>\n      friend exception_ptr std::make_exception_ptr(_Ex) noexcept;\n\n    public:\n      exception_ptr() noexcept;\n\n      exception'
[#] parse_declaration, is_constructor=True, meet line: 'exception_ptr std::make_exception_ptr(_Ex) noexcept;\n\n    public:\n      exception_ptr() noexcept;\n\n      exception_ptr(const exception_ptr&) noexcept;\n\n\n      exception_ptr(nullptr_t) noexcept\n      :'
[#] parse_declaration, is_constructor=True, meet line: 'exception_ptr() noexcept;\n\n      exception_ptr(const exception_ptr&) noexcept;\n\n\n      exception_ptr(nullptr_t) noexcept\n      : _M_exception_object(0)\n      { }\n\n      exception_ptr(exception_ptr&& _'
[#] parse_declaration, is_constructor=True, meet line: 'exception_ptr(const exception_ptr&) noexcept;\n\n\n      exception_ptr(nullptr_t) noexcept\n      : _M_exception_object(0)\n      { }\n\n      exception_ptr(exception_ptr&& __o) noexcept\n      : _M_exception'
[#] parse_declaration, is_constructor=True, meet line: 'exception_ptr(nullptr_t) noexcept\n      : _M_exception_object(0)\n      { }\n\n      exception_ptr(exception_ptr&& __o) noexcept\n      : _M_exception_object(__o._M_exception_object)\n      { __o._M_except'
[#] parse_declaration, is_constructor=True, meet line: 'exception_ptr(exception_ptr&& __o) noexcept\n      : _M_exception_object(__o._M_exception_object)\n      { __o._M_exception_object = 0; }\n# 117 "/usr/include/c++/7/bits/exception_ptr.h" 3\n      exceptio'
[#] parse_declaration, is_constructor=True, meet line: 'exception_ptr&\n      operator=(const exception_ptr&) noexcept;\n\n\n      exception_ptr&\n      operator=(exception_ptr&& __o) noexcept\n      {\n        exception_ptr(static_cast<exception_ptr&&>(__o)).swa'
[#] parse_declaration, is_constructor=True, meet line: 'exception_ptr&\n      operator=(exception_ptr&& __o) noexcept\n      {\n        exception_ptr(static_cast<exception_ptr&&>(__o)).swap(*this);\n        return *this;\n      }\n\n\n      ~exception_ptr() noexce'
[#] parse_declaration, is_constructor=True, meet line: 'exception_ptr() noexcept;\n\n      void\n      swap(exception_ptr&) noexcept;\n# 144 "/usr/include/c++/7/bits/exception_ptr.h" 3\n      explicit operator bool() const\n      { return _M_exception_object; }\n'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      swap(exception_ptr&) noexcept;\n# 144 "/usr/include/c++/7/bits/exception_ptr.h" 3\n      explicit operator bool() const\n      { return _M_exception_object; }\n\n\n      friend bool\n      operato'
[#] parse_declaration, is_constructor=False, meet line: 'operator bool() const\n      { return _M_exception_object; }\n\n\n      friend bool\n      operator==(const exception_ptr&, const exception_ptr&)\n noexcept __attribute__ ((__pure__));\n\n      const class st'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      operator==(const exception_ptr&, const exception_ptr&)\n noexcept __attribute__ ((__pure__));\n\n      const class std::type_info*\n      __cxa_exception_type() const noexcept\n __attribute__ (('
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator==(const exception_ptr&, const exception_ptr&)\n      noexcept __attribute__ ((__pure__));\n\n    bool\n    operator!=(const exception_ptr&, const exception_ptr&)\n      noexcept __attribu'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator!=(const exception_ptr&, const exception_ptr&)\n      noexcept __attribute__ ((__pure__));\n\n    inline void\n    swap(exception_ptr& __lhs, exception_ptr& __rhs)\n    { __lhs.swap(__rhs)'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    swap(exception_ptr& __lhs, exception_ptr& __rhs)\n    { __lhs.swap(__rhs); }\n\n    template<typename _Ex>\n      inline void\n      __dest_thunk(void* __x)\n      { static_cast<_Ex*>(__x)->~_Ex();'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      __dest_thunk(void* __x)\n      { static_cast<_Ex*>(__x)->~_Ex(); }\n\n  }\n\n\n  template<typename _Ex>\n    exception_ptr\n    make_exception_ptr(_Ex __ex) noexcept\n    {\n\n      void* __e = __cxxa'
[#] parse_declaration, is_constructor=False, meet line: 'exception_ptr\n    make_exception_ptr(_Ex __ex) noexcept\n    {\n\n      void* __e = __cxxabiv1::__cxa_allocate_exception(sizeof(_Ex));\n      (void) __cxxabiv1::__cxa_init_primary_exception(\n   __e, const'
[#] parse_declaration, is_constructor=False, meet line: 'exception_ptr\n    copy_exception(_Ex __ex) noexcept __attribute__ ((__deprecated__));\n\n  template<typename _Ex>\n    exception_ptr\n    copy_exception(_Ex __ex) noexcept\n    { return std::make_exception'
[#] parse_declaration, is_constructor=False, meet line: 'exception_ptr\n    copy_exception(_Ex __ex) noexcept\n    { return std::make_exception_ptr<_Ex>(__ex); }\n\n\n}\n\n}\n\n#pragma GCC visibility pop\n# 143 "/usr/include/c++/7/exception" 2 3\n# 1 "/usr/include/c++'
[#] parse_declaration, is_constructor=False, meet line: 'exception_ptr _M_ptr;\n\n  public:\n    nested_exception() noexcept : _M_ptr(current_exception()) { }\n\n    nested_exception(const nested_exception&) noexcept = default;\n\n    nested_exception& operator=(c'
[#] parse_declaration, is_constructor=True, meet line: 'nested_exception() noexcept : _M_ptr(current_exception()) { }\n\n    nested_exception(const nested_exception&) noexcept = default;\n\n    nested_exception& operator=(const nested_exception&) noexcept = de'
[#] parse_declaration, is_constructor=True, meet line: 'nested_exception(const nested_exception&) noexcept = default;\n\n    nested_exception& operator=(const nested_exception&) noexcept = default;\n\n    virtual ~nested_exception() noexcept;\n\n    [[noreturn]]'
[#] parse_declaration, is_constructor=True, meet line: 'nested_exception& operator=(const nested_exception&) noexcept = default;\n\n    virtual ~nested_exception() noexcept;\n\n    [[noreturn]]\n    void\n    rethrow_nested() const\n    {\n      if (_M_ptr)\n rethr'
[#] parse_declaration, is_constructor=True, meet line: 'nested_exception() noexcept;\n\n    [[noreturn]]\n    void\n    rethrow_nested() const\n    {\n      if (_M_ptr)\n rethrow_exception(_M_ptr);\n      std::terminate();\n    }\n\n    exception_ptr\n    nested_ptr()'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    rethrow_nested() const\n    {\n      if (_M_ptr)\n rethrow_exception(_M_ptr);\n      std::terminate();\n    }\n\n    exception_ptr\n    nested_ptr() const noexcept\n    { return _M_ptr; }\n  };\n\n  temp'
[#] parse_declaration, is_constructor=False, meet line: 'exception_ptr\n    nested_ptr() const noexcept\n    { return _M_ptr; }\n  };\n\n  template<typename _Except>\n    struct _Nested_exception : public _Except, public nested_exception\n    {\n      explicit _Nes'
[#] parse_declaration, is_constructor=True, meet line: '_Nested_exception(const _Except& __ex)\n      : _Except(__ex)\n      { }\n\n      explicit _Nested_exception(_Except&& __ex)\n      : _Except(static_cast<_Except&&>(__ex))\n      { }\n    };\n\n\n\n\n  template<t'
[#] parse_declaration, is_constructor=True, meet line: '_Nested_exception(_Except&& __ex)\n      : _Except(static_cast<_Except&&>(__ex))\n      { }\n    };\n\n\n\n\n  template<typename _Tp>\n    inline void\n    __throw_with_nested_impl(_Tp&& __t, true_type)\n    {\n '
[#] parse_declaration, is_constructor=False, meet line: 'void\n    __throw_with_nested_impl(_Tp&& __t, true_type)\n    {\n      using _Up = typename remove_reference<_Tp>::type;\n      throw _Nested_exception<_Up>{std::forward<_Tp>(__t)};\n    }\n\n  template<type'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    __throw_with_nested_impl(_Tp&& __t, false_type)\n    { throw std::forward<_Tp>(__t); }\n\n\n\n  template<typename _Tp>\n    [[noreturn]]\n    inline void\n    throw_with_nested(_Tp&& __t)\n    {\n     '
[#] parse_declaration, is_constructor=False, meet line: 'void\n    throw_with_nested(_Tp&& __t)\n    {\n      using _Up = typename decay<_Tp>::type;\n      using _CopyConstructible\n = __and_<is_copy_constructible<_Up>, is_move_constructible<_Up>>;\n      static_'
[#] parse_declaration, is_constructor=False, meet line: '__rethrow_if_nested_cond<_Ex>\n    __rethrow_if_nested_impl(const _Ex* __ptr)\n    {\n      if (auto __ne_ptr = dynamic_cast<const nested_exception*>(__ptr))\n __ne_ptr->rethrow_nested();\n    }\n\n\n  inline'
[#] parse_declaration, is_constructor=False, meet line: 'void\n  __rethrow_if_nested_impl(const void*)\n  { }\n\n\n  template<typename _Ex>\n    inline void\n    rethrow_if_nested(const _Ex& __ex)\n    { std::__rethrow_if_nested_impl(std::__addressof(__ex)); }\n\n\n}\n'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    rethrow_if_nested(const _Ex& __ex)\n    { std::__rethrow_if_nested_impl(std::__addressof(__ex)); }\n\n\n}\n\n}\n\n\n\n#pragma GCC visibility pop\n# 144 "/usr/include/c++/7/exception" 2 3\n# 41 "/usr/incl'
[#] parse_declaration, is_constructor=True, meet line: 'bad_alloc() throw() { }\n\n\n\n    virtual ~bad_alloc() throw();\n\n\n    virtual const char* what() const throw();\n  };\n\n\n  class bad_array_new_length : public bad_alloc\n  {\n  public:\n    bad_array_new_leng'
[#] parse_declaration, is_constructor=True, meet line: 'bad_alloc() throw();\n\n\n    virtual const char* what() const throw();\n  };\n\n\n  class bad_array_new_length : public bad_alloc\n  {\n  public:\n    bad_array_new_length() throw() { };\n\n\n\n    virtual ~bad_ar'
[#] parse_declaration, is_constructor=False, meet line: 'char* what() const throw();\n  };\n\n\n  class bad_array_new_length : public bad_alloc\n  {\n  public:\n    bad_array_new_length() throw() { };\n\n\n\n    virtual ~bad_array_new_length() throw();\n\n\n    virtual c'
[#] parse_declaration, is_constructor=True, meet line: 'bad_array_new_length() throw() { };\n\n\n\n    virtual ~bad_array_new_length() throw();\n\n\n    virtual const char* what() const throw();\n  };\n\n\n\n\n\n\n  struct nothrow_t\n  {\n\n    explicit nothrow_t() = defaul'
[#] parse_declaration, is_constructor=True, meet line: 'bad_array_new_length() throw();\n\n\n    virtual const char* what() const throw();\n  };\n\n\n\n\n\n\n  struct nothrow_t\n  {\n\n    explicit nothrow_t() = default;\n\n  };\n\n  extern const nothrow_t nothrow;\n\n\n\n  typ'
[#] parse_declaration, is_constructor=False, meet line: 'char* what() const throw();\n  };\n\n\n\n\n\n\n  struct nothrow_t\n  {\n\n    explicit nothrow_t() = default;\n\n  };\n\n  extern const nothrow_t nothrow;\n\n\n\n  typedef void (*new_handler)();\n\n\n\n  new_handler set_new'
[#] parse_declaration, is_constructor=True, meet line: 'nothrow_t() = default;\n\n  };\n\n  extern const nothrow_t nothrow;\n\n\n\n  typedef void (*new_handler)();\n\n\n\n  new_handler set_new_handler(new_handler) throw();\n\n\n\n  new_handler get_new_handler() noexcept;\n'
[#] parse_declaration, is_constructor=False, meet line: 'const nothrow_t nothrow;\n\n\n\n  typedef void (*new_handler)();\n\n\n\n  new_handler set_new_handler(new_handler) throw();\n\n\n\n  new_handler get_new_handler() noexcept;\n\n}\n# 120 "/usr/include/c++/7/new" 3\nvoi'
[#] parse_declaration, is_constructor=False, meet line: 'new_handler set_new_handler(new_handler) throw();\n\n\n\n  new_handler get_new_handler() noexcept;\n\n}\n# 120 "/usr/include/c++/7/new" 3\nvoid* operator new(std::size_t)\n  __attribute__((__externally_visible'
[#] parse_declaration, is_constructor=False, meet line: 'new_handler get_new_handler() noexcept;\n\n}\n# 120 "/usr/include/c++/7/new" 3\nvoid* operator new(std::size_t)\n  __attribute__((__externally_visible__));\nvoid* operator new[](std::size_t)\n  __attribute__'
[#] parse_declaration, is_constructor=False, meet line: 'void* operator new(std::size_t)\n  __attribute__((__externally_visible__));\nvoid* operator new[](std::size_t)\n  __attribute__((__externally_visible__));\nvoid operator delete(void*) noexcept\n  __attribu'
[#] parse_declaration, is_constructor=False, meet line: 'void* operator new[](std::size_t)\n  __attribute__((__externally_visible__));\nvoid operator delete(void*) noexcept\n  __attribute__((__externally_visible__));\nvoid operator delete[](void*) noexcept\n  __'
[#] parse_declaration, is_constructor=False, meet line: 'void operator delete(void*) noexcept\n  __attribute__((__externally_visible__));\nvoid operator delete[](void*) noexcept\n  __attribute__((__externally_visible__));\n\nvoid operator delete(void*, std::size'
[#] parse_declaration, is_constructor=False, meet line: 'void operator delete[](void*) noexcept\n  __attribute__((__externally_visible__));\n\nvoid operator delete(void*, std::size_t) noexcept\n  __attribute__((__externally_visible__));\nvoid operator delete[](v'
[#] parse_declaration, is_constructor=False, meet line: 'void operator delete(void*, std::size_t) noexcept\n  __attribute__((__externally_visible__));\nvoid operator delete[](void*, std::size_t) noexcept\n  __attribute__((__externally_visible__));\n\nvoid* opera'
[#] parse_declaration, is_constructor=False, meet line: 'void operator delete[](void*, std::size_t) noexcept\n  __attribute__((__externally_visible__));\n\nvoid* operator new(std::size_t, const std::nothrow_t&) noexcept\n  __attribute__((__externally_visible__)'
[#] parse_declaration, is_constructor=False, meet line: 'void* operator new(std::size_t, const std::nothrow_t&) noexcept\n  __attribute__((__externally_visible__));\nvoid* operator new[](std::size_t, const std::nothrow_t&) noexcept\n  __attribute__((__external'
[#] parse_declaration, is_constructor=False, meet line: 'void* operator new[](std::size_t, const std::nothrow_t&) noexcept\n  __attribute__((__externally_visible__));\nvoid operator delete(void*, const std::nothrow_t&) noexcept\n  __attribute__((__externally_v'
[#] parse_declaration, is_constructor=False, meet line: 'void operator delete(void*, const std::nothrow_t&) noexcept\n  __attribute__((__externally_visible__));\nvoid operator delete[](void*, const std::nothrow_t&) noexcept\n  __attribute__((__externally_visib'
[#] parse_declaration, is_constructor=False, meet line: 'void operator delete[](void*, const std::nothrow_t&) noexcept\n  __attribute__((__externally_visible__));\n# 168 "/usr/include/c++/7/new" 3\ninline void* operator new(std::size_t, void* __p) noexcept\n{ r'
[#] parse_declaration, is_constructor=False, meet line: 'void* operator new(std::size_t, void* __p) noexcept\n{ return __p; }\ninline void* operator new[](std::size_t, void* __p) noexcept\n{ return __p; }\n\n\ninline void operator delete (void*, void*) noexcept {'
[#] parse_declaration, is_constructor=False, meet line: 'void* operator new[](std::size_t, void* __p) noexcept\n{ return __p; }\n\n\ninline void operator delete (void*, void*) noexcept { }\ninline void operator delete[](void*, void*) noexcept { }\n\n}\n# 216 "/usr/'
[#] parse_declaration, is_constructor=False, meet line: 'void operator delete (void*, void*) noexcept { }\ninline void operator delete[](void*, void*) noexcept { }\n\n}\n# 216 "/usr/include/c++/7/new" 3\n#pragma GCC visibility pop\n# 60 "/usr/include/c++/7/bits/s'
[#] parse_declaration, is_constructor=False, meet line: 'void operator delete[](void*, void*) noexcept { }\n\n}\n# 216 "/usr/include/c++/7/new" 3\n#pragma GCC visibility pop\n# 60 "/usr/include/c++/7/bits/stl_construct.h" 2 3\n\n# 1 "/usr/include/c++/7/ext/alloc_t'
[#] parse_declaration, is_constructor=False, meet line: 'auto\n _S_allocate(_Alloc2& __a, size_type __n, const_void_pointer __hint, int)\n -> decltype(__a.allocate(__n, __hint))\n { return __a.allocate(__n, __hint); }\n\n      template<typename _Alloc2>\n static '
[#] parse_declaration, is_constructor=False, meet line: 'pointer\n _S_allocate(_Alloc2& __a, size_type __n, const_void_pointer, ...)\n { return __a.allocate(__n); }\n\n      template<typename _Tp, typename... _Args>\n struct __construct_helper\n {\n   template<typ'
[#] parse_declaration, is_constructor=False, meet line: 'true_type __test(int);\n\n   template<typename>\n     static false_type __test(...);\n\n   using type = decltype(__test<_Alloc>(0));\n };\n\n      template<typename _Tp, typename... _Args>\n using __has_constr'
[#] parse_declaration, is_constructor=False, meet line: 'false_type __test(...);\n\n   using type = decltype(__test<_Alloc>(0));\n };\n\n      template<typename _Tp, typename... _Args>\n using __has_construct\n   = typename __construct_helper<_Tp, _Args...>::type;'
[#] parse_declaration, is_constructor=False, meet line: '_Require<__has_construct<_Tp, _Args...>>\n _S_construct(_Alloc& __a, _Tp* __p, _Args&&... __args)\n { __a.construct(__p, std::forward<_Args>(__args)...); }\n\n      template<typename _Tp, typename... _Arg'
[#] parse_declaration, is_constructor=False, meet line: '_Require<__and_<__not_<__has_construct<_Tp, _Args...>>,\n          is_constructible<_Tp, _Args...>>>\n _S_construct(_Alloc&, _Tp* __p, _Args&&... __args)\n { ::new((void*)__p) _Tp(std::forward<_Args>(__a'
[#] parse_declaration, is_constructor=False, meet line: 'auto\n _S_destroy(_Alloc2& __a, _Tp* __p, int)\n -> decltype(__a.destroy(__p))\n { __a.destroy(__p); }\n\n      template<typename _Alloc2, typename _Tp>\n static void\n _S_destroy(_Alloc2&, _Tp* __p, ...)\n {'
[#] parse_declaration, is_constructor=False, meet line: 'void\n _S_destroy(_Alloc2&, _Tp* __p, ...)\n { __p->~_Tp(); }\n\n      template<typename _Alloc2>\n static auto\n _S_max_size(_Alloc2& __a, int)\n -> decltype(__a.max_size())\n { return __a.max_size(); }\n\n   '
[#] parse_declaration, is_constructor=False, meet line: 'auto\n _S_max_size(_Alloc2& __a, int)\n -> decltype(__a.max_size())\n { return __a.max_size(); }\n\n      template<typename _Alloc2>\n static size_type\n _S_max_size(_Alloc2&, ...)\n {\n\n\n   return __gnu_cxx::'
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n _S_max_size(_Alloc2&, ...)\n {\n\n\n   return __gnu_cxx::__numeric_traits<size_type>::__max\n     / sizeof(value_type);\n }\n\n      template<typename _Alloc2>\n static auto\n _S_select(_Alloc2& __a,'
[#] parse_declaration, is_constructor=False, meet line: 'auto\n _S_select(_Alloc2& __a, int)\n -> decltype(__a.select_on_container_copy_construction())\n { return __a.select_on_container_copy_construction(); }\n\n      template<typename _Alloc2>\n static _Alloc2\n'
[#] parse_declaration, is_constructor=False, meet line: '_Alloc2\n _S_select(_Alloc2& __a, ...)\n { return __a; }\n\n    public:\n# 299 "/usr/include/c++/7/bits/alloc_traits.h" 3\n      static pointer\n      allocate(_Alloc& __a, size_type __n)\n      { return __a.'
[#] parse_declaration, is_constructor=False, meet line: 'pointer\n      allocate(_Alloc& __a, size_type __n)\n      { return __a.allocate(__n); }\n# 314 "/usr/include/c++/7/bits/alloc_traits.h" 3\n      static pointer\n      allocate(_Alloc& __a, size_type __n, '
[#] parse_declaration, is_constructor=False, meet line: 'pointer\n      allocate(_Alloc& __a, size_type __n, const_void_pointer __hint)\n      { return _S_allocate(__a, __n, __hint, 0); }\n# 326 "/usr/include/c++/7/bits/alloc_traits.h" 3\n      static void\n    '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      deallocate(_Alloc& __a, pointer __p, size_type __n)\n      { __a.deallocate(__p, __n); }\n# 341 "/usr/include/c++/7/bits/alloc_traits.h" 3\n      template<typename _Tp, typename... _Args>\n sta'
[#] parse_declaration, is_constructor=False, meet line: 'auto construct(_Alloc& __a, _Tp* __p, _Args&&... __args)\n -> decltype(_S_construct(__a, __p, std::forward<_Args>(__args)...))\n { _S_construct(__a, __p, std::forward<_Args>(__args)...); }\n# 354 "/usr/i'
[#] parse_declaration, is_constructor=False, meet line: 'void destroy(_Alloc& __a, _Tp* __p)\n { _S_destroy(__a, __p, 0); }\n# 366 "/usr/include/c++/7/bits/alloc_traits.h" 3\n      static size_type max_size(const _Alloc& __a) noexcept\n      { return _S_max_siz'
[#] parse_declaration, is_constructor=False, meet line: 'size_type max_size(const _Alloc& __a) noexcept\n      { return _S_max_size(__a, 0); }\n# 377 "/usr/include/c++/7/bits/alloc_traits.h" 3\n      static _Alloc\n      select_on_container_copy_construction(co'
[#] parse_declaration, is_constructor=False, meet line: '_Alloc\n      select_on_container_copy_construction(const _Alloc& __rhs)\n      { return _S_select(__rhs, 0); }\n    };\n\n\n  template<typename _Tp>\n    struct allocator_traits<allocator<_Tp>>\n    {\n\n     '
[#] parse_declaration, is_constructor=False, meet line: 'pointer\n      allocate(allocator_type& __a, size_type __n)\n      { return __a.allocate(__n); }\n# 448 "/usr/include/c++/7/bits/alloc_traits.h" 3\n      static pointer\n      allocate(allocator_type& __a,'
[#] parse_declaration, is_constructor=False, meet line: 'pointer\n      allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)\n      { return __a.allocate(__n, __hint); }\n# 460 "/usr/include/c++/7/bits/alloc_traits.h" 3\n      static void\n   '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      deallocate(allocator_type& __a, pointer __p, size_type __n)\n      { __a.deallocate(__p, __n); }\n# 472 "/usr/include/c++/7/bits/alloc_traits.h" 3\n      template<typename _Up, typename... _Ar'
[#] parse_declaration, is_constructor=False, meet line: 'void\n construct(allocator_type& __a, _Up* __p, _Args&&... __args)\n { __a.construct(__p, std::forward<_Args>(__args)...); }\n# 484 "/usr/include/c++/7/bits/alloc_traits.h" 3\n      template<typename _Up>'
[#] parse_declaration, is_constructor=False, meet line: 'void\n destroy(allocator_type& __a, _Up* __p)\n { __a.destroy(__p); }\n\n\n\n\n\n\n      static size_type\n      max_size(const allocator_type& __a) noexcept\n      { return __a.max_size(); }\n\n\n\n\n\n\n      static '
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      max_size(const allocator_type& __a) noexcept\n      { return __a.max_size(); }\n\n\n\n\n\n\n      static allocator_type\n      select_on_container_copy_construction(const allocator_type& __rhs)'
[#] parse_declaration, is_constructor=False, meet line: 'allocator_type\n      select_on_container_copy_construction(const allocator_type& __rhs)\n      { return __rhs; }\n    };\n\n\n  template<typename _Alloc>\n    inline void\n    __do_alloc_on_copy(_Alloc& __on'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    __do_alloc_on_copy(_Alloc& __one, const _Alloc& __two, true_type)\n    { __one = __two; }\n\n  template<typename _Alloc>\n    inline void\n    __do_alloc_on_copy(_Alloc&, const _Alloc&, false_type'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    __do_alloc_on_copy(_Alloc&, const _Alloc&, false_type)\n    { }\n\n  template<typename _Alloc>\n    inline void __alloc_on_copy(_Alloc& __one, const _Alloc& __two)\n    {\n      typedef allocator_t'
[#] parse_declaration, is_constructor=False, meet line: 'void __alloc_on_copy(_Alloc& __one, const _Alloc& __two)\n    {\n      typedef allocator_traits<_Alloc> __traits;\n      typedef typename __traits::propagate_on_container_copy_assignment __pocca;\n      _'
[#] parse_declaration, is_constructor=False, meet line: '_Alloc __alloc_on_copy(const _Alloc& __a)\n    {\n      typedef allocator_traits<_Alloc> __traits;\n      return __traits::select_on_container_copy_construction(__a);\n    }\n\n  template<typename _Alloc>\n '
[#] parse_declaration, is_constructor=False, meet line: 'void __do_alloc_on_move(_Alloc& __one, _Alloc& __two, true_type)\n    { __one = std::move(__two); }\n\n  template<typename _Alloc>\n    inline void __do_alloc_on_move(_Alloc&, _Alloc&, false_type)\n    { }'
[#] parse_declaration, is_constructor=False, meet line: 'void __do_alloc_on_move(_Alloc&, _Alloc&, false_type)\n    { }\n\n  template<typename _Alloc>\n    inline void __alloc_on_move(_Alloc& __one, _Alloc& __two)\n    {\n      typedef allocator_traits<_Alloc> __'
[#] parse_declaration, is_constructor=False, meet line: 'void __alloc_on_move(_Alloc& __one, _Alloc& __two)\n    {\n      typedef allocator_traits<_Alloc> __traits;\n      typedef typename __traits::propagate_on_container_move_assignment __pocma;\n      __do_al'
[#] parse_declaration, is_constructor=False, meet line: 'void __do_alloc_on_swap(_Alloc& __one, _Alloc& __two, true_type)\n    {\n      using std::swap;\n      swap(__one, __two);\n    }\n\n  template<typename _Alloc>\n    inline void __do_alloc_on_swap(_Alloc&, _'
[#] parse_declaration, is_constructor=False, meet line: 'void __do_alloc_on_swap(_Alloc&, _Alloc&, false_type)\n    { }\n\n  template<typename _Alloc>\n    inline void __alloc_on_swap(_Alloc& __one, _Alloc& __two)\n    {\n      typedef allocator_traits<_Alloc> __'
[#] parse_declaration, is_constructor=False, meet line: 'void __alloc_on_swap(_Alloc& __one, _Alloc& __two)\n    {\n      typedef allocator_traits<_Alloc> __traits;\n      typedef typename __traits::propagate_on_container_swap __pocs;\n      __do_alloc_on_swap('
[#] parse_declaration, is_constructor=False, meet line: 'true_type\n _M_select(int);\n\n      template<typename _Up>\n static false_type\n _M_select(...);\n\n    public:\n      typedef decltype(_M_select<typename _Alloc::value_type>(0)) type;\n    };\n\n\n  template<ty'
[#] parse_declaration, is_constructor=False, meet line: 'false_type\n _M_select(...);\n\n    public:\n      typedef decltype(_M_select<typename _Alloc::value_type>(0)) type;\n    };\n\n\n  template<typename _Alloc>\n    struct __is_copy_insertable\n    : __is_copy_in'
[#] parse_declaration, is_constructor=False, meet line: 'std::enable_if<__is_custom_pointer<_Ptr>::value>::type\n      construct(_Alloc& __a, _Ptr __p, _Args&&... __args)\n      {\n _Base_type::construct(__a, std::addressof(*__p),\n         std::forward<_Args>('
[#] parse_declaration, is_constructor=False, meet line: 'std::enable_if<__is_custom_pointer<_Ptr>::value>::type\n      destroy(_Alloc& __a, _Ptr __p)\n      { _Base_type::destroy(__a, std::addressof(*__p)); }\n\n    static _Alloc _S_select_on_copy(const _Alloc&'
[#] parse_declaration, is_constructor=False, meet line: '_Alloc _S_select_on_copy(const _Alloc& __a)\n    { return _Base_type::select_on_container_copy_construction(__a); }\n\n    static void _S_on_swap(_Alloc& __a, _Alloc& __b)\n    { std::__alloc_on_swap(__a,'
[#] parse_declaration, is_constructor=False, meet line: 'void _S_on_swap(_Alloc& __a, _Alloc& __b)\n    { std::__alloc_on_swap(__a, __b); }\n\n    static constexpr bool _S_propagate_on_copy_assign()\n    { return _Base_type::propagate_on_container_copy_assignme'
[#] parse_declaration, is_constructor=False, meet line: 'bool _S_propagate_on_copy_assign()\n    { return _Base_type::propagate_on_container_copy_assignment::value; }\n\n    static constexpr bool _S_propagate_on_move_assign()\n    { return _Base_type::propagate'
[#] parse_declaration, is_constructor=False, meet line: 'bool _S_propagate_on_move_assign()\n    { return _Base_type::propagate_on_container_move_assignment::value; }\n\n    static constexpr bool _S_propagate_on_swap()\n    { return _Base_type::propagate_on_con'
[#] parse_declaration, is_constructor=False, meet line: 'bool _S_propagate_on_swap()\n    { return _Base_type::propagate_on_container_swap::value; }\n\n    static constexpr bool _S_always_equal()\n    { return _Base_type::is_always_equal::value; }\n\n    static c'
[#] parse_declaration, is_constructor=False, meet line: 'bool _S_always_equal()\n    { return _Base_type::is_always_equal::value; }\n\n    static constexpr bool _S_nothrow_move()\n    { return _S_propagate_on_move_assign() || _S_always_equal(); }\n\n    template<'
[#] parse_declaration, is_constructor=False, meet line: 'bool _S_nothrow_move()\n    { return _S_propagate_on_move_assign() || _S_always_equal(); }\n\n    template<typename _Tp>\n      struct rebind\n      { typedef typename _Base_type::template rebind_alloc<_Tp'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _Construct(_T1* __p, _Args&&... __args)\n    { ::new(static_cast<void*>(__p)) _T1(std::forward<_Args>(__args)...); }\n# 87 "/usr/include/c++/7/bits/stl_construct.h" 3\n  template<typename _T1>\n '
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _Construct_novalue(_T1* __p)\n    { ::new(static_cast<void*>(__p)) _T1; }\n\n\n\n\n  template<typename _Tp>\n    inline void\n    _Destroy(_Tp* __pointer)\n    { __pointer->~_Tp(); }\n\n  template<bool>'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _Destroy(_Tp* __pointer)\n    { __pointer->~_Tp(); }\n\n  template<bool>\n    struct _Destroy_aux\n    {\n      template<typename _ForwardIterator>\n        static void\n        __destroy(_ForwardIte'
[#] parse_declaration, is_constructor=False, meet line: 'void\n        __destroy(_ForwardIterator __first, _ForwardIterator __last)\n {\n   for (; __first != __last; ++__first)\n     std::_Destroy(std::__addressof(*__first));\n }\n    };\n\n  template<>\n    struct '
[#] parse_declaration, is_constructor=False, meet line: 'void\n        __destroy(_ForwardIterator, _ForwardIterator) { }\n    };\n\n\n\n\n\n\n  template<typename _ForwardIterator>\n    inline void\n    _Destroy(_ForwardIterator __first, _ForwardIterator __last)\n    {\n'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _Destroy(_ForwardIterator __first, _ForwardIterator __last)\n    {\n      typedef typename iterator_traits<_ForwardIterator>::value_type\n                       _Value_type;\n\n\n      static_asser'
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n        __destroy_n(_ForwardIterator __first, _Size __count)\n {\n   for (; __count > 0; (void)++__first, --__count)\n     std::_Destroy(std::__addressof(*__first));\n   return __first;\n '
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n        __destroy_n(_ForwardIterator __first, _Size __count)\n {\n   std::advance(__first, __count);\n   return __first;\n }\n    };\n\n\n\n\n\n\n  template<typename _ForwardIterator, typename _S'
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n    _Destroy_n(_ForwardIterator __first, _Size __count)\n    {\n      typedef typename iterator_traits<_ForwardIterator>::value_type\n                       _Value_type;\n\n\n      static_a'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _Destroy(_ForwardIterator __first, _ForwardIterator __last,\n      _Allocator& __alloc)\n    {\n      typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;\n      for (; __first != __last; ++__'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _Destroy(_ForwardIterator __first, _ForwardIterator __last,\n      allocator<_Tp>&)\n    {\n      _Destroy(__first, __last);\n    }\n# 232 "/usr/include/c++/7/bits/stl_construct.h" 3\n\n}\n# 61 "/usr'
[#] parse_declaration, is_constructor=False, meet line: 'pair<_Tp*, ptrdiff_t>\n    get_temporary_buffer(ptrdiff_t __len) noexcept\n    {\n      const ptrdiff_t __max =\n __gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp);\n      if (__len > __max)\n __l'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    return_temporary_buffer(_Tp* __p)\n    { ::operator delete(__p, std::nothrow); }\n\n\n\n\n\n\n\n  template<typename _ForwardIterator, typename _Tp>\n    class _Temporary_buffer\n    {\n\n     \n\n    public'
[#] parse_declaration, is_constructor=False, meet line: 'size_type _M_original_len;\n      size_type _M_len;\n      pointer _M_buffer;\n\n    public:\n\n      size_type\n      size() const\n      { return _M_len; }\n\n\n      size_type\n      requested_size() const\n   '
[#] parse_declaration, is_constructor=False, meet line: 'size_type _M_len;\n      pointer _M_buffer;\n\n    public:\n\n      size_type\n      size() const\n      { return _M_len; }\n\n\n      size_type\n      requested_size() const\n      { return _M_original_len; }\n\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'pointer _M_buffer;\n\n    public:\n\n      size_type\n      size() const\n      { return _M_len; }\n\n\n      size_type\n      requested_size() const\n      { return _M_original_len; }\n\n\n      iterator\n      beg'
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      size() const\n      { return _M_len; }\n\n\n      size_type\n      requested_size() const\n      { return _M_original_len; }\n\n\n      iterator\n      begin()\n      { return _M_buffer; }\n\n\n    '
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      requested_size() const\n      { return _M_original_len; }\n\n\n      iterator\n      begin()\n      { return _M_buffer; }\n\n\n      iterator\n      end()\n      { return _M_buffer + _M_len; }\n\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      begin()\n      { return _M_buffer; }\n\n\n      iterator\n      end()\n      { return _M_buffer + _M_len; }\n\n\n\n\n\n      _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last);\n\n '
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      end()\n      { return _M_buffer + _M_len; }\n\n\n\n\n\n      _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last);\n\n      ~_Temporary_buffer()\n      {\n std::_Destroy(_M_buffer,'
[#] parse_declaration, is_constructor=True, meet line: '_Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last);\n\n      ~_Temporary_buffer()\n      {\n std::_Destroy(_M_buffer, _M_buffer + _M_len);\n std::return_temporary_buffer(_M_buffer);\n     '
[#] parse_declaration, is_constructor=True, meet line: '_Temporary_buffer()\n      {\n std::_Destroy(_M_buffer, _M_buffer + _M_len);\n std::return_temporary_buffer(_M_buffer);\n      }\n\n    private:\n\n      _Temporary_buffer(const _Temporary_buffer&);\n\n      vo'
[#] parse_declaration, is_constructor=True, meet line: '_Temporary_buffer(const _Temporary_buffer&);\n\n      void\n      operator=(const _Temporary_buffer&);\n    };\n\n\n  template<bool>\n    struct __uninitialized_construct_buf_dispatch\n    {\n      template<typ'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      operator=(const _Temporary_buffer&);\n    };\n\n\n  template<bool>\n    struct __uninitialized_construct_buf_dispatch\n    {\n      template<typename _Pointer, typename _ForwardIterator>\n        s'
[#] parse_declaration, is_constructor=False, meet line: 'void\n        __ucr(_Pointer __first, _Pointer __last,\n       _ForwardIterator __seed)\n        {\n   if(__first == __last)\n     return;\n\n   _Pointer __cur = __first;\n   try\n     {\n       std::_Construct'
[#] parse_declaration, is_constructor=False, meet line: 'void\n        __ucr(_Pointer, _Pointer, _ForwardIterator) { }\n    };\n# 229 "/usr/include/c++/7/bits/stl_tempbuf.h" 3\n  template<typename _Pointer, typename _ForwardIterator>\n    inline void\n    __unini'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    __uninitialized_construct_buf(_Pointer __first, _Pointer __last,\n      _ForwardIterator __seed)\n    {\n      typedef typename std::iterator_traits<_Pointer>::value_type\n _ValueType;\n\n      std'
[#] parse_declaration, is_constructor=False, meet line: '_Temporary_buffer<_ForwardIterator, _Tp>::\n    _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last)\n    : _M_original_len(std::distance(__first, __last)),\n      _M_len(0), _M_buffer(0)'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_specialized = false;\n\n\n\n\n    static constexpr int digits = 0;\n\n\n    static constexpr int digits10 = 0;\n\n\n\n\n    static constexpr int max_digits10 = 0;\n\n\n\n    static constexpr bool is_signed = f'
[#] parse_declaration, is_constructor=False, meet line: 'int digits = 0;\n\n\n    static constexpr int digits10 = 0;\n\n\n\n\n    static constexpr int max_digits10 = 0;\n\n\n\n    static constexpr bool is_signed = false;\n\n\n    static constexpr bool is_integer = false;\n'
[#] parse_declaration, is_constructor=False, meet line: 'int digits10 = 0;\n\n\n\n\n    static constexpr int max_digits10 = 0;\n\n\n\n    static constexpr bool is_signed = false;\n\n\n    static constexpr bool is_integer = false;\n\n\n\n\n    static constexpr bool is_exact '
[#] parse_declaration, is_constructor=False, meet line: 'int max_digits10 = 0;\n\n\n\n    static constexpr bool is_signed = false;\n\n\n    static constexpr bool is_integer = false;\n\n\n\n\n    static constexpr bool is_exact = false;\n\n\n\n    static constexpr int radix '
[#] parse_declaration, is_constructor=False, meet line: 'bool is_signed = false;\n\n\n    static constexpr bool is_integer = false;\n\n\n\n\n    static constexpr bool is_exact = false;\n\n\n\n    static constexpr int radix = 0;\n\n\n\n    static constexpr int min_exponent '
[#] parse_declaration, is_constructor=False, meet line: 'bool is_integer = false;\n\n\n\n\n    static constexpr bool is_exact = false;\n\n\n\n    static constexpr int radix = 0;\n\n\n\n    static constexpr int min_exponent = 0;\n\n\n\n    static constexpr int min_exponent10'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_exact = false;\n\n\n\n    static constexpr int radix = 0;\n\n\n\n    static constexpr int min_exponent = 0;\n\n\n\n    static constexpr int min_exponent10 = 0;\n\n\n\n\n    static constexpr int max_exponent = '
[#] parse_declaration, is_constructor=False, meet line: 'int radix = 0;\n\n\n\n    static constexpr int min_exponent = 0;\n\n\n\n    static constexpr int min_exponent10 = 0;\n\n\n\n\n    static constexpr int max_exponent = 0;\n\n\n\n    static constexpr int max_exponent10 ='
[#] parse_declaration, is_constructor=False, meet line: 'int min_exponent = 0;\n\n\n\n    static constexpr int min_exponent10 = 0;\n\n\n\n\n    static constexpr int max_exponent = 0;\n\n\n\n    static constexpr int max_exponent10 = 0;\n\n\n    static constexpr bool has_inf'
[#] parse_declaration, is_constructor=False, meet line: 'int min_exponent10 = 0;\n\n\n\n\n    static constexpr int max_exponent = 0;\n\n\n\n    static constexpr int max_exponent10 = 0;\n\n\n    static constexpr bool has_infinity = false;\n\n\n\n    static constexpr bool ha'
[#] parse_declaration, is_constructor=False, meet line: 'int max_exponent = 0;\n\n\n\n    static constexpr int max_exponent10 = 0;\n\n\n    static constexpr bool has_infinity = false;\n\n\n\n    static constexpr bool has_quiet_NaN = false;\n\n\n\n    static constexpr bool'
[#] parse_declaration, is_constructor=False, meet line: 'int max_exponent10 = 0;\n\n\n    static constexpr bool has_infinity = false;\n\n\n\n    static constexpr bool has_quiet_NaN = false;\n\n\n\n    static constexpr bool has_signaling_NaN = false;\n\n\n    static const'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_infinity = false;\n\n\n\n    static constexpr bool has_quiet_NaN = false;\n\n\n\n    static constexpr bool has_signaling_NaN = false;\n\n\n    static constexpr float_denorm_style has_denorm = denorm_abs'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_quiet_NaN = false;\n\n\n\n    static constexpr bool has_signaling_NaN = false;\n\n\n    static constexpr float_denorm_style has_denorm = denorm_absent;\n\n\n\n    static constexpr bool has_denorm_loss ='
[#] parse_declaration, is_constructor=False, meet line: 'bool has_signaling_NaN = false;\n\n\n    static constexpr float_denorm_style has_denorm = denorm_absent;\n\n\n\n    static constexpr bool has_denorm_loss = false;\n\n\n\n    static constexpr bool is_iec559 = fal'
[#] parse_declaration, is_constructor=False, meet line: 'float_denorm_style has_denorm = denorm_absent;\n\n\n\n    static constexpr bool has_denorm_loss = false;\n\n\n\n    static constexpr bool is_iec559 = false;\n\n\n\n\n    static constexpr bool is_bounded = false;\n#'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_denorm_loss = false;\n\n\n\n    static constexpr bool is_iec559 = false;\n\n\n\n\n    static constexpr bool is_bounded = false;\n# 288 "/usr/include/c++/7/limits" 3\n    static constexpr bool is_modulo '
[#] parse_declaration, is_constructor=False, meet line: 'bool is_iec559 = false;\n\n\n\n\n    static constexpr bool is_bounded = false;\n# 288 "/usr/include/c++/7/limits" 3\n    static constexpr bool is_modulo = false;\n\n\n    static constexpr bool traps = false;\n\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_bounded = false;\n# 288 "/usr/include/c++/7/limits" 3\n    static constexpr bool is_modulo = false;\n\n\n    static constexpr bool traps = false;\n\n\n    static constexpr bool tinyness_before = false'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_modulo = false;\n\n\n    static constexpr bool traps = false;\n\n\n    static constexpr bool tinyness_before = false;\n\n\n\n\n    static constexpr float_round_style round_style =\n          round_toward_'
[#] parse_declaration, is_constructor=False, meet line: 'bool traps = false;\n\n\n    static constexpr bool tinyness_before = false;\n\n\n\n\n    static constexpr float_round_style round_style =\n          round_toward_zero;\n  };\n# 311 "/usr/include/c++/7/limits" 3\n'
[#] parse_declaration, is_constructor=False, meet line: 'bool tinyness_before = false;\n\n\n\n\n    static constexpr float_round_style round_style =\n          round_toward_zero;\n  };\n# 311 "/usr/include/c++/7/limits" 3\n  template<typename _Tp>\n    struct numeric'
[#] parse_declaration, is_constructor=False, meet line: 'float_round_style round_style =\n          round_toward_zero;\n  };\n# 311 "/usr/include/c++/7/limits" 3\n  template<typename _Tp>\n    struct numeric_limits : public __numeric_limits_base\n    {\n\n\n      st'
[#] parse_declaration, is_constructor=False, meet line: '_Tp\n      min() noexcept { return _Tp(); }\n\n\n      static constexpr _Tp\n      max() noexcept { return _Tp(); }\n\n\n\n\n      static constexpr _Tp\n      lowest() noexcept { return _Tp(); }\n\n\n\n\n      static'
[#] parse_declaration, is_constructor=False, meet line: '_Tp\n      max() noexcept { return _Tp(); }\n\n\n\n\n      static constexpr _Tp\n      lowest() noexcept { return _Tp(); }\n\n\n\n\n      static constexpr _Tp\n      epsilon() noexcept { return _Tp(); }\n\n\n      st'
[#] parse_declaration, is_constructor=False, meet line: '_Tp\n      lowest() noexcept { return _Tp(); }\n\n\n\n\n      static constexpr _Tp\n      epsilon() noexcept { return _Tp(); }\n\n\n      static constexpr _Tp\n      round_error() noexcept { return _Tp(); }\n\n\n  '
[#] parse_declaration, is_constructor=False, meet line: '_Tp\n      epsilon() noexcept { return _Tp(); }\n\n\n      static constexpr _Tp\n      round_error() noexcept { return _Tp(); }\n\n\n      static constexpr _Tp\n      infinity() noexcept { return _Tp(); }\n\n\n\n '
[#] parse_declaration, is_constructor=False, meet line: '_Tp\n      round_error() noexcept { return _Tp(); }\n\n\n      static constexpr _Tp\n      infinity() noexcept { return _Tp(); }\n\n\n\n      static constexpr _Tp\n      quiet_NaN() noexcept { return _Tp(); }\n\n'
[#] parse_declaration, is_constructor=False, meet line: '_Tp\n      infinity() noexcept { return _Tp(); }\n\n\n\n      static constexpr _Tp\n      quiet_NaN() noexcept { return _Tp(); }\n\n\n\n      static constexpr _Tp\n      signaling_NaN() noexcept { return _Tp(); '
[#] parse_declaration, is_constructor=False, meet line: '_Tp\n      quiet_NaN() noexcept { return _Tp(); }\n\n\n\n      static constexpr _Tp\n      signaling_NaN() noexcept { return _Tp(); }\n\n\n\n\n      static constexpr _Tp\n      denorm_min() noexcept { return _Tp('
[#] parse_declaration, is_constructor=False, meet line: '_Tp\n      signaling_NaN() noexcept { return _Tp(); }\n\n\n\n\n      static constexpr _Tp\n      denorm_min() noexcept { return _Tp(); }\n    };\n\n\n\n\n  template<typename _Tp>\n    struct numeric_limits<const _T'
[#] parse_declaration, is_constructor=False, meet line: '_Tp\n      denorm_min() noexcept { return _Tp(); }\n    };\n\n\n\n\n  template<typename _Tp>\n    struct numeric_limits<const _Tp>\n    : public numeric_limits<_Tp> { };\n\n  template<typename _Tp>\n    struct nu'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_specialized = true;\n\n      static constexpr bool\n      min() noexcept { return false; }\n\n      static constexpr bool\n      max() noexcept { return true; }\n\n\n      static constexpr bool\n      l'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      min() noexcept { return false; }\n\n      static constexpr bool\n      max() noexcept { return true; }\n\n\n      static constexpr bool\n      lowest() noexcept { return min(); }\n\n      static con'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      max() noexcept { return true; }\n\n\n      static constexpr bool\n      lowest() noexcept { return min(); }\n\n      static constexpr int digits = 1;\n      static constexpr int digits10 = 0;\n\n   '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      lowest() noexcept { return min(); }\n\n      static constexpr int digits = 1;\n      static constexpr int digits10 = 0;\n\n      static constexpr int max_digits10 = 0;\n\n      static constexpr bo'
[#] parse_declaration, is_constructor=False, meet line: 'int digits = 1;\n      static constexpr int digits10 = 0;\n\n      static constexpr int max_digits10 = 0;\n\n      static constexpr bool is_signed = false;\n      static constexpr bool is_integer = true;\n  '
[#] parse_declaration, is_constructor=False, meet line: 'int digits10 = 0;\n\n      static constexpr int max_digits10 = 0;\n\n      static constexpr bool is_signed = false;\n      static constexpr bool is_integer = true;\n      static constexpr bool is_exact = tr'
[#] parse_declaration, is_constructor=False, meet line: 'int max_digits10 = 0;\n\n      static constexpr bool is_signed = false;\n      static constexpr bool is_integer = true;\n      static constexpr bool is_exact = true;\n      static constexpr int radix = 2;\n'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_signed = false;\n      static constexpr bool is_integer = true;\n      static constexpr bool is_exact = true;\n      static constexpr int radix = 2;\n\n      static constexpr bool\n      epsilon() n'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_integer = true;\n      static constexpr bool is_exact = true;\n      static constexpr int radix = 2;\n\n      static constexpr bool\n      epsilon() noexcept { return false; }\n\n      static constex'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_exact = true;\n      static constexpr int radix = 2;\n\n      static constexpr bool\n      epsilon() noexcept { return false; }\n\n      static constexpr bool\n      round_error() noexcept { return f'
[#] parse_declaration, is_constructor=False, meet line: 'int radix = 2;\n\n      static constexpr bool\n      epsilon() noexcept { return false; }\n\n      static constexpr bool\n      round_error() noexcept { return false; }\n\n      static constexpr int min_expon'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      epsilon() noexcept { return false; }\n\n      static constexpr bool\n      round_error() noexcept { return false; }\n\n      static constexpr int min_exponent = 0;\n      static constexpr int min'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      round_error() noexcept { return false; }\n\n      static constexpr int min_exponent = 0;\n      static constexpr int min_exponent10 = 0;\n      static constexpr int max_exponent = 0;\n      stat'
[#] parse_declaration, is_constructor=False, meet line: 'int min_exponent = 0;\n      static constexpr int min_exponent10 = 0;\n      static constexpr int max_exponent = 0;\n      static constexpr int max_exponent10 = 0;\n\n      static constexpr bool has_infini'
[#] parse_declaration, is_constructor=False, meet line: 'int min_exponent10 = 0;\n      static constexpr int max_exponent = 0;\n      static constexpr int max_exponent10 = 0;\n\n      static constexpr bool has_infinity = false;\n      static constexpr bool has_q'
[#] parse_declaration, is_constructor=False, meet line: 'int max_exponent = 0;\n      static constexpr int max_exponent10 = 0;\n\n      static constexpr bool has_infinity = false;\n      static constexpr bool has_quiet_NaN = false;\n      static constexpr bool h'
[#] parse_declaration, is_constructor=False, meet line: 'int max_exponent10 = 0;\n\n      static constexpr bool has_infinity = false;\n      static constexpr bool has_quiet_NaN = false;\n      static constexpr bool has_signaling_NaN = false;\n      static conste'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_infinity = false;\n      static constexpr bool has_quiet_NaN = false;\n      static constexpr bool has_signaling_NaN = false;\n      static constexpr float_denorm_style has_denorm\n       = denor'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_quiet_NaN = false;\n      static constexpr bool has_signaling_NaN = false;\n      static constexpr float_denorm_style has_denorm\n       = denorm_absent;\n      static constexpr bool has_denorm_l'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_signaling_NaN = false;\n      static constexpr float_denorm_style has_denorm\n       = denorm_absent;\n      static constexpr bool has_denorm_loss = false;\n\n      static constexpr bool\n      inf'
[#] parse_declaration, is_constructor=False, meet line: 'float_denorm_style has_denorm\n       = denorm_absent;\n      static constexpr bool has_denorm_loss = false;\n\n      static constexpr bool\n      infinity() noexcept { return false; }\n\n      static conste'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_denorm_loss = false;\n\n      static constexpr bool\n      infinity() noexcept { return false; }\n\n      static constexpr bool\n      quiet_NaN() noexcept { return false; }\n\n      static constexpr'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      infinity() noexcept { return false; }\n\n      static constexpr bool\n      quiet_NaN() noexcept { return false; }\n\n      static constexpr bool\n      signaling_NaN() noexcept { return false; }'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      quiet_NaN() noexcept { return false; }\n\n      static constexpr bool\n      signaling_NaN() noexcept { return false; }\n\n      static constexpr bool\n      denorm_min() noexcept { return false;'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      signaling_NaN() noexcept { return false; }\n\n      static constexpr bool\n      denorm_min() noexcept { return false; }\n\n      static constexpr bool is_iec559 = false;\n      static constexpr '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      denorm_min() noexcept { return false; }\n\n      static constexpr bool is_iec559 = false;\n      static constexpr bool is_bounded = true;\n      static constexpr bool is_modulo = false;\n\n\n\n\n   '
[#] parse_declaration, is_constructor=False, meet line: 'bool is_iec559 = false;\n      static constexpr bool is_bounded = true;\n      static constexpr bool is_modulo = false;\n\n\n\n\n      static constexpr bool traps = true;\n      static constexpr bool tinyness'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_bounded = true;\n      static constexpr bool is_modulo = false;\n\n\n\n\n      static constexpr bool traps = true;\n      static constexpr bool tinyness_before = false;\n      static constexpr float_r'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_modulo = false;\n\n\n\n\n      static constexpr bool traps = true;\n      static constexpr bool tinyness_before = false;\n      static constexpr float_round_style round_style\n       = round_toward_ze'
[#] parse_declaration, is_constructor=False, meet line: 'bool traps = true;\n      static constexpr bool tinyness_before = false;\n      static constexpr float_round_style round_style\n       = round_toward_zero;\n    };\n\n\n  template<>\n    struct numeric_limits'
[#] parse_declaration, is_constructor=False, meet line: 'bool tinyness_before = false;\n      static constexpr float_round_style round_style\n       = round_toward_zero;\n    };\n\n\n  template<>\n    struct numeric_limits<char>\n    {\n      static constexpr bool i'
[#] parse_declaration, is_constructor=False, meet line: 'float_round_style round_style\n       = round_toward_zero;\n    };\n\n\n  template<>\n    struct numeric_limits<char>\n    {\n      static constexpr bool is_specialized = true;\n\n      static constexpr char\n  '
[#] parse_declaration, is_constructor=False, meet line: 'bool is_specialized = true;\n\n      static constexpr char\n      min() noexcept { return (((char)(-1) < 0) ? -(((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) +'
[#] parse_declaration, is_constructor=False, meet line: 'char\n      min() noexcept { return (((char)(-1) < 0) ? -(((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0) - 1 : (char)0); }\n\n      static cons'
[#] parse_declaration, is_constructor=False, meet line: 'char\n      max() noexcept { return (((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0); }\n\n\n      static constexpr char\n      lowest() noexcept '
[#] parse_declaration, is_constructor=False, meet line: 'char\n      lowest() noexcept { return min(); }\n\n\n      static constexpr int digits = (sizeof(char) * 8 - ((char)(-1) < 0));\n      static constexpr int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0))'
[#] parse_declaration, is_constructor=False, meet line: 'int digits = (sizeof(char) * 8 - ((char)(-1) < 0));\n      static constexpr int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643L / 2136);\n\n      static constexpr int max_digits10 = 0;\n\n      st'
[#] parse_declaration, is_constructor=False, meet line: 'int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643L / 2136);\n\n      static constexpr int max_digits10 = 0;\n\n      static constexpr bool is_signed = ((char)(-1) < 0);\n      static constexpr bo'
[#] parse_declaration, is_constructor=False, meet line: 'int max_digits10 = 0;\n\n      static constexpr bool is_signed = ((char)(-1) < 0);\n      static constexpr bool is_integer = true;\n      static constexpr bool is_exact = true;\n      static constexpr int '
[#] parse_declaration, is_constructor=False, meet line: 'bool is_signed = ((char)(-1) < 0);\n      static constexpr bool is_integer = true;\n      static constexpr bool is_exact = true;\n      static constexpr int radix = 2;\n\n      static constexpr char\n      '
[#] parse_declaration, is_constructor=False, meet line: 'bool is_integer = true;\n      static constexpr bool is_exact = true;\n      static constexpr int radix = 2;\n\n      static constexpr char\n      epsilon() noexcept { return 0; }\n\n      static constexpr c'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_exact = true;\n      static constexpr int radix = 2;\n\n      static constexpr char\n      epsilon() noexcept { return 0; }\n\n      static constexpr char\n      round_error() noexcept { return 0; }\n'
[#] parse_declaration, is_constructor=False, meet line: 'int radix = 2;\n\n      static constexpr char\n      epsilon() noexcept { return 0; }\n\n      static constexpr char\n      round_error() noexcept { return 0; }\n\n      static constexpr int min_exponent = 0;'
[#] parse_declaration, is_constructor=False, meet line: 'char\n      epsilon() noexcept { return 0; }\n\n      static constexpr char\n      round_error() noexcept { return 0; }\n\n      static constexpr int min_exponent = 0;\n      static constexpr int min_exponen'
[#] parse_declaration, is_constructor=False, meet line: 'char\n      round_error() noexcept { return 0; }\n\n      static constexpr int min_exponent = 0;\n      static constexpr int min_exponent10 = 0;\n      static constexpr int max_exponent = 0;\n      static c'
[#] parse_declaration, is_constructor=False, meet line: 'int min_exponent = 0;\n      static constexpr int min_exponent10 = 0;\n      static constexpr int max_exponent = 0;\n      static constexpr int max_exponent10 = 0;\n\n      static constexpr bool has_infini'
[#] parse_declaration, is_constructor=False, meet line: 'int min_exponent10 = 0;\n      static constexpr int max_exponent = 0;\n      static constexpr int max_exponent10 = 0;\n\n      static constexpr bool has_infinity = false;\n      static constexpr bool has_q'
[#] parse_declaration, is_constructor=False, meet line: 'int max_exponent = 0;\n      static constexpr int max_exponent10 = 0;\n\n      static constexpr bool has_infinity = false;\n      static constexpr bool has_quiet_NaN = false;\n      static constexpr bool h'
[#] parse_declaration, is_constructor=False, meet line: 'int max_exponent10 = 0;\n\n      static constexpr bool has_infinity = false;\n      static constexpr bool has_quiet_NaN = false;\n      static constexpr bool has_signaling_NaN = false;\n      static conste'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_infinity = false;\n      static constexpr bool has_quiet_NaN = false;\n      static constexpr bool has_signaling_NaN = false;\n      static constexpr float_denorm_style has_denorm\n       = denor'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_quiet_NaN = false;\n      static constexpr bool has_signaling_NaN = false;\n      static constexpr float_denorm_style has_denorm\n       = denorm_absent;\n      static constexpr bool has_denorm_l'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_signaling_NaN = false;\n      static constexpr float_denorm_style has_denorm\n       = denorm_absent;\n      static constexpr bool has_denorm_loss = false;\n\n      static constexpr\n      char inf'
[#] parse_declaration, is_constructor=False, meet line: 'float_denorm_style has_denorm\n       = denorm_absent;\n      static constexpr bool has_denorm_loss = false;\n\n      static constexpr\n      char infinity() noexcept { return char(); }\n\n      static const'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_denorm_loss = false;\n\n      static constexpr\n      char infinity() noexcept { return char(); }\n\n      static constexpr char\n      quiet_NaN() noexcept { return char(); }\n\n      static constex'
[#] parse_declaration, is_constructor=False, meet line: 'char infinity() noexcept { return char(); }\n\n      static constexpr char\n      quiet_NaN() noexcept { return char(); }\n\n      static constexpr char\n      signaling_NaN() noexcept { return char(); }\n\n '
[#] parse_declaration, is_constructor=False, meet line: 'char\n      quiet_NaN() noexcept { return char(); }\n\n      static constexpr char\n      signaling_NaN() noexcept { return char(); }\n\n      static constexpr char\n      denorm_min() noexcept { return stat'
[#] parse_declaration, is_constructor=False, meet line: 'char\n      signaling_NaN() noexcept { return char(); }\n\n      static constexpr char\n      denorm_min() noexcept { return static_cast<char>(0); }\n\n      static constexpr bool is_iec559 = false;\n      s'
[#] parse_declaration, is_constructor=False, meet line: 'char\n      denorm_min() noexcept { return static_cast<char>(0); }\n\n      static constexpr bool is_iec559 = false;\n      static constexpr bool is_bounded = true;\n      static constexpr bool is_modulo ='
[#] parse_declaration, is_constructor=False, meet line: 'bool is_iec559 = false;\n      static constexpr bool is_bounded = true;\n      static constexpr bool is_modulo = !is_signed;\n\n      static constexpr bool traps = true;\n      static constexpr bool tinyne'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_bounded = true;\n      static constexpr bool is_modulo = !is_signed;\n\n      static constexpr bool traps = true;\n      static constexpr bool tinyness_before = false;\n      static constexpr float'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_modulo = !is_signed;\n\n      static constexpr bool traps = true;\n      static constexpr bool tinyness_before = false;\n      static constexpr float_round_style round_style\n       = round_toward_'
[#] parse_declaration, is_constructor=False, meet line: 'bool traps = true;\n      static constexpr bool tinyness_before = false;\n      static constexpr float_round_style round_style\n       = round_toward_zero;\n    };\n\n\n  template<>\n    struct numeric_limits'
[#] parse_declaration, is_constructor=False, meet line: 'bool tinyness_before = false;\n      static constexpr float_round_style round_style\n       = round_toward_zero;\n    };\n\n\n  template<>\n    struct numeric_limits<signed char>\n    {\n      static constexpr'
[#] parse_declaration, is_constructor=False, meet line: 'float_round_style round_style\n       = round_toward_zero;\n    };\n\n\n  template<>\n    struct numeric_limits<signed char>\n    {\n      static constexpr bool is_specialized = true;\n\n      static constexpr '
[#] parse_declaration, is_constructor=False, meet line: 'bool is_specialized = true;\n\n      static constexpr signed char\n      min() noexcept { return -0x7f - 1; }\n\n      static constexpr signed char\n      max() noexcept { return 0x7f; }\n\n\n      static cons'
[#] parse_declaration, is_constructor=False, meet line: 'signed char\n      min() noexcept { return -0x7f - 1; }\n\n      static constexpr signed char\n      max() noexcept { return 0x7f; }\n\n\n      static constexpr signed char\n      lowest() noexcept { return m'
[#] parse_declaration, is_constructor=False, meet line: 'signed char\n      max() noexcept { return 0x7f; }\n\n\n      static constexpr signed char\n      lowest() noexcept { return min(); }\n\n\n      static constexpr int digits = (sizeof(signed char) * 8 - ((sign'
[#] parse_declaration, is_constructor=False, meet line: 'signed char\n      lowest() noexcept { return min(); }\n\n\n      static constexpr int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));\n      static constexpr int digits10\n       = ((sizeof(s'
[#] parse_declaration, is_constructor=False, meet line: 'int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));\n      static constexpr int digits10\n       = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643L / 2136);\n\n      static conste'
[#] parse_declaration, is_constructor=False, meet line: 'int digits10\n       = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643L / 2136);\n\n      static constexpr int max_digits10 = 0;\n\n      static constexpr bool is_signed = true;\n      static con'
[#] parse_declaration, is_constructor=False, meet line: 'int max_digits10 = 0;\n\n      static constexpr bool is_signed = true;\n      static constexpr bool is_integer = true;\n      static constexpr bool is_exact = true;\n      static constexpr int radix = 2;\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_signed = true;\n      static constexpr bool is_integer = true;\n      static constexpr bool is_exact = true;\n      static constexpr int radix = 2;\n\n      static constexpr signed char\n      epsil'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_integer = true;\n      static constexpr bool is_exact = true;\n      static constexpr int radix = 2;\n\n      static constexpr signed char\n      epsilon() noexcept { return 0; }\n\n      static cons'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_exact = true;\n      static constexpr int radix = 2;\n\n      static constexpr signed char\n      epsilon() noexcept { return 0; }\n\n      static constexpr signed char\n      round_error() noexcept '
[#] parse_declaration, is_constructor=False, meet line: 'int radix = 2;\n\n      static constexpr signed char\n      epsilon() noexcept { return 0; }\n\n      static constexpr signed char\n      round_error() noexcept { return 0; }\n\n      static constexpr int min'
[#] parse_declaration, is_constructor=False, meet line: 'signed char\n      epsilon() noexcept { return 0; }\n\n      static constexpr signed char\n      round_error() noexcept { return 0; }\n\n      static constexpr int min_exponent = 0;\n      static constexpr i'
[#] parse_declaration, is_constructor=False, meet line: 'signed char\n      round_error() noexcept { return 0; }\n\n      static constexpr int min_exponent = 0;\n      static constexpr int min_exponent10 = 0;\n      static constexpr int max_exponent = 0;\n      s'
[#] parse_declaration, is_constructor=False, meet line: 'int min_exponent = 0;\n      static constexpr int min_exponent10 = 0;\n      static constexpr int max_exponent = 0;\n      static constexpr int max_exponent10 = 0;\n\n      static constexpr bool has_infini'
[#] parse_declaration, is_constructor=False, meet line: 'int min_exponent10 = 0;\n      static constexpr int max_exponent = 0;\n      static constexpr int max_exponent10 = 0;\n\n      static constexpr bool has_infinity = false;\n      static constexpr bool has_q'
[#] parse_declaration, is_constructor=False, meet line: 'int max_exponent = 0;\n      static constexpr int max_exponent10 = 0;\n\n      static constexpr bool has_infinity = false;\n      static constexpr bool has_quiet_NaN = false;\n      static constexpr bool h'
[#] parse_declaration, is_constructor=False, meet line: 'int max_exponent10 = 0;\n\n      static constexpr bool has_infinity = false;\n      static constexpr bool has_quiet_NaN = false;\n      static constexpr bool has_signaling_NaN = false;\n      static conste'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_infinity = false;\n      static constexpr bool has_quiet_NaN = false;\n      static constexpr bool has_signaling_NaN = false;\n      static constexpr float_denorm_style has_denorm\n       = denor'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_quiet_NaN = false;\n      static constexpr bool has_signaling_NaN = false;\n      static constexpr float_denorm_style has_denorm\n       = denorm_absent;\n      static constexpr bool has_denorm_l'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_signaling_NaN = false;\n      static constexpr float_denorm_style has_denorm\n       = denorm_absent;\n      static constexpr bool has_denorm_loss = false;\n\n      static constexpr signed char\n  '
[#] parse_declaration, is_constructor=False, meet line: 'float_denorm_style has_denorm\n       = denorm_absent;\n      static constexpr bool has_denorm_loss = false;\n\n      static constexpr signed char\n      infinity() noexcept { return static_cast<signed cha'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_denorm_loss = false;\n\n      static constexpr signed char\n      infinity() noexcept { return static_cast<signed char>(0); }\n\n      static constexpr signed char\n      quiet_NaN() noexcept { ret'
[#] parse_declaration, is_constructor=False, meet line: 'signed char\n      infinity() noexcept { return static_cast<signed char>(0); }\n\n      static constexpr signed char\n      quiet_NaN() noexcept { return static_cast<signed char>(0); }\n\n      static const'
[#] parse_declaration, is_constructor=False, meet line: 'signed char\n      quiet_NaN() noexcept { return static_cast<signed char>(0); }\n\n      static constexpr signed char\n      signaling_NaN() noexcept\n      { return static_cast<signed char>(0); }\n\n      s'
[#] parse_declaration, is_constructor=False, meet line: 'signed char\n      signaling_NaN() noexcept\n      { return static_cast<signed char>(0); }\n\n      static constexpr signed char\n      denorm_min() noexcept\n      { return static_cast<signed char>(0); }\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'signed char\n      denorm_min() noexcept\n      { return static_cast<signed char>(0); }\n\n      static constexpr bool is_iec559 = false;\n      static constexpr bool is_bounded = true;\n      static conste'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_iec559 = false;\n      static constexpr bool is_bounded = true;\n      static constexpr bool is_modulo = false;\n\n      static constexpr bool traps = true;\n      static constexpr bool tinyness_be'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_bounded = true;\n      static constexpr bool is_modulo = false;\n\n      static constexpr bool traps = true;\n      static constexpr bool tinyness_before = false;\n      static constexpr float_roun'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_modulo = false;\n\n      static constexpr bool traps = true;\n      static constexpr bool tinyness_before = false;\n      static constexpr float_round_style round_style\n       = round_toward_zero;'
[#] parse_declaration, is_constructor=False, meet line: 'bool traps = true;\n      static constexpr bool tinyness_before = false;\n      static constexpr float_round_style round_style\n       = round_toward_zero;\n    };\n\n\n  template<>\n    struct numeric_limits'
[#] parse_declaration, is_constructor=False, meet line: 'bool tinyness_before = false;\n      static constexpr float_round_style round_style\n       = round_toward_zero;\n    };\n\n\n  template<>\n    struct numeric_limits<unsigned char>\n    {\n      static constex'
[#] parse_declaration, is_constructor=False, meet line: 'float_round_style round_style\n       = round_toward_zero;\n    };\n\n\n  template<>\n    struct numeric_limits<unsigned char>\n    {\n      static constexpr bool is_specialized = true;\n\n      static constexp'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_specialized = true;\n\n      static constexpr unsigned char\n      min() noexcept { return 0; }\n\n      static constexpr unsigned char\n      max() noexcept { return 0x7f * 2U + 1; }\n\n\n      static'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned char\n      min() noexcept { return 0; }\n\n      static constexpr unsigned char\n      max() noexcept { return 0x7f * 2U + 1; }\n\n\n      static constexpr unsigned char\n      lowest() noexcept { r'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned char\n      max() noexcept { return 0x7f * 2U + 1; }\n\n\n      static constexpr unsigned char\n      lowest() noexcept { return min(); }\n\n\n      static constexpr int digits\n       = (sizeof(unsig'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned char\n      lowest() noexcept { return min(); }\n\n\n      static constexpr int digits\n       = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));\n      static constexpr int digits10\n      '
[#] parse_declaration, is_constructor=False, meet line: 'int digits\n       = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));\n      static constexpr int digits10\n       = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643L / 2136);\n\n    '
[#] parse_declaration, is_constructor=False, meet line: 'int digits10\n       = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643L / 2136);\n\n      static constexpr int max_digits10 = 0;\n\n      static constexpr bool is_signed = false;\n      stati'
[#] parse_declaration, is_constructor=False, meet line: 'int max_digits10 = 0;\n\n      static constexpr bool is_signed = false;\n      static constexpr bool is_integer = true;\n      static constexpr bool is_exact = true;\n      static constexpr int radix = 2;\n'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_signed = false;\n      static constexpr bool is_integer = true;\n      static constexpr bool is_exact = true;\n      static constexpr int radix = 2;\n\n      static constexpr unsigned char\n      ep'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_integer = true;\n      static constexpr bool is_exact = true;\n      static constexpr int radix = 2;\n\n      static constexpr unsigned char\n      epsilon() noexcept { return 0; }\n\n      static co'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_exact = true;\n      static constexpr int radix = 2;\n\n      static constexpr unsigned char\n      epsilon() noexcept { return 0; }\n\n      static constexpr unsigned char\n      round_error() noexc'
[#] parse_declaration, is_constructor=False, meet line: 'int radix = 2;\n\n      static constexpr unsigned char\n      epsilon() noexcept { return 0; }\n\n      static constexpr unsigned char\n      round_error() noexcept { return 0; }\n\n      static constexpr int'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned char\n      epsilon() noexcept { return 0; }\n\n      static constexpr unsigned char\n      round_error() noexcept { return 0; }\n\n      static constexpr int min_exponent = 0;\n      static constex'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned char\n      round_error() noexcept { return 0; }\n\n      static constexpr int min_exponent = 0;\n      static constexpr int min_exponent10 = 0;\n      static constexpr int max_exponent = 0;\n     '
[#] parse_declaration, is_constructor=False, meet line: 'int min_exponent = 0;\n      static constexpr int min_exponent10 = 0;\n      static constexpr int max_exponent = 0;\n      static constexpr int max_exponent10 = 0;\n\n      static constexpr bool has_infini'
[#] parse_declaration, is_constructor=False, meet line: 'int min_exponent10 = 0;\n      static constexpr int max_exponent = 0;\n      static constexpr int max_exponent10 = 0;\n\n      static constexpr bool has_infinity = false;\n      static constexpr bool has_q'
[#] parse_declaration, is_constructor=False, meet line: 'int max_exponent = 0;\n      static constexpr int max_exponent10 = 0;\n\n      static constexpr bool has_infinity = false;\n      static constexpr bool has_quiet_NaN = false;\n      static constexpr bool h'
[#] parse_declaration, is_constructor=False, meet line: 'int max_exponent10 = 0;\n\n      static constexpr bool has_infinity = false;\n      static constexpr bool has_quiet_NaN = false;\n      static constexpr bool has_signaling_NaN = false;\n      static conste'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_infinity = false;\n      static constexpr bool has_quiet_NaN = false;\n      static constexpr bool has_signaling_NaN = false;\n      static constexpr float_denorm_style has_denorm\n       = denor'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_quiet_NaN = false;\n      static constexpr bool has_signaling_NaN = false;\n      static constexpr float_denorm_style has_denorm\n       = denorm_absent;\n      static constexpr bool has_denorm_l'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_signaling_NaN = false;\n      static constexpr float_denorm_style has_denorm\n       = denorm_absent;\n      static constexpr bool has_denorm_loss = false;\n\n      static constexpr unsigned char\n'
[#] parse_declaration, is_constructor=False, meet line: 'float_denorm_style has_denorm\n       = denorm_absent;\n      static constexpr bool has_denorm_loss = false;\n\n      static constexpr unsigned char\n      infinity() noexcept\n      { return static_cast<un'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_denorm_loss = false;\n\n      static constexpr unsigned char\n      infinity() noexcept\n      { return static_cast<unsigned char>(0); }\n\n      static constexpr unsigned char\n      quiet_NaN() no'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned char\n      infinity() noexcept\n      { return static_cast<unsigned char>(0); }\n\n      static constexpr unsigned char\n      quiet_NaN() noexcept\n      { return static_cast<unsigned char>(0); }'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned char\n      quiet_NaN() noexcept\n      { return static_cast<unsigned char>(0); }\n\n      static constexpr unsigned char\n      signaling_NaN() noexcept\n      { return static_cast<unsigned char>('
[#] parse_declaration, is_constructor=False, meet line: 'unsigned char\n      signaling_NaN() noexcept\n      { return static_cast<unsigned char>(0); }\n\n      static constexpr unsigned char\n      denorm_min() noexcept\n      { return static_cast<unsigned char>'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned char\n      denorm_min() noexcept\n      { return static_cast<unsigned char>(0); }\n\n      static constexpr bool is_iec559 = false;\n      static constexpr bool is_bounded = true;\n      static co'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_iec559 = false;\n      static constexpr bool is_bounded = true;\n      static constexpr bool is_modulo = true;\n\n      static constexpr bool traps = true;\n      static constexpr bool tinyness_bef'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_bounded = true;\n      static constexpr bool is_modulo = true;\n\n      static constexpr bool traps = true;\n      static constexpr bool tinyness_before = false;\n      static constexpr float_round'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_modulo = true;\n\n      static constexpr bool traps = true;\n      static constexpr bool tinyness_before = false;\n      static constexpr float_round_style round_style\n       = round_toward_zero;\n'
[#] parse_declaration, is_constructor=False, meet line: 'bool traps = true;\n      static constexpr bool tinyness_before = false;\n      static constexpr float_round_style round_style\n       = round_toward_zero;\n    };\n\n\n  template<>\n    struct numeric_limits'
[#] parse_declaration, is_constructor=False, meet line: 'bool tinyness_before = false;\n      static constexpr float_round_style round_style\n       = round_toward_zero;\n    };\n\n\n  template<>\n    struct numeric_limits<wchar_t>\n    {\n      static constexpr boo'
[#] parse_declaration, is_constructor=False, meet line: 'float_round_style round_style\n       = round_toward_zero;\n    };\n\n\n  template<>\n    struct numeric_limits<wchar_t>\n    {\n      static constexpr bool is_specialized = true;\n\n      static constexpr wcha'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_specialized = true;\n\n      static constexpr wchar_t\n      min() noexcept { return (((wchar_t)(-1) < 0) ? -(((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) '
[#] parse_declaration, is_constructor=False, meet line: 'wchar_t\n      min() noexcept { return (((wchar_t)(-1) < 0) ? -(((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0) - 1 : (wchar_t)'
[#] parse_declaration, is_constructor=False, meet line: 'wchar_t\n      max() noexcept { return (((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0); }\n\n\n      static constexpr wchar_t\n   '
[#] parse_declaration, is_constructor=False, meet line: 'wchar_t\n      lowest() noexcept { return min(); }\n\n\n      static constexpr int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));\n      static constexpr int digits10\n       = ((sizeof(wchar_t) * 8 '
[#] parse_declaration, is_constructor=False, meet line: 'int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));\n      static constexpr int digits10\n       = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643L / 2136);\n\n      static constexpr int max_digi'
[#] parse_declaration, is_constructor=False, meet line: 'int digits10\n       = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643L / 2136);\n\n      static constexpr int max_digits10 = 0;\n\n      static constexpr bool is_signed = ((wchar_t)(-1) < 0);\n      sta'
[#] parse_declaration, is_constructor=False, meet line: 'int max_digits10 = 0;\n\n      static constexpr bool is_signed = ((wchar_t)(-1) < 0);\n      static constexpr bool is_integer = true;\n      static constexpr bool is_exact = true;\n      static constexpr i'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_signed = ((wchar_t)(-1) < 0);\n      static constexpr bool is_integer = true;\n      static constexpr bool is_exact = true;\n      static constexpr int radix = 2;\n\n      static constexpr wchar_t\n'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_integer = true;\n      static constexpr bool is_exact = true;\n      static constexpr int radix = 2;\n\n      static constexpr wchar_t\n      epsilon() noexcept { return 0; }\n\n      static constexp'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_exact = true;\n      static constexpr int radix = 2;\n\n      static constexpr wchar_t\n      epsilon() noexcept { return 0; }\n\n      static constexpr wchar_t\n      round_error() noexcept { return'
[#] parse_declaration, is_constructor=False, meet line: 'int radix = 2;\n\n      static constexpr wchar_t\n      epsilon() noexcept { return 0; }\n\n      static constexpr wchar_t\n      round_error() noexcept { return 0; }\n\n      static constexpr int min_exponen'
[#] parse_declaration, is_constructor=False, meet line: 'wchar_t\n      epsilon() noexcept { return 0; }\n\n      static constexpr wchar_t\n      round_error() noexcept { return 0; }\n\n      static constexpr int min_exponent = 0;\n      static constexpr int min_e'
[#] parse_declaration, is_constructor=False, meet line: 'wchar_t\n      round_error() noexcept { return 0; }\n\n      static constexpr int min_exponent = 0;\n      static constexpr int min_exponent10 = 0;\n      static constexpr int max_exponent = 0;\n      stati'
[#] parse_declaration, is_constructor=False, meet line: 'int min_exponent = 0;\n      static constexpr int min_exponent10 = 0;\n      static constexpr int max_exponent = 0;\n      static constexpr int max_exponent10 = 0;\n\n      static constexpr bool has_infini'
[#] parse_declaration, is_constructor=False, meet line: 'int min_exponent10 = 0;\n      static constexpr int max_exponent = 0;\n      static constexpr int max_exponent10 = 0;\n\n      static constexpr bool has_infinity = false;\n      static constexpr bool has_q'
[#] parse_declaration, is_constructor=False, meet line: 'int max_exponent = 0;\n      static constexpr int max_exponent10 = 0;\n\n      static constexpr bool has_infinity = false;\n      static constexpr bool has_quiet_NaN = false;\n      static constexpr bool h'
[#] parse_declaration, is_constructor=False, meet line: 'int max_exponent10 = 0;\n\n      static constexpr bool has_infinity = false;\n      static constexpr bool has_quiet_NaN = false;\n      static constexpr bool has_signaling_NaN = false;\n      static conste'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_infinity = false;\n      static constexpr bool has_quiet_NaN = false;\n      static constexpr bool has_signaling_NaN = false;\n      static constexpr float_denorm_style has_denorm\n       = denor'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_quiet_NaN = false;\n      static constexpr bool has_signaling_NaN = false;\n      static constexpr float_denorm_style has_denorm\n       = denorm_absent;\n      static constexpr bool has_denorm_l'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_signaling_NaN = false;\n      static constexpr float_denorm_style has_denorm\n       = denorm_absent;\n      static constexpr bool has_denorm_loss = false;\n\n      static constexpr wchar_t\n      '
[#] parse_declaration, is_constructor=False, meet line: 'float_denorm_style has_denorm\n       = denorm_absent;\n      static constexpr bool has_denorm_loss = false;\n\n      static constexpr wchar_t\n      infinity() noexcept { return wchar_t(); }\n\n      static'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_denorm_loss = false;\n\n      static constexpr wchar_t\n      infinity() noexcept { return wchar_t(); }\n\n      static constexpr wchar_t\n      quiet_NaN() noexcept { return wchar_t(); }\n\n      st'
[#] parse_declaration, is_constructor=False, meet line: 'wchar_t\n      infinity() noexcept { return wchar_t(); }\n\n      static constexpr wchar_t\n      quiet_NaN() noexcept { return wchar_t(); }\n\n      static constexpr wchar_t\n      signaling_NaN() noexcept '
[#] parse_declaration, is_constructor=False, meet line: 'wchar_t\n      quiet_NaN() noexcept { return wchar_t(); }\n\n      static constexpr wchar_t\n      signaling_NaN() noexcept { return wchar_t(); }\n\n      static constexpr wchar_t\n      denorm_min() noexcep'
[#] parse_declaration, is_constructor=False, meet line: 'wchar_t\n      signaling_NaN() noexcept { return wchar_t(); }\n\n      static constexpr wchar_t\n      denorm_min() noexcept { return wchar_t(); }\n\n      static constexpr bool is_iec559 = false;\n      sta'
[#] parse_declaration, is_constructor=False, meet line: 'wchar_t\n      denorm_min() noexcept { return wchar_t(); }\n\n      static constexpr bool is_iec559 = false;\n      static constexpr bool is_bounded = true;\n      static constexpr bool is_modulo = !is_sig'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_iec559 = false;\n      static constexpr bool is_bounded = true;\n      static constexpr bool is_modulo = !is_signed;\n\n      static constexpr bool traps = true;\n      static constexpr bool tinyne'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_bounded = true;\n      static constexpr bool is_modulo = !is_signed;\n\n      static constexpr bool traps = true;\n      static constexpr bool tinyness_before = false;\n      static constexpr float'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_modulo = !is_signed;\n\n      static constexpr bool traps = true;\n      static constexpr bool tinyness_before = false;\n      static constexpr float_round_style round_style\n       = round_toward_'
[#] parse_declaration, is_constructor=False, meet line: 'bool traps = true;\n      static constexpr bool tinyness_before = false;\n      static constexpr float_round_style round_style\n       = round_toward_zero;\n    };\n\n\n\n  template<>\n    struct numeric_limit'
[#] parse_declaration, is_constructor=False, meet line: 'bool tinyness_before = false;\n      static constexpr float_round_style round_style\n       = round_toward_zero;\n    };\n\n\n\n  template<>\n    struct numeric_limits<char16_t>\n    {\n      static constexpr b'
[#] parse_declaration, is_constructor=False, meet line: 'float_round_style round_style\n       = round_toward_zero;\n    };\n\n\n\n  template<>\n    struct numeric_limits<char16_t>\n    {\n      static constexpr bool is_specialized = true;\n\n      static constexpr ch'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_specialized = true;\n\n      static constexpr char16_t\n      min() noexcept { return (((char16_t)(-1) < 0) ? -(((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) '
[#] parse_declaration, is_constructor=False, meet line: 'char16_t\n      min() noexcept { return (((char16_t)(-1) < 0) ? -(((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0) - 1 : (c'
[#] parse_declaration, is_constructor=False, meet line: 'char16_t\n      max() noexcept { return (((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0); }\n\n      static constexpr char16'
[#] parse_declaration, is_constructor=False, meet line: 'char16_t\n      lowest() noexcept { return min(); }\n\n      static constexpr int digits = (sizeof(char16_t) * 8 - ((char16_t)(-1) < 0));\n      static constexpr int digits10 = ((sizeof(char16_t) * 8 - (('
[#] parse_declaration, is_constructor=False, meet line: 'int digits = (sizeof(char16_t) * 8 - ((char16_t)(-1) < 0));\n      static constexpr int digits10 = ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) * 643L / 2136);\n      static constexpr int max_digits10'
[#] parse_declaration, is_constructor=False, meet line: 'int digits10 = ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) * 643L / 2136);\n      static constexpr int max_digits10 = 0;\n      static constexpr bool is_signed = ((char16_t)(-1) < 0);\n      static co'
[#] parse_declaration, is_constructor=False, meet line: 'int max_digits10 = 0;\n      static constexpr bool is_signed = ((char16_t)(-1) < 0);\n      static constexpr bool is_integer = true;\n      static constexpr bool is_exact = true;\n      static constexpr i'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_signed = ((char16_t)(-1) < 0);\n      static constexpr bool is_integer = true;\n      static constexpr bool is_exact = true;\n      static constexpr int radix = 2;\n\n      static constexpr char16_'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_integer = true;\n      static constexpr bool is_exact = true;\n      static constexpr int radix = 2;\n\n      static constexpr char16_t\n      epsilon() noexcept { return 0; }\n\n      static constex'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_exact = true;\n      static constexpr int radix = 2;\n\n      static constexpr char16_t\n      epsilon() noexcept { return 0; }\n\n      static constexpr char16_t\n      round_error() noexcept { retu'
[#] parse_declaration, is_constructor=False, meet line: 'int radix = 2;\n\n      static constexpr char16_t\n      epsilon() noexcept { return 0; }\n\n      static constexpr char16_t\n      round_error() noexcept { return 0; }\n\n      static constexpr int min_expon'
[#] parse_declaration, is_constructor=False, meet line: 'char16_t\n      epsilon() noexcept { return 0; }\n\n      static constexpr char16_t\n      round_error() noexcept { return 0; }\n\n      static constexpr int min_exponent = 0;\n      static constexpr int min'
[#] parse_declaration, is_constructor=False, meet line: 'char16_t\n      round_error() noexcept { return 0; }\n\n      static constexpr int min_exponent = 0;\n      static constexpr int min_exponent10 = 0;\n      static constexpr int max_exponent = 0;\n      stat'
[#] parse_declaration, is_constructor=False, meet line: 'int min_exponent = 0;\n      static constexpr int min_exponent10 = 0;\n      static constexpr int max_exponent = 0;\n      static constexpr int max_exponent10 = 0;\n\n      static constexpr bool has_infini'
[#] parse_declaration, is_constructor=False, meet line: 'int min_exponent10 = 0;\n      static constexpr int max_exponent = 0;\n      static constexpr int max_exponent10 = 0;\n\n      static constexpr bool has_infinity = false;\n      static constexpr bool has_q'
[#] parse_declaration, is_constructor=False, meet line: 'int max_exponent = 0;\n      static constexpr int max_exponent10 = 0;\n\n      static constexpr bool has_infinity = false;\n      static constexpr bool has_quiet_NaN = false;\n      static constexpr bool h'
[#] parse_declaration, is_constructor=False, meet line: 'int max_exponent10 = 0;\n\n      static constexpr bool has_infinity = false;\n      static constexpr bool has_quiet_NaN = false;\n      static constexpr bool has_signaling_NaN = false;\n      static conste'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_infinity = false;\n      static constexpr bool has_quiet_NaN = false;\n      static constexpr bool has_signaling_NaN = false;\n      static constexpr float_denorm_style has_denorm = denorm_absen'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_quiet_NaN = false;\n      static constexpr bool has_signaling_NaN = false;\n      static constexpr float_denorm_style has_denorm = denorm_absent;\n      static constexpr bool has_denorm_loss = f'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_signaling_NaN = false;\n      static constexpr float_denorm_style has_denorm = denorm_absent;\n      static constexpr bool has_denorm_loss = false;\n\n      static constexpr char16_t\n      infini'
[#] parse_declaration, is_constructor=False, meet line: 'float_denorm_style has_denorm = denorm_absent;\n      static constexpr bool has_denorm_loss = false;\n\n      static constexpr char16_t\n      infinity() noexcept { return char16_t(); }\n\n      static cons'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_denorm_loss = false;\n\n      static constexpr char16_t\n      infinity() noexcept { return char16_t(); }\n\n      static constexpr char16_t\n      quiet_NaN() noexcept { return char16_t(); }\n\n    '
[#] parse_declaration, is_constructor=False, meet line: 'char16_t\n      infinity() noexcept { return char16_t(); }\n\n      static constexpr char16_t\n      quiet_NaN() noexcept { return char16_t(); }\n\n      static constexpr char16_t\n      signaling_NaN() noex'
[#] parse_declaration, is_constructor=False, meet line: 'char16_t\n      quiet_NaN() noexcept { return char16_t(); }\n\n      static constexpr char16_t\n      signaling_NaN() noexcept { return char16_t(); }\n\n      static constexpr char16_t\n      denorm_min() no'
[#] parse_declaration, is_constructor=False, meet line: 'char16_t\n      signaling_NaN() noexcept { return char16_t(); }\n\n      static constexpr char16_t\n      denorm_min() noexcept { return char16_t(); }\n\n      static constexpr bool is_iec559 = false;\n     '
[#] parse_declaration, is_constructor=False, meet line: 'char16_t\n      denorm_min() noexcept { return char16_t(); }\n\n      static constexpr bool is_iec559 = false;\n      static constexpr bool is_bounded = true;\n      static constexpr bool is_modulo = !is_s'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_iec559 = false;\n      static constexpr bool is_bounded = true;\n      static constexpr bool is_modulo = !is_signed;\n\n      static constexpr bool traps = true;\n      static constexpr bool tinyne'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_bounded = true;\n      static constexpr bool is_modulo = !is_signed;\n\n      static constexpr bool traps = true;\n      static constexpr bool tinyness_before = false;\n      static constexpr float'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_modulo = !is_signed;\n\n      static constexpr bool traps = true;\n      static constexpr bool tinyness_before = false;\n      static constexpr float_round_style round_style = round_toward_zero;\n '
[#] parse_declaration, is_constructor=False, meet line: 'bool traps = true;\n      static constexpr bool tinyness_before = false;\n      static constexpr float_round_style round_style = round_toward_zero;\n    };\n\n\n  template<>\n    struct numeric_limits<char32'
[#] parse_declaration, is_constructor=False, meet line: 'bool tinyness_before = false;\n      static constexpr float_round_style round_style = round_toward_zero;\n    };\n\n\n  template<>\n    struct numeric_limits<char32_t>\n    {\n      static constexpr bool is_s'
[#] parse_declaration, is_constructor=False, meet line: 'float_round_style round_style = round_toward_zero;\n    };\n\n\n  template<>\n    struct numeric_limits<char32_t>\n    {\n      static constexpr bool is_specialized = true;\n\n      static constexpr char32_t\n '
[#] parse_declaration, is_constructor=False, meet line: 'bool is_specialized = true;\n\n      static constexpr char32_t\n      min() noexcept { return (((char32_t)(-1) < 0) ? -(((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) '
[#] parse_declaration, is_constructor=False, meet line: 'char32_t\n      min() noexcept { return (((char32_t)(-1) < 0) ? -(((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0) - 1 : (c'
[#] parse_declaration, is_constructor=False, meet line: 'char32_t\n      max() noexcept { return (((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0); }\n\n      static constexpr char32'
[#] parse_declaration, is_constructor=False, meet line: 'char32_t\n      lowest() noexcept { return min(); }\n\n      static constexpr int digits = (sizeof(char32_t) * 8 - ((char32_t)(-1) < 0));\n      static constexpr int digits10 = ((sizeof(char32_t) * 8 - (('
[#] parse_declaration, is_constructor=False, meet line: 'int digits = (sizeof(char32_t) * 8 - ((char32_t)(-1) < 0));\n      static constexpr int digits10 = ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) * 643L / 2136);\n      static constexpr int max_digits10'
[#] parse_declaration, is_constructor=False, meet line: 'int digits10 = ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) * 643L / 2136);\n      static constexpr int max_digits10 = 0;\n      static constexpr bool is_signed = ((char32_t)(-1) < 0);\n      static co'
[#] parse_declaration, is_constructor=False, meet line: 'int max_digits10 = 0;\n      static constexpr bool is_signed = ((char32_t)(-1) < 0);\n      static constexpr bool is_integer = true;\n      static constexpr bool is_exact = true;\n      static constexpr i'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_signed = ((char32_t)(-1) < 0);\n      static constexpr bool is_integer = true;\n      static constexpr bool is_exact = true;\n      static constexpr int radix = 2;\n\n      static constexpr char32_'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_integer = true;\n      static constexpr bool is_exact = true;\n      static constexpr int radix = 2;\n\n      static constexpr char32_t\n      epsilon() noexcept { return 0; }\n\n      static constex'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_exact = true;\n      static constexpr int radix = 2;\n\n      static constexpr char32_t\n      epsilon() noexcept { return 0; }\n\n      static constexpr char32_t\n      round_error() noexcept { retu'
[#] parse_declaration, is_constructor=False, meet line: 'int radix = 2;\n\n      static constexpr char32_t\n      epsilon() noexcept { return 0; }\n\n      static constexpr char32_t\n      round_error() noexcept { return 0; }\n\n      static constexpr int min_expon'
[#] parse_declaration, is_constructor=False, meet line: 'char32_t\n      epsilon() noexcept { return 0; }\n\n      static constexpr char32_t\n      round_error() noexcept { return 0; }\n\n      static constexpr int min_exponent = 0;\n      static constexpr int min'
[#] parse_declaration, is_constructor=False, meet line: 'char32_t\n      round_error() noexcept { return 0; }\n\n      static constexpr int min_exponent = 0;\n      static constexpr int min_exponent10 = 0;\n      static constexpr int max_exponent = 0;\n      stat'
[#] parse_declaration, is_constructor=False, meet line: 'int min_exponent = 0;\n      static constexpr int min_exponent10 = 0;\n      static constexpr int max_exponent = 0;\n      static constexpr int max_exponent10 = 0;\n\n      static constexpr bool has_infini'
[#] parse_declaration, is_constructor=False, meet line: 'int min_exponent10 = 0;\n      static constexpr int max_exponent = 0;\n      static constexpr int max_exponent10 = 0;\n\n      static constexpr bool has_infinity = false;\n      static constexpr bool has_q'
[#] parse_declaration, is_constructor=False, meet line: 'int max_exponent = 0;\n      static constexpr int max_exponent10 = 0;\n\n      static constexpr bool has_infinity = false;\n      static constexpr bool has_quiet_NaN = false;\n      static constexpr bool h'
[#] parse_declaration, is_constructor=False, meet line: 'int max_exponent10 = 0;\n\n      static constexpr bool has_infinity = false;\n      static constexpr bool has_quiet_NaN = false;\n      static constexpr bool has_signaling_NaN = false;\n      static conste'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_infinity = false;\n      static constexpr bool has_quiet_NaN = false;\n      static constexpr bool has_signaling_NaN = false;\n      static constexpr float_denorm_style has_denorm = denorm_absen'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_quiet_NaN = false;\n      static constexpr bool has_signaling_NaN = false;\n      static constexpr float_denorm_style has_denorm = denorm_absent;\n      static constexpr bool has_denorm_loss = f'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_signaling_NaN = false;\n      static constexpr float_denorm_style has_denorm = denorm_absent;\n      static constexpr bool has_denorm_loss = false;\n\n      static constexpr char32_t\n      infini'
[#] parse_declaration, is_constructor=False, meet line: 'float_denorm_style has_denorm = denorm_absent;\n      static constexpr bool has_denorm_loss = false;\n\n      static constexpr char32_t\n      infinity() noexcept { return char32_t(); }\n\n      static cons'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_denorm_loss = false;\n\n      static constexpr char32_t\n      infinity() noexcept { return char32_t(); }\n\n      static constexpr char32_t\n      quiet_NaN() noexcept { return char32_t(); }\n\n    '
[#] parse_declaration, is_constructor=False, meet line: 'char32_t\n      infinity() noexcept { return char32_t(); }\n\n      static constexpr char32_t\n      quiet_NaN() noexcept { return char32_t(); }\n\n      static constexpr char32_t\n      signaling_NaN() noex'
[#] parse_declaration, is_constructor=False, meet line: 'char32_t\n      quiet_NaN() noexcept { return char32_t(); }\n\n      static constexpr char32_t\n      signaling_NaN() noexcept { return char32_t(); }\n\n      static constexpr char32_t\n      denorm_min() no'
[#] parse_declaration, is_constructor=False, meet line: 'char32_t\n      signaling_NaN() noexcept { return char32_t(); }\n\n      static constexpr char32_t\n      denorm_min() noexcept { return char32_t(); }\n\n      static constexpr bool is_iec559 = false;\n     '
[#] parse_declaration, is_constructor=False, meet line: 'char32_t\n      denorm_min() noexcept { return char32_t(); }\n\n      static constexpr bool is_iec559 = false;\n      static constexpr bool is_bounded = true;\n      static constexpr bool is_modulo = !is_s'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_iec559 = false;\n      static constexpr bool is_bounded = true;\n      static constexpr bool is_modulo = !is_signed;\n\n      static constexpr bool traps = true;\n      static constexpr bool tinyne'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_bounded = true;\n      static constexpr bool is_modulo = !is_signed;\n\n      static constexpr bool traps = true;\n      static constexpr bool tinyness_before = false;\n      static constexpr float'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_modulo = !is_signed;\n\n      static constexpr bool traps = true;\n      static constexpr bool tinyness_before = false;\n      static constexpr float_round_style round_style = round_toward_zero;\n '
[#] parse_declaration, is_constructor=False, meet line: 'bool traps = true;\n      static constexpr bool tinyness_before = false;\n      static constexpr float_round_style round_style = round_toward_zero;\n    };\n\n\n\n  template<>\n    struct numeric_limits<short'
[#] parse_declaration, is_constructor=False, meet line: 'bool tinyness_before = false;\n      static constexpr float_round_style round_style = round_toward_zero;\n    };\n\n\n\n  template<>\n    struct numeric_limits<short>\n    {\n      static constexpr bool is_spe'
[#] parse_declaration, is_constructor=False, meet line: 'float_round_style round_style = round_toward_zero;\n    };\n\n\n\n  template<>\n    struct numeric_limits<short>\n    {\n      static constexpr bool is_specialized = true;\n\n      static constexpr short\n      '
[#] parse_declaration, is_constructor=False, meet line: 'bool is_specialized = true;\n\n      static constexpr short\n      min() noexcept { return -0x7fff - 1; }\n\n      static constexpr short\n      max() noexcept { return 0x7fff; }\n\n\n      static constexpr sh'
[#] parse_declaration, is_constructor=False, meet line: 'short\n      min() noexcept { return -0x7fff - 1; }\n\n      static constexpr short\n      max() noexcept { return 0x7fff; }\n\n\n      static constexpr short\n      lowest() noexcept { return min(); }\n\n\n    '
[#] parse_declaration, is_constructor=False, meet line: 'short\n      max() noexcept { return 0x7fff; }\n\n\n      static constexpr short\n      lowest() noexcept { return min(); }\n\n\n      static constexpr int digits = (sizeof(short) * 8 - ((short)(-1) < 0));\n  '
[#] parse_declaration, is_constructor=False, meet line: 'short\n      lowest() noexcept { return min(); }\n\n\n      static constexpr int digits = (sizeof(short) * 8 - ((short)(-1) < 0));\n      static constexpr int digits10 = ((sizeof(short) * 8 - ((short)(-1) '
[#] parse_declaration, is_constructor=False, meet line: 'int digits = (sizeof(short) * 8 - ((short)(-1) < 0));\n      static constexpr int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643L / 2136);\n\n      static constexpr int max_digits10 = 0;\n\n    '
[#] parse_declaration, is_constructor=False, meet line: 'int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643L / 2136);\n\n      static constexpr int max_digits10 = 0;\n\n      static constexpr bool is_signed = true;\n      static constexpr bool is_inte'
[#] parse_declaration, is_constructor=False, meet line: 'int max_digits10 = 0;\n\n      static constexpr bool is_signed = true;\n      static constexpr bool is_integer = true;\n      static constexpr bool is_exact = true;\n      static constexpr int radix = 2;\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_signed = true;\n      static constexpr bool is_integer = true;\n      static constexpr bool is_exact = true;\n      static constexpr int radix = 2;\n\n      static constexpr short\n      epsilon() n'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_integer = true;\n      static constexpr bool is_exact = true;\n      static constexpr int radix = 2;\n\n      static constexpr short\n      epsilon() noexcept { return 0; }\n\n      static constexpr '
[#] parse_declaration, is_constructor=False, meet line: 'bool is_exact = true;\n      static constexpr int radix = 2;\n\n      static constexpr short\n      epsilon() noexcept { return 0; }\n\n      static constexpr short\n      round_error() noexcept { return 0; '
[#] parse_declaration, is_constructor=False, meet line: 'int radix = 2;\n\n      static constexpr short\n      epsilon() noexcept { return 0; }\n\n      static constexpr short\n      round_error() noexcept { return 0; }\n\n      static constexpr int min_exponent = '
[#] parse_declaration, is_constructor=False, meet line: 'short\n      epsilon() noexcept { return 0; }\n\n      static constexpr short\n      round_error() noexcept { return 0; }\n\n      static constexpr int min_exponent = 0;\n      static constexpr int min_expon'
[#] parse_declaration, is_constructor=False, meet line: 'short\n      round_error() noexcept { return 0; }\n\n      static constexpr int min_exponent = 0;\n      static constexpr int min_exponent10 = 0;\n      static constexpr int max_exponent = 0;\n      static '
[#] parse_declaration, is_constructor=False, meet line: 'int min_exponent = 0;\n      static constexpr int min_exponent10 = 0;\n      static constexpr int max_exponent = 0;\n      static constexpr int max_exponent10 = 0;\n\n      static constexpr bool has_infini'
[#] parse_declaration, is_constructor=False, meet line: 'int min_exponent10 = 0;\n      static constexpr int max_exponent = 0;\n      static constexpr int max_exponent10 = 0;\n\n      static constexpr bool has_infinity = false;\n      static constexpr bool has_q'
[#] parse_declaration, is_constructor=False, meet line: 'int max_exponent = 0;\n      static constexpr int max_exponent10 = 0;\n\n      static constexpr bool has_infinity = false;\n      static constexpr bool has_quiet_NaN = false;\n      static constexpr bool h'
[#] parse_declaration, is_constructor=False, meet line: 'int max_exponent10 = 0;\n\n      static constexpr bool has_infinity = false;\n      static constexpr bool has_quiet_NaN = false;\n      static constexpr bool has_signaling_NaN = false;\n      static conste'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_infinity = false;\n      static constexpr bool has_quiet_NaN = false;\n      static constexpr bool has_signaling_NaN = false;\n      static constexpr float_denorm_style has_denorm\n       = denor'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_quiet_NaN = false;\n      static constexpr bool has_signaling_NaN = false;\n      static constexpr float_denorm_style has_denorm\n       = denorm_absent;\n      static constexpr bool has_denorm_l'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_signaling_NaN = false;\n      static constexpr float_denorm_style has_denorm\n       = denorm_absent;\n      static constexpr bool has_denorm_loss = false;\n\n      static constexpr short\n      in'
[#] parse_declaration, is_constructor=False, meet line: 'float_denorm_style has_denorm\n       = denorm_absent;\n      static constexpr bool has_denorm_loss = false;\n\n      static constexpr short\n      infinity() noexcept { return short(); }\n\n      static con'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_denorm_loss = false;\n\n      static constexpr short\n      infinity() noexcept { return short(); }\n\n      static constexpr short\n      quiet_NaN() noexcept { return short(); }\n\n      static con'
[#] parse_declaration, is_constructor=False, meet line: 'short\n      infinity() noexcept { return short(); }\n\n      static constexpr short\n      quiet_NaN() noexcept { return short(); }\n\n      static constexpr short\n      signaling_NaN() noexcept { return s'
[#] parse_declaration, is_constructor=False, meet line: 'short\n      quiet_NaN() noexcept { return short(); }\n\n      static constexpr short\n      signaling_NaN() noexcept { return short(); }\n\n      static constexpr short\n      denorm_min() noexcept { return'
[#] parse_declaration, is_constructor=False, meet line: 'short\n      signaling_NaN() noexcept { return short(); }\n\n      static constexpr short\n      denorm_min() noexcept { return short(); }\n\n      static constexpr bool is_iec559 = false;\n      static cons'
[#] parse_declaration, is_constructor=False, meet line: 'short\n      denorm_min() noexcept { return short(); }\n\n      static constexpr bool is_iec559 = false;\n      static constexpr bool is_bounded = true;\n      static constexpr bool is_modulo = false;\n\n   '
[#] parse_declaration, is_constructor=False, meet line: 'bool is_iec559 = false;\n      static constexpr bool is_bounded = true;\n      static constexpr bool is_modulo = false;\n\n      static constexpr bool traps = true;\n      static constexpr bool tinyness_be'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_bounded = true;\n      static constexpr bool is_modulo = false;\n\n      static constexpr bool traps = true;\n      static constexpr bool tinyness_before = false;\n      static constexpr float_roun'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_modulo = false;\n\n      static constexpr bool traps = true;\n      static constexpr bool tinyness_before = false;\n      static constexpr float_round_style round_style\n       = round_toward_zero;'
[#] parse_declaration, is_constructor=False, meet line: 'bool traps = true;\n      static constexpr bool tinyness_before = false;\n      static constexpr float_round_style round_style\n       = round_toward_zero;\n    };\n\n\n  template<>\n    struct numeric_limits'
[#] parse_declaration, is_constructor=False, meet line: 'bool tinyness_before = false;\n      static constexpr float_round_style round_style\n       = round_toward_zero;\n    };\n\n\n  template<>\n    struct numeric_limits<unsigned short>\n    {\n      static conste'
[#] parse_declaration, is_constructor=False, meet line: 'float_round_style round_style\n       = round_toward_zero;\n    };\n\n\n  template<>\n    struct numeric_limits<unsigned short>\n    {\n      static constexpr bool is_specialized = true;\n\n      static constex'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_specialized = true;\n\n      static constexpr unsigned short\n      min() noexcept { return 0; }\n\n      static constexpr unsigned short\n      max() noexcept { return 0x7fff * 2U + 1; }\n\n\n      st'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned short\n      min() noexcept { return 0; }\n\n      static constexpr unsigned short\n      max() noexcept { return 0x7fff * 2U + 1; }\n\n\n      static constexpr unsigned short\n      lowest() noexcep'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned short\n      max() noexcept { return 0x7fff * 2U + 1; }\n\n\n      static constexpr unsigned short\n      lowest() noexcept { return min(); }\n\n\n      static constexpr int digits\n       = (sizeof(u'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned short\n      lowest() noexcept { return min(); }\n\n\n      static constexpr int digits\n       = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));\n      static constexpr int digits10\n   '
[#] parse_declaration, is_constructor=False, meet line: 'int digits\n       = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));\n      static constexpr int digits10\n       = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643L / 2136);\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'int digits10\n       = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643L / 2136);\n\n      static constexpr int max_digits10 = 0;\n\n      static constexpr bool is_signed = false;\n      sta'
[#] parse_declaration, is_constructor=False, meet line: 'int max_digits10 = 0;\n\n      static constexpr bool is_signed = false;\n      static constexpr bool is_integer = true;\n      static constexpr bool is_exact = true;\n      static constexpr int radix = 2;\n'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_signed = false;\n      static constexpr bool is_integer = true;\n      static constexpr bool is_exact = true;\n      static constexpr int radix = 2;\n\n      static constexpr unsigned short\n      e'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_integer = true;\n      static constexpr bool is_exact = true;\n      static constexpr int radix = 2;\n\n      static constexpr unsigned short\n      epsilon() noexcept { return 0; }\n\n      static c'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_exact = true;\n      static constexpr int radix = 2;\n\n      static constexpr unsigned short\n      epsilon() noexcept { return 0; }\n\n      static constexpr unsigned short\n      round_error() noe'
[#] parse_declaration, is_constructor=False, meet line: 'int radix = 2;\n\n      static constexpr unsigned short\n      epsilon() noexcept { return 0; }\n\n      static constexpr unsigned short\n      round_error() noexcept { return 0; }\n\n      static constexpr i'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned short\n      epsilon() noexcept { return 0; }\n\n      static constexpr unsigned short\n      round_error() noexcept { return 0; }\n\n      static constexpr int min_exponent = 0;\n      static const'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned short\n      round_error() noexcept { return 0; }\n\n      static constexpr int min_exponent = 0;\n      static constexpr int min_exponent10 = 0;\n      static constexpr int max_exponent = 0;\n    '
[#] parse_declaration, is_constructor=False, meet line: 'int min_exponent = 0;\n      static constexpr int min_exponent10 = 0;\n      static constexpr int max_exponent = 0;\n      static constexpr int max_exponent10 = 0;\n\n      static constexpr bool has_infini'
[#] parse_declaration, is_constructor=False, meet line: 'int min_exponent10 = 0;\n      static constexpr int max_exponent = 0;\n      static constexpr int max_exponent10 = 0;\n\n      static constexpr bool has_infinity = false;\n      static constexpr bool has_q'
[#] parse_declaration, is_constructor=False, meet line: 'int max_exponent = 0;\n      static constexpr int max_exponent10 = 0;\n\n      static constexpr bool has_infinity = false;\n      static constexpr bool has_quiet_NaN = false;\n      static constexpr bool h'
[#] parse_declaration, is_constructor=False, meet line: 'int max_exponent10 = 0;\n\n      static constexpr bool has_infinity = false;\n      static constexpr bool has_quiet_NaN = false;\n      static constexpr bool has_signaling_NaN = false;\n      static conste'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_infinity = false;\n      static constexpr bool has_quiet_NaN = false;\n      static constexpr bool has_signaling_NaN = false;\n      static constexpr float_denorm_style has_denorm\n       = denor'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_quiet_NaN = false;\n      static constexpr bool has_signaling_NaN = false;\n      static constexpr float_denorm_style has_denorm\n       = denorm_absent;\n      static constexpr bool has_denorm_l'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_signaling_NaN = false;\n      static constexpr float_denorm_style has_denorm\n       = denorm_absent;\n      static constexpr bool has_denorm_loss = false;\n\n      static constexpr unsigned short'
[#] parse_declaration, is_constructor=False, meet line: 'float_denorm_style has_denorm\n       = denorm_absent;\n      static constexpr bool has_denorm_loss = false;\n\n      static constexpr unsigned short\n      infinity() noexcept\n      { return static_cast<u'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_denorm_loss = false;\n\n      static constexpr unsigned short\n      infinity() noexcept\n      { return static_cast<unsigned short>(0); }\n\n      static constexpr unsigned short\n      quiet_NaN()'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned short\n      infinity() noexcept\n      { return static_cast<unsigned short>(0); }\n\n      static constexpr unsigned short\n      quiet_NaN() noexcept\n      { return static_cast<unsigned short>(0'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned short\n      quiet_NaN() noexcept\n      { return static_cast<unsigned short>(0); }\n\n      static constexpr unsigned short\n      signaling_NaN() noexcept\n      { return static_cast<unsigned sho'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned short\n      signaling_NaN() noexcept\n      { return static_cast<unsigned short>(0); }\n\n      static constexpr unsigned short\n      denorm_min() noexcept\n      { return static_cast<unsigned sh'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned short\n      denorm_min() noexcept\n      { return static_cast<unsigned short>(0); }\n\n      static constexpr bool is_iec559 = false;\n      static constexpr bool is_bounded = true;\n      static '
[#] parse_declaration, is_constructor=False, meet line: 'bool is_iec559 = false;\n      static constexpr bool is_bounded = true;\n      static constexpr bool is_modulo = true;\n\n      static constexpr bool traps = true;\n      static constexpr bool tinyness_bef'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_bounded = true;\n      static constexpr bool is_modulo = true;\n\n      static constexpr bool traps = true;\n      static constexpr bool tinyness_before = false;\n      static constexpr float_round'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_modulo = true;\n\n      static constexpr bool traps = true;\n      static constexpr bool tinyness_before = false;\n      static constexpr float_round_style round_style\n       = round_toward_zero;\n'
[#] parse_declaration, is_constructor=False, meet line: 'bool traps = true;\n      static constexpr bool tinyness_before = false;\n      static constexpr float_round_style round_style\n       = round_toward_zero;\n    };\n\n\n  template<>\n    struct numeric_limits'
[#] parse_declaration, is_constructor=False, meet line: 'bool tinyness_before = false;\n      static constexpr float_round_style round_style\n       = round_toward_zero;\n    };\n\n\n  template<>\n    struct numeric_limits<int>\n    {\n      static constexpr bool is'
[#] parse_declaration, is_constructor=False, meet line: 'float_round_style round_style\n       = round_toward_zero;\n    };\n\n\n  template<>\n    struct numeric_limits<int>\n    {\n      static constexpr bool is_specialized = true;\n\n      static constexpr int\n    '
[#] parse_declaration, is_constructor=False, meet line: 'bool is_specialized = true;\n\n      static constexpr int\n      min() noexcept { return -0x7fffffff - 1; }\n\n      static constexpr int\n      max() noexcept { return 0x7fffffff; }\n\n\n      static constexp'
[#] parse_declaration, is_constructor=False, meet line: 'int\n      min() noexcept { return -0x7fffffff - 1; }\n\n      static constexpr int\n      max() noexcept { return 0x7fffffff; }\n\n\n      static constexpr int\n      lowest() noexcept { return min(); }\n\n\n  '
[#] parse_declaration, is_constructor=False, meet line: 'int\n      max() noexcept { return 0x7fffffff; }\n\n\n      static constexpr int\n      lowest() noexcept { return min(); }\n\n\n      static constexpr int digits = (sizeof(int) * 8 - ((int)(-1) < 0));\n      '
[#] parse_declaration, is_constructor=False, meet line: 'int\n      lowest() noexcept { return min(); }\n\n\n      static constexpr int digits = (sizeof(int) * 8 - ((int)(-1) < 0));\n      static constexpr int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 64'
[#] parse_declaration, is_constructor=False, meet line: 'int digits = (sizeof(int) * 8 - ((int)(-1) < 0));\n      static constexpr int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643L / 2136);\n\n      static constexpr int max_digits10 = 0;\n\n      static'
[#] parse_declaration, is_constructor=False, meet line: 'int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643L / 2136);\n\n      static constexpr int max_digits10 = 0;\n\n      static constexpr bool is_signed = true;\n      static constexpr bool is_integer '
[#] parse_declaration, is_constructor=False, meet line: 'int max_digits10 = 0;\n\n      static constexpr bool is_signed = true;\n      static constexpr bool is_integer = true;\n      static constexpr bool is_exact = true;\n      static constexpr int radix = 2;\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_signed = true;\n      static constexpr bool is_integer = true;\n      static constexpr bool is_exact = true;\n      static constexpr int radix = 2;\n\n      static constexpr int\n      epsilon() noe'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_integer = true;\n      static constexpr bool is_exact = true;\n      static constexpr int radix = 2;\n\n      static constexpr int\n      epsilon() noexcept { return 0; }\n\n      static constexpr in'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_exact = true;\n      static constexpr int radix = 2;\n\n      static constexpr int\n      epsilon() noexcept { return 0; }\n\n      static constexpr int\n      round_error() noexcept { return 0; }\n\n '
[#] parse_declaration, is_constructor=False, meet line: 'int radix = 2;\n\n      static constexpr int\n      epsilon() noexcept { return 0; }\n\n      static constexpr int\n      round_error() noexcept { return 0; }\n\n      static constexpr int min_exponent = 0;\n '
[#] parse_declaration, is_constructor=False, meet line: 'int\n      epsilon() noexcept { return 0; }\n\n      static constexpr int\n      round_error() noexcept { return 0; }\n\n      static constexpr int min_exponent = 0;\n      static constexpr int min_exponent1'
[#] parse_declaration, is_constructor=False, meet line: 'int\n      round_error() noexcept { return 0; }\n\n      static constexpr int min_exponent = 0;\n      static constexpr int min_exponent10 = 0;\n      static constexpr int max_exponent = 0;\n      static co'
[#] parse_declaration, is_constructor=False, meet line: 'int min_exponent = 0;\n      static constexpr int min_exponent10 = 0;\n      static constexpr int max_exponent = 0;\n      static constexpr int max_exponent10 = 0;\n\n      static constexpr bool has_infini'
[#] parse_declaration, is_constructor=False, meet line: 'int min_exponent10 = 0;\n      static constexpr int max_exponent = 0;\n      static constexpr int max_exponent10 = 0;\n\n      static constexpr bool has_infinity = false;\n      static constexpr bool has_q'
[#] parse_declaration, is_constructor=False, meet line: 'int max_exponent = 0;\n      static constexpr int max_exponent10 = 0;\n\n      static constexpr bool has_infinity = false;\n      static constexpr bool has_quiet_NaN = false;\n      static constexpr bool h'
[#] parse_declaration, is_constructor=False, meet line: 'int max_exponent10 = 0;\n\n      static constexpr bool has_infinity = false;\n      static constexpr bool has_quiet_NaN = false;\n      static constexpr bool has_signaling_NaN = false;\n      static conste'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_infinity = false;\n      static constexpr bool has_quiet_NaN = false;\n      static constexpr bool has_signaling_NaN = false;\n      static constexpr float_denorm_style has_denorm\n       = denor'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_quiet_NaN = false;\n      static constexpr bool has_signaling_NaN = false;\n      static constexpr float_denorm_style has_denorm\n       = denorm_absent;\n      static constexpr bool has_denorm_l'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_signaling_NaN = false;\n      static constexpr float_denorm_style has_denorm\n       = denorm_absent;\n      static constexpr bool has_denorm_loss = false;\n\n      static constexpr int\n      infi'
[#] parse_declaration, is_constructor=False, meet line: 'float_denorm_style has_denorm\n       = denorm_absent;\n      static constexpr bool has_denorm_loss = false;\n\n      static constexpr int\n      infinity() noexcept { return static_cast<int>(0); }\n\n      '
[#] parse_declaration, is_constructor=False, meet line: 'bool has_denorm_loss = false;\n\n      static constexpr int\n      infinity() noexcept { return static_cast<int>(0); }\n\n      static constexpr int\n      quiet_NaN() noexcept { return static_cast<int>(0);'
[#] parse_declaration, is_constructor=False, meet line: 'int\n      infinity() noexcept { return static_cast<int>(0); }\n\n      static constexpr int\n      quiet_NaN() noexcept { return static_cast<int>(0); }\n\n      static constexpr int\n      signaling_NaN() n'
[#] parse_declaration, is_constructor=False, meet line: 'int\n      quiet_NaN() noexcept { return static_cast<int>(0); }\n\n      static constexpr int\n      signaling_NaN() noexcept { return static_cast<int>(0); }\n\n      static constexpr int\n      denorm_min()'
[#] parse_declaration, is_constructor=False, meet line: 'int\n      signaling_NaN() noexcept { return static_cast<int>(0); }\n\n      static constexpr int\n      denorm_min() noexcept { return static_cast<int>(0); }\n\n      static constexpr bool is_iec559 = fals'
[#] parse_declaration, is_constructor=False, meet line: 'int\n      denorm_min() noexcept { return static_cast<int>(0); }\n\n      static constexpr bool is_iec559 = false;\n      static constexpr bool is_bounded = true;\n      static constexpr bool is_modulo = f'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_iec559 = false;\n      static constexpr bool is_bounded = true;\n      static constexpr bool is_modulo = false;\n\n      static constexpr bool traps = true;\n      static constexpr bool tinyness_be'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_bounded = true;\n      static constexpr bool is_modulo = false;\n\n      static constexpr bool traps = true;\n      static constexpr bool tinyness_before = false;\n      static constexpr float_roun'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_modulo = false;\n\n      static constexpr bool traps = true;\n      static constexpr bool tinyness_before = false;\n      static constexpr float_round_style round_style\n       = round_toward_zero;'
[#] parse_declaration, is_constructor=False, meet line: 'bool traps = true;\n      static constexpr bool tinyness_before = false;\n      static constexpr float_round_style round_style\n       = round_toward_zero;\n    };\n\n\n  template<>\n    struct numeric_limits'
[#] parse_declaration, is_constructor=False, meet line: 'bool tinyness_before = false;\n      static constexpr float_round_style round_style\n       = round_toward_zero;\n    };\n\n\n  template<>\n    struct numeric_limits<unsigned int>\n    {\n      static constexp'
[#] parse_declaration, is_constructor=False, meet line: 'float_round_style round_style\n       = round_toward_zero;\n    };\n\n\n  template<>\n    struct numeric_limits<unsigned int>\n    {\n      static constexpr bool is_specialized = true;\n\n      static constexpr'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_specialized = true;\n\n      static constexpr unsigned int\n      min() noexcept { return 0; }\n\n      static constexpr unsigned int\n      max() noexcept { return 0x7fffffff * 2U + 1; }\n\n\n      st'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned int\n      min() noexcept { return 0; }\n\n      static constexpr unsigned int\n      max() noexcept { return 0x7fffffff * 2U + 1; }\n\n\n      static constexpr unsigned int\n      lowest() noexcept '
[#] parse_declaration, is_constructor=False, meet line: 'unsigned int\n      max() noexcept { return 0x7fffffff * 2U + 1; }\n\n\n      static constexpr unsigned int\n      lowest() noexcept { return min(); }\n\n\n      static constexpr int digits\n       = (sizeof(u'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned int\n      lowest() noexcept { return min(); }\n\n\n      static constexpr int digits\n       = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));\n      static constexpr int digits10\n       = '
[#] parse_declaration, is_constructor=False, meet line: 'int digits\n       = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));\n      static constexpr int digits10\n       = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643L / 2136);\n\n      st'
[#] parse_declaration, is_constructor=False, meet line: 'int digits10\n       = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643L / 2136);\n\n      static constexpr int max_digits10 = 0;\n\n      static constexpr bool is_signed = false;\n      static '
[#] parse_declaration, is_constructor=False, meet line: 'int max_digits10 = 0;\n\n      static constexpr bool is_signed = false;\n      static constexpr bool is_integer = true;\n      static constexpr bool is_exact = true;\n      static constexpr int radix = 2;\n'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_signed = false;\n      static constexpr bool is_integer = true;\n      static constexpr bool is_exact = true;\n      static constexpr int radix = 2;\n\n      static constexpr unsigned int\n      eps'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_integer = true;\n      static constexpr bool is_exact = true;\n      static constexpr int radix = 2;\n\n      static constexpr unsigned int\n      epsilon() noexcept { return 0; }\n\n      static con'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_exact = true;\n      static constexpr int radix = 2;\n\n      static constexpr unsigned int\n      epsilon() noexcept { return 0; }\n\n      static constexpr unsigned int\n      round_error() noexcep'
[#] parse_declaration, is_constructor=False, meet line: 'int radix = 2;\n\n      static constexpr unsigned int\n      epsilon() noexcept { return 0; }\n\n      static constexpr unsigned int\n      round_error() noexcept { return 0; }\n\n      static constexpr int m'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned int\n      epsilon() noexcept { return 0; }\n\n      static constexpr unsigned int\n      round_error() noexcept { return 0; }\n\n      static constexpr int min_exponent = 0;\n      static constexpr'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned int\n      round_error() noexcept { return 0; }\n\n      static constexpr int min_exponent = 0;\n      static constexpr int min_exponent10 = 0;\n      static constexpr int max_exponent = 0;\n      '
[#] parse_declaration, is_constructor=False, meet line: 'int min_exponent = 0;\n      static constexpr int min_exponent10 = 0;\n      static constexpr int max_exponent = 0;\n      static constexpr int max_exponent10 = 0;\n\n      static constexpr bool has_infini'
[#] parse_declaration, is_constructor=False, meet line: 'int min_exponent10 = 0;\n      static constexpr int max_exponent = 0;\n      static constexpr int max_exponent10 = 0;\n\n      static constexpr bool has_infinity = false;\n      static constexpr bool has_q'
[#] parse_declaration, is_constructor=False, meet line: 'int max_exponent = 0;\n      static constexpr int max_exponent10 = 0;\n\n      static constexpr bool has_infinity = false;\n      static constexpr bool has_quiet_NaN = false;\n      static constexpr bool h'
[#] parse_declaration, is_constructor=False, meet line: 'int max_exponent10 = 0;\n\n      static constexpr bool has_infinity = false;\n      static constexpr bool has_quiet_NaN = false;\n      static constexpr bool has_signaling_NaN = false;\n      static conste'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_infinity = false;\n      static constexpr bool has_quiet_NaN = false;\n      static constexpr bool has_signaling_NaN = false;\n      static constexpr float_denorm_style has_denorm\n       = denor'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_quiet_NaN = false;\n      static constexpr bool has_signaling_NaN = false;\n      static constexpr float_denorm_style has_denorm\n       = denorm_absent;\n      static constexpr bool has_denorm_l'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_signaling_NaN = false;\n      static constexpr float_denorm_style has_denorm\n       = denorm_absent;\n      static constexpr bool has_denorm_loss = false;\n\n      static constexpr unsigned int\n '
[#] parse_declaration, is_constructor=False, meet line: 'float_denorm_style has_denorm\n       = denorm_absent;\n      static constexpr bool has_denorm_loss = false;\n\n      static constexpr unsigned int\n      infinity() noexcept { return static_cast<unsigned '
[#] parse_declaration, is_constructor=False, meet line: 'bool has_denorm_loss = false;\n\n      static constexpr unsigned int\n      infinity() noexcept { return static_cast<unsigned int>(0); }\n\n      static constexpr unsigned int\n      quiet_NaN() noexcept\n  '
[#] parse_declaration, is_constructor=False, meet line: 'unsigned int\n      infinity() noexcept { return static_cast<unsigned int>(0); }\n\n      static constexpr unsigned int\n      quiet_NaN() noexcept\n      { return static_cast<unsigned int>(0); }\n\n      st'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned int\n      quiet_NaN() noexcept\n      { return static_cast<unsigned int>(0); }\n\n      static constexpr unsigned int\n      signaling_NaN() noexcept\n      { return static_cast<unsigned int>(0); '
[#] parse_declaration, is_constructor=False, meet line: 'unsigned int\n      signaling_NaN() noexcept\n      { return static_cast<unsigned int>(0); }\n\n      static constexpr unsigned int\n      denorm_min() noexcept\n      { return static_cast<unsigned int>(0);'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned int\n      denorm_min() noexcept\n      { return static_cast<unsigned int>(0); }\n\n      static constexpr bool is_iec559 = false;\n      static constexpr bool is_bounded = true;\n      static cons'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_iec559 = false;\n      static constexpr bool is_bounded = true;\n      static constexpr bool is_modulo = true;\n\n      static constexpr bool traps = true;\n      static constexpr bool tinyness_bef'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_bounded = true;\n      static constexpr bool is_modulo = true;\n\n      static constexpr bool traps = true;\n      static constexpr bool tinyness_before = false;\n      static constexpr float_round'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_modulo = true;\n\n      static constexpr bool traps = true;\n      static constexpr bool tinyness_before = false;\n      static constexpr float_round_style round_style\n       = round_toward_zero;\n'
[#] parse_declaration, is_constructor=False, meet line: 'bool traps = true;\n      static constexpr bool tinyness_before = false;\n      static constexpr float_round_style round_style\n       = round_toward_zero;\n    };\n\n\n  template<>\n    struct numeric_limits'
[#] parse_declaration, is_constructor=False, meet line: 'bool tinyness_before = false;\n      static constexpr float_round_style round_style\n       = round_toward_zero;\n    };\n\n\n  template<>\n    struct numeric_limits<long>\n    {\n      static constexpr bool i'
[#] parse_declaration, is_constructor=False, meet line: 'float_round_style round_style\n       = round_toward_zero;\n    };\n\n\n  template<>\n    struct numeric_limits<long>\n    {\n      static constexpr bool is_specialized = true;\n\n      static constexpr long\n  '
[#] parse_declaration, is_constructor=False, meet line: 'bool is_specialized = true;\n\n      static constexpr long\n      min() noexcept { return -0x7fffffffffffffffL - 1; }\n\n      static constexpr long\n      max() noexcept { return 0x7fffffffffffffffL; }\n\n\n '
[#] parse_declaration, is_constructor=False, meet line: 'long\n      min() noexcept { return -0x7fffffffffffffffL - 1; }\n\n      static constexpr long\n      max() noexcept { return 0x7fffffffffffffffL; }\n\n\n      static constexpr long\n      lowest() noexcept {'
[#] parse_declaration, is_constructor=False, meet line: 'long\n      max() noexcept { return 0x7fffffffffffffffL; }\n\n\n      static constexpr long\n      lowest() noexcept { return min(); }\n\n\n      static constexpr int digits = (sizeof(long) * 8 - ((long)(-1) '
[#] parse_declaration, is_constructor=False, meet line: 'long\n      lowest() noexcept { return min(); }\n\n\n      static constexpr int digits = (sizeof(long) * 8 - ((long)(-1) < 0));\n      static constexpr int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0))'
[#] parse_declaration, is_constructor=False, meet line: 'int digits = (sizeof(long) * 8 - ((long)(-1) < 0));\n      static constexpr int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643L / 2136);\n\n      static constexpr int max_digits10 = 0;\n\n      st'
[#] parse_declaration, is_constructor=False, meet line: 'int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643L / 2136);\n\n      static constexpr int max_digits10 = 0;\n\n      static constexpr bool is_signed = true;\n      static constexpr bool is_intege'
[#] parse_declaration, is_constructor=False, meet line: 'int max_digits10 = 0;\n\n      static constexpr bool is_signed = true;\n      static constexpr bool is_integer = true;\n      static constexpr bool is_exact = true;\n      static constexpr int radix = 2;\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_signed = true;\n      static constexpr bool is_integer = true;\n      static constexpr bool is_exact = true;\n      static constexpr int radix = 2;\n\n      static constexpr long\n      epsilon() no'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_integer = true;\n      static constexpr bool is_exact = true;\n      static constexpr int radix = 2;\n\n      static constexpr long\n      epsilon() noexcept { return 0; }\n\n      static constexpr l'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_exact = true;\n      static constexpr int radix = 2;\n\n      static constexpr long\n      epsilon() noexcept { return 0; }\n\n      static constexpr long\n      round_error() noexcept { return 0; }\n'
[#] parse_declaration, is_constructor=False, meet line: 'int radix = 2;\n\n      static constexpr long\n      epsilon() noexcept { return 0; }\n\n      static constexpr long\n      round_error() noexcept { return 0; }\n\n      static constexpr int min_exponent = 0;'
[#] parse_declaration, is_constructor=False, meet line: 'long\n      epsilon() noexcept { return 0; }\n\n      static constexpr long\n      round_error() noexcept { return 0; }\n\n      static constexpr int min_exponent = 0;\n      static constexpr int min_exponen'
[#] parse_declaration, is_constructor=False, meet line: 'long\n      round_error() noexcept { return 0; }\n\n      static constexpr int min_exponent = 0;\n      static constexpr int min_exponent10 = 0;\n      static constexpr int max_exponent = 0;\n      static c'
[#] parse_declaration, is_constructor=False, meet line: 'int min_exponent = 0;\n      static constexpr int min_exponent10 = 0;\n      static constexpr int max_exponent = 0;\n      static constexpr int max_exponent10 = 0;\n\n      static constexpr bool has_infini'
[#] parse_declaration, is_constructor=False, meet line: 'int min_exponent10 = 0;\n      static constexpr int max_exponent = 0;\n      static constexpr int max_exponent10 = 0;\n\n      static constexpr bool has_infinity = false;\n      static constexpr bool has_q'
[#] parse_declaration, is_constructor=False, meet line: 'int max_exponent = 0;\n      static constexpr int max_exponent10 = 0;\n\n      static constexpr bool has_infinity = false;\n      static constexpr bool has_quiet_NaN = false;\n      static constexpr bool h'
[#] parse_declaration, is_constructor=False, meet line: 'int max_exponent10 = 0;\n\n      static constexpr bool has_infinity = false;\n      static constexpr bool has_quiet_NaN = false;\n      static constexpr bool has_signaling_NaN = false;\n      static conste'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_infinity = false;\n      static constexpr bool has_quiet_NaN = false;\n      static constexpr bool has_signaling_NaN = false;\n      static constexpr float_denorm_style has_denorm\n       = denor'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_quiet_NaN = false;\n      static constexpr bool has_signaling_NaN = false;\n      static constexpr float_denorm_style has_denorm\n       = denorm_absent;\n      static constexpr bool has_denorm_l'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_signaling_NaN = false;\n      static constexpr float_denorm_style has_denorm\n       = denorm_absent;\n      static constexpr bool has_denorm_loss = false;\n\n      static constexpr long\n      inf'
[#] parse_declaration, is_constructor=False, meet line: 'float_denorm_style has_denorm\n       = denorm_absent;\n      static constexpr bool has_denorm_loss = false;\n\n      static constexpr long\n      infinity() noexcept { return static_cast<long>(0); }\n\n    '
[#] parse_declaration, is_constructor=False, meet line: 'bool has_denorm_loss = false;\n\n      static constexpr long\n      infinity() noexcept { return static_cast<long>(0); }\n\n      static constexpr long\n      quiet_NaN() noexcept { return static_cast<long>'
[#] parse_declaration, is_constructor=False, meet line: 'long\n      infinity() noexcept { return static_cast<long>(0); }\n\n      static constexpr long\n      quiet_NaN() noexcept { return static_cast<long>(0); }\n\n      static constexpr long\n      signaling_Na'
[#] parse_declaration, is_constructor=False, meet line: 'long\n      quiet_NaN() noexcept { return static_cast<long>(0); }\n\n      static constexpr long\n      signaling_NaN() noexcept { return static_cast<long>(0); }\n\n      static constexpr long\n      denorm_'
[#] parse_declaration, is_constructor=False, meet line: 'long\n      signaling_NaN() noexcept { return static_cast<long>(0); }\n\n      static constexpr long\n      denorm_min() noexcept { return static_cast<long>(0); }\n\n      static constexpr bool is_iec559 = '
[#] parse_declaration, is_constructor=False, meet line: 'long\n      denorm_min() noexcept { return static_cast<long>(0); }\n\n      static constexpr bool is_iec559 = false;\n      static constexpr bool is_bounded = true;\n      static constexpr bool is_modulo ='
[#] parse_declaration, is_constructor=False, meet line: 'bool is_iec559 = false;\n      static constexpr bool is_bounded = true;\n      static constexpr bool is_modulo = false;\n\n      static constexpr bool traps = true;\n      static constexpr bool tinyness_be'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_bounded = true;\n      static constexpr bool is_modulo = false;\n\n      static constexpr bool traps = true;\n      static constexpr bool tinyness_before = false;\n      static constexpr float_roun'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_modulo = false;\n\n      static constexpr bool traps = true;\n      static constexpr bool tinyness_before = false;\n      static constexpr float_round_style round_style\n       = round_toward_zero;'
[#] parse_declaration, is_constructor=False, meet line: 'bool traps = true;\n      static constexpr bool tinyness_before = false;\n      static constexpr float_round_style round_style\n       = round_toward_zero;\n    };\n\n\n  template<>\n    struct numeric_limits'
[#] parse_declaration, is_constructor=False, meet line: 'bool tinyness_before = false;\n      static constexpr float_round_style round_style\n       = round_toward_zero;\n    };\n\n\n  template<>\n    struct numeric_limits<unsigned long>\n    {\n      static constex'
[#] parse_declaration, is_constructor=False, meet line: 'float_round_style round_style\n       = round_toward_zero;\n    };\n\n\n  template<>\n    struct numeric_limits<unsigned long>\n    {\n      static constexpr bool is_specialized = true;\n\n      static constexp'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_specialized = true;\n\n      static constexpr unsigned long\n      min() noexcept { return 0; }\n\n      static constexpr unsigned long\n      max() noexcept { return 0x7fffffffffffffffL * 2UL + 1; '
[#] parse_declaration, is_constructor=False, meet line: 'unsigned long\n      min() noexcept { return 0; }\n\n      static constexpr unsigned long\n      max() noexcept { return 0x7fffffffffffffffL * 2UL + 1; }\n\n\n      static constexpr unsigned long\n      lowes'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned long\n      max() noexcept { return 0x7fffffffffffffffL * 2UL + 1; }\n\n\n      static constexpr unsigned long\n      lowest() noexcept { return min(); }\n\n\n      static constexpr int digits\n      '
[#] parse_declaration, is_constructor=False, meet line: 'unsigned long\n      lowest() noexcept { return min(); }\n\n\n      static constexpr int digits\n       = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));\n      static constexpr int digits10\n      '
[#] parse_declaration, is_constructor=False, meet line: 'int digits\n       = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));\n      static constexpr int digits10\n       = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643L / 2136);\n\n    '
[#] parse_declaration, is_constructor=False, meet line: 'int digits10\n       = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643L / 2136);\n\n      static constexpr int max_digits10 = 0;\n\n      static constexpr bool is_signed = false;\n      stati'
[#] parse_declaration, is_constructor=False, meet line: 'int max_digits10 = 0;\n\n      static constexpr bool is_signed = false;\n      static constexpr bool is_integer = true;\n      static constexpr bool is_exact = true;\n      static constexpr int radix = 2;\n'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_signed = false;\n      static constexpr bool is_integer = true;\n      static constexpr bool is_exact = true;\n      static constexpr int radix = 2;\n\n      static constexpr unsigned long\n      ep'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_integer = true;\n      static constexpr bool is_exact = true;\n      static constexpr int radix = 2;\n\n      static constexpr unsigned long\n      epsilon() noexcept { return 0; }\n\n      static co'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_exact = true;\n      static constexpr int radix = 2;\n\n      static constexpr unsigned long\n      epsilon() noexcept { return 0; }\n\n      static constexpr unsigned long\n      round_error() noexc'
[#] parse_declaration, is_constructor=False, meet line: 'int radix = 2;\n\n      static constexpr unsigned long\n      epsilon() noexcept { return 0; }\n\n      static constexpr unsigned long\n      round_error() noexcept { return 0; }\n\n      static constexpr int'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned long\n      epsilon() noexcept { return 0; }\n\n      static constexpr unsigned long\n      round_error() noexcept { return 0; }\n\n      static constexpr int min_exponent = 0;\n      static constex'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned long\n      round_error() noexcept { return 0; }\n\n      static constexpr int min_exponent = 0;\n      static constexpr int min_exponent10 = 0;\n      static constexpr int max_exponent = 0;\n     '
[#] parse_declaration, is_constructor=False, meet line: 'int min_exponent = 0;\n      static constexpr int min_exponent10 = 0;\n      static constexpr int max_exponent = 0;\n      static constexpr int max_exponent10 = 0;\n\n      static constexpr bool has_infini'
[#] parse_declaration, is_constructor=False, meet line: 'int min_exponent10 = 0;\n      static constexpr int max_exponent = 0;\n      static constexpr int max_exponent10 = 0;\n\n      static constexpr bool has_infinity = false;\n      static constexpr bool has_q'
[#] parse_declaration, is_constructor=False, meet line: 'int max_exponent = 0;\n      static constexpr int max_exponent10 = 0;\n\n      static constexpr bool has_infinity = false;\n      static constexpr bool has_quiet_NaN = false;\n      static constexpr bool h'
[#] parse_declaration, is_constructor=False, meet line: 'int max_exponent10 = 0;\n\n      static constexpr bool has_infinity = false;\n      static constexpr bool has_quiet_NaN = false;\n      static constexpr bool has_signaling_NaN = false;\n      static conste'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_infinity = false;\n      static constexpr bool has_quiet_NaN = false;\n      static constexpr bool has_signaling_NaN = false;\n      static constexpr float_denorm_style has_denorm\n       = denor'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_quiet_NaN = false;\n      static constexpr bool has_signaling_NaN = false;\n      static constexpr float_denorm_style has_denorm\n       = denorm_absent;\n      static constexpr bool has_denorm_l'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_signaling_NaN = false;\n      static constexpr float_denorm_style has_denorm\n       = denorm_absent;\n      static constexpr bool has_denorm_loss = false;\n\n      static constexpr unsigned long\n'
[#] parse_declaration, is_constructor=False, meet line: 'float_denorm_style has_denorm\n       = denorm_absent;\n      static constexpr bool has_denorm_loss = false;\n\n      static constexpr unsigned long\n      infinity() noexcept\n      { return static_cast<un'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_denorm_loss = false;\n\n      static constexpr unsigned long\n      infinity() noexcept\n      { return static_cast<unsigned long>(0); }\n\n      static constexpr unsigned long\n      quiet_NaN() no'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned long\n      infinity() noexcept\n      { return static_cast<unsigned long>(0); }\n\n      static constexpr unsigned long\n      quiet_NaN() noexcept\n      { return static_cast<unsigned long>(0); }'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned long\n      quiet_NaN() noexcept\n      { return static_cast<unsigned long>(0); }\n\n      static constexpr unsigned long\n      signaling_NaN() noexcept\n      { return static_cast<unsigned long>('
[#] parse_declaration, is_constructor=False, meet line: 'unsigned long\n      signaling_NaN() noexcept\n      { return static_cast<unsigned long>(0); }\n\n      static constexpr unsigned long\n      denorm_min() noexcept\n      { return static_cast<unsigned long>'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned long\n      denorm_min() noexcept\n      { return static_cast<unsigned long>(0); }\n\n      static constexpr bool is_iec559 = false;\n      static constexpr bool is_bounded = true;\n      static co'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_iec559 = false;\n      static constexpr bool is_bounded = true;\n      static constexpr bool is_modulo = true;\n\n      static constexpr bool traps = true;\n      static constexpr bool tinyness_bef'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_bounded = true;\n      static constexpr bool is_modulo = true;\n\n      static constexpr bool traps = true;\n      static constexpr bool tinyness_before = false;\n      static constexpr float_round'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_modulo = true;\n\n      static constexpr bool traps = true;\n      static constexpr bool tinyness_before = false;\n      static constexpr float_round_style round_style\n       = round_toward_zero;\n'
[#] parse_declaration, is_constructor=False, meet line: 'bool traps = true;\n      static constexpr bool tinyness_before = false;\n      static constexpr float_round_style round_style\n       = round_toward_zero;\n    };\n\n\n  template<>\n    struct numeric_limits'
[#] parse_declaration, is_constructor=False, meet line: 'bool tinyness_before = false;\n      static constexpr float_round_style round_style\n       = round_toward_zero;\n    };\n\n\n  template<>\n    struct numeric_limits<long long>\n    {\n      static constexpr b'
[#] parse_declaration, is_constructor=False, meet line: 'float_round_style round_style\n       = round_toward_zero;\n    };\n\n\n  template<>\n    struct numeric_limits<long long>\n    {\n      static constexpr bool is_specialized = true;\n\n      static constexpr lo'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_specialized = true;\n\n      static constexpr long long\n      min() noexcept { return -0x7fffffffffffffffLL - 1; }\n\n      static constexpr long long\n      max() noexcept { return 0x7ffffffffffff'
[#] parse_declaration, is_constructor=False, meet line: 'long long\n      min() noexcept { return -0x7fffffffffffffffLL - 1; }\n\n      static constexpr long long\n      max() noexcept { return 0x7fffffffffffffffLL; }\n\n\n      static constexpr long long\n      lo'
[#] parse_declaration, is_constructor=False, meet line: 'long long\n      max() noexcept { return 0x7fffffffffffffffLL; }\n\n\n      static constexpr long long\n      lowest() noexcept { return min(); }\n\n\n      static constexpr int digits\n       = (sizeof(long l'
[#] parse_declaration, is_constructor=False, meet line: 'long long\n      lowest() noexcept { return min(); }\n\n\n      static constexpr int digits\n       = (sizeof(long long) * 8 - ((long long)(-1) < 0));\n      static constexpr int digits10\n       = ((sizeof('
[#] parse_declaration, is_constructor=False, meet line: 'int digits\n       = (sizeof(long long) * 8 - ((long long)(-1) < 0));\n      static constexpr int digits10\n       = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643L / 2136);\n\n      static constex'
[#] parse_declaration, is_constructor=False, meet line: 'int digits10\n       = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643L / 2136);\n\n      static constexpr int max_digits10 = 0;\n\n      static constexpr bool is_signed = true;\n      static constex'
[#] parse_declaration, is_constructor=False, meet line: 'int max_digits10 = 0;\n\n      static constexpr bool is_signed = true;\n      static constexpr bool is_integer = true;\n      static constexpr bool is_exact = true;\n      static constexpr int radix = 2;\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_signed = true;\n      static constexpr bool is_integer = true;\n      static constexpr bool is_exact = true;\n      static constexpr int radix = 2;\n\n      static constexpr long long\n      epsilon'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_integer = true;\n      static constexpr bool is_exact = true;\n      static constexpr int radix = 2;\n\n      static constexpr long long\n      epsilon() noexcept { return 0; }\n\n      static conste'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_exact = true;\n      static constexpr int radix = 2;\n\n      static constexpr long long\n      epsilon() noexcept { return 0; }\n\n      static constexpr long long\n      round_error() noexcept { re'
[#] parse_declaration, is_constructor=False, meet line: 'int radix = 2;\n\n      static constexpr long long\n      epsilon() noexcept { return 0; }\n\n      static constexpr long long\n      round_error() noexcept { return 0; }\n\n      static constexpr int min_exp'
[#] parse_declaration, is_constructor=False, meet line: 'long long\n      epsilon() noexcept { return 0; }\n\n      static constexpr long long\n      round_error() noexcept { return 0; }\n\n      static constexpr int min_exponent = 0;\n      static constexpr int m'
[#] parse_declaration, is_constructor=False, meet line: 'long long\n      round_error() noexcept { return 0; }\n\n      static constexpr int min_exponent = 0;\n      static constexpr int min_exponent10 = 0;\n      static constexpr int max_exponent = 0;\n      sta'
[#] parse_declaration, is_constructor=False, meet line: 'int min_exponent = 0;\n      static constexpr int min_exponent10 = 0;\n      static constexpr int max_exponent = 0;\n      static constexpr int max_exponent10 = 0;\n\n      static constexpr bool has_infini'
[#] parse_declaration, is_constructor=False, meet line: 'int min_exponent10 = 0;\n      static constexpr int max_exponent = 0;\n      static constexpr int max_exponent10 = 0;\n\n      static constexpr bool has_infinity = false;\n      static constexpr bool has_q'
[#] parse_declaration, is_constructor=False, meet line: 'int max_exponent = 0;\n      static constexpr int max_exponent10 = 0;\n\n      static constexpr bool has_infinity = false;\n      static constexpr bool has_quiet_NaN = false;\n      static constexpr bool h'
[#] parse_declaration, is_constructor=False, meet line: 'int max_exponent10 = 0;\n\n      static constexpr bool has_infinity = false;\n      static constexpr bool has_quiet_NaN = false;\n      static constexpr bool has_signaling_NaN = false;\n      static conste'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_infinity = false;\n      static constexpr bool has_quiet_NaN = false;\n      static constexpr bool has_signaling_NaN = false;\n      static constexpr float_denorm_style has_denorm\n       = denor'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_quiet_NaN = false;\n      static constexpr bool has_signaling_NaN = false;\n      static constexpr float_denorm_style has_denorm\n       = denorm_absent;\n      static constexpr bool has_denorm_l'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_signaling_NaN = false;\n      static constexpr float_denorm_style has_denorm\n       = denorm_absent;\n      static constexpr bool has_denorm_loss = false;\n\n      static constexpr long long\n    '
[#] parse_declaration, is_constructor=False, meet line: 'float_denorm_style has_denorm\n       = denorm_absent;\n      static constexpr bool has_denorm_loss = false;\n\n      static constexpr long long\n      infinity() noexcept { return static_cast<long long>(0'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_denorm_loss = false;\n\n      static constexpr long long\n      infinity() noexcept { return static_cast<long long>(0); }\n\n      static constexpr long long\n      quiet_NaN() noexcept { return st'
[#] parse_declaration, is_constructor=False, meet line: 'long long\n      infinity() noexcept { return static_cast<long long>(0); }\n\n      static constexpr long long\n      quiet_NaN() noexcept { return static_cast<long long>(0); }\n\n      static constexpr lon'
[#] parse_declaration, is_constructor=False, meet line: 'long long\n      quiet_NaN() noexcept { return static_cast<long long>(0); }\n\n      static constexpr long long\n      signaling_NaN() noexcept\n      { return static_cast<long long>(0); }\n\n      static co'
[#] parse_declaration, is_constructor=False, meet line: 'long long\n      signaling_NaN() noexcept\n      { return static_cast<long long>(0); }\n\n      static constexpr long long\n      denorm_min() noexcept { return static_cast<long long>(0); }\n\n      static c'
[#] parse_declaration, is_constructor=False, meet line: 'long long\n      denorm_min() noexcept { return static_cast<long long>(0); }\n\n      static constexpr bool is_iec559 = false;\n      static constexpr bool is_bounded = true;\n      static constexpr bool i'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_iec559 = false;\n      static constexpr bool is_bounded = true;\n      static constexpr bool is_modulo = false;\n\n      static constexpr bool traps = true;\n      static constexpr bool tinyness_be'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_bounded = true;\n      static constexpr bool is_modulo = false;\n\n      static constexpr bool traps = true;\n      static constexpr bool tinyness_before = false;\n      static constexpr float_roun'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_modulo = false;\n\n      static constexpr bool traps = true;\n      static constexpr bool tinyness_before = false;\n      static constexpr float_round_style round_style\n       = round_toward_zero;'
[#] parse_declaration, is_constructor=False, meet line: 'bool traps = true;\n      static constexpr bool tinyness_before = false;\n      static constexpr float_round_style round_style\n       = round_toward_zero;\n    };\n\n\n  template<>\n    struct numeric_limits'
[#] parse_declaration, is_constructor=False, meet line: 'bool tinyness_before = false;\n      static constexpr float_round_style round_style\n       = round_toward_zero;\n    };\n\n\n  template<>\n    struct numeric_limits<unsigned long long>\n    {\n      static co'
[#] parse_declaration, is_constructor=False, meet line: 'float_round_style round_style\n       = round_toward_zero;\n    };\n\n\n  template<>\n    struct numeric_limits<unsigned long long>\n    {\n      static constexpr bool is_specialized = true;\n\n      static con'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_specialized = true;\n\n      static constexpr unsigned long long\n      min() noexcept { return 0; }\n\n      static constexpr unsigned long long\n      max() noexcept { return 0x7fffffffffffffffLL '
[#] parse_declaration, is_constructor=False, meet line: 'unsigned long long\n      min() noexcept { return 0; }\n\n      static constexpr unsigned long long\n      max() noexcept { return 0x7fffffffffffffffLL * 2ULL + 1; }\n\n\n      static constexpr unsigned long'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned long long\n      max() noexcept { return 0x7fffffffffffffffLL * 2ULL + 1; }\n\n\n      static constexpr unsigned long long\n      lowest() noexcept { return min(); }\n\n\n      static constexpr int d'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned long long\n      lowest() noexcept { return min(); }\n\n\n      static constexpr int digits\n       = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));\n      static constexpr int '
[#] parse_declaration, is_constructor=False, meet line: 'int digits\n       = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));\n      static constexpr int digits10\n       = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) *'
[#] parse_declaration, is_constructor=False, meet line: 'int digits10\n       = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643L / 2136);\n\n      static constexpr int max_digits10 = 0;\n\n      static constexpr bool is_signed = false;\n '
[#] parse_declaration, is_constructor=False, meet line: 'int max_digits10 = 0;\n\n      static constexpr bool is_signed = false;\n      static constexpr bool is_integer = true;\n      static constexpr bool is_exact = true;\n      static constexpr int radix = 2;\n'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_signed = false;\n      static constexpr bool is_integer = true;\n      static constexpr bool is_exact = true;\n      static constexpr int radix = 2;\n\n      static constexpr unsigned long long\n   '
[#] parse_declaration, is_constructor=False, meet line: 'bool is_integer = true;\n      static constexpr bool is_exact = true;\n      static constexpr int radix = 2;\n\n      static constexpr unsigned long long\n      epsilon() noexcept { return 0; }\n\n      stat'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_exact = true;\n      static constexpr int radix = 2;\n\n      static constexpr unsigned long long\n      epsilon() noexcept { return 0; }\n\n      static constexpr unsigned long long\n      round_err'
[#] parse_declaration, is_constructor=False, meet line: 'int radix = 2;\n\n      static constexpr unsigned long long\n      epsilon() noexcept { return 0; }\n\n      static constexpr unsigned long long\n      round_error() noexcept { return 0; }\n\n      static con'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned long long\n      epsilon() noexcept { return 0; }\n\n      static constexpr unsigned long long\n      round_error() noexcept { return 0; }\n\n      static constexpr int min_exponent = 0;\n      stat'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned long long\n      round_error() noexcept { return 0; }\n\n      static constexpr int min_exponent = 0;\n      static constexpr int min_exponent10 = 0;\n      static constexpr int max_exponent = 0;\n'
[#] parse_declaration, is_constructor=False, meet line: 'int min_exponent = 0;\n      static constexpr int min_exponent10 = 0;\n      static constexpr int max_exponent = 0;\n      static constexpr int max_exponent10 = 0;\n\n      static constexpr bool has_infini'
[#] parse_declaration, is_constructor=False, meet line: 'int min_exponent10 = 0;\n      static constexpr int max_exponent = 0;\n      static constexpr int max_exponent10 = 0;\n\n      static constexpr bool has_infinity = false;\n      static constexpr bool has_q'
[#] parse_declaration, is_constructor=False, meet line: 'int max_exponent = 0;\n      static constexpr int max_exponent10 = 0;\n\n      static constexpr bool has_infinity = false;\n      static constexpr bool has_quiet_NaN = false;\n      static constexpr bool h'
[#] parse_declaration, is_constructor=False, meet line: 'int max_exponent10 = 0;\n\n      static constexpr bool has_infinity = false;\n      static constexpr bool has_quiet_NaN = false;\n      static constexpr bool has_signaling_NaN = false;\n      static conste'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_infinity = false;\n      static constexpr bool has_quiet_NaN = false;\n      static constexpr bool has_signaling_NaN = false;\n      static constexpr float_denorm_style has_denorm\n       = denor'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_quiet_NaN = false;\n      static constexpr bool has_signaling_NaN = false;\n      static constexpr float_denorm_style has_denorm\n       = denorm_absent;\n      static constexpr bool has_denorm_l'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_signaling_NaN = false;\n      static constexpr float_denorm_style has_denorm\n       = denorm_absent;\n      static constexpr bool has_denorm_loss = false;\n\n      static constexpr unsigned long '
[#] parse_declaration, is_constructor=False, meet line: 'float_denorm_style has_denorm\n       = denorm_absent;\n      static constexpr bool has_denorm_loss = false;\n\n      static constexpr unsigned long long\n      infinity() noexcept\n      { return static_ca'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_denorm_loss = false;\n\n      static constexpr unsigned long long\n      infinity() noexcept\n      { return static_cast<unsigned long long>(0); }\n\n      static constexpr unsigned long long\n     '
[#] parse_declaration, is_constructor=False, meet line: 'unsigned long long\n      infinity() noexcept\n      { return static_cast<unsigned long long>(0); }\n\n      static constexpr unsigned long long\n      quiet_NaN() noexcept\n      { return static_cast<unsig'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned long long\n      quiet_NaN() noexcept\n      { return static_cast<unsigned long long>(0); }\n\n      static constexpr unsigned long long\n      signaling_NaN() noexcept\n      { return static_cast<'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned long long\n      signaling_NaN() noexcept\n      { return static_cast<unsigned long long>(0); }\n\n      static constexpr unsigned long long\n      denorm_min() noexcept\n      { return static_cast'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned long long\n      denorm_min() noexcept\n      { return static_cast<unsigned long long>(0); }\n\n      static constexpr bool is_iec559 = false;\n      static constexpr bool is_bounded = true;\n     '
[#] parse_declaration, is_constructor=False, meet line: 'bool is_iec559 = false;\n      static constexpr bool is_bounded = true;\n      static constexpr bool is_modulo = true;\n\n      static constexpr bool traps = true;\n      static constexpr bool tinyness_bef'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_bounded = true;\n      static constexpr bool is_modulo = true;\n\n      static constexpr bool traps = true;\n      static constexpr bool tinyness_before = false;\n      static constexpr float_round'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_modulo = true;\n\n      static constexpr bool traps = true;\n      static constexpr bool tinyness_before = false;\n      static constexpr float_round_style round_style\n       = round_toward_zero;\n'
[#] parse_declaration, is_constructor=False, meet line: 'bool traps = true;\n      static constexpr bool tinyness_before = false;\n      static constexpr float_round_style round_style\n       = round_toward_zero;\n    };\n# 1570 "/usr/include/c++/7/limits" 3\n  t'
[#] parse_declaration, is_constructor=False, meet line: 'bool tinyness_before = false;\n      static constexpr float_round_style round_style\n       = round_toward_zero;\n    };\n# 1570 "/usr/include/c++/7/limits" 3\n  template<> struct numeric_limits<__int128> '
[#] parse_declaration, is_constructor=False, meet line: 'float_round_style round_style\n       = round_toward_zero;\n    };\n# 1570 "/usr/include/c++/7/limits" 3\n  template<> struct numeric_limits<__int128> { static constexpr bool is_specialized = true; static'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_specialized = true; static constexpr __int128 min() noexcept { return (((__int128)(-1) < 0) ? -(((__int128)(-1) < 0) ? (((((__int128)1 << ((128 - ((__int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : '
[#] parse_declaration, is_constructor=False, meet line: '__int128 min() noexcept { return (((__int128)(-1) < 0) ? -(((__int128)(-1) < 0) ? (((((__int128)1 << ((128 - ((__int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(__int128)0) - 1 : (__int128)0); } static co'
[#] parse_declaration, is_constructor=False, meet line: '__int128 max() noexcept { return (((__int128)(-1) < 0) ? (((((__int128)1 << ((128 - ((__int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(__int128)0); } static constexpr int digits = 128 - 1; static constex'
[#] parse_declaration, is_constructor=False, meet line: 'int digits = 128 - 1; static constexpr int digits10 = (128 - 1) * 643L / 2136; static constexpr bool is_signed = true; static constexpr bool is_integer = true; static constexpr bool is_exact = true; s'
[#] parse_declaration, is_constructor=False, meet line: 'int digits10 = (128 - 1) * 643L / 2136; static constexpr bool is_signed = true; static constexpr bool is_integer = true; static constexpr bool is_exact = true; static constexpr int radix = 2; static c'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_signed = true; static constexpr bool is_integer = true; static constexpr bool is_exact = true; static constexpr int radix = 2; static constexpr __int128 epsilon() noexcept { return 0; } static'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_integer = true; static constexpr bool is_exact = true; static constexpr int radix = 2; static constexpr __int128 epsilon() noexcept { return 0; } static constexpr __int128 round_error() noexce'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_exact = true; static constexpr int radix = 2; static constexpr __int128 epsilon() noexcept { return 0; } static constexpr __int128 round_error() noexcept { return 0; } static constexpr __int12'
[#] parse_declaration, is_constructor=False, meet line: 'int radix = 2; static constexpr __int128 epsilon() noexcept { return 0; } static constexpr __int128 round_error() noexcept { return 0; } static constexpr __int128 lowest() noexcept { return min(); } s'
[#] parse_declaration, is_constructor=False, meet line: '__int128 epsilon() noexcept { return 0; } static constexpr __int128 round_error() noexcept { return 0; } static constexpr __int128 lowest() noexcept { return min(); } static constexpr int max_digits10'
[#] parse_declaration, is_constructor=False, meet line: '__int128 round_error() noexcept { return 0; } static constexpr __int128 lowest() noexcept { return min(); } static constexpr int max_digits10 = 0; static constexpr int min_exponent = 0; static constex'
[#] parse_declaration, is_constructor=False, meet line: '__int128 lowest() noexcept { return min(); } static constexpr int max_digits10 = 0; static constexpr int min_exponent = 0; static constexpr int min_exponent10 = 0; static constexpr int max_exponent = '
[#] parse_declaration, is_constructor=False, meet line: 'int max_digits10 = 0; static constexpr int min_exponent = 0; static constexpr int min_exponent10 = 0; static constexpr int max_exponent = 0; static constexpr int max_exponent10 = 0; static constexpr b'
[#] parse_declaration, is_constructor=False, meet line: 'int min_exponent = 0; static constexpr int min_exponent10 = 0; static constexpr int max_exponent = 0; static constexpr int max_exponent10 = 0; static constexpr bool has_infinity = false; static conste'
[#] parse_declaration, is_constructor=False, meet line: 'int min_exponent10 = 0; static constexpr int max_exponent = 0; static constexpr int max_exponent10 = 0; static constexpr bool has_infinity = false; static constexpr bool has_quiet_NaN = false; static '
[#] parse_declaration, is_constructor=False, meet line: 'int max_exponent = 0; static constexpr int max_exponent10 = 0; static constexpr bool has_infinity = false; static constexpr bool has_quiet_NaN = false; static constexpr bool has_signaling_NaN = false;'
[#] parse_declaration, is_constructor=False, meet line: 'int max_exponent10 = 0; static constexpr bool has_infinity = false; static constexpr bool has_quiet_NaN = false; static constexpr bool has_signaling_NaN = false; static constexpr float_denorm_style ha'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_infinity = false; static constexpr bool has_quiet_NaN = false; static constexpr bool has_signaling_NaN = false; static constexpr float_denorm_style has_denorm = denorm_absent; static constexp'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_quiet_NaN = false; static constexpr bool has_signaling_NaN = false; static constexpr float_denorm_style has_denorm = denorm_absent; static constexpr bool has_denorm_loss = false; static const'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_signaling_NaN = false; static constexpr float_denorm_style has_denorm = denorm_absent; static constexpr bool has_denorm_loss = false; static constexpr __int128 infinity() noexcept { return st'
[#] parse_declaration, is_constructor=False, meet line: 'float_denorm_style has_denorm = denorm_absent; static constexpr bool has_denorm_loss = false; static constexpr __int128 infinity() noexcept { return static_cast<__int128>(0); } static constexpr __int1'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_denorm_loss = false; static constexpr __int128 infinity() noexcept { return static_cast<__int128>(0); } static constexpr __int128 quiet_NaN() noexcept { return static_cast<__int128>(0); } sta'
[#] parse_declaration, is_constructor=False, meet line: '__int128 infinity() noexcept { return static_cast<__int128>(0); } static constexpr __int128 quiet_NaN() noexcept { return static_cast<__int128>(0); } static constexpr __int128 signaling_NaN() noexcept'
[#] parse_declaration, is_constructor=False, meet line: '__int128 quiet_NaN() noexcept { return static_cast<__int128>(0); } static constexpr __int128 signaling_NaN() noexcept { return static_cast<__int128>(0); } static constexpr __int128 denorm_min() noexce'
[#] parse_declaration, is_constructor=False, meet line: '__int128 signaling_NaN() noexcept { return static_cast<__int128>(0); } static constexpr __int128 denorm_min() noexcept { return static_cast<__int128>(0); } static constexpr bool is_iec559 = false; sta'
[#] parse_declaration, is_constructor=False, meet line: '__int128 denorm_min() noexcept { return static_cast<__int128>(0); } static constexpr bool is_iec559 = false; static constexpr bool is_bounded = true; static constexpr bool is_modulo = false; static co'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_iec559 = false; static constexpr bool is_bounded = true; static constexpr bool is_modulo = false; static constexpr bool traps = true; static constexpr bool tinyness_before = false; static cons'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_bounded = true; static constexpr bool is_modulo = false; static constexpr bool traps = true; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = rou'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_modulo = false; static constexpr bool traps = true; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = round_toward_zero; }; template<> struct nume'
[#] parse_declaration, is_constructor=False, meet line: 'bool traps = true; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = round_toward_zero; }; template<> struct numeric_limits<unsigned __int128> { static co'
[#] parse_declaration, is_constructor=False, meet line: 'bool tinyness_before = false; static constexpr float_round_style round_style = round_toward_zero; }; template<> struct numeric_limits<unsigned __int128> { static constexpr bool is_specialized = true; '
[#] parse_declaration, is_constructor=False, meet line: 'float_round_style round_style = round_toward_zero; }; template<> struct numeric_limits<unsigned __int128> { static constexpr bool is_specialized = true; static constexpr unsigned __int128 min() noexce'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_specialized = true; static constexpr unsigned __int128 min() noexcept { return 0; } static constexpr unsigned __int128 max() noexcept { return (((unsigned __int128)(-1) < 0) ? (((((unsigned __'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned __int128 min() noexcept { return 0; } static constexpr unsigned __int128 max() noexcept { return (((unsigned __int128)(-1) < 0) ? (((((unsigned __int128)1 << ((128 - ((unsigned __int128)(-1) '
[#] parse_declaration, is_constructor=False, meet line: 'unsigned __int128 max() noexcept { return (((unsigned __int128)(-1) < 0) ? (((((unsigned __int128)1 << ((128 - ((unsigned __int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(unsigned __int128)0); } static c'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned __int128 lowest() noexcept { return min(); } static constexpr int max_digits10 = 0; static constexpr int digits = 128; static constexpr int digits10 = 128 * 643L / 2136; static constexpr bool'
[#] parse_declaration, is_constructor=False, meet line: 'int max_digits10 = 0; static constexpr int digits = 128; static constexpr int digits10 = 128 * 643L / 2136; static constexpr bool is_signed = false; static constexpr bool is_integer = true; static con'
[#] parse_declaration, is_constructor=False, meet line: 'int digits = 128; static constexpr int digits10 = 128 * 643L / 2136; static constexpr bool is_signed = false; static constexpr bool is_integer = true; static constexpr bool is_exact = true; static con'
[#] parse_declaration, is_constructor=False, meet line: 'int digits10 = 128 * 643L / 2136; static constexpr bool is_signed = false; static constexpr bool is_integer = true; static constexpr bool is_exact = true; static constexpr int radix = 2; static conste'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_signed = false; static constexpr bool is_integer = true; static constexpr bool is_exact = true; static constexpr int radix = 2; static constexpr unsigned __int128 epsilon() noexcept { return 0'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_integer = true; static constexpr bool is_exact = true; static constexpr int radix = 2; static constexpr unsigned __int128 epsilon() noexcept { return 0; } static constexpr unsigned __int128 ro'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_exact = true; static constexpr int radix = 2; static constexpr unsigned __int128 epsilon() noexcept { return 0; } static constexpr unsigned __int128 round_error() noexcept { return 0; } static'
[#] parse_declaration, is_constructor=False, meet line: 'int radix = 2; static constexpr unsigned __int128 epsilon() noexcept { return 0; } static constexpr unsigned __int128 round_error() noexcept { return 0; } static constexpr int min_exponent = 0; static'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned __int128 epsilon() noexcept { return 0; } static constexpr unsigned __int128 round_error() noexcept { return 0; } static constexpr int min_exponent = 0; static constexpr int min_exponent10 = '
[#] parse_declaration, is_constructor=False, meet line: 'unsigned __int128 round_error() noexcept { return 0; } static constexpr int min_exponent = 0; static constexpr int min_exponent10 = 0; static constexpr int max_exponent = 0; static constexpr int max_e'
[#] parse_declaration, is_constructor=False, meet line: 'int min_exponent = 0; static constexpr int min_exponent10 = 0; static constexpr int max_exponent = 0; static constexpr int max_exponent10 = 0; static constexpr bool has_infinity = false; static conste'
[#] parse_declaration, is_constructor=False, meet line: 'int min_exponent10 = 0; static constexpr int max_exponent = 0; static constexpr int max_exponent10 = 0; static constexpr bool has_infinity = false; static constexpr bool has_quiet_NaN = false; static '
[#] parse_declaration, is_constructor=False, meet line: 'int max_exponent = 0; static constexpr int max_exponent10 = 0; static constexpr bool has_infinity = false; static constexpr bool has_quiet_NaN = false; static constexpr bool has_signaling_NaN = false;'
[#] parse_declaration, is_constructor=False, meet line: 'int max_exponent10 = 0; static constexpr bool has_infinity = false; static constexpr bool has_quiet_NaN = false; static constexpr bool has_signaling_NaN = false; static constexpr float_denorm_style ha'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_infinity = false; static constexpr bool has_quiet_NaN = false; static constexpr bool has_signaling_NaN = false; static constexpr float_denorm_style has_denorm = denorm_absent; static constexp'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_quiet_NaN = false; static constexpr bool has_signaling_NaN = false; static constexpr float_denorm_style has_denorm = denorm_absent; static constexpr bool has_denorm_loss = false; static const'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_signaling_NaN = false; static constexpr float_denorm_style has_denorm = denorm_absent; static constexpr bool has_denorm_loss = false; static constexpr unsigned __int128 infinity() noexcept { '
[#] parse_declaration, is_constructor=False, meet line: 'float_denorm_style has_denorm = denorm_absent; static constexpr bool has_denorm_loss = false; static constexpr unsigned __int128 infinity() noexcept { return static_cast<unsigned __int128>(0); } stati'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_denorm_loss = false; static constexpr unsigned __int128 infinity() noexcept { return static_cast<unsigned __int128>(0); } static constexpr unsigned __int128 quiet_NaN() noexcept { return stat'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned __int128 infinity() noexcept { return static_cast<unsigned __int128>(0); } static constexpr unsigned __int128 quiet_NaN() noexcept { return static_cast<unsigned __int128>(0); } static constex'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned __int128 quiet_NaN() noexcept { return static_cast<unsigned __int128>(0); } static constexpr unsigned __int128 signaling_NaN() noexcept { return static_cast<unsigned __int128>(0); } static co'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned __int128 signaling_NaN() noexcept { return static_cast<unsigned __int128>(0); } static constexpr unsigned __int128 denorm_min() noexcept { return static_cast<unsigned __int128>(0); } static c'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned __int128 denorm_min() noexcept { return static_cast<unsigned __int128>(0); } static constexpr bool is_iec559 = false; static constexpr bool is_bounded = true; static constexpr bool is_modulo '
[#] parse_declaration, is_constructor=False, meet line: 'bool is_iec559 = false; static constexpr bool is_bounded = true; static constexpr bool is_modulo = true; static constexpr bool traps = true; static constexpr bool tinyness_before = false; static const'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_bounded = true; static constexpr bool is_modulo = true; static constexpr bool traps = true; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = roun'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_modulo = true; static constexpr bool traps = true; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = round_toward_zero; };\n# 1593 "/usr/include/c+'
[#] parse_declaration, is_constructor=False, meet line: 'bool traps = true; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = round_toward_zero; };\n# 1593 "/usr/include/c++/7/limits" 3\n  template<>\n    struct nu'
[#] parse_declaration, is_constructor=False, meet line: 'bool tinyness_before = false; static constexpr float_round_style round_style = round_toward_zero; };\n# 1593 "/usr/include/c++/7/limits" 3\n  template<>\n    struct numeric_limits<float>\n    {\n      stat'
[#] parse_declaration, is_constructor=False, meet line: 'float_round_style round_style = round_toward_zero; };\n# 1593 "/usr/include/c++/7/limits" 3\n  template<>\n    struct numeric_limits<float>\n    {\n      static constexpr bool is_specialized = true;\n\n     '
[#] parse_declaration, is_constructor=False, meet line: 'bool is_specialized = true;\n\n      static constexpr float\n      min() noexcept { return 1.17549435082228750796873653722224568e-38F; }\n\n      static constexpr float\n      max() noexcept { return 3.4028'
[#] parse_declaration, is_constructor=False, meet line: 'float\n      min() noexcept { return 1.17549435082228750796873653722224568e-38F; }\n\n      static constexpr float\n      max() noexcept { return 3.40282346638528859811704183484516925e+38F; }\n\n\n      stat'
[#] parse_declaration, is_constructor=False, meet line: 'float\n      max() noexcept { return 3.40282346638528859811704183484516925e+38F; }\n\n\n      static constexpr float\n      lowest() noexcept { return -3.40282346638528859811704183484516925e+38F; }\n\n\n     '
[#] parse_declaration, is_constructor=False, meet line: 'float\n      lowest() noexcept { return -3.40282346638528859811704183484516925e+38F; }\n\n\n      static constexpr int digits = 24;\n      static constexpr int digits10 = 6;\n\n      static constexpr int max'
[#] parse_declaration, is_constructor=False, meet line: 'int digits = 24;\n      static constexpr int digits10 = 6;\n\n      static constexpr int max_digits10\n  = (2 + (24) * 643L / 2136);\n\n      static constexpr bool is_signed = true;\n      static constexpr b'
[#] parse_declaration, is_constructor=False, meet line: 'int digits10 = 6;\n\n      static constexpr int max_digits10\n  = (2 + (24) * 643L / 2136);\n\n      static constexpr bool is_signed = true;\n      static constexpr bool is_integer = false;\n      static con'
[#] parse_declaration, is_constructor=False, meet line: 'int max_digits10\n  = (2 + (24) * 643L / 2136);\n\n      static constexpr bool is_signed = true;\n      static constexpr bool is_integer = false;\n      static constexpr bool is_exact = false;\n      static'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_signed = true;\n      static constexpr bool is_integer = false;\n      static constexpr bool is_exact = false;\n      static constexpr int radix = 2;\n\n      static constexpr float\n      epsilon()'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_integer = false;\n      static constexpr bool is_exact = false;\n      static constexpr int radix = 2;\n\n      static constexpr float\n      epsilon() noexcept { return 1.1920928955078125000000000'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_exact = false;\n      static constexpr int radix = 2;\n\n      static constexpr float\n      epsilon() noexcept { return 1.19209289550781250000000000000000000e-7F; }\n\n      static constexpr float\n'
[#] parse_declaration, is_constructor=False, meet line: 'int radix = 2;\n\n      static constexpr float\n      epsilon() noexcept { return 1.19209289550781250000000000000000000e-7F; }\n\n      static constexpr float\n      round_error() noexcept { return 0.5F; }\n'
[#] parse_declaration, is_constructor=False, meet line: 'float\n      epsilon() noexcept { return 1.19209289550781250000000000000000000e-7F; }\n\n      static constexpr float\n      round_error() noexcept { return 0.5F; }\n\n      static constexpr int min_exponen'
[#] parse_declaration, is_constructor=False, meet line: 'float\n      round_error() noexcept { return 0.5F; }\n\n      static constexpr int min_exponent = (-125);\n      static constexpr int min_exponent10 = (-37);\n      static constexpr int max_exponent = 128;'
[#] parse_declaration, is_constructor=False, meet line: 'int min_exponent = (-125);\n      static constexpr int min_exponent10 = (-37);\n      static constexpr int max_exponent = 128;\n      static constexpr int max_exponent10 = 38;\n\n      static constexpr boo'
[#] parse_declaration, is_constructor=False, meet line: 'int min_exponent10 = (-37);\n      static constexpr int max_exponent = 128;\n      static constexpr int max_exponent10 = 38;\n\n      static constexpr bool has_infinity = 1;\n      static constexpr bool ha'
[#] parse_declaration, is_constructor=False, meet line: 'int max_exponent = 128;\n      static constexpr int max_exponent10 = 38;\n\n      static constexpr bool has_infinity = 1;\n      static constexpr bool has_quiet_NaN = 1;\n      static constexpr bool has_si'
[#] parse_declaration, is_constructor=False, meet line: 'int max_exponent10 = 38;\n\n      static constexpr bool has_infinity = 1;\n      static constexpr bool has_quiet_NaN = 1;\n      static constexpr bool has_signaling_NaN = has_quiet_NaN;\n      static const'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_infinity = 1;\n      static constexpr bool has_quiet_NaN = 1;\n      static constexpr bool has_signaling_NaN = has_quiet_NaN;\n      static constexpr float_denorm_style has_denorm\n = bool(1) ? d'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_quiet_NaN = 1;\n      static constexpr bool has_signaling_NaN = has_quiet_NaN;\n      static constexpr float_denorm_style has_denorm\n = bool(1) ? denorm_present : denorm_absent;\n      static co'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_signaling_NaN = has_quiet_NaN;\n      static constexpr float_denorm_style has_denorm\n = bool(1) ? denorm_present : denorm_absent;\n      static constexpr bool has_denorm_loss\n       = false;\n\n '
[#] parse_declaration, is_constructor=False, meet line: 'float_denorm_style has_denorm\n = bool(1) ? denorm_present : denorm_absent;\n      static constexpr bool has_denorm_loss\n       = false;\n\n      static constexpr float\n      infinity() noexcept { return '
[#] parse_declaration, is_constructor=False, meet line: 'bool has_denorm_loss\n       = false;\n\n      static constexpr float\n      infinity() noexcept { return __builtin_huge_valf(); }\n\n      static constexpr float\n      quiet_NaN() noexcept { return __built'
[#] parse_declaration, is_constructor=False, meet line: 'float\n      infinity() noexcept { return __builtin_huge_valf(); }\n\n      static constexpr float\n      quiet_NaN() noexcept { return __builtin_nanf(""); }\n\n      static constexpr float\n      signaling_'
[#] parse_declaration, is_constructor=False, meet line: 'float\n      quiet_NaN() noexcept { return __builtin_nanf(""); }\n\n      static constexpr float\n      signaling_NaN() noexcept { return __builtin_nansf(""); }\n\n      static constexpr float\n      denorm_'
[#] parse_declaration, is_constructor=False, meet line: 'float\n      signaling_NaN() noexcept { return __builtin_nansf(""); }\n\n      static constexpr float\n      denorm_min() noexcept { return 1.40129846432481707092372958328991613e-45F; }\n\n      static cons'
[#] parse_declaration, is_constructor=False, meet line: 'float\n      denorm_min() noexcept { return 1.40129846432481707092372958328991613e-45F; }\n\n      static constexpr bool is_iec559\n = has_infinity && has_quiet_NaN && has_denorm == denorm_present;\n      '
[#] parse_declaration, is_constructor=False, meet line: 'bool is_iec559\n = has_infinity && has_quiet_NaN && has_denorm == denorm_present;\n      static constexpr bool is_bounded = true;\n      static constexpr bool is_modulo = false;\n\n      static constexpr b'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_bounded = true;\n      static constexpr bool is_modulo = false;\n\n      static constexpr bool traps = false;\n      static constexpr bool tinyness_before\n       = false;\n      static constexpr fl'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_modulo = false;\n\n      static constexpr bool traps = false;\n      static constexpr bool tinyness_before\n       = false;\n      static constexpr float_round_style round_style\n       = round_to_n'
[#] parse_declaration, is_constructor=False, meet line: 'bool traps = false;\n      static constexpr bool tinyness_before\n       = false;\n      static constexpr float_round_style round_style\n       = round_to_nearest;\n    };\n\n\n\n\n\n\n  template<>\n    struct num'
[#] parse_declaration, is_constructor=False, meet line: 'bool tinyness_before\n       = false;\n      static constexpr float_round_style round_style\n       = round_to_nearest;\n    };\n\n\n\n\n\n\n  template<>\n    struct numeric_limits<double>\n    {\n      static cons'
[#] parse_declaration, is_constructor=False, meet line: 'float_round_style round_style\n       = round_to_nearest;\n    };\n\n\n\n\n\n\n  template<>\n    struct numeric_limits<double>\n    {\n      static constexpr bool is_specialized = true;\n\n      static constexpr do'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_specialized = true;\n\n      static constexpr double\n      min() noexcept { return double(2.22507385850720138309023271733240406e-308L); }\n\n      static constexpr double\n      max() noexcept { re'
[#] parse_declaration, is_constructor=False, meet line: 'double\n      min() noexcept { return double(2.22507385850720138309023271733240406e-308L); }\n\n      static constexpr double\n      max() noexcept { return double(1.79769313486231570814527423731704357e+3'
[#] parse_declaration, is_constructor=False, meet line: 'double\n      max() noexcept { return double(1.79769313486231570814527423731704357e+308L); }\n\n\n      static constexpr double\n      lowest() noexcept { return -double(1.797693134862315708145274237317043'
[#] parse_declaration, is_constructor=False, meet line: 'double\n      lowest() noexcept { return -double(1.79769313486231570814527423731704357e+308L); }\n\n\n      static constexpr int digits = 53;\n      static constexpr int digits10 = 15;\n\n      static conste'
[#] parse_declaration, is_constructor=False, meet line: 'int digits = 53;\n      static constexpr int digits10 = 15;\n\n      static constexpr int max_digits10\n  = (2 + (53) * 643L / 2136);\n\n      static constexpr bool is_signed = true;\n      static constexpr '
[#] parse_declaration, is_constructor=False, meet line: 'int digits10 = 15;\n\n      static constexpr int max_digits10\n  = (2 + (53) * 643L / 2136);\n\n      static constexpr bool is_signed = true;\n      static constexpr bool is_integer = false;\n      static co'
[#] parse_declaration, is_constructor=False, meet line: 'int max_digits10\n  = (2 + (53) * 643L / 2136);\n\n      static constexpr bool is_signed = true;\n      static constexpr bool is_integer = false;\n      static constexpr bool is_exact = false;\n      static'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_signed = true;\n      static constexpr bool is_integer = false;\n      static constexpr bool is_exact = false;\n      static constexpr int radix = 2;\n\n      static constexpr double\n      epsilon('
[#] parse_declaration, is_constructor=False, meet line: 'bool is_integer = false;\n      static constexpr bool is_exact = false;\n      static constexpr int radix = 2;\n\n      static constexpr double\n      epsilon() noexcept { return double(2.22044604925031308'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_exact = false;\n      static constexpr int radix = 2;\n\n      static constexpr double\n      epsilon() noexcept { return double(2.22044604925031308084726333618164062e-16L); }\n\n      static conste'
[#] parse_declaration, is_constructor=False, meet line: 'int radix = 2;\n\n      static constexpr double\n      epsilon() noexcept { return double(2.22044604925031308084726333618164062e-16L); }\n\n      static constexpr double\n      round_error() noexcept { retu'
[#] parse_declaration, is_constructor=False, meet line: 'double\n      epsilon() noexcept { return double(2.22044604925031308084726333618164062e-16L); }\n\n      static constexpr double\n      round_error() noexcept { return 0.5; }\n\n      static constexpr int m'
[#] parse_declaration, is_constructor=False, meet line: 'double\n      round_error() noexcept { return 0.5; }\n\n      static constexpr int min_exponent = (-1021);\n      static constexpr int min_exponent10 = (-307);\n      static constexpr int max_exponent = 10'
[#] parse_declaration, is_constructor=False, meet line: 'int min_exponent = (-1021);\n      static constexpr int min_exponent10 = (-307);\n      static constexpr int max_exponent = 1024;\n      static constexpr int max_exponent10 = 308;\n\n      static constexpr'
[#] parse_declaration, is_constructor=False, meet line: 'int min_exponent10 = (-307);\n      static constexpr int max_exponent = 1024;\n      static constexpr int max_exponent10 = 308;\n\n      static constexpr bool has_infinity = 1;\n      static constexpr bool'
[#] parse_declaration, is_constructor=False, meet line: 'int max_exponent = 1024;\n      static constexpr int max_exponent10 = 308;\n\n      static constexpr bool has_infinity = 1;\n      static constexpr bool has_quiet_NaN = 1;\n      static constexpr bool has_'
[#] parse_declaration, is_constructor=False, meet line: 'int max_exponent10 = 308;\n\n      static constexpr bool has_infinity = 1;\n      static constexpr bool has_quiet_NaN = 1;\n      static constexpr bool has_signaling_NaN = has_quiet_NaN;\n      static cons'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_infinity = 1;\n      static constexpr bool has_quiet_NaN = 1;\n      static constexpr bool has_signaling_NaN = has_quiet_NaN;\n      static constexpr float_denorm_style has_denorm\n = bool(1) ? d'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_quiet_NaN = 1;\n      static constexpr bool has_signaling_NaN = has_quiet_NaN;\n      static constexpr float_denorm_style has_denorm\n = bool(1) ? denorm_present : denorm_absent;\n      static co'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_signaling_NaN = has_quiet_NaN;\n      static constexpr float_denorm_style has_denorm\n = bool(1) ? denorm_present : denorm_absent;\n      static constexpr bool has_denorm_loss\n        = false;\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'float_denorm_style has_denorm\n = bool(1) ? denorm_present : denorm_absent;\n      static constexpr bool has_denorm_loss\n        = false;\n\n      static constexpr double\n      infinity() noexcept { retur'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_denorm_loss\n        = false;\n\n      static constexpr double\n      infinity() noexcept { return __builtin_huge_val(); }\n\n      static constexpr double\n      quiet_NaN() noexcept { return __bui'
[#] parse_declaration, is_constructor=False, meet line: 'double\n      infinity() noexcept { return __builtin_huge_val(); }\n\n      static constexpr double\n      quiet_NaN() noexcept { return __builtin_nan(""); }\n\n      static constexpr double\n      signaling'
[#] parse_declaration, is_constructor=False, meet line: 'double\n      quiet_NaN() noexcept { return __builtin_nan(""); }\n\n      static constexpr double\n      signaling_NaN() noexcept { return __builtin_nans(""); }\n\n      static constexpr double\n      denorm'
[#] parse_declaration, is_constructor=False, meet line: 'double\n      signaling_NaN() noexcept { return __builtin_nans(""); }\n\n      static constexpr double\n      denorm_min() noexcept { return double(4.94065645841246544176568792868221372e-324L); }\n\n      s'
[#] parse_declaration, is_constructor=False, meet line: 'double\n      denorm_min() noexcept { return double(4.94065645841246544176568792868221372e-324L); }\n\n      static constexpr bool is_iec559\n = has_infinity && has_quiet_NaN && has_denorm == denorm_prese'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_iec559\n = has_infinity && has_quiet_NaN && has_denorm == denorm_present;\n      static constexpr bool is_bounded = true;\n      static constexpr bool is_modulo = false;\n\n      static constexpr b'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_bounded = true;\n      static constexpr bool is_modulo = false;\n\n      static constexpr bool traps = false;\n      static constexpr bool tinyness_before\n       = false;\n      static constexpr fl'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_modulo = false;\n\n      static constexpr bool traps = false;\n      static constexpr bool tinyness_before\n       = false;\n      static constexpr float_round_style round_style\n       = round_to_n'
[#] parse_declaration, is_constructor=False, meet line: 'bool traps = false;\n      static constexpr bool tinyness_before\n       = false;\n      static constexpr float_round_style round_style\n       = round_to_nearest;\n    };\n\n\n\n\n\n\n  template<>\n    struct num'
[#] parse_declaration, is_constructor=False, meet line: 'bool tinyness_before\n       = false;\n      static constexpr float_round_style round_style\n       = round_to_nearest;\n    };\n\n\n\n\n\n\n  template<>\n    struct numeric_limits<long double>\n    {\n      static'
[#] parse_declaration, is_constructor=False, meet line: 'float_round_style round_style\n       = round_to_nearest;\n    };\n\n\n\n\n\n\n  template<>\n    struct numeric_limits<long double>\n    {\n      static constexpr bool is_specialized = true;\n\n      static constex'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_specialized = true;\n\n      static constexpr long double\n      min() noexcept { return 3.36210314311209350626267781732175260e-4932L; }\n\n      static constexpr long double\n      max() noexcept {'
[#] parse_declaration, is_constructor=False, meet line: 'long double\n      min() noexcept { return 3.36210314311209350626267781732175260e-4932L; }\n\n      static constexpr long double\n      max() noexcept { return 1.18973149535723176502126385303097021e+4932L'
[#] parse_declaration, is_constructor=False, meet line: 'long double\n      max() noexcept { return 1.18973149535723176502126385303097021e+4932L; }\n\n\n      static constexpr long double\n      lowest() noexcept { return -1.18973149535723176502126385303097021e+'
[#] parse_declaration, is_constructor=False, meet line: 'long double\n      lowest() noexcept { return -1.18973149535723176502126385303097021e+4932L; }\n\n\n      static constexpr int digits = 64;\n      static constexpr int digits10 = 18;\n\n      static constexp'
[#] parse_declaration, is_constructor=False, meet line: 'int digits = 64;\n      static constexpr int digits10 = 18;\n\n      static constexpr int max_digits10\n  = (2 + (64) * 643L / 2136);\n\n      static constexpr bool is_signed = true;\n      static constexpr '
[#] parse_declaration, is_constructor=False, meet line: 'int digits10 = 18;\n\n      static constexpr int max_digits10\n  = (2 + (64) * 643L / 2136);\n\n      static constexpr bool is_signed = true;\n      static constexpr bool is_integer = false;\n      static co'
[#] parse_declaration, is_constructor=False, meet line: 'int max_digits10\n  = (2 + (64) * 643L / 2136);\n\n      static constexpr bool is_signed = true;\n      static constexpr bool is_integer = false;\n      static constexpr bool is_exact = false;\n      static'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_signed = true;\n      static constexpr bool is_integer = false;\n      static constexpr bool is_exact = false;\n      static constexpr int radix = 2;\n\n      static constexpr long double\n      eps'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_integer = false;\n      static constexpr bool is_exact = false;\n      static constexpr int radix = 2;\n\n      static constexpr long double\n      epsilon() noexcept { return 1.0842021724855044340'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_exact = false;\n      static constexpr int radix = 2;\n\n      static constexpr long double\n      epsilon() noexcept { return 1.08420217248550443400745280086994171e-19L; }\n\n      static constexpr'
[#] parse_declaration, is_constructor=False, meet line: 'int radix = 2;\n\n      static constexpr long double\n      epsilon() noexcept { return 1.08420217248550443400745280086994171e-19L; }\n\n      static constexpr long double\n      round_error() noexcept { re'
[#] parse_declaration, is_constructor=False, meet line: 'long double\n      epsilon() noexcept { return 1.08420217248550443400745280086994171e-19L; }\n\n      static constexpr long double\n      round_error() noexcept { return 0.5L; }\n\n      static constexpr in'
[#] parse_declaration, is_constructor=False, meet line: 'long double\n      round_error() noexcept { return 0.5L; }\n\n      static constexpr int min_exponent = (-16381);\n      static constexpr int min_exponent10 = (-4931);\n      static constexpr int max_expon'
[#] parse_declaration, is_constructor=False, meet line: 'int min_exponent = (-16381);\n      static constexpr int min_exponent10 = (-4931);\n      static constexpr int max_exponent = 16384;\n      static constexpr int max_exponent10 = 4932;\n\n      static const'
[#] parse_declaration, is_constructor=False, meet line: 'int min_exponent10 = (-4931);\n      static constexpr int max_exponent = 16384;\n      static constexpr int max_exponent10 = 4932;\n\n      static constexpr bool has_infinity = 1;\n      static constexpr b'
[#] parse_declaration, is_constructor=False, meet line: 'int max_exponent = 16384;\n      static constexpr int max_exponent10 = 4932;\n\n      static constexpr bool has_infinity = 1;\n      static constexpr bool has_quiet_NaN = 1;\n      static constexpr bool ha'
[#] parse_declaration, is_constructor=False, meet line: 'int max_exponent10 = 4932;\n\n      static constexpr bool has_infinity = 1;\n      static constexpr bool has_quiet_NaN = 1;\n      static constexpr bool has_signaling_NaN = has_quiet_NaN;\n      static con'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_infinity = 1;\n      static constexpr bool has_quiet_NaN = 1;\n      static constexpr bool has_signaling_NaN = has_quiet_NaN;\n      static constexpr float_denorm_style has_denorm\n = bool(1) ? d'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_quiet_NaN = 1;\n      static constexpr bool has_signaling_NaN = has_quiet_NaN;\n      static constexpr float_denorm_style has_denorm\n = bool(1) ? denorm_present : denorm_absent;\n      static co'
[#] parse_declaration, is_constructor=False, meet line: 'bool has_signaling_NaN = has_quiet_NaN;\n      static constexpr float_denorm_style has_denorm\n = bool(1) ? denorm_present : denorm_absent;\n      static constexpr bool has_denorm_loss\n = false;\n\n      s'
[#] parse_declaration, is_constructor=False, meet line: 'float_denorm_style has_denorm\n = bool(1) ? denorm_present : denorm_absent;\n      static constexpr bool has_denorm_loss\n = false;\n\n      static constexpr long double\n      infinity() noexcept { return '
[#] parse_declaration, is_constructor=False, meet line: 'bool has_denorm_loss\n = false;\n\n      static constexpr long double\n      infinity() noexcept { return __builtin_huge_vall(); }\n\n      static constexpr long double\n      quiet_NaN() noexcept { return _'
[#] parse_declaration, is_constructor=False, meet line: 'long double\n      infinity() noexcept { return __builtin_huge_vall(); }\n\n      static constexpr long double\n      quiet_NaN() noexcept { return __builtin_nanl(""); }\n\n      static constexpr long doubl'
[#] parse_declaration, is_constructor=False, meet line: 'long double\n      quiet_NaN() noexcept { return __builtin_nanl(""); }\n\n      static constexpr long double\n      signaling_NaN() noexcept { return __builtin_nansl(""); }\n\n      static constexpr long do'
[#] parse_declaration, is_constructor=False, meet line: 'long double\n      signaling_NaN() noexcept { return __builtin_nansl(""); }\n\n      static constexpr long double\n      denorm_min() noexcept { return 3.64519953188247460252840593361941982e-4951L; }\n\n   '
[#] parse_declaration, is_constructor=False, meet line: 'long double\n      denorm_min() noexcept { return 3.64519953188247460252840593361941982e-4951L; }\n\n      static constexpr bool is_iec559\n = has_infinity && has_quiet_NaN && has_denorm == denorm_present'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_iec559\n = has_infinity && has_quiet_NaN && has_denorm == denorm_present;\n      static constexpr bool is_bounded = true;\n      static constexpr bool is_modulo = false;\n\n      static constexpr b'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_bounded = true;\n      static constexpr bool is_modulo = false;\n\n      static constexpr bool traps = false;\n      static constexpr bool tinyness_before =\n      false;\n      static constexpr flo'
[#] parse_declaration, is_constructor=False, meet line: 'bool is_modulo = false;\n\n      static constexpr bool traps = false;\n      static constexpr bool tinyness_before =\n      false;\n      static constexpr float_round_style round_style =\n            round_'
[#] parse_declaration, is_constructor=False, meet line: 'bool traps = false;\n      static constexpr bool tinyness_before =\n      false;\n      static constexpr float_round_style round_style =\n            round_to_nearest;\n    };\n\n\n\n\n\n\n}\n# 36 "/usr/include/c+'
[#] parse_declaration, is_constructor=False, meet line: 'bool tinyness_before =\n      false;\n      static constexpr float_round_style round_style =\n            round_to_nearest;\n    };\n\n\n\n\n\n\n}\n# 36 "/usr/include/c++/7/bits/uniform_int_dist.h" 2 3\n\nnamespace'
[#] parse_declaration, is_constructor=False, meet line: 'float_round_style round_style =\n            round_to_nearest;\n    };\n\n\n\n\n\n\n}\n# 36 "/usr/include/c++/7/bits/uniform_int_dist.h" 2 3\n\nnamespace std __attribute__ ((__visibility__ ("default")))\n{\n\n  name'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      _Power_of_2(_Tp __x)\n      {\n return ((__x - 1) & __x) == 0;\n      };\n\n  }\n\n\n\n\n\n\n\n\n  template<typename _IntType = int>\n    class uniform_int_distribution\n    {\n      static_assert(std::is_i'
[#] parse_declaration, is_constructor=True, meet line: 'param_type(_IntType __a = 0,\n     _IntType __b = std::numeric_limits<_IntType>::max())\n : _M_a(__a), _M_b(__b)\n {\n   ;\n }\n\n result_type\n a() const\n { return _M_a; }\n\n result_type\n b() const\n { return '
[#] parse_declaration, is_constructor=False, meet line: 'result_type\n a() const\n { return _M_a; }\n\n result_type\n b() const\n { return _M_b; }\n\n friend bool\n operator==(const param_type& __p1, const param_type& __p2)\n { return __p1._M_a == __p2._M_a && __p1._'
[#] parse_declaration, is_constructor=False, meet line: 'result_type\n b() const\n { return _M_b; }\n\n friend bool\n operator==(const param_type& __p1, const param_type& __p2)\n { return __p1._M_a == __p2._M_a && __p1._M_b == __p2._M_b; }\n\n friend bool\n operator'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n operator==(const param_type& __p1, const param_type& __p2)\n { return __p1._M_a == __p2._M_a && __p1._M_b == __p2._M_b; }\n\n friend bool\n operator!=(const param_type& __p1, const param_type& __p2)'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n operator!=(const param_type& __p1, const param_type& __p2)\n { return !(__p1 == __p2); }\n\n      private:\n _IntType _M_a;\n _IntType _M_b;\n      };\n\n    public:\n\n\n\n      explicit\n      uniform_int_'
[#] parse_declaration, is_constructor=False, meet line: '_IntType _M_a;\n _IntType _M_b;\n      };\n\n    public:\n\n\n\n      explicit\n      uniform_int_distribution(_IntType __a = 0,\n      _IntType __b = std::numeric_limits<_IntType>::max())\n      : _M_param(__a,'
[#] parse_declaration, is_constructor=False, meet line: '_IntType _M_b;\n      };\n\n    public:\n\n\n\n      explicit\n      uniform_int_distribution(_IntType __a = 0,\n      _IntType __b = std::numeric_limits<_IntType>::max())\n      : _M_param(__a, __b)\n      { }\n'
[#] parse_declaration, is_constructor=True, meet line: 'uniform_int_distribution(_IntType __a = 0,\n      _IntType __b = std::numeric_limits<_IntType>::max())\n      : _M_param(__a, __b)\n      { }\n\n      explicit\n      uniform_int_distribution(const param_ty'
[#] parse_declaration, is_constructor=True, meet line: 'uniform_int_distribution(const param_type& __p)\n      : _M_param(__p)\n      { }\n\n\n\n\n\n\n      void\n      reset() { }\n\n      result_type\n      a() const\n      { return _M_param.a(); }\n\n      result_type\n'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      reset() { }\n\n      result_type\n      a() const\n      { return _M_param.a(); }\n\n      result_type\n      b() const\n      { return _M_param.b(); }\n\n\n\n\n      param_type\n      param() const\n    '
[#] parse_declaration, is_constructor=False, meet line: 'result_type\n      a() const\n      { return _M_param.a(); }\n\n      result_type\n      b() const\n      { return _M_param.b(); }\n\n\n\n\n      param_type\n      param() const\n      { return _M_param; }\n\n\n\n\n\n  '
[#] parse_declaration, is_constructor=False, meet line: 'result_type\n      b() const\n      { return _M_param.b(); }\n\n\n\n\n      param_type\n      param() const\n      { return _M_param; }\n\n\n\n\n\n      void\n      param(const param_type& __param)\n      { _M_param ='
[#] parse_declaration, is_constructor=False, meet line: 'param_type\n      param() const\n      { return _M_param; }\n\n\n\n\n\n      void\n      param(const param_type& __param)\n      { _M_param = __param; }\n\n\n\n\n      result_type\n      min() const\n      { return th'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      param(const param_type& __param)\n      { _M_param = __param; }\n\n\n\n\n      result_type\n      min() const\n      { return this->a(); }\n\n\n\n\n      result_type\n      max() const\n      { return thi'
[#] parse_declaration, is_constructor=False, meet line: 'result_type\n      min() const\n      { return this->a(); }\n\n\n\n\n      result_type\n      max() const\n      { return this->b(); }\n\n\n\n\n      template<typename _UniformRandomNumberGenerator>\n result_type\n o'
[#] parse_declaration, is_constructor=False, meet line: 'result_type\n      max() const\n      { return this->b(); }\n\n\n\n\n      template<typename _UniformRandomNumberGenerator>\n result_type\n operator()(_UniformRandomNumberGenerator& __urng)\n        { return th'
[#] parse_declaration, is_constructor=False, meet line: 'result_type\n operator()(_UniformRandomNumberGenerator& __urng)\n        { return this->operator()(__urng, _M_param); }\n\n      template<typename _UniformRandomNumberGenerator>\n result_type\n operator()(_'
[#] parse_declaration, is_constructor=False, meet line: 'result_type\n operator()(_UniformRandomNumberGenerator& __urng,\n     const param_type& __p);\n\n      template<typename _ForwardIterator,\n        typename _UniformRandomNumberGenerator>\n void\n __generate'
[#] parse_declaration, is_constructor=False, meet line: 'void\n __generate(_ForwardIterator __f, _ForwardIterator __t,\n     _UniformRandomNumberGenerator& __urng)\n { this->__generate(__f, __t, __urng, _M_param); }\n\n      template<typename _ForwardIterator,\n '
[#] parse_declaration, is_constructor=False, meet line: 'void\n __generate(_ForwardIterator __f, _ForwardIterator __t,\n     _UniformRandomNumberGenerator& __urng,\n     const param_type& __p)\n { this->__generate_impl(__f, __t, __urng, __p); }\n\n      template<'
[#] parse_declaration, is_constructor=False, meet line: 'void\n __generate(result_type* __f, result_type* __t,\n     _UniformRandomNumberGenerator& __urng,\n     const param_type& __p)\n { this->__generate_impl(__f, __t, __urng, __p); }\n\n\n\n\n\n      friend bool\n '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      operator==(const uniform_int_distribution& __d1,\n   const uniform_int_distribution& __d2)\n      { return __d1._M_param == __d2._M_param; }\n\n    private:\n      template<typename _ForwardIter'
[#] parse_declaration, is_constructor=False, meet line: 'void\n __generate_impl(_ForwardIterator __f, _ForwardIterator __t,\n   _UniformRandomNumberGenerator& __urng,\n   const param_type& __p);\n\n      param_type _M_param;\n    };\n\n  template<typename _IntType>'
[#] parse_declaration, is_constructor=False, meet line: 'param_type _M_param;\n    };\n\n  template<typename _IntType>\n    template<typename _UniformRandomNumberGenerator>\n      typename uniform_int_distribution<_IntType>::result_type\n      uniform_int_distrib'
[#] parse_declaration, is_constructor=False, meet line: 'uniform_int_distribution<_IntType>::result_type\n      uniform_int_distribution<_IntType>::\n      operator()(_UniformRandomNumberGenerator& __urng,\n   const param_type& __param)\n      {\n typedef typena'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      uniform_int_distribution<_IntType>::\n      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,\n        _UniformRandomNumberGenerator& __urng,\n        const param_type& __param)\n    '
[#] parse_declaration, is_constructor=False, meet line: 'void\n    __move_median_to_first(_Iterator __result,_Iterator __a, _Iterator __b,\n      _Iterator __c, _Compare __comp)\n    {\n      if (__comp(__a, __b))\n {\n   if (__comp(__b, __c))\n     std::iter_swap'
[#] parse_declaration, is_constructor=False, meet line: '_InputIterator\n    __find_if(_InputIterator __first, _InputIterator __last,\n       _Predicate __pred, input_iterator_tag)\n    {\n      while (__first != __last && !__pred(__first))\n ++__first;\n      re'
[#] parse_declaration, is_constructor=False, meet line: '_RandomAccessIterator\n    __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last,\n       _Predicate __pred, random_access_iterator_tag)\n    {\n      typename iterator_traits<_RandomAcces'
[#] parse_declaration, is_constructor=False, meet line: '_Iterator\n    __find_if(_Iterator __first, _Iterator __last, _Predicate __pred)\n    {\n      return __find_if(__first, __last, __pred,\n         std::__iterator_category(__first));\n    }\n\n\n  template<ty'
[#] parse_declaration, is_constructor=False, meet line: '_InputIterator\n    __find_if_not(_InputIterator __first, _InputIterator __last,\n    _Predicate __pred)\n    {\n      return std::__find_if(__first, __last,\n       __gnu_cxx::__ops::__negate(__pred),\n   '
[#] parse_declaration, is_constructor=False, meet line: '_InputIterator\n    __find_if_not_n(_InputIterator __first, _Distance& __len, _Predicate __pred)\n    {\n      for (; __len; --__len, ++__first)\n if (!__pred(__first))\n   break;\n      return __first;\n   '
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator1\n    __search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n      _ForwardIterator2 __first2, _ForwardIterator2 __last2,\n      _BinaryPredicate __predicate)\n    {\n\n      if ('
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n    __search_n_aux(_ForwardIterator __first, _ForwardIterator __last,\n     _Integer __count, _UnaryPredicate __unary_pred,\n     std::forward_iterator_tag)\n    {\n      __first = std::_'
[#] parse_declaration, is_constructor=False, meet line: '_RandomAccessIter\n    __search_n_aux(_RandomAccessIter __first, _RandomAccessIter __last,\n     _Integer __count, _UnaryPredicate __unary_pred,\n     std::random_access_iterator_tag)\n    {\n      typedef'
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n    __search_n(_ForwardIterator __first, _ForwardIterator __last,\n        _Integer __count,\n        _UnaryPredicate __unary_pred)\n    {\n      if (__count <= 0)\n return __first;\n\n     '
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator1\n    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n        _ForwardIterator2 __first2, _ForwardIterator2 __last2,\n        forward_iterator_tag, forward_iterator_ta'
[#] parse_declaration, is_constructor=False, meet line: '_BidirectionalIterator1\n    __find_end(_BidirectionalIterator1 __first1,\n        _BidirectionalIterator1 __last1,\n        _BidirectionalIterator2 __first2,\n        _BidirectionalIterator2 __last2,\n   '
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator1\n    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n      _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n    {\n\n     \n     \n     \n\n\n      ;\n      ;\n\n      ret'
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator1\n    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n      _ForwardIterator2 __first2, _ForwardIterator2 __last2,\n      _BinaryPredicate __comp)\n    {\n\n     \n     \n   '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    all_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n    { return __last == std::find_if_not(__first, __last, __pred); }\n# 523 "/usr/include/c++/7/bits/stl_algo.h" 3\n  tem'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    none_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n    { return __last == std::find_if(__first, __last, __pred); }\n# 541 "/usr/include/c++/7/bits/stl_algo.h" 3\n  templa'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    any_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n    { return !std::none_of(__first, __last, __pred); }\n# 556 "/usr/include/c++/7/bits/stl_algo.h" 3\n  template<typenam'
[#] parse_declaration, is_constructor=False, meet line: '_InputIterator\n    find_if_not(_InputIterator __first, _InputIterator __last,\n  _Predicate __pred)\n    {\n\n     \n     \n\n      ;\n      return std::__find_if_not(__first, __last,\n    __gnu_cxx::__ops::__'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    is_partitioned(_InputIterator __first, _InputIterator __last,\n     _Predicate __pred)\n    {\n      __first = std::find_if_not(__first, __last, __pred);\n      if (__first == __last)\n return tru'
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n    partition_point(_ForwardIterator __first, _ForwardIterator __last,\n      _Predicate __pred)\n    {\n\n     \n     \n\n\n\n      ;\n\n      typedef typename iterator_traits<_ForwardIterator>'
[#] parse_declaration, is_constructor=False, meet line: '_OutputIterator\n    __remove_copy_if(_InputIterator __first, _InputIterator __last,\n       _OutputIterator __result, _Predicate __pred)\n    {\n      for (; __first != __last; ++__first)\n if (!__pred(__'
[#] parse_declaration, is_constructor=False, meet line: '_OutputIterator\n    remove_copy(_InputIterator __first, _InputIterator __last,\n  _OutputIterator __result, const _Tp& __value)\n    {\n\n     \n     \n\n     \n\n      ;\n\n      return std::__remove_copy_if(__'
[#] parse_declaration, is_constructor=False, meet line: '_OutputIterator\n    remove_copy_if(_InputIterator __first, _InputIterator __last,\n     _OutputIterator __result, _Predicate __pred)\n    {\n\n     \n     \n\n     \n\n      ;\n\n      return std::__remove_copy_'
[#] parse_declaration, is_constructor=False, meet line: '_OutputIterator\n    copy_if(_InputIterator __first, _InputIterator __last,\n     _OutputIterator __result, _Predicate __pred)\n    {\n\n     \n     \n\n     \n\n      ;\n\n      for (; __first != __last; ++__fir'
[#] parse_declaration, is_constructor=False, meet line: '_OutputIterator\n    __copy_n(_InputIterator __first, _Size __n,\n      _OutputIterator __result, input_iterator_tag)\n    {\n      if (__n > 0)\n {\n   while (true)\n     {\n       *__result = *__first;\n    '
[#] parse_declaration, is_constructor=False, meet line: '_OutputIterator\n    __copy_n(_RandomAccessIterator __first, _Size __n,\n      _OutputIterator __result, random_access_iterator_tag)\n    { return std::copy(__first, __first + __n, __result); }\n# 797 "/u'
[#] parse_declaration, is_constructor=False, meet line: '_OutputIterator\n    copy_n(_InputIterator __first, _Size __n, _OutputIterator __result)\n    {\n\n     \n     \n\n\n      return std::__copy_n(__first, __n, __result,\n      std::__iterator_category(__first))'
[#] parse_declaration, is_constructor=False, meet line: 'pair<_OutputIterator1, _OutputIterator2>\n    partition_copy(_InputIterator __first, _InputIterator __last,\n     _OutputIterator1 __out_true, _OutputIterator2 __out_false,\n     _Predicate __pred)\n    {'
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n    __remove_if(_ForwardIterator __first, _ForwardIterator __last,\n  _Predicate __pred)\n    {\n      __first = std::__find_if(__first, __last, __pred);\n      if (__first == __last)\n re'
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n    remove(_ForwardIterator __first, _ForwardIterator __last,\n    const _Tp& __value)\n    {\n\n     \n\n     \n\n      ;\n\n      return std::__remove_if(__first, __last,\n  __gnu_cxx::__ops::'
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n    remove_if(_ForwardIterator __first, _ForwardIterator __last,\n       _Predicate __pred)\n    {\n\n     \n\n     \n\n      ;\n\n      return std::__remove_if(__first, __last,\n         __gnu_'
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n    __adjacent_find(_ForwardIterator __first, _ForwardIterator __last,\n      _BinaryPredicate __binary_pred)\n    {\n      if (__first == __last)\n return __last;\n      _ForwardIterator '
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n    __unique(_ForwardIterator __first, _ForwardIterator __last,\n      _BinaryPredicate __binary_pred)\n    {\n\n      __first = std::__adjacent_find(__first, __last, __binary_pred);\n    '
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n    unique(_ForwardIterator __first, _ForwardIterator __last)\n    {\n\n     \n\n     \n\n      ;\n\n      return std::__unique(__first, __last,\n      __gnu_cxx::__ops::__iter_equal_to_iter())'
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n    unique(_ForwardIterator __first, _ForwardIterator __last,\n    _BinaryPredicate __binary_pred)\n    {\n\n     \n\n     \n\n\n      ;\n\n      return std::__unique(__first, __last,\n      __gn'
[#] parse_declaration, is_constructor=False, meet line: '_OutputIterator\n    __unique_copy(_ForwardIterator __first, _ForwardIterator __last,\n    _OutputIterator __result, _BinaryPredicate __binary_pred,\n    forward_iterator_tag, output_iterator_tag)\n    {\n'
[#] parse_declaration, is_constructor=False, meet line: '_OutputIterator\n    __unique_copy(_InputIterator __first, _InputIterator __last,\n    _OutputIterator __result, _BinaryPredicate __binary_pred,\n    input_iterator_tag, output_iterator_tag)\n    {\n\n     '
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n    __unique_copy(_InputIterator __first, _InputIterator __last,\n    _ForwardIterator __result, _BinaryPredicate __binary_pred,\n    input_iterator_tag, forward_iterator_tag)\n    {\n\n  '
[#] parse_declaration, is_constructor=False, meet line: 'void\n    __reverse(_BidirectionalIterator __first, _BidirectionalIterator __last,\n       bidirectional_iterator_tag)\n    {\n      while (true)\n if (__first == __last || __first == --__last)\n   return;\n'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    __reverse(_RandomAccessIterator __first, _RandomAccessIterator __last,\n       random_access_iterator_tag)\n    {\n      if (__first == __last)\n return;\n      --__last;\n      while (__first < __'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)\n    {\n\n     \n\n      ;\n      std::__reverse(__first, __last, std::__iterator_category(__first));\n    }\n# 1205 "/usr/inclu'
[#] parse_declaration, is_constructor=False, meet line: '_OutputIterator\n    reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last,\n   _OutputIterator __result)\n    {\n\n     \n\n     \n\n      ;\n\n      while (__first != __last)\n {\n   --__las'
[#] parse_declaration, is_constructor=False, meet line: '_EuclideanRingElement\n    __gcd(_EuclideanRingElement __m, _EuclideanRingElement __n)\n    {\n      while (__n != 0)\n {\n   _EuclideanRingElement __t = __m % __n;\n   __m = __n;\n   __n = __t;\n }\n      ret'
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n    __rotate(_ForwardIterator __first,\n      _ForwardIterator __middle,\n      _ForwardIterator __last,\n      forward_iterator_tag)\n    {\n      if (__first == __middle)\n return __last;'
[#] parse_declaration, is_constructor=False, meet line: '_BidirectionalIterator\n    __rotate(_BidirectionalIterator __first,\n      _BidirectionalIterator __middle,\n      _BidirectionalIterator __last,\n       bidirectional_iterator_tag)\n    {\n\n     \n\n\n      '
[#] parse_declaration, is_constructor=False, meet line: '_RandomAccessIterator\n    __rotate(_RandomAccessIterator __first,\n      _RandomAccessIterator __middle,\n      _RandomAccessIterator __last,\n      random_access_iterator_tag)\n    {\n\n     \n\n\n      if (_'
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n    rotate(_ForwardIterator __first, _ForwardIterator __middle,\n    _ForwardIterator __last)\n    {\n\n     \n\n      ;\n      ;\n\n      return std::__rotate(__first, __middle, __last,\n     '
[#] parse_declaration, is_constructor=False, meet line: '_OutputIterator\n    rotate_copy(_ForwardIterator __first, _ForwardIterator __middle,\n  _ForwardIterator __last, _OutputIterator __result)\n    {\n\n     \n     \n\n      ;\n      ;\n\n      return std::copy(__'
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n    __partition(_ForwardIterator __first, _ForwardIterator __last,\n  _Predicate __pred, forward_iterator_tag)\n    {\n      if (__first == __last)\n return __first;\n\n      while (__pred('
[#] parse_declaration, is_constructor=False, meet line: '_BidirectionalIterator\n    __partition(_BidirectionalIterator __first, _BidirectionalIterator __last,\n  _Predicate __pred, bidirectional_iterator_tag)\n    {\n      while (true)\n {\n   while (true)\n     '
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n    __stable_partition_adaptive(_ForwardIterator __first,\n    _ForwardIterator __last,\n    _Predicate __pred, _Distance __len,\n    _Pointer __buffer,\n    _Distance __buffer_size)\n    '
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n    __stable_partition(_ForwardIterator __first, _ForwardIterator __last,\n         _Predicate __pred)\n    {\n      __first = std::__find_if_not(__first, __last, __pred);\n\n      if (__f'
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n    stable_partition(_ForwardIterator __first, _ForwardIterator __last,\n       _Predicate __pred)\n    {\n\n     \n\n     \n\n      ;\n\n      return std::__stable_partition(__first, __last,\n '
[#] parse_declaration, is_constructor=False, meet line: 'void\n    __heap_select(_RandomAccessIterator __first,\n    _RandomAccessIterator __middle,\n    _RandomAccessIterator __last, _Compare __comp)\n    {\n      std::__make_heap(__first, __middle, __comp);\n  '
[#] parse_declaration, is_constructor=False, meet line: '_RandomAccessIterator\n    __partial_sort_copy(_InputIterator __first, _InputIterator __last,\n   _RandomAccessIterator __result_first,\n   _RandomAccessIterator __result_last,\n   _Compare __comp)\n    {\n'
[#] parse_declaration, is_constructor=False, meet line: '_RandomAccessIterator\n    partial_sort_copy(_InputIterator __first, _InputIterator __last,\n        _RandomAccessIterator __result_first,\n        _RandomAccessIterator __result_last)\n    {\n# 1749 "/usr'
[#] parse_declaration, is_constructor=False, meet line: '_RandomAccessIterator\n    partial_sort_copy(_InputIterator __first, _InputIterator __last,\n        _RandomAccessIterator __result_first,\n        _RandomAccessIterator __result_last,\n        _Compare _'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    __unguarded_linear_insert(_RandomAccessIterator __last,\n         _Compare __comp)\n    {\n      typename iterator_traits<_RandomAccessIterator>::value_type\n __val = std::move(*__last);\n      _R'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    __insertion_sort(_RandomAccessIterator __first,\n       _RandomAccessIterator __last, _Compare __comp)\n    {\n      if (__first == __last) return;\n\n      for (_RandomAccessIterator __i = __firs'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    __unguarded_insertion_sort(_RandomAccessIterator __first,\n          _RandomAccessIterator __last, _Compare __comp)\n    {\n      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)\n'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    __final_insertion_sort(_RandomAccessIterator __first,\n      _RandomAccessIterator __last, _Compare __comp)\n    {\n      if (__last - __first > int(_S_threshold))\n {\n   std::__insertion_sort(__'
[#] parse_declaration, is_constructor=False, meet line: '_RandomAccessIterator\n    __unguarded_partition(_RandomAccessIterator __first,\n     _RandomAccessIterator __last,\n     _RandomAccessIterator __pivot, _Compare __comp)\n    {\n      while (true)\n {\n   wh'
[#] parse_declaration, is_constructor=False, meet line: '_RandomAccessIterator\n    __unguarded_partition_pivot(_RandomAccessIterator __first,\n    _RandomAccessIterator __last, _Compare __comp)\n    {\n      _RandomAccessIterator __mid = __first + (__last - __'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    __partial_sort(_RandomAccessIterator __first,\n     _RandomAccessIterator __middle,\n     _RandomAccessIterator __last,\n     _Compare __comp)\n    {\n      std::__heap_select(__first, __middle, _'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    __introsort_loop(_RandomAccessIterator __first,\n       _RandomAccessIterator __last,\n       _Size __depth_limit, _Compare __comp)\n    {\n      while (__last - __first > int(_S_threshold))\n {\n '
[#] parse_declaration, is_constructor=False, meet line: 'void\n    __sort(_RandomAccessIterator __first, _RandomAccessIterator __last,\n    _Compare __comp)\n    {\n      if (__first != __last)\n {\n   std::__introsort_loop(__first, __last,\n    std::__lg(__last -'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth,\n    _RandomAccessIterator __last, _Size __depth_limit,\n    _Compare __comp)\n    {\n      while (__last - __first > 3)\n'
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n    lower_bound(_ForwardIterator __first, _ForwardIterator __last,\n  const _Tp& __val, _Compare __comp)\n    {\n\n     \n     \n\n     \n                    ;\n\n      return std::__lower_boun'
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n    __upper_bound(_ForwardIterator __first, _ForwardIterator __last,\n    const _Tp& __val, _Compare __comp)\n    {\n      typedef typename iterator_traits<_ForwardIterator>::difference_'
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n    upper_bound(_ForwardIterator __first, _ForwardIterator __last,\n  const _Tp& __val)\n    {\n\n     \n     \n\n      ;\n\n      return std::__upper_bound(__first, __last, __val,\n    __gnu_c'
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n    upper_bound(_ForwardIterator __first, _ForwardIterator __last,\n  const _Tp& __val, _Compare __comp)\n    {\n\n     \n     \n\n     \n                    ;\n\n      return std::__upper_boun'
[#] parse_declaration, is_constructor=False, meet line: 'pair<_ForwardIterator, _ForwardIterator>\n    __equal_range(_ForwardIterator __first, _ForwardIterator __last,\n    const _Tp& __val,\n    _CompareItTp __comp_it_val, _CompareTpIt __comp_val_it)\n    {\n  '
[#] parse_declaration, is_constructor=False, meet line: 'pair<_ForwardIterator, _ForwardIterator>\n    equal_range(_ForwardIterator __first, _ForwardIterator __last,\n  const _Tp& __val)\n    {\n\n     \n     \n\n     \n\n      ;\n      ;\n\n      return std::__equal_ra'
[#] parse_declaration, is_constructor=False, meet line: 'pair<_ForwardIterator, _ForwardIterator>\n    equal_range(_ForwardIterator __first, _ForwardIterator __last,\n  const _Tp& __val, _Compare __comp)\n    {\n\n     \n     \n\n     \n\n     \n                    ;\n'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    binary_search(_ForwardIterator __first, _ForwardIterator __last,\n    const _Tp& __val)\n    {\n\n     \n     \n\n      ;\n      ;\n\n      _ForwardIterator __i\n = std::__lower_bound(__first, __last, _'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    binary_search(_ForwardIterator __first, _ForwardIterator __last,\n    const _Tp& __val, _Compare __comp)\n    {\n\n     \n     \n\n     \n                    ;\n     \n                    ;\n\n      _For'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    __move_merge_adaptive(_InputIterator1 __first1, _InputIterator1 __last1,\n     _InputIterator2 __first2, _InputIterator2 __last2,\n     _OutputIterator __result, _Compare __comp)\n    {\n      wh'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    __move_merge_adaptive_backward(_BidirectionalIterator1 __first1,\n       _BidirectionalIterator1 __last1,\n       _BidirectionalIterator2 __first2,\n       _BidirectionalIterator2 __last2,\n     '
[#] parse_declaration, is_constructor=False, meet line: '_BidirectionalIterator1\n    __rotate_adaptive(_BidirectionalIterator1 __first,\n        _BidirectionalIterator1 __middle,\n        _BidirectionalIterator1 __last,\n        _Distance __len1, _Distance __l'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    __merge_adaptive(_BidirectionalIterator __first,\n       _BidirectionalIterator __middle,\n       _BidirectionalIterator __last,\n       _Distance __len1, _Distance __len2,\n       _Pointer __buf'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    __merge_without_buffer(_BidirectionalIterator __first,\n      _BidirectionalIterator __middle,\n      _BidirectionalIterator __last,\n      _Distance __len1, _Distance __len2,\n      _Compare __c'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    __inplace_merge(_BidirectionalIterator __first,\n      _BidirectionalIterator __middle,\n      _BidirectionalIterator __last,\n      _Compare __comp)\n    {\n      typedef typename iterator_traits'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    inplace_merge(_BidirectionalIterator __first,\n    _BidirectionalIterator __middle,\n    _BidirectionalIterator __last)\n    {\n\n     \n\n     \n\n      ;\n      ;\n      ;\n\n      std::__inplace_merge('
[#] parse_declaration, is_constructor=False, meet line: 'void\n    inplace_merge(_BidirectionalIterator __first,\n    _BidirectionalIterator __middle,\n    _BidirectionalIterator __last,\n    _Compare __comp)\n    {\n\n     \n\n     \n\n\n      ;\n      ;\n      ;\n\n     '
[#] parse_declaration, is_constructor=False, meet line: '_OutputIterator\n    __move_merge(_InputIterator __first1, _InputIterator __last1,\n   _InputIterator __first2, _InputIterator __last2,\n   _OutputIterator __result, _Compare __comp)\n    {\n      while (_'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    __merge_sort_loop(_RandomAccessIterator1 __first,\n        _RandomAccessIterator1 __last,\n        _RandomAccessIterator2 __result, _Distance __step_size,\n        _Compare __comp)\n    {\n      c'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    __chunk_insertion_sort(_RandomAccessIterator __first,\n      _RandomAccessIterator __last,\n      _Distance __chunk_size, _Compare __comp)\n    {\n      while (__last - __first >= __chunk_size)\n '
[#] parse_declaration, is_constructor=False, meet line: 'void\n    __merge_sort_with_buffer(_RandomAccessIterator __first,\n        _RandomAccessIterator __last,\n        _Pointer __buffer, _Compare __comp)\n    {\n      typedef typename iterator_traits<_RandomA'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    __stable_sort_adaptive(_RandomAccessIterator __first,\n      _RandomAccessIterator __last,\n      _Pointer __buffer, _Distance __buffer_size,\n      _Compare __comp)\n    {\n      const _Distance '
[#] parse_declaration, is_constructor=False, meet line: 'void\n    __inplace_stable_sort(_RandomAccessIterator __first,\n     _RandomAccessIterator __last, _Compare __comp)\n    {\n      if (__last - __first < 15)\n {\n   std::__insertion_sort(__first, __last, __'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    __includes(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2,\n        _Compare __comp)\n    {\n      while (__first1 != __last1 && __f'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    includes(_InputIterator1 __first1, _InputIterator1 __last1,\n      _InputIterator2 __first2, _InputIterator2 __last2)\n    {\n\n     \n     \n     \n\n\n     \n\n\n      ;\n      ;\n      ;\n      ;\n\n      '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    includes(_InputIterator1 __first1, _InputIterator1 __last1,\n      _InputIterator2 __first2, _InputIterator2 __last2,\n      _Compare __comp)\n    {\n\n     \n     \n     \n\n\n     \n\n\n      ;\n      ;\n'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    __next_permutation(_BidirectionalIterator __first,\n         _BidirectionalIterator __last, _Compare __comp)\n    {\n      if (__first == __last)\n return false;\n      _BidirectionalIterator __i '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    next_permutation(_BidirectionalIterator __first,\n       _BidirectionalIterator __last)\n    {\n\n     \n\n     \n\n      ;\n      ;\n\n      return std::__next_permutation\n (__first, __last, __gnu_cxx:'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    next_permutation(_BidirectionalIterator __first,\n       _BidirectionalIterator __last, _Compare __comp)\n    {\n\n     \n\n     \n\n\n      ;\n      ;\n\n      return std::__next_permutation\n (__first, '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    __prev_permutation(_BidirectionalIterator __first,\n         _BidirectionalIterator __last, _Compare __comp)\n    {\n      if (__first == __last)\n return false;\n      _BidirectionalIterator __i '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    prev_permutation(_BidirectionalIterator __first,\n       _BidirectionalIterator __last)\n    {\n\n     \n\n     \n\n      ;\n      ;\n\n      return std::__prev_permutation(__first, __last,\n         __g'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    prev_permutation(_BidirectionalIterator __first,\n       _BidirectionalIterator __last, _Compare __comp)\n    {\n\n     \n\n     \n\n\n      ;\n      ;\n\n      return std::__prev_permutation(__first, __'
[#] parse_declaration, is_constructor=False, meet line: '_OutputIterator\n    __replace_copy_if(_InputIterator __first, _InputIterator __last,\n        _OutputIterator __result,\n        _Predicate __pred, const _Tp& __new_value)\n    {\n      for (; __first != '
[#] parse_declaration, is_constructor=False, meet line: '_OutputIterator\n    replace_copy(_InputIterator __first, _InputIterator __last,\n   _OutputIterator __result,\n   const _Tp& __old_value, const _Tp& __new_value)\n    {\n\n     \n     \n\n     \n\n      ;\n\n    '
[#] parse_declaration, is_constructor=False, meet line: '_OutputIterator\n    replace_copy_if(_InputIterator __first, _InputIterator __last,\n      _OutputIterator __result,\n      _Predicate __pred, const _Tp& __new_value)\n    {\n\n     \n     \n\n     \n\n      ;\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'iterator_traits<_InputIterator>::difference_type\n    __count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n    {\n      typename iterator_traits<_InputIterator>::difference_type '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    is_sorted(_ForwardIterator __first, _ForwardIterator __last)\n    { return std::is_sorted_until(__first, __last) == __last; }\n# 3221 "/usr/include/c++/7/bits/stl_algo.h" 3\n  template<typename '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    is_sorted(_ForwardIterator __first, _ForwardIterator __last,\n       _Compare __comp)\n    { return std::is_sorted_until(__first, __last, __comp) == __last; }\n\n  template<typename _ForwardItera'
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n    __is_sorted_until(_ForwardIterator __first, _ForwardIterator __last,\n        _Compare __comp)\n    {\n      if (__first == __last)\n return __last;\n\n      _ForwardIterator __next = _'
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n    is_sorted_until(_ForwardIterator __first, _ForwardIterator __last)\n    {\n\n     \n     \n\n      ;\n      ;\n\n      return std::__is_sorted_until(__first, __last,\n        __gnu_cxx::__o'
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n    is_sorted_until(_ForwardIterator __first, _ForwardIterator __last,\n      _Compare __comp)\n    {\n\n     \n     \n\n\n      ;\n      ;\n\n      return std::__is_sorted_until(__first, __last'
[#] parse_declaration, is_constructor=False, meet line: 'pair<const _Tp&, const _Tp&>\n    minmax(const _Tp& __a, const _Tp& __b)\n    {\n\n     \n\n      return __b < __a ? pair<const _Tp&, const _Tp&>(__b, __a)\n         : pair<const _Tp&, const _Tp&>(__a, __b);'
[#] parse_declaration, is_constructor=False, meet line: 'pair<const _Tp&, const _Tp&>\n    minmax(const _Tp& __a, const _Tp& __b, _Compare __comp)\n    {\n      return __comp(__b, __a) ? pair<const _Tp&, const _Tp&>(__b, __a)\n         : pair<const _Tp&, const '
[#] parse_declaration, is_constructor=False, meet line: 'pair<_ForwardIterator, _ForwardIterator>\n    __minmax_element(_ForwardIterator __first, _ForwardIterator __last,\n       _Compare __comp)\n    {\n      _ForwardIterator __next = __first;\n      if (__firs'
[#] parse_declaration, is_constructor=False, meet line: 'pair<_ForwardIterator, _ForwardIterator>\n    minmax_element(_ForwardIterator __first, _ForwardIterator __last)\n    {\n\n     \n     \n\n      ;\n      ;\n\n      return std::__minmax_element(__first, __last,\n'
[#] parse_declaration, is_constructor=False, meet line: 'pair<_ForwardIterator, _ForwardIterator>\n    minmax_element(_ForwardIterator __first, _ForwardIterator __last,\n     _Compare __comp)\n    {\n\n     \n     \n\n\n      ;\n      ;\n\n      return std::__minmax_el'
[#] parse_declaration, is_constructor=False, meet line: '_Tp\n    min(initializer_list<_Tp> __l)\n    { return *std::min_element(__l.begin(), __l.end()); }\n\n  template<typename _Tp, typename _Compare>\n    constexpr\n    inline _Tp\n    min(initializer_list<_Tp>'
[#] parse_declaration, is_constructor=False, meet line: '_Tp\n    min(initializer_list<_Tp> __l, _Compare __comp)\n    { return *std::min_element(__l.begin(), __l.end(), __comp); }\n\n  template<typename _Tp>\n    constexpr\n    inline _Tp\n    max(initializer_lis'
[#] parse_declaration, is_constructor=False, meet line: '_Tp\n    max(initializer_list<_Tp> __l)\n    { return *std::max_element(__l.begin(), __l.end()); }\n\n  template<typename _Tp, typename _Compare>\n    constexpr\n    inline _Tp\n    max(initializer_list<_Tp>'
[#] parse_declaration, is_constructor=False, meet line: '_Tp\n    max(initializer_list<_Tp> __l, _Compare __comp)\n    { return *std::max_element(__l.begin(), __l.end(), __comp); }\n\n  template<typename _Tp>\n    constexpr\n    inline pair<_Tp, _Tp>\n    minmax(i'
[#] parse_declaration, is_constructor=False, meet line: 'pair<_Tp, _Tp>\n    minmax(initializer_list<_Tp> __l)\n    {\n      pair<const _Tp*, const _Tp*> __p =\n std::minmax_element(__l.begin(), __l.end());\n      return std::make_pair(*__p.first, *__p.second);\n'
[#] parse_declaration, is_constructor=False, meet line: 'pair<_Tp, _Tp>\n    minmax(initializer_list<_Tp> __l, _Compare __comp)\n    {\n      pair<const _Tp*, const _Tp*> __p =\n std::minmax_element(__l.begin(), __l.end(), __comp);\n      return std::make_pair(*'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n       _ForwardIterator2 __first2, _BinaryPredicate __pred)\n    {\n\n\n      for (; __first1 != __last1; ++__first1, (void'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n     _ForwardIterator2 __first2)\n    {\n\n     \n     \n     \n\n\n      ;\n\n      return std::__is_permutation(__first1, __last1'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n     _ForwardIterator2 __first2, _BinaryPredicate __pred)\n    {\n\n     \n     \n     \n\n\n      ;\n\n      return std::__is_perm'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n       _ForwardIterator2 __first2, _ForwardIterator2 __last2,\n       _BinaryPredicate __pred)\n    {\n      using _Cat1\n '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n     _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n    {\n      ;\n      ;\n\n      return\n std::__is_permutation(__'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n     _ForwardIterator2 __first2, _ForwardIterator2 __last2,\n     _BinaryPredicate __pred)\n    {\n      ;\n      ;\n\n      re'
[#] parse_declaration, is_constructor=False, meet line: 'pair<_IntType, _IntType>\n    __gen_two_uniform_ints(_IntType __b0, _IntType __b1,\n      _UniformRandomBitGenerator&& __g)\n    {\n      _IntType __x\n = uniform_int_distribution<_IntType>{0, (__b0 * __b1'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,\n     _UniformRandomNumberGenerator&& __g)\n    {\n\n     \n\n      ;\n\n      if (__first == __last)\n return;\n\n      typedef type'
[#] parse_declaration, is_constructor=False, meet line: '_Function\n    for_each(_InputIterator __first, _InputIterator __last, _Function __f)\n    {\n\n     \n      ;\n      for (; __first != __last; ++__first)\n __f(*__first);\n      return __f;\n    }\n# 3897 "/us'
[#] parse_declaration, is_constructor=False, meet line: '_InputIterator\n    find(_InputIterator __first, _InputIterator __last,\n  const _Tp& __val)\n    {\n\n     \n     \n\n      ;\n      return std::__find_if(__first, __last,\n       __gnu_cxx::__ops::__iter_equa'
[#] parse_declaration, is_constructor=False, meet line: '_InputIterator\n    find_if(_InputIterator __first, _InputIterator __last,\n     _Predicate __pred)\n    {\n\n     \n     \n\n      ;\n\n      return std::__find_if(__first, __last,\n       __gnu_cxx::__ops::__p'
[#] parse_declaration, is_constructor=False, meet line: '_InputIterator\n    find_first_of(_InputIterator __first1, _InputIterator __last1,\n    _ForwardIterator __first2, _ForwardIterator __last2)\n    {\n\n     \n     \n     \n\n\n      ;\n      ;\n\n      for (; __fi'
[#] parse_declaration, is_constructor=False, meet line: '_InputIterator\n    find_first_of(_InputIterator __first1, _InputIterator __last1,\n    _ForwardIterator __first2, _ForwardIterator __last2,\n    _BinaryPredicate __comp)\n    {\n\n     \n     \n     \n\n\n     '
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n    adjacent_find(_ForwardIterator __first, _ForwardIterator __last)\n    {\n\n     \n     \n\n      ;\n\n      return std::__adjacent_find(__first, __last,\n      __gnu_cxx::__ops::__iter_equ'
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n    adjacent_find(_ForwardIterator __first, _ForwardIterator __last,\n    _BinaryPredicate __binary_pred)\n    {\n\n     \n     \n\n\n      ;\n\n      return std::__adjacent_find(__first, __las'
[#] parse_declaration, is_constructor=False, meet line: 'iterator_traits<_InputIterator>::difference_type\n    count(_InputIterator __first, _InputIterator __last, const _Tp& __value)\n    {\n\n     \n     \n\n      ;\n\n      return std::__count_if(__first, __last,'
[#] parse_declaration, is_constructor=False, meet line: 'iterator_traits<_InputIterator>::difference_type\n    count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n    {\n\n     \n     \n\n      ;\n\n      return std::__count_if(__first, __las'
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator1\n    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n    _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n    {\n\n     \n     \n     \n\n\n      ;\n      ;\n\n      return '
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator1\n    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n    _ForwardIterator2 __first2, _ForwardIterator2 __last2,\n    _BinaryPredicate __predicate)\n    {\n\n     \n     \n    '
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n    search_n(_ForwardIterator __first, _ForwardIterator __last,\n      _Integer __count, const _Tp& __val)\n    {\n\n     \n     \n\n      ;\n\n      return std::__search_n(__first, __last, __'
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n    search_n(_ForwardIterator __first, _ForwardIterator __last,\n      _Integer __count, const _Tp& __val,\n      _BinaryPredicate __binary_pred)\n    {\n\n     \n     \n\n      ;\n\n      retu'
[#] parse_declaration, is_constructor=False, meet line: '_OutputIterator\n    transform(_InputIterator __first, _InputIterator __last,\n       _OutputIterator __result, _UnaryOperation __unary_op)\n    {\n\n     \n     \n\n\n      ;\n\n      for (; __first != __last; '
[#] parse_declaration, is_constructor=False, meet line: '_OutputIterator\n    transform(_InputIterator1 __first1, _InputIterator1 __last1,\n       _InputIterator2 __first2, _OutputIterator __result,\n       _BinaryOperation __binary_op)\n    {\n\n     \n     \n    '
[#] parse_declaration, is_constructor=False, meet line: 'void\n    replace(_ForwardIterator __first, _ForwardIterator __last,\n     const _Tp& __old_value, const _Tp& __new_value)\n    {\n\n     \n\n     \n\n     \n\n      ;\n\n      for (; __first != __last; ++__first)'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    replace_if(_ForwardIterator __first, _ForwardIterator __last,\n        _Predicate __pred, const _Tp& __new_value)\n    {\n\n     \n\n     \n\n     \n\n      ;\n\n      for (; __first != __last; ++__first'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    generate(_ForwardIterator __first, _ForwardIterator __last,\n      _Generator __gen)\n    {\n\n     \n     \n\n      ;\n\n      for (; __first != __last; ++__first)\n *__first = __gen();\n    }\n# 4457 "'
[#] parse_declaration, is_constructor=False, meet line: '_OutputIterator\n    generate_n(_OutputIterator __first, _Size __n, _Generator __gen)\n    {\n\n     \n\n\n\n      for (__decltype(__n + 0) __niter = __n;\n    __niter > 0; --__niter, ++__first)\n *__first = __'
[#] parse_declaration, is_constructor=False, meet line: '_OutputIterator\n    unique_copy(_InputIterator __first, _InputIterator __last,\n  _OutputIterator __result)\n    {\n\n     \n     \n\n     \n\n      ;\n\n      if (__first == __last)\n return __result;\n      retu'
[#] parse_declaration, is_constructor=False, meet line: '_OutputIterator\n    unique_copy(_InputIterator __first, _InputIterator __last,\n  _OutputIterator __result,\n  _BinaryPredicate __binary_pred)\n    {\n\n     \n     \n\n      ;\n\n      if (__first == __last)\n '
[#] parse_declaration, is_constructor=False, meet line: 'void\n    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)\n    {\n\n     \n\n      ;\n\n      if (__first != __last)\n for (_RandomAccessIterator __i = __first + 1; __i != __last; +'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,\n\n     _RandomNumberGenerator&& __rand)\n\n\n\n    {\n\n     \n\n      ;\n\n      if (__first == __last)\n return;\n      for (_'
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n    partition(_ForwardIterator __first, _ForwardIterator __last,\n       _Predicate __pred)\n    {\n\n     \n\n     \n\n      ;\n\n      return std::__partition(__first, __last, __pred,\n       '
[#] parse_declaration, is_constructor=False, meet line: 'void\n    partial_sort(_RandomAccessIterator __first,\n   _RandomAccessIterator __middle,\n   _RandomAccessIterator __last)\n    {\n\n     \n\n     \n\n      ;\n      ;\n      ;\n\n      std::__partial_sort(__first'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    partial_sort(_RandomAccessIterator __first,\n   _RandomAccessIterator __middle,\n   _RandomAccessIterator __last,\n   _Compare __comp)\n    {\n\n     \n\n     \n\n\n      ;\n      ;\n      ;\n\n      std::_'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,\n  _RandomAccessIterator __last)\n    {\n\n     \n\n     \n\n      ;\n      ;\n      ;\n\n      if (__first == __last || __nth == _'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,\n  _RandomAccessIterator __last, _Compare __comp)\n    {\n\n     \n\n     \n\n\n      ;\n      ;\n      ;\n\n      if (__first == __'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    sort(_RandomAccessIterator __first, _RandomAccessIterator __last)\n    {\n\n     \n\n     \n\n      ;\n      ;\n\n      std::__sort(__first, __last, __gnu_cxx::__ops::__iter_less_iter());\n    }\n# 4854 '
[#] parse_declaration, is_constructor=False, meet line: 'void\n    sort(_RandomAccessIterator __first, _RandomAccessIterator __last,\n  _Compare __comp)\n    {\n\n     \n\n     \n\n\n      ;\n      ;\n\n      std::__sort(__first, __last, __gnu_cxx::__ops::__iter_comp_it'
[#] parse_declaration, is_constructor=False, meet line: '_OutputIterator\n    __merge(_InputIterator1 __first1, _InputIterator1 __last1,\n     _InputIterator2 __first2, _InputIterator2 __last2,\n     _OutputIterator __result, _Compare __comp)\n    {\n      while'
[#] parse_declaration, is_constructor=False, meet line: '_OutputIterator\n    merge(_InputIterator1 __first1, _InputIterator1 __last1,\n   _InputIterator2 __first2, _InputIterator2 __last2,\n   _OutputIterator __result)\n    {\n\n     \n     \n     \n\n     \n\n     \n\n'
[#] parse_declaration, is_constructor=False, meet line: '_OutputIterator\n    merge(_InputIterator1 __first1, _InputIterator1 __last1,\n   _InputIterator2 __first2, _InputIterator2 __last2,\n   _OutputIterator __result, _Compare __comp)\n    {\n\n     \n     \n    '
[#] parse_declaration, is_constructor=False, meet line: 'void\n    __stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,\n    _Compare __comp)\n    {\n      typedef typename iterator_traits<_RandomAccessIterator>::value_type\n _ValueType;\n  '
[#] parse_declaration, is_constructor=False, meet line: 'void\n    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)\n    {\n\n     \n\n     \n\n      ;\n      ;\n\n      std::__stable_sort(__first, __last,\n        __gnu_cxx::__ops::__iter_less_'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,\n  _Compare __comp)\n    {\n\n     \n\n     \n\n\n      ;\n      ;\n\n      std::__stable_sort(__first, __last,\n        __gnu_cxx:'
[#] parse_declaration, is_constructor=False, meet line: '_OutputIterator\n    __set_union(_InputIterator1 __first1, _InputIterator1 __last1,\n  _InputIterator2 __first2, _InputIterator2 __last2,\n  _OutputIterator __result, _Compare __comp)\n    {\n      while ('
[#] parse_declaration, is_constructor=False, meet line: '_OutputIterator\n    set_union(_InputIterator1 __first1, _InputIterator1 __last1,\n       _InputIterator2 __first2, _InputIterator2 __last2,\n       _OutputIterator __result)\n    {\n\n     \n     \n     \n\n  '
[#] parse_declaration, is_constructor=False, meet line: '_OutputIterator\n    set_union(_InputIterator1 __first1, _InputIterator1 __last1,\n       _InputIterator2 __first2, _InputIterator2 __last2,\n       _OutputIterator __result, _Compare __comp)\n    {\n\n    '
[#] parse_declaration, is_constructor=False, meet line: '_OutputIterator\n    __set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,\n         _InputIterator2 __first2, _InputIterator2 __last2,\n         _OutputIterator __result, _Compare __comp'
[#] parse_declaration, is_constructor=False, meet line: '_OutputIterator\n    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,\n       _InputIterator2 __first2, _InputIterator2 __last2,\n       _OutputIterator __result)\n    {\n\n     \n     \n  '
[#] parse_declaration, is_constructor=False, meet line: '_OutputIterator\n    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,\n       _InputIterator2 __first2, _InputIterator2 __last2,\n       _OutputIterator __result, _Compare __comp)\n    '
[#] parse_declaration, is_constructor=False, meet line: '_OutputIterator\n    __set_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n       _InputIterator2 __first2, _InputIterator2 __last2,\n       _OutputIterator __result, _Compare __comp)\n    '
[#] parse_declaration, is_constructor=False, meet line: '_OutputIterator\n    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n     _InputIterator2 __first2, _InputIterator2 __last2,\n     _OutputIterator __result)\n    {\n\n     \n     \n     \n\n '
[#] parse_declaration, is_constructor=False, meet line: '_OutputIterator\n    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n     _InputIterator2 __first2, _InputIterator2 __last2,\n     _OutputIterator __result, _Compare __comp)\n    {\n\n   '
[#] parse_declaration, is_constructor=False, meet line: '_OutputIterator\n    __set_symmetric_difference(_InputIterator1 __first1,\n          _InputIterator1 __last1,\n          _InputIterator2 __first2,\n          _InputIterator2 __last2,\n          _OutputIter'
[#] parse_declaration, is_constructor=False, meet line: '_OutputIterator\n    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2,\n        _OutputIterator __result)\n    {\n\n    '
[#] parse_declaration, is_constructor=False, meet line: '_OutputIterator\n    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2,\n        _OutputIterator __result,\n        _Co'
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n    __min_element(_ForwardIterator __first, _ForwardIterator __last,\n    _Compare __comp)\n    {\n      if (__first == __last)\n return __first;\n      _ForwardIterator __result = __first'
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n    inline min_element(_ForwardIterator __first, _ForwardIterator __last)\n    {\n\n     \n     \n\n      ;\n      ;\n\n      return std::__min_element(__first, __last,\n    __gnu_cxx::__ops::_'
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n    min_element(_ForwardIterator __first, _ForwardIterator __last,\n  _Compare __comp)\n    {\n\n     \n     \n\n\n      ;\n      ;\n\n      return std::__min_element(__first, __last,\n    __gnu_'
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n    __max_element(_ForwardIterator __first, _ForwardIterator __last,\n    _Compare __comp)\n    {\n      if (__first == __last) return __first;\n      _ForwardIterator __result = __first;'
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n    max_element(_ForwardIterator __first, _ForwardIterator __last)\n    {\n\n     \n     \n\n      ;\n      ;\n\n      return std::__max_element(__first, __last,\n    __gnu_cxx::__ops::__iter_l'
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n    max_element(_ForwardIterator __first, _ForwardIterator __last,\n  _Compare __comp)\n    {\n\n     \n     \n\n\n      ;\n      ;\n\n      return std::__max_element(__first, __last,\n    __gnu_'
[#] parse_declaration, is_constructor=False, meet line: '_RandomAccessIterator\n    __sample(_InputIterator __first, _InputIterator __last, input_iterator_tag,\n      _RandomAccessIterator __out, random_access_iterator_tag,\n      _Size __n, _UniformRandomBitG'
[#] parse_declaration, is_constructor=False, meet line: '_OutputIterator\n    __sample(_ForwardIterator __first, _ForwardIterator __last,\n      forward_iterator_tag,\n      _OutputIterator __out, _Cat,\n      _Size __n, _UniformRandomBitGenerator&& __g)\n    {\n'
[#] parse_declaration, is_constructor=False, meet line: 'wchar_t *wcscpy (wchar_t *__restrict __dest,\n   const wchar_t *__restrict __src)\n     throw () __attribute__ ((__nonnull__ (1, 2)));\n\n\nextern wchar_t *wcsncpy (wchar_t *__restrict __dest,\n    const wc'
[#] parse_declaration, is_constructor=False, meet line: 'wchar_t *wcsncpy (wchar_t *__restrict __dest,\n    const wchar_t *__restrict __src, size_t __n)\n     throw () __attribute__ ((__nonnull__ (1, 2)));\n\n\nextern wchar_t *wcscat (wchar_t *__restrict __dest,'
[#] parse_declaration, is_constructor=False, meet line: 'wchar_t *wcscat (wchar_t *__restrict __dest,\n   const wchar_t *__restrict __src)\n     throw () __attribute__ ((__nonnull__ (1, 2)));\n\nextern wchar_t *wcsncat (wchar_t *__restrict __dest,\n    const wch'
[#] parse_declaration, is_constructor=False, meet line: 'wchar_t *wcsncat (wchar_t *__restrict __dest,\n    const wchar_t *__restrict __src, size_t __n)\n     throw () __attribute__ ((__nonnull__ (1, 2)));\n\n\nextern int wcscmp (const wchar_t *__s1, const wchar'
[#] parse_declaration, is_constructor=False, meet line: 'int wcscmp (const wchar_t *__s1, const wchar_t *__s2)\n     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));\n\nextern int wcsncmp (const wchar_t *__s1, const wchar_t *__s2, size'
[#] parse_declaration, is_constructor=False, meet line: 'int wcsncmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)\n     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));\n\n\n\nextern int wcscasecmp (const wchar_t *__s1, const w'
[#] parse_declaration, is_constructor=False, meet line: 'int wcscasecmp (const wchar_t *__s1, const wchar_t *__s2) throw ();\n\n\nextern int wcsncasecmp (const wchar_t *__s1, const wchar_t *__s2,\n   size_t __n) throw ();\n\n\n\nextern int wcscasecmp_l (const wchar'
[#] parse_declaration, is_constructor=False, meet line: 'int wcsncasecmp (const wchar_t *__s1, const wchar_t *__s2,\n   size_t __n) throw ();\n\n\n\nextern int wcscasecmp_l (const wchar_t *__s1, const wchar_t *__s2,\n    locale_t __loc) throw ();\n\nextern int wcsn'
[#] parse_declaration, is_constructor=False, meet line: 'int wcscasecmp_l (const wchar_t *__s1, const wchar_t *__s2,\n    locale_t __loc) throw ();\n\nextern int wcsncasecmp_l (const wchar_t *__s1, const wchar_t *__s2,\n     size_t __n, locale_t __loc) throw ()'
[#] parse_declaration, is_constructor=False, meet line: 'int wcsncasecmp_l (const wchar_t *__s1, const wchar_t *__s2,\n     size_t __n, locale_t __loc) throw ();\n\n\n\n\nextern int wcscoll (const wchar_t *__s1, const wchar_t *__s2) throw ();\n\n\n\nextern size_t wcs'
[#] parse_declaration, is_constructor=False, meet line: 'int wcscoll (const wchar_t *__s1, const wchar_t *__s2) throw ();\n\n\n\nextern size_t wcsxfrm (wchar_t *__restrict __s1,\n         const wchar_t *__restrict __s2, size_t __n) throw ();\n\n\n\n\n\n\n\nextern int wc'
[#] parse_declaration, is_constructor=False, meet line: 'size_t wcsxfrm (wchar_t *__restrict __s1,\n         const wchar_t *__restrict __s2, size_t __n) throw ();\n\n\n\n\n\n\n\nextern int wcscoll_l (const wchar_t *__s1, const wchar_t *__s2,\n        locale_t __loc) '
[#] parse_declaration, is_constructor=False, meet line: 'int wcscoll_l (const wchar_t *__s1, const wchar_t *__s2,\n        locale_t __loc) throw ();\n\n\n\n\nextern size_t wcsxfrm_l (wchar_t *__s1, const wchar_t *__s2,\n    size_t __n, locale_t __loc) throw ();\n\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'size_t wcsxfrm_l (wchar_t *__s1, const wchar_t *__s2,\n    size_t __n, locale_t __loc) throw ();\n\n\nextern wchar_t *wcsdup (const wchar_t *__s) throw () __attribute__ ((__malloc__));\n\n\n\n\nextern "C++" wc'
[#] parse_declaration, is_constructor=False, meet line: 'wchar_t *wcsdup (const wchar_t *__s) throw () __attribute__ ((__malloc__));\n\n\n\n\nextern "C++" wchar_t *wcschr (wchar_t *__wcs, wchar_t __wc)\n     throw () __asm ("wcschr") __attribute__ ((__pure__));\ne'
[#] parse_declaration, is_constructor=False, meet line: ' wchar_t *wcschr (wchar_t *__wcs, wchar_t __wc)\n     throw () __asm ("wcschr") __attribute__ ((__pure__));\nextern "C++" const wchar_t *wcschr (const wchar_t *__wcs, wchar_t __wc)\n     throw () __asm ('
[#] parse_declaration, is_constructor=False, meet line: ' const wchar_t *wcschr (const wchar_t *__wcs, wchar_t __wc)\n     throw () __asm ("wcschr") __attribute__ ((__pure__));\n\n\n\n\n\n\nextern "C++" wchar_t *wcsrchr (wchar_t *__wcs, wchar_t __wc)\n     throw () '
[#] parse_declaration, is_constructor=False, meet line: ' wchar_t *wcsrchr (wchar_t *__wcs, wchar_t __wc)\n     throw () __asm ("wcsrchr") __attribute__ ((__pure__));\nextern "C++" const wchar_t *wcsrchr (const wchar_t *__wcs, wchar_t __wc)\n     throw () __as'
[#] parse_declaration, is_constructor=False, meet line: ' const wchar_t *wcsrchr (const wchar_t *__wcs, wchar_t __wc)\n     throw () __asm ("wcsrchr") __attribute__ ((__pure__));\n# 181 "/usr/include/wchar.h" 3 4\nextern wchar_t *wcschrnul (const wchar_t *__s,'
[#] parse_declaration, is_constructor=False, meet line: 'wchar_t *wcschrnul (const wchar_t *__s, wchar_t __wc)\n     throw () __attribute__ ((__pure__));\n\n\n\n\nextern size_t wcscspn (const wchar_t *__wcs, const wchar_t *__reject)\n     throw () __attribute__ (('
[#] parse_declaration, is_constructor=False, meet line: 'size_t wcscspn (const wchar_t *__wcs, const wchar_t *__reject)\n     throw () __attribute__ ((__pure__));\n\n\nextern size_t wcsspn (const wchar_t *__wcs, const wchar_t *__accept)\n     throw () __attribut'
[#] parse_declaration, is_constructor=False, meet line: 'size_t wcsspn (const wchar_t *__wcs, const wchar_t *__accept)\n     throw () __attribute__ ((__pure__));\n\n\nextern "C++" wchar_t *wcspbrk (wchar_t *__wcs, const wchar_t *__accept)\n     throw () __asm ("'
[#] parse_declaration, is_constructor=False, meet line: ' wchar_t *wcspbrk (wchar_t *__wcs, const wchar_t *__accept)\n     throw () __asm ("wcspbrk") __attribute__ ((__pure__));\nextern "C++" const wchar_t *wcspbrk (const wchar_t *__wcs,\n         const wchar_'
[#] parse_declaration, is_constructor=False, meet line: ' const wchar_t *wcspbrk (const wchar_t *__wcs,\n         const wchar_t *__accept)\n     throw () __asm ("wcspbrk") __attribute__ ((__pure__));\n\n\n\n\n\n\nextern "C++" wchar_t *wcsstr (wchar_t *__haystack, co'
[#] parse_declaration, is_constructor=False, meet line: ' wchar_t *wcsstr (wchar_t *__haystack, const wchar_t *__needle)\n     throw () __asm ("wcsstr") __attribute__ ((__pure__));\nextern "C++" const wchar_t *wcsstr (const wchar_t *__haystack,\n        const '
[#] parse_declaration, is_constructor=False, meet line: ' const wchar_t *wcsstr (const wchar_t *__haystack,\n        const wchar_t *__needle)\n     throw () __asm ("wcsstr") __attribute__ ((__pure__));\n\n\n\n\n\n\nextern wchar_t *wcstok (wchar_t *__restrict __s,\n  '
[#] parse_declaration, is_constructor=False, meet line: 'wchar_t *wcstok (wchar_t *__restrict __s,\n   const wchar_t *__restrict __delim,\n   wchar_t **__restrict __ptr) throw ();\n\n\nextern size_t wcslen (const wchar_t *__s) throw () __attribute__ ((__pure__))'
[#] parse_declaration, is_constructor=False, meet line: 'size_t wcslen (const wchar_t *__s) throw () __attribute__ ((__pure__));\n\n\n\n\nextern "C++" wchar_t *wcswcs (wchar_t *__haystack, const wchar_t *__needle)\n     throw () __asm ("wcswcs") __attribute__ ((_'
[#] parse_declaration, is_constructor=False, meet line: ' wchar_t *wcswcs (wchar_t *__haystack, const wchar_t *__needle)\n     throw () __asm ("wcswcs") __attribute__ ((__pure__));\nextern "C++" const wchar_t *wcswcs (const wchar_t *__haystack,\n        const '
[#] parse_declaration, is_constructor=False, meet line: ' const wchar_t *wcswcs (const wchar_t *__haystack,\n        const wchar_t *__needle)\n     throw () __asm ("wcswcs") __attribute__ ((__pure__));\n# 240 "/usr/include/wchar.h" 3 4\nextern size_t wcsnlen (c'
[#] parse_declaration, is_constructor=False, meet line: 'size_t wcsnlen (const wchar_t *__s, size_t __maxlen)\n     throw () __attribute__ ((__pure__));\n\n\n\n\n\nextern "C++" wchar_t *wmemchr (wchar_t *__s, wchar_t __c, size_t __n)\n     throw () __asm ("wmemchr"'
[#] parse_declaration, is_constructor=False, meet line: ' wchar_t *wmemchr (wchar_t *__s, wchar_t __c, size_t __n)\n     throw () __asm ("wmemchr") __attribute__ ((__pure__));\nextern "C++" const wchar_t *wmemchr (const wchar_t *__s, wchar_t __c,\n         siz'
[#] parse_declaration, is_constructor=False, meet line: ' const wchar_t *wmemchr (const wchar_t *__s, wchar_t __c,\n         size_t __n)\n     throw () __asm ("wmemchr") __attribute__ ((__pure__));\n\n\n\n\n\n\nextern int wmemcmp (const wchar_t *__s1, const wchar_t '
[#] parse_declaration, is_constructor=False, meet line: 'int wmemcmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)\n     throw () __attribute__ ((__pure__));\n\n\nextern wchar_t *wmemcpy (wchar_t *__restrict __s1,\n    const wchar_t *__restrict __s2, si'
[#] parse_declaration, is_constructor=False, meet line: 'wchar_t *wmemcpy (wchar_t *__restrict __s1,\n    const wchar_t *__restrict __s2, size_t __n) throw ();\n\n\n\nextern wchar_t *wmemmove (wchar_t *__s1, const wchar_t *__s2, size_t __n)\n     throw ();\n\n\nexte'
[#] parse_declaration, is_constructor=False, meet line: 'wchar_t *wmemmove (wchar_t *__s1, const wchar_t *__s2, size_t __n)\n     throw ();\n\n\nextern wchar_t *wmemset (wchar_t *__s, wchar_t __c, size_t __n) throw ();\n\n\n\n\nextern wchar_t *wmempcpy (wchar_t *__r'
[#] parse_declaration, is_constructor=False, meet line: 'wchar_t *wmemset (wchar_t *__s, wchar_t __c, size_t __n) throw ();\n\n\n\n\nextern wchar_t *wmempcpy (wchar_t *__restrict __s1,\n     const wchar_t *__restrict __s2, size_t __n)\n     throw ();\n\n\n\n\n\nextern w'
[#] parse_declaration, is_constructor=False, meet line: 'wchar_t *wmempcpy (wchar_t *__restrict __s1,\n     const wchar_t *__restrict __s2, size_t __n)\n     throw ();\n\n\n\n\n\nextern wint_t btowc (int __c) throw ();\n\n\n\nextern int wctob (wint_t __c) throw ();\n\n\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'wint_t btowc (int __c) throw ();\n\n\n\nextern int wctob (wint_t __c) throw ();\n\n\n\nextern int mbsinit (const mbstate_t *__ps) throw () __attribute__ ((__pure__));\n\n\n\nextern size_t mbrtowc (wchar_t *__rest'
[#] parse_declaration, is_constructor=False, meet line: 'int wctob (wint_t __c) throw ();\n\n\n\nextern int mbsinit (const mbstate_t *__ps) throw () __attribute__ ((__pure__));\n\n\n\nextern size_t mbrtowc (wchar_t *__restrict __pwc,\n         const char *__restrict'
[#] parse_declaration, is_constructor=False, meet line: 'int mbsinit (const mbstate_t *__ps) throw () __attribute__ ((__pure__));\n\n\n\nextern size_t mbrtowc (wchar_t *__restrict __pwc,\n         const char *__restrict __s, size_t __n,\n         mbstate_t *__res'
[#] parse_declaration, is_constructor=False, meet line: 'size_t mbrtowc (wchar_t *__restrict __pwc,\n         const char *__restrict __s, size_t __n,\n         mbstate_t *__restrict __p) throw ();\n\n\nextern size_t wcrtomb (char *__restrict __s, wchar_t __wc,\n '
[#] parse_declaration, is_constructor=False, meet line: 'size_t wcrtomb (char *__restrict __s, wchar_t __wc,\n         mbstate_t *__restrict __ps) throw ();\n\n\nextern size_t __mbrlen (const char *__restrict __s, size_t __n,\n   mbstate_t *__restrict __ps) thro'
[#] parse_declaration, is_constructor=False, meet line: 'size_t __mbrlen (const char *__restrict __s, size_t __n,\n   mbstate_t *__restrict __ps) throw ();\nextern size_t mbrlen (const char *__restrict __s, size_t __n,\n        mbstate_t *__restrict __ps) thro'
[#] parse_declaration, is_constructor=False, meet line: 'size_t mbrlen (const char *__restrict __s, size_t __n,\n        mbstate_t *__restrict __ps) throw ();\n# 337 "/usr/include/wchar.h" 3 4\nextern size_t mbsrtowcs (wchar_t *__restrict __dst,\n    const char'
[#] parse_declaration, is_constructor=False, meet line: 'size_t mbsrtowcs (wchar_t *__restrict __dst,\n    const char **__restrict __src, size_t __len,\n    mbstate_t *__restrict __ps) throw ();\n\n\n\nextern size_t wcsrtombs (char *__restrict __dst,\n    const wc'
[#] parse_declaration, is_constructor=False, meet line: 'size_t wcsrtombs (char *__restrict __dst,\n    const wchar_t **__restrict __src, size_t __len,\n    mbstate_t *__restrict __ps) throw ();\n\n\n\n\n\nextern size_t mbsnrtowcs (wchar_t *__restrict __dst,\n     c'
[#] parse_declaration, is_constructor=False, meet line: 'size_t mbsnrtowcs (wchar_t *__restrict __dst,\n     const char **__restrict __src, size_t __nmc,\n     size_t __len, mbstate_t *__restrict __ps) throw ();\n\n\n\nextern size_t wcsnrtombs (char *__restrict _'
[#] parse_declaration, is_constructor=False, meet line: 'size_t wcsnrtombs (char *__restrict __dst,\n     const wchar_t **__restrict __src,\n     size_t __nwc, size_t __len,\n     mbstate_t *__restrict __ps) throw ();\n\n\n\n\n\n\nextern int wcwidth (wchar_t __c) thr'
[#] parse_declaration, is_constructor=False, meet line: 'int wcwidth (wchar_t __c) throw ();\n\n\n\nextern int wcswidth (const wchar_t *__s, size_t __n) throw ();\n\n\n\n\n\nextern double wcstod (const wchar_t *__restrict __nptr,\n        wchar_t **__restrict __endptr'
[#] parse_declaration, is_constructor=False, meet line: 'int wcswidth (const wchar_t *__s, size_t __n) throw ();\n\n\n\n\n\nextern double wcstod (const wchar_t *__restrict __nptr,\n        wchar_t **__restrict __endptr) throw ();\n\n\n\nextern float wcstof (const wcha'
[#] parse_declaration, is_constructor=False, meet line: 'double wcstod (const wchar_t *__restrict __nptr,\n        wchar_t **__restrict __endptr) throw ();\n\n\n\nextern float wcstof (const wchar_t *__restrict __nptr,\n       wchar_t **__restrict __endptr) throw '
[#] parse_declaration, is_constructor=False, meet line: 'float wcstof (const wchar_t *__restrict __nptr,\n       wchar_t **__restrict __endptr) throw ();\nextern long double wcstold (const wchar_t *__restrict __nptr,\n       wchar_t **__restrict __endptr) thro'
[#] parse_declaration, is_constructor=False, meet line: 'long double wcstold (const wchar_t *__restrict __nptr,\n       wchar_t **__restrict __endptr) throw ();\n# 396 "/usr/include/wchar.h" 3 4\nextern _Float32 wcstof32 (const wchar_t *__restrict __nptr,\n    '
[#] parse_declaration, is_constructor=False, meet line: '_Float32 wcstof32 (const wchar_t *__restrict __nptr,\n     wchar_t **__restrict __endptr) throw ();\n\n\n\nextern _Float64 wcstof64 (const wchar_t *__restrict __nptr,\n     wchar_t **__restrict __endptr) th'
[#] parse_declaration, is_constructor=False, meet line: '_Float64 wcstof64 (const wchar_t *__restrict __nptr,\n     wchar_t **__restrict __endptr) throw ();\n\n\n\nextern _Float128 wcstof128 (const wchar_t *__restrict __nptr,\n       wchar_t **__restrict __endptr'
[#] parse_declaration, is_constructor=False, meet line: '_Float128 wcstof128 (const wchar_t *__restrict __nptr,\n       wchar_t **__restrict __endptr) throw ();\n\n\n\nextern _Float32x wcstof32x (const wchar_t *__restrict __nptr,\n       wchar_t **__restrict __en'
[#] parse_declaration, is_constructor=False, meet line: '_Float32x wcstof32x (const wchar_t *__restrict __nptr,\n       wchar_t **__restrict __endptr) throw ();\n\n\n\nextern _Float64x wcstof64x (const wchar_t *__restrict __nptr,\n       wchar_t **__restrict __en'
[#] parse_declaration, is_constructor=False, meet line: '_Float64x wcstof64x (const wchar_t *__restrict __nptr,\n       wchar_t **__restrict __endptr) throw ();\n# 428 "/usr/include/wchar.h" 3 4\nextern long int wcstol (const wchar_t *__restrict __nptr,\n   wch'
[#] parse_declaration, is_constructor=False, meet line: 'long int wcstol (const wchar_t *__restrict __nptr,\n   wchar_t **__restrict __endptr, int __base) throw ();\n\n\n\nextern unsigned long int wcstoul (const wchar_t *__restrict __nptr,\n      wchar_t **__rest'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned long int wcstoul (const wchar_t *__restrict __nptr,\n      wchar_t **__restrict __endptr, int __base)\n     throw ();\n\n\n\n\n__extension__\nextern long long int wcstoll (const wchar_t *__restrict _'
[#] parse_declaration, is_constructor=False, meet line: 'long long int wcstoll (const wchar_t *__restrict __nptr,\n         wchar_t **__restrict __endptr, int __base)\n     throw ();\n\n\n\n__extension__\nextern unsigned long long int wcstoull (const wchar_t *__re'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned long long int wcstoull (const wchar_t *__restrict __nptr,\n     wchar_t **__restrict __endptr,\n     int __base) throw ();\n\n\n\n\n\n__extension__\nextern long long int wcstoq (const wchar_t *__restr'
[#] parse_declaration, is_constructor=False, meet line: 'long long int wcstoq (const wchar_t *__restrict __nptr,\n        wchar_t **__restrict __endptr, int __base)\n     throw ();\n\n\n\n__extension__\nextern unsigned long long int wcstouq (const wchar_t *__restr'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned long long int wcstouq (const wchar_t *__restrict __nptr,\n           wchar_t **__restrict __endptr,\n           int __base) throw ();\n\n\n\n\n\n\nextern long int wcstol_l (const wchar_t *__restrict _'
[#] parse_declaration, is_constructor=False, meet line: 'long int wcstol_l (const wchar_t *__restrict __nptr,\n     wchar_t **__restrict __endptr, int __base,\n     locale_t __loc) throw ();\n\nextern unsigned long int wcstoul_l (const wchar_t *__restrict __npt'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned long int wcstoul_l (const wchar_t *__restrict __nptr,\n        wchar_t **__restrict __endptr,\n        int __base, locale_t __loc) throw ();\n\n__extension__\nextern long long int wcstoll_l (const'
[#] parse_declaration, is_constructor=False, meet line: 'long long int wcstoll_l (const wchar_t *__restrict __nptr,\n    wchar_t **__restrict __endptr,\n    int __base, locale_t __loc) throw ();\n\n__extension__\nextern unsigned long long int wcstoull_l (const w'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned long long int wcstoull_l (const wchar_t *__restrict __nptr,\n       wchar_t **__restrict __endptr,\n       int __base, locale_t __loc)\n     throw ();\n\nextern double wcstod_l (const wchar_t *__r'
[#] parse_declaration, is_constructor=False, meet line: 'double wcstod_l (const wchar_t *__restrict __nptr,\n   wchar_t **__restrict __endptr, locale_t __loc)\n     throw ();\n\nextern float wcstof_l (const wchar_t *__restrict __nptr,\n         wchar_t **__restr'
[#] parse_declaration, is_constructor=False, meet line: 'float wcstof_l (const wchar_t *__restrict __nptr,\n         wchar_t **__restrict __endptr, locale_t __loc)\n     throw ();\n\nextern long double wcstold_l (const wchar_t *__restrict __nptr,\n         wchar'
[#] parse_declaration, is_constructor=False, meet line: 'long double wcstold_l (const wchar_t *__restrict __nptr,\n         wchar_t **__restrict __endptr,\n         locale_t __loc) throw ();\n# 511 "/usr/include/wchar.h" 3 4\nextern _Float32 wcstof32_l (const w'
[#] parse_declaration, is_constructor=False, meet line: '_Float32 wcstof32_l (const wchar_t *__restrict __nptr,\n       wchar_t **__restrict __endptr,\n       locale_t __loc) throw ();\n\n\n\nextern _Float64 wcstof64_l (const wchar_t *__restrict __nptr,\n       wc'
[#] parse_declaration, is_constructor=False, meet line: '_Float64 wcstof64_l (const wchar_t *__restrict __nptr,\n       wchar_t **__restrict __endptr,\n       locale_t __loc) throw ();\n\n\n\nextern _Float128 wcstof128_l (const wchar_t *__restrict __nptr,\n       '
[#] parse_declaration, is_constructor=False, meet line: '_Float128 wcstof128_l (const wchar_t *__restrict __nptr,\n         wchar_t **__restrict __endptr,\n         locale_t __loc) throw ();\n\n\n\nextern _Float32x wcstof32x_l (const wchar_t *__restrict __nptr,\n '
[#] parse_declaration, is_constructor=False, meet line: '_Float32x wcstof32x_l (const wchar_t *__restrict __nptr,\n         wchar_t **__restrict __endptr,\n         locale_t __loc) throw ();\n\n\n\nextern _Float64x wcstof64x_l (const wchar_t *__restrict __nptr,\n '
[#] parse_declaration, is_constructor=False, meet line: '_Float64x wcstof64x_l (const wchar_t *__restrict __nptr,\n         wchar_t **__restrict __endptr,\n         locale_t __loc) throw ();\n# 551 "/usr/include/wchar.h" 3 4\nextern wchar_t *wcpcpy (wchar_t *__'
[#] parse_declaration, is_constructor=False, meet line: 'wchar_t *wcpcpy (wchar_t *__restrict __dest,\n   const wchar_t *__restrict __src) throw ();\n\n\n\nextern wchar_t *wcpncpy (wchar_t *__restrict __dest,\n    const wchar_t *__restrict __src, size_t __n)\n    '
[#] parse_declaration, is_constructor=False, meet line: 'wchar_t *wcpncpy (wchar_t *__restrict __dest,\n    const wchar_t *__restrict __src, size_t __n)\n     throw ();\n# 567 "/usr/include/wchar.h" 3 4\nextern __FILE *open_wmemstream (wchar_t **__bufloc, size_'
[#] parse_declaration, is_constructor=False, meet line: '__FILE *open_wmemstream (wchar_t **__bufloc, size_t *__sizeloc) throw ();\n\n\n\n\n\nextern int fwide (__FILE *__fp, int __mode) throw ();\n\n\n\n\n\n\nextern int fwprintf (__FILE *__restrict __stream,\n       cons'
[#] parse_declaration, is_constructor=False, meet line: 'int fwide (__FILE *__fp, int __mode) throw ();\n\n\n\n\n\n\nextern int fwprintf (__FILE *__restrict __stream,\n       const wchar_t *__restrict __format, ...)\n                                                 '
[#] parse_declaration, is_constructor=False, meet line: 'int fwprintf (__FILE *__restrict __stream,\n       const wchar_t *__restrict __format, ...)\n                                                           ;\n\n\n\n\nextern int wprintf (const wchar_t *__restric'
[#] parse_declaration, is_constructor=False, meet line: 'int wprintf (const wchar_t *__restrict __format, ...)\n                                                           ;\n\nextern int swprintf (wchar_t *__restrict __s, size_t __n,\n       const wchar_t *__re'
[#] parse_declaration, is_constructor=False, meet line: 'int swprintf (wchar_t *__restrict __s, size_t __n,\n       const wchar_t *__restrict __format, ...)\n     throw () ;\n\n\n\n\n\nextern int vfwprintf (__FILE *__restrict __s,\n        const wchar_t *__restrict '
[#] parse_declaration, is_constructor=False, meet line: 'int vfwprintf (__FILE *__restrict __s,\n        const wchar_t *__restrict __format,\n        __gnuc_va_list __arg)\n                                                           ;\n\n\n\n\nextern int vwprintf (c'
[#] parse_declaration, is_constructor=False, meet line: 'int vwprintf (const wchar_t *__restrict __format,\n       __gnuc_va_list __arg)\n                                                           ;\n\n\nextern int vswprintf (wchar_t *__restrict __s, size_t __n,'
[#] parse_declaration, is_constructor=False, meet line: 'int vswprintf (wchar_t *__restrict __s, size_t __n,\n        const wchar_t *__restrict __format,\n        __gnuc_va_list __arg)\n     throw () ;\n\n\n\n\n\n\nextern int fwscanf (__FILE *__restrict __stream,\n   '
[#] parse_declaration, is_constructor=False, meet line: 'int fwscanf (__FILE *__restrict __stream,\n      const wchar_t *__restrict __format, ...)\n                                                          ;\n\n\n\n\nextern int wscanf (const wchar_t *__restrict __'
[#] parse_declaration, is_constructor=False, meet line: 'int wscanf (const wchar_t *__restrict __format, ...)\n                                                          ;\n\nextern int swscanf (const wchar_t *__restrict __s,\n      const wchar_t *__restrict __f'
[#] parse_declaration, is_constructor=False, meet line: 'int swscanf (const wchar_t *__restrict __s,\n      const wchar_t *__restrict __format, ...)\n     throw () ;\n# 673 "/usr/include/wchar.h" 3 4\nextern int vfwscanf (__FILE *__restrict __s,\n       const wc'
[#] parse_declaration, is_constructor=False, meet line: 'int vfwscanf (__FILE *__restrict __s,\n       const wchar_t *__restrict __format,\n       __gnuc_va_list __arg)\n                                                          ;\n\n\n\n\nextern int vwscanf (const '
[#] parse_declaration, is_constructor=False, meet line: 'int vwscanf (const wchar_t *__restrict __format,\n      __gnuc_va_list __arg)\n                                                          ;\n\nextern int vswscanf (const wchar_t *__restrict __s,\n       con'
[#] parse_declaration, is_constructor=False, meet line: 'int vswscanf (const wchar_t *__restrict __s,\n       const wchar_t *__restrict __format,\n       __gnuc_va_list __arg)\n     throw () ;\n# 727 "/usr/include/wchar.h" 3 4\nextern wint_t fgetwc (__FILE *__st'
[#] parse_declaration, is_constructor=False, meet line: 'wint_t fgetwc (__FILE *__stream);\nextern wint_t getwc (__FILE *__stream);\n\n\n\n\n\nextern wint_t getwchar (void);\n\n\n\n\n\n\nextern wint_t fputwc (wchar_t __wc, __FILE *__stream);\nextern wint_t putwc (wchar_t '
[#] parse_declaration, is_constructor=False, meet line: 'wint_t getwc (__FILE *__stream);\n\n\n\n\n\nextern wint_t getwchar (void);\n\n\n\n\n\n\nextern wint_t fputwc (wchar_t __wc, __FILE *__stream);\nextern wint_t putwc (wchar_t __wc, __FILE *__stream);\n\n\n\n\n\nextern wint'
[#] parse_declaration, is_constructor=False, meet line: 'wint_t getwchar (void);\n\n\n\n\n\n\nextern wint_t fputwc (wchar_t __wc, __FILE *__stream);\nextern wint_t putwc (wchar_t __wc, __FILE *__stream);\n\n\n\n\n\nextern wint_t putwchar (wchar_t __wc);\n\n\n\n\n\n\n\nextern wch'
[#] parse_declaration, is_constructor=False, meet line: 'wint_t fputwc (wchar_t __wc, __FILE *__stream);\nextern wint_t putwc (wchar_t __wc, __FILE *__stream);\n\n\n\n\n\nextern wint_t putwchar (wchar_t __wc);\n\n\n\n\n\n\n\nextern wchar_t *fgetws (wchar_t *__restrict __w'
[#] parse_declaration, is_constructor=False, meet line: 'wint_t putwc (wchar_t __wc, __FILE *__stream);\n\n\n\n\n\nextern wint_t putwchar (wchar_t __wc);\n\n\n\n\n\n\n\nextern wchar_t *fgetws (wchar_t *__restrict __ws, int __n,\n   __FILE *__restrict __stream);\n\n\n\n\n\nexter'
[#] parse_declaration, is_constructor=False, meet line: 'wint_t putwchar (wchar_t __wc);\n\n\n\n\n\n\n\nextern wchar_t *fgetws (wchar_t *__restrict __ws, int __n,\n   __FILE *__restrict __stream);\n\n\n\n\n\nextern int fputws (const wchar_t *__restrict __ws,\n     __FILE *'
[#] parse_declaration, is_constructor=False, meet line: 'wchar_t *fgetws (wchar_t *__restrict __ws, int __n,\n   __FILE *__restrict __stream);\n\n\n\n\n\nextern int fputws (const wchar_t *__restrict __ws,\n     __FILE *__restrict __stream);\n\n\n\n\n\n\nextern wint_t unge'
[#] parse_declaration, is_constructor=False, meet line: 'int fputws (const wchar_t *__restrict __ws,\n     __FILE *__restrict __stream);\n\n\n\n\n\n\nextern wint_t ungetwc (wint_t __wc, __FILE *__stream);\n# 782 "/usr/include/wchar.h" 3 4\nextern wint_t getwc_unlocke'
[#] parse_declaration, is_constructor=False, meet line: 'wint_t ungetwc (wint_t __wc, __FILE *__stream);\n# 782 "/usr/include/wchar.h" 3 4\nextern wint_t getwc_unlocked (__FILE *__stream);\nextern wint_t getwchar_unlocked (void);\n\n\n\n\n\n\n\nextern wint_t fgetwc_un'
[#] parse_declaration, is_constructor=False, meet line: 'wint_t getwc_unlocked (__FILE *__stream);\nextern wint_t getwchar_unlocked (void);\n\n\n\n\n\n\n\nextern wint_t fgetwc_unlocked (__FILE *__stream);\n\n\n\n\n\n\n\nextern wint_t fputwc_unlocked (wchar_t __wc, __FILE *_'
[#] parse_declaration, is_constructor=False, meet line: 'wint_t getwchar_unlocked (void);\n\n\n\n\n\n\n\nextern wint_t fgetwc_unlocked (__FILE *__stream);\n\n\n\n\n\n\n\nextern wint_t fputwc_unlocked (wchar_t __wc, __FILE *__stream);\n# 808 "/usr/include/wchar.h" 3 4\nextern'
[#] parse_declaration, is_constructor=False, meet line: 'wint_t fgetwc_unlocked (__FILE *__stream);\n\n\n\n\n\n\n\nextern wint_t fputwc_unlocked (wchar_t __wc, __FILE *__stream);\n# 808 "/usr/include/wchar.h" 3 4\nextern wint_t putwc_unlocked (wchar_t __wc, __FILE *_'
[#] parse_declaration, is_constructor=False, meet line: 'wint_t fputwc_unlocked (wchar_t __wc, __FILE *__stream);\n# 808 "/usr/include/wchar.h" 3 4\nextern wint_t putwc_unlocked (wchar_t __wc, __FILE *__stream);\nextern wint_t putwchar_unlocked (wchar_t __wc);'
[#] parse_declaration, is_constructor=False, meet line: 'wint_t putwc_unlocked (wchar_t __wc, __FILE *__stream);\nextern wint_t putwchar_unlocked (wchar_t __wc);\n# 818 "/usr/include/wchar.h" 3 4\nextern wchar_t *fgetws_unlocked (wchar_t *__restrict __ws, int '
[#] parse_declaration, is_constructor=False, meet line: 'wint_t putwchar_unlocked (wchar_t __wc);\n# 818 "/usr/include/wchar.h" 3 4\nextern wchar_t *fgetws_unlocked (wchar_t *__restrict __ws, int __n,\n     __FILE *__restrict __stream);\n\n\n\n\n\n\n\nextern int fputw'
[#] parse_declaration, is_constructor=False, meet line: 'wchar_t *fgetws_unlocked (wchar_t *__restrict __ws, int __n,\n     __FILE *__restrict __stream);\n\n\n\n\n\n\n\nextern int fputws_unlocked (const wchar_t *__restrict __ws,\n       __FILE *__restrict __stream);\n'
[#] parse_declaration, is_constructor=False, meet line: 'int fputws_unlocked (const wchar_t *__restrict __ws,\n       __FILE *__restrict __stream);\n\n\n\n\n\n\nextern size_t wcsftime (wchar_t *__restrict __s, size_t __maxsize,\n   const wchar_t *__restrict __format'
[#] parse_declaration, is_constructor=False, meet line: 'size_t wcsftime (wchar_t *__restrict __s, size_t __maxsize,\n   const wchar_t *__restrict __format,\n   const struct tm *__restrict __tp) throw ();\n\n\n\n\nextern size_t wcsftime_l (wchar_t *__restrict __s,'
[#] parse_declaration, is_constructor=False, meet line: 'size_t wcsftime_l (wchar_t *__restrict __s, size_t __maxsize,\n     const wchar_t *__restrict __format,\n     const struct tm *__restrict __tp,\n     locale_t __loc) throw ();\n# 857 "/usr/include/wchar.h'
[#] parse_declaration, is_constructor=False, meet line: 'streamoff _M_off;\n      _StateT _M_state;\n\n    public:\n\n\n\n\n      fpos()\n      : _M_off(0), _M_state() { }\n# 133 "/usr/include/c++/7/bits/postypes.h" 3\n      fpos(streamoff __off)\n      : _M_off(__off)'
[#] parse_declaration, is_constructor=False, meet line: '_StateT _M_state;\n\n    public:\n\n\n\n\n      fpos()\n      : _M_off(0), _M_state() { }\n# 133 "/usr/include/c++/7/bits/postypes.h" 3\n      fpos(streamoff __off)\n      : _M_off(__off), _M_state() { }\n\n\n     '
[#] parse_declaration, is_constructor=True, meet line: 'fpos()\n      : _M_off(0), _M_state() { }\n# 133 "/usr/include/c++/7/bits/postypes.h" 3\n      fpos(streamoff __off)\n      : _M_off(__off), _M_state() { }\n\n\n      operator streamoff() const { return _M_o'
[#] parse_declaration, is_constructor=True, meet line: 'fpos(streamoff __off)\n      : _M_off(__off), _M_state() { }\n\n\n      operator streamoff() const { return _M_off; }\n\n\n      void\n      state(_StateT __st)\n      { _M_state = __st; }\n\n\n      _StateT\n    '
[#] parse_declaration, is_constructor=False, meet line: 'operator streamoff() const { return _M_off; }\n\n\n      void\n      state(_StateT __st)\n      { _M_state = __st; }\n\n\n      _StateT\n      state() const\n      { return _M_state; }\n\n\n\n\n\n      fpos&\n      op'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      state(_StateT __st)\n      { _M_state = __st; }\n\n\n      _StateT\n      state() const\n      { return _M_state; }\n\n\n\n\n\n      fpos&\n      operator+=(streamoff __off)\n      {\n _M_off += __off;\n r'
[#] parse_declaration, is_constructor=False, meet line: '_StateT\n      state() const\n      { return _M_state; }\n\n\n\n\n\n      fpos&\n      operator+=(streamoff __off)\n      {\n _M_off += __off;\n return *this;\n      }\n\n\n\n\n\n      fpos&\n      operator-=(streamoff _'
[#] parse_declaration, is_constructor=True, meet line: 'fpos&\n      operator+=(streamoff __off)\n      {\n _M_off += __off;\n return *this;\n      }\n\n\n\n\n\n      fpos&\n      operator-=(streamoff __off)\n      {\n _M_off -= __off;\n return *this;\n      }\n\n\n\n\n\n\n\n    '
[#] parse_declaration, is_constructor=True, meet line: 'fpos&\n      operator-=(streamoff __off)\n      {\n _M_off -= __off;\n return *this;\n      }\n\n\n\n\n\n\n\n      fpos\n      operator+(streamoff __off) const\n      {\n fpos __pos(*this);\n __pos += __off;\n return _'
[#] parse_declaration, is_constructor=True, meet line: 'fpos\n      operator+(streamoff __off) const\n      {\n fpos __pos(*this);\n __pos += __off;\n return __pos;\n      }\n\n\n\n\n\n\n\n      fpos\n      operator-(streamoff __off) const\n      {\n fpos __pos(*this);\n __'
[#] parse_declaration, is_constructor=True, meet line: 'fpos\n      operator-(streamoff __off) const\n      {\n fpos __pos(*this);\n __pos -= __off;\n return __pos;\n      }\n\n\n\n\n\n\n      streamoff\n      operator-(const fpos& __other) const\n      { return _M_off -'
[#] parse_declaration, is_constructor=False, meet line: 'streamoff\n      operator-(const fpos& __other) const\n      { return _M_off - __other._M_off; }\n    };\n\n\n\n\n\n\n  template<typename _StateT>\n    inline bool\n    operator==(const fpos<_StateT>& __lhs, cons'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator==(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)\n    { return streamoff(__lhs) == streamoff(__rhs); }\n\n  template<typename _StateT>\n    inline bool\n    operator!=(const fpos'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)\n    { return streamoff(__lhs) != streamoff(__rhs); }\n\n\n\n\n\n  typedef fpos<mbstate_t> streampos;\n\n  typedef fpos<mbstate_t> ws'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      assign(char_type& __c1, const char_type& __c2)\n      { __c1 = __c2; }\n\n      static constexpr bool\n      eq(const char_type& __c1, const char_type& __c2)\n      { return __c1 == __c2; }\n\n   '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      eq(const char_type& __c1, const char_type& __c2)\n      { return __c1 == __c2; }\n\n      static constexpr bool\n      lt(const char_type& __c1, const char_type& __c2)\n      { return __c1 < __c'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      lt(const char_type& __c1, const char_type& __c2)\n      { return __c1 < __c2; }\n\n      static constexpr int\n      compare(const char_type* __s1, const char_type* __s2, std::size_t __n);\n\n   '
[#] parse_declaration, is_constructor=False, meet line: 'int\n      compare(const char_type* __s1, const char_type* __s2, std::size_t __n);\n\n      static constexpr std::size_t\n      length(const char_type* __s);\n\n      static constexpr const char_type*\n     '
[#] parse_declaration, is_constructor=False, meet line: 'std::size_t\n      length(const char_type* __s);\n\n      static constexpr const char_type*\n      find(const char_type* __s, std::size_t __n, const char_type& __a);\n\n      static char_type*\n      move(ch'
[#] parse_declaration, is_constructor=False, meet line: 'char_type*\n      find(const char_type* __s, std::size_t __n, const char_type& __a);\n\n      static char_type*\n      move(char_type* __s1, const char_type* __s2, std::size_t __n);\n\n      static char_typ'
[#] parse_declaration, is_constructor=False, meet line: 'char_type*\n      move(char_type* __s1, const char_type* __s2, std::size_t __n);\n\n      static char_type*\n      copy(char_type* __s1, const char_type* __s2, std::size_t __n);\n\n      static char_type*\n '
[#] parse_declaration, is_constructor=False, meet line: 'char_type*\n      copy(char_type* __s1, const char_type* __s2, std::size_t __n);\n\n      static char_type*\n      assign(char_type* __s, std::size_t __n, char_type __a);\n\n      static constexpr char_type'
[#] parse_declaration, is_constructor=False, meet line: 'char_type*\n      assign(char_type* __s, std::size_t __n, char_type __a);\n\n      static constexpr char_type\n      to_char_type(const int_type& __c)\n      { return static_cast<char_type>(__c); }\n\n      '
[#] parse_declaration, is_constructor=False, meet line: 'char_type\n      to_char_type(const int_type& __c)\n      { return static_cast<char_type>(__c); }\n\n      static constexpr int_type\n      to_int_type(const char_type& __c)\n      { return static_cast<int_'
[#] parse_declaration, is_constructor=False, meet line: 'int_type\n      to_int_type(const char_type& __c)\n      { return static_cast<int_type>(__c); }\n\n      static constexpr bool\n      eq_int_type(const int_type& __c1, const int_type& __c2)\n      { return '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      eq_int_type(const int_type& __c1, const int_type& __c2)\n      { return __c1 == __c2; }\n\n      static constexpr int_type\n      eof()\n      { return static_cast<int_type>(-1); }\n\n      static'
[#] parse_declaration, is_constructor=False, meet line: 'int_type\n      eof()\n      { return static_cast<int_type>(-1); }\n\n      static constexpr int_type\n      not_eof(const int_type& __c)\n      { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_ty'
[#] parse_declaration, is_constructor=False, meet line: 'int_type\n      not_eof(const int_type& __c)\n      { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }\n    };\n\n  template<typename _CharT>\n    constexpr int\n    char_traits<_CharT>::\n'
[#] parse_declaration, is_constructor=False, meet line: 'int\n    char_traits<_CharT>::\n    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)\n    {\n      for (std::size_t __i = 0; __i < __n; ++__i)\n if (lt(__s1[__i], __s2[__i]))\n   retur'
[#] parse_declaration, is_constructor=False, meet line: 'std::size_t\n    char_traits<_CharT>::\n    length(const char_type* __p)\n    {\n      std::size_t __i = 0;\n      while (!eq(__p[__i], char_type()))\n        ++__i;\n      return __i;\n    }\n\n  template<type'
[#] parse_declaration, is_constructor=False, meet line: 'char_traits<_CharT>::char_type*\n    char_traits<_CharT>::\n    find(const char_type* __s, std::size_t __n, const char_type& __a)\n    {\n      for (std::size_t __i = 0; __i < __n; ++__i)\n        if (eq(_'
[#] parse_declaration, is_constructor=False, meet line: 'char_traits<_CharT>::char_type*\n    char_traits<_CharT>::\n    move(char_type* __s1, const char_type* __s2, std::size_t __n)\n    {\n      return static_cast<_CharT*>(__builtin_memmove(__s1, __s2,\n      '
[#] parse_declaration, is_constructor=False, meet line: 'char_traits<_CharT>::char_type*\n    char_traits<_CharT>::\n    copy(char_type* __s1, const char_type* __s2, std::size_t __n)\n    {\n\n      std::copy(__s2, __s2 + __n, __s1);\n      return __s1;\n    }\n\n  '
[#] parse_declaration, is_constructor=False, meet line: 'char_traits<_CharT>::char_type*\n    char_traits<_CharT>::\n    assign(char_type* __s, std::size_t __n, char_type __a)\n    {\n\n      std::fill_n(__s, __n, __a);\n      return __s;\n    }\n\n\n}\n\nnamespace std'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      assign(char_type& __c1, const char_type& __c2) noexcept\n      { __c1 = __c2; }\n\n      static constexpr bool\n      eq(const char_type& __c1, const char_type& __c2) noexcept\n      { return __'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      eq(const char_type& __c1, const char_type& __c2) noexcept\n      { return __c1 == __c2; }\n\n      static constexpr bool\n      lt(const char_type& __c1, const char_type& __c2) noexcept\n      {'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      lt(const char_type& __c1, const char_type& __c2) noexcept\n      {\n\n return (static_cast<unsigned char>(__c1)\n  < static_cast<unsigned char>(__c2));\n      }\n\n      static int\n      compare(c'
[#] parse_declaration, is_constructor=False, meet line: 'int\n      compare(const char_type* __s1, const char_type* __s2, size_t __n)\n      {\n\n\n\n\n\n\n if (__n == 0)\n   return 0;\n return __builtin_memcmp(__s1, __s2, __n);\n      }\n\n      static size_t\n      leng'
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n      length(const char_type* __s)\n      {\n\n\n\n\n return __builtin_strlen(__s);\n      }\n\n      static const char_type*\n      find(const char_type* __s, size_t __n, const char_type& __a)\n      {\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'char_type*\n      find(const char_type* __s, size_t __n, const char_type& __a)\n      {\n\n\n\n\n\n\n if (__n == 0)\n   return 0;\n return static_cast<const char_type*>(__builtin_memchr(__s, __a, __n));\n      }\n'
[#] parse_declaration, is_constructor=False, meet line: 'char_type*\n      move(char_type* __s1, const char_type* __s2, size_t __n)\n      {\n if (__n == 0)\n   return __s1;\n return static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n));\n      }\n\n      sta'
[#] parse_declaration, is_constructor=False, meet line: 'char_type*\n      copy(char_type* __s1, const char_type* __s2, size_t __n)\n      {\n if (__n == 0)\n   return __s1;\n return static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n));\n      }\n\n      stat'
[#] parse_declaration, is_constructor=False, meet line: 'char_type*\n      assign(char_type* __s, size_t __n, char_type __a)\n      {\n if (__n == 0)\n   return __s;\n return static_cast<char_type*>(__builtin_memset(__s, __a, __n));\n      }\n\n      static constex'
[#] parse_declaration, is_constructor=False, meet line: 'char_type\n      to_char_type(const int_type& __c) noexcept\n      { return static_cast<char_type>(__c); }\n\n\n\n      static constexpr int_type\n      to_int_type(const char_type& __c) noexcept\n      { ret'
[#] parse_declaration, is_constructor=False, meet line: 'int_type\n      to_int_type(const char_type& __c) noexcept\n      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }\n\n      static constexpr bool\n      eq_int_type(const int_type& __c1, '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept\n      { return __c1 == __c2; }\n\n      static constexpr int_type\n      eof() noexcept\n      { return static_cast<int_type>(-1'
[#] parse_declaration, is_constructor=False, meet line: 'int_type\n      eof() noexcept\n      { return static_cast<int_type>(-1); }\n\n      static constexpr int_type\n      not_eof(const int_type& __c) noexcept\n      { return (__c == eof()) ? 0 : __c; }\n  };\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'int_type\n      not_eof(const int_type& __c) noexcept\n      { return (__c == eof()) ? 0 : __c; }\n  };\n\n\n\n\n  template<>\n    struct char_traits<wchar_t>\n    {\n      typedef wchar_t char_type;\n      typed'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      assign(char_type& __c1, const char_type& __c2) noexcept\n      { __c1 = __c2; }\n\n      static constexpr bool\n      eq(const char_type& __c1, const char_type& __c2) noexcept\n      { return __'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      eq(const char_type& __c1, const char_type& __c2) noexcept\n      { return __c1 == __c2; }\n\n      static constexpr bool\n      lt(const char_type& __c1, const char_type& __c2) noexcept\n      {'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      lt(const char_type& __c1, const char_type& __c2) noexcept\n      { return __c1 < __c2; }\n\n      static int\n      compare(const char_type* __s1, const char_type* __s2, size_t __n)\n      {\n\n\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'int\n      compare(const char_type* __s1, const char_type* __s2, size_t __n)\n      {\n\n\n\n\n\n\n if (__n == 0)\n   return 0;\n else\n   return wmemcmp(__s1, __s2, __n);\n      }\n\n      static size_t\n      lengt'
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n      length(const char_type* __s)\n      {\n\n\n\n\n\n   return wcslen(__s);\n      }\n\n      static const char_type*\n      find(const char_type* __s, size_t __n, const char_type& __a)\n      {\n\n\n\n\n\n\n i'
[#] parse_declaration, is_constructor=False, meet line: 'char_type*\n      find(const char_type* __s, size_t __n, const char_type& __a)\n      {\n\n\n\n\n\n\n if (__n == 0)\n   return 0;\n else\n   return wmemchr(__s, __a, __n);\n      }\n\n      static char_type*\n      m'
[#] parse_declaration, is_constructor=False, meet line: 'char_type*\n      move(char_type* __s1, const char_type* __s2, size_t __n)\n      {\n if (__n == 0)\n   return __s1;\n return wmemmove(__s1, __s2, __n);\n      }\n\n      static char_type*\n      copy(char_typ'
[#] parse_declaration, is_constructor=False, meet line: 'char_type*\n      copy(char_type* __s1, const char_type* __s2, size_t __n)\n      {\n if (__n == 0)\n   return __s1;\n return wmemcpy(__s1, __s2, __n);\n      }\n\n      static char_type*\n      assign(char_ty'
[#] parse_declaration, is_constructor=False, meet line: 'char_type*\n      assign(char_type* __s, size_t __n, char_type __a)\n      {\n if (__n == 0)\n   return __s;\n return wmemset(__s, __a, __n);\n      }\n\n      static constexpr char_type\n      to_char_type(co'
[#] parse_declaration, is_constructor=False, meet line: 'char_type\n      to_char_type(const int_type& __c) noexcept\n      { return char_type(__c); }\n\n      static constexpr int_type\n      to_int_type(const char_type& __c) noexcept\n      { return int_type(__'
[#] parse_declaration, is_constructor=False, meet line: 'int_type\n      to_int_type(const char_type& __c) noexcept\n      { return int_type(__c); }\n\n      static constexpr bool\n      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept\n      { re'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept\n      { return __c1 == __c2; }\n\n      static constexpr int_type\n      eof() noexcept\n      { return static_cast<int_type>((0'
[#] parse_declaration, is_constructor=False, meet line: 'int_type\n      eof() noexcept\n      { return static_cast<int_type>((0xffffffffu)); }\n\n      static constexpr int_type\n      not_eof(const int_type& __c) noexcept\n      { return eq_int_type(__c, eof())'
[#] parse_declaration, is_constructor=False, meet line: 'int_type\n      not_eof(const int_type& __c) noexcept\n      { return eq_int_type(__c, eof()) ? 0 : __c; }\n  };\n\n\n\n}\n\n\n\n\n# 1 "/usr/include/c++/7/cstdint" 1 3\n# 32 "/usr/include/c++/7/cstdint" 3\n       \n'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      assign(char_type& __c1, const char_type& __c2) noexcept\n      { __c1 = __c2; }\n\n      static constexpr bool\n      eq(const char_type& __c1, const char_type& __c2) noexcept\n      { return __'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      eq(const char_type& __c1, const char_type& __c2) noexcept\n      { return __c1 == __c2; }\n\n      static constexpr bool\n      lt(const char_type& __c1, const char_type& __c2) noexcept\n      {'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      lt(const char_type& __c1, const char_type& __c2) noexcept\n      { return __c1 < __c2; }\n\n      static int\n      compare(const char_type* __s1, const char_type* __s2, size_t __n)\n      {\n fo'
[#] parse_declaration, is_constructor=False, meet line: 'int\n      compare(const char_type* __s1, const char_type* __s2, size_t __n)\n      {\n for (size_t __i = 0; __i < __n; ++__i)\n   if (lt(__s1[__i], __s2[__i]))\n     return -1;\n   else if (lt(__s2[__i], _'
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n      length(const char_type* __s)\n      {\n size_t __i = 0;\n while (!eq(__s[__i], char_type()))\n   ++__i;\n return __i;\n      }\n\n      static const char_type*\n      find(const char_type* __s, si'
[#] parse_declaration, is_constructor=False, meet line: 'char_type*\n      find(const char_type* __s, size_t __n, const char_type& __a)\n      {\n for (size_t __i = 0; __i < __n; ++__i)\n   if (eq(__s[__i], __a))\n     return __s + __i;\n return 0;\n      }\n\n     '
[#] parse_declaration, is_constructor=False, meet line: 'char_type*\n      move(char_type* __s1, const char_type* __s2, size_t __n)\n      {\n if (__n == 0)\n   return __s1;\n return (static_cast<char_type*>\n  (__builtin_memmove(__s1, __s2, __n * sizeof(char_typ'
[#] parse_declaration, is_constructor=False, meet line: 'char_type*\n      copy(char_type* __s1, const char_type* __s2, size_t __n)\n      {\n if (__n == 0)\n   return __s1;\n return (static_cast<char_type*>\n  (__builtin_memcpy(__s1, __s2, __n * sizeof(char_type'
[#] parse_declaration, is_constructor=False, meet line: 'char_type*\n      assign(char_type* __s, size_t __n, char_type __a)\n      {\n for (size_t __i = 0; __i < __n; ++__i)\n   assign(__s[__i], __a);\n return __s;\n      }\n\n      static constexpr char_type\n    '
[#] parse_declaration, is_constructor=False, meet line: 'char_type\n      to_char_type(const int_type& __c) noexcept\n      { return char_type(__c); }\n\n      static constexpr int_type\n      to_int_type(const char_type& __c) noexcept\n      { return int_type(__'
[#] parse_declaration, is_constructor=False, meet line: 'int_type\n      to_int_type(const char_type& __c) noexcept\n      { return int_type(__c); }\n\n      static constexpr bool\n      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept\n      { re'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept\n      { return __c1 == __c2; }\n\n      static constexpr int_type\n      eof() noexcept\n      { return static_cast<int_type>(-1'
[#] parse_declaration, is_constructor=False, meet line: 'int_type\n      eof() noexcept\n      { return static_cast<int_type>(-1); }\n\n      static constexpr int_type\n      not_eof(const int_type& __c) noexcept\n      { return eq_int_type(__c, eof()) ? 0 : __c;'
[#] parse_declaration, is_constructor=False, meet line: 'int_type\n      not_eof(const int_type& __c) noexcept\n      { return eq_int_type(__c, eof()) ? 0 : __c; }\n    };\n\n  template<>\n    struct char_traits<char32_t>\n    {\n      typedef char32_t char_type;\n '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      assign(char_type& __c1, const char_type& __c2) noexcept\n      { __c1 = __c2; }\n\n      static constexpr bool\n      eq(const char_type& __c1, const char_type& __c2) noexcept\n      { return __'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      eq(const char_type& __c1, const char_type& __c2) noexcept\n      { return __c1 == __c2; }\n\n      static constexpr bool\n      lt(const char_type& __c1, const char_type& __c2) noexcept\n      {'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      lt(const char_type& __c1, const char_type& __c2) noexcept\n      { return __c1 < __c2; }\n\n      static int\n      compare(const char_type* __s1, const char_type* __s2, size_t __n)\n      {\n fo'
[#] parse_declaration, is_constructor=False, meet line: 'int\n      compare(const char_type* __s1, const char_type* __s2, size_t __n)\n      {\n for (size_t __i = 0; __i < __n; ++__i)\n   if (lt(__s1[__i], __s2[__i]))\n     return -1;\n   else if (lt(__s2[__i], _'
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n      length(const char_type* __s)\n      {\n size_t __i = 0;\n while (!eq(__s[__i], char_type()))\n   ++__i;\n return __i;\n      }\n\n      static const char_type*\n      find(const char_type* __s, si'
[#] parse_declaration, is_constructor=False, meet line: 'char_type*\n      find(const char_type* __s, size_t __n, const char_type& __a)\n      {\n for (size_t __i = 0; __i < __n; ++__i)\n   if (eq(__s[__i], __a))\n     return __s + __i;\n return 0;\n      }\n\n     '
[#] parse_declaration, is_constructor=False, meet line: 'char_type*\n      move(char_type* __s1, const char_type* __s2, size_t __n)\n      {\n if (__n == 0)\n   return __s1;\n return (static_cast<char_type*>\n  (__builtin_memmove(__s1, __s2, __n * sizeof(char_typ'
[#] parse_declaration, is_constructor=False, meet line: 'char_type*\n      copy(char_type* __s1, const char_type* __s2, size_t __n)\n      {\n if (__n == 0)\n   return __s1;\n return (static_cast<char_type*>\n  (__builtin_memcpy(__s1, __s2, __n * sizeof(char_type'
[#] parse_declaration, is_constructor=False, meet line: 'char_type*\n      assign(char_type* __s, size_t __n, char_type __a)\n      {\n for (size_t __i = 0; __i < __n; ++__i)\n   assign(__s[__i], __a);\n return __s;\n      }\n\n      static constexpr char_type\n    '
[#] parse_declaration, is_constructor=False, meet line: 'char_type\n      to_char_type(const int_type& __c) noexcept\n      { return char_type(__c); }\n\n      static constexpr int_type\n      to_int_type(const char_type& __c) noexcept\n      { return int_type(__'
[#] parse_declaration, is_constructor=False, meet line: 'int_type\n      to_int_type(const char_type& __c) noexcept\n      { return int_type(__c); }\n\n      static constexpr bool\n      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept\n      { re'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept\n      { return __c1 == __c2; }\n\n      static constexpr int_type\n      eof() noexcept\n      { return static_cast<int_type>(-1'
[#] parse_declaration, is_constructor=False, meet line: 'int_type\n      eof() noexcept\n      { return static_cast<int_type>(-1); }\n\n      static constexpr int_type\n      not_eof(const int_type& __c) noexcept\n      { return eq_int_type(__c, eof()) ? 0 : __c;'
[#] parse_declaration, is_constructor=False, meet line: 'int_type\n      not_eof(const int_type& __c) noexcept\n      { return eq_int_type(__c, eof()) ? 0 : __c; }\n    };\n\n\n}\n# 41 "/usr/include/c++/7/string" 2 3\n# 1 "/usr/include/c++/7/bits/allocator.h" 1 3\n#'
[#] parse_declaration, is_constructor=True, meet line: 'new_allocator() noexcept { }\n\n      new_allocator(const new_allocator&) noexcept { }\n\n      template<typename _Tp1>\n new_allocator(const new_allocator<_Tp1>&) noexcept { }\n\n      ~new_allocator() noex'
[#] parse_declaration, is_constructor=True, meet line: 'new_allocator(const new_allocator&) noexcept { }\n\n      template<typename _Tp1>\n new_allocator(const new_allocator<_Tp1>&) noexcept { }\n\n      ~new_allocator() noexcept { }\n\n      pointer\n      addres'
[#] parse_declaration, is_constructor=True, meet line: 'new_allocator(const new_allocator<_Tp1>&) noexcept { }\n\n      ~new_allocator() noexcept { }\n\n      pointer\n      address(reference __x) const noexcept\n      { return std::__addressof(__x); }\n\n      co'
[#] parse_declaration, is_constructor=True, meet line: 'new_allocator() noexcept { }\n\n      pointer\n      address(reference __x) const noexcept\n      { return std::__addressof(__x); }\n\n      const_pointer\n      address(const_reference __x) const noexcept\n '
[#] parse_declaration, is_constructor=False, meet line: 'pointer\n      address(reference __x) const noexcept\n      { return std::__addressof(__x); }\n\n      const_pointer\n      address(const_reference __x) const noexcept\n      { return std::__addressof(__x);'
[#] parse_declaration, is_constructor=False, meet line: 'const_pointer\n      address(const_reference __x) const noexcept\n      { return std::__addressof(__x); }\n\n\n\n      pointer\n      allocate(size_type __n, const void* = static_cast<const void*>(0))\n      '
[#] parse_declaration, is_constructor=False, meet line: 'pointer\n      allocate(size_type __n, const void* = static_cast<const void*>(0))\n      {\n if (__n > this->max_size())\n   std::__throw_bad_alloc();\n# 111 "/usr/include/c++/7/ext/new_allocator.h" 3\n ret'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      deallocate(pointer __p, size_type)\n      {\n\n\n\n\n\n\n\n ::operator delete(__p);\n      }\n\n      size_type\n      max_size() const noexcept\n      { return size_t(-1) / sizeof(_Tp); }\n\n\n      templa'
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      max_size() const noexcept\n      { return size_t(-1) / sizeof(_Tp); }\n\n\n      template<typename _Up, typename... _Args>\n void\n construct(_Up* __p, _Args&&... __args)\n { ::new((void *)__'
[#] parse_declaration, is_constructor=False, meet line: 'void\n construct(_Up* __p, _Args&&... __args)\n { ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }\n\n      template<typename _Up>\n void\n destroy(_Up* __p) { __p->~_Up(); }\n# 151 "/usr/include/c+'
[#] parse_declaration, is_constructor=False, meet line: 'void\n destroy(_Up* __p) { __p->~_Up(); }\n# 151 "/usr/include/c++/7/ext/new_allocator.h" 3\n    };\n\n  template<typename _Tp>\n    inline bool\n    operator==(const new_allocator<_Tp>&, const new_allocator'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator==(const new_allocator<_Tp>&, const new_allocator<_Tp>&)\n    { return true; }\n\n  template<typename _Tp>\n    inline bool\n    operator!=(const new_allocator<_Tp>&, const new_allocator<_'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator!=(const new_allocator<_Tp>&, const new_allocator<_Tp>&)\n    { return false; }\n\n\n}\n# 34 "/usr/include/x86_64-linux-gnu/c++/7/bits/c++allocator.h" 2 3\n\n\nnamespace std\n{\n# 47 "/usr/incl'
[#] parse_declaration, is_constructor=False, meet line: 'void\n construct(_Up* __p, _Args&&... __args)\n { ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }\n\n      template<typename _Up>\n void\n destroy(_Up* __p) { __p->~_Up(); }\n\n    };\n# 107 "/usr/in'
[#] parse_declaration, is_constructor=False, meet line: 'void\n destroy(_Up* __p) { __p->~_Up(); }\n\n    };\n# 107 "/usr/include/c++/7/bits/allocator.h" 3\n  template<typename _Tp>\n    class allocator: public __allocator_base<_Tp>\n    {\n   public:\n      typedef'
[#] parse_declaration, is_constructor=True, meet line: 'allocator() throw() { }\n\n      allocator(const allocator& __a) throw()\n      : __allocator_base<_Tp>(__a) { }\n\n      template<typename _Tp1>\n allocator(const allocator<_Tp1>&) throw() { }\n\n      ~allo'
[#] parse_declaration, is_constructor=True, meet line: 'allocator(const allocator& __a) throw()\n      : __allocator_base<_Tp>(__a) { }\n\n      template<typename _Tp1>\n allocator(const allocator<_Tp1>&) throw() { }\n\n      ~allocator() throw() { }\n\n\n    };\n\n '
[#] parse_declaration, is_constructor=True, meet line: 'allocator(const allocator<_Tp1>&) throw() { }\n\n      ~allocator() throw() { }\n\n\n    };\n\n  template<typename _T1, typename _T2>\n    inline bool\n    operator==(const allocator<_T1>&, const allocator<_T2'
[#] parse_declaration, is_constructor=True, meet line: 'allocator() throw() { }\n\n\n    };\n\n  template<typename _T1, typename _T2>\n    inline bool\n    operator==(const allocator<_T1>&, const allocator<_T2>&)\n    noexcept\n    { return true; }\n\n  template<type'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator==(const allocator<_T1>&, const allocator<_T2>&)\n    noexcept\n    { return true; }\n\n  template<typename _Tp>\n    inline bool\n    operator==(const allocator<_Tp>&, const allocator<_Tp>'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator==(const allocator<_Tp>&, const allocator<_Tp>&)\n    noexcept\n    { return true; }\n\n  template<typename _T1, typename _T2>\n    inline bool\n    operator!=(const allocator<_T1>&, const '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator!=(const allocator<_T1>&, const allocator<_T2>&)\n    noexcept\n    { return false; }\n\n  template<typename _Tp>\n    inline bool\n    operator!=(const allocator<_Tp>&, const allocator<_Tp'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator!=(const allocator<_Tp>&, const allocator<_Tp>&)\n    noexcept\n    { return false; }\n\n\n\n\n\n\n  extern template class allocator<char>;\n  extern template class allocator<wchar_t>;\n\n\n\n\n\n\n  '
[#] parse_declaration, is_constructor=False, meet line: 'template class allocator<char>;\n  extern template class allocator<wchar_t>;\n\n\n\n\n\n\n  template<typename _Alloc, bool = __is_empty(_Alloc)>\n    struct __alloc_swap\n    { static void _S_do_it(_Alloc&, _Al'
[#] parse_declaration, is_constructor=False, meet line: 'template class allocator<wchar_t>;\n\n\n\n\n\n\n  template<typename _Alloc, bool = __is_empty(_Alloc)>\n    struct __alloc_swap\n    { static void _S_do_it(_Alloc&, _Alloc&) noexcept { } };\n\n  template<typenam'
[#] parse_declaration, is_constructor=False, meet line: 'void _S_do_it(_Alloc&, _Alloc&) noexcept { } };\n\n  template<typename _Alloc>\n    struct __alloc_swap<_Alloc, false>\n    {\n      static void\n      _S_do_it(_Alloc& __one, _Alloc& __two) noexcept\n      '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _S_do_it(_Alloc& __one, _Alloc& __two) noexcept\n      {\n\n if (__one != __two)\n   swap(__one, __two);\n      }\n    };\n\n\n  template<typename _Alloc, bool = __is_empty(_Alloc)>\n    struct __all'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      _S_do_it(const _Alloc&, const _Alloc&)\n      { return false; }\n    };\n\n  template<typename _Alloc>\n    struct __alloc_neq<_Alloc, false>\n    {\n      static bool\n      _S_do_it(const _Alloc&'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      _S_do_it(const _Alloc& __one, const _Alloc& __two)\n      { return __one != __two; }\n    };\n\n\n  template<typename _Tp, bool\n    = __or_<is_copy_constructible<typename _Tp::value_type>,\n     '
[#] parse_declaration, is_constructor=False, meet line: 'bool _S_do_it(_Tp&) noexcept { return false; } };\n\n  template<typename _Tp>\n    struct __shrink_to_fit_aux<_Tp, true>\n    {\n      static bool\n      _S_do_it(_Tp& __c) noexcept\n      {\n\n try\n   {\n     '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      _S_do_it(_Tp& __c) noexcept\n      {\n\n try\n   {\n     _Tp(__make_move_if_noexcept_iterator(__c.begin()),\n  __make_move_if_noexcept_iterator(__c.end()),\n  __c.get_allocator()).swap(__c);\n     '
[#] parse_declaration, is_constructor=False, meet line: 'char *decimal_point;\n  char *thousands_sep;\n\n\n\n\n\n  char *grouping;\n\n\n\n\n\n  char *int_curr_symbol;\n  char *currency_symbol;\n  char *mon_decimal_point;\n  char *mon_thousands_sep;\n  char *mon_grouping;\n  '
[#] parse_declaration, is_constructor=False, meet line: 'char *thousands_sep;\n\n\n\n\n\n  char *grouping;\n\n\n\n\n\n  char *int_curr_symbol;\n  char *currency_symbol;\n  char *mon_decimal_point;\n  char *mon_thousands_sep;\n  char *mon_grouping;\n  char *positive_sign;\n  '
[#] parse_declaration, is_constructor=False, meet line: 'char *grouping;\n\n\n\n\n\n  char *int_curr_symbol;\n  char *currency_symbol;\n  char *mon_decimal_point;\n  char *mon_thousands_sep;\n  char *mon_grouping;\n  char *positive_sign;\n  char *negative_sign;\n  char '
[#] parse_declaration, is_constructor=False, meet line: 'char *int_curr_symbol;\n  char *currency_symbol;\n  char *mon_decimal_point;\n  char *mon_thousands_sep;\n  char *mon_grouping;\n  char *positive_sign;\n  char *negative_sign;\n  char int_frac_digits;\n  char'
[#] parse_declaration, is_constructor=False, meet line: 'char *currency_symbol;\n  char *mon_decimal_point;\n  char *mon_thousands_sep;\n  char *mon_grouping;\n  char *positive_sign;\n  char *negative_sign;\n  char int_frac_digits;\n  char frac_digits;\n\n  char p_c'
[#] parse_declaration, is_constructor=False, meet line: 'char *mon_decimal_point;\n  char *mon_thousands_sep;\n  char *mon_grouping;\n  char *positive_sign;\n  char *negative_sign;\n  char int_frac_digits;\n  char frac_digits;\n\n  char p_cs_precedes;\n\n  char p_sep'
[#] parse_declaration, is_constructor=False, meet line: 'char *mon_thousands_sep;\n  char *mon_grouping;\n  char *positive_sign;\n  char *negative_sign;\n  char int_frac_digits;\n  char frac_digits;\n\n  char p_cs_precedes;\n\n  char p_sep_by_space;\n\n  char n_cs_pre'
[#] parse_declaration, is_constructor=False, meet line: 'char *mon_grouping;\n  char *positive_sign;\n  char *negative_sign;\n  char int_frac_digits;\n  char frac_digits;\n\n  char p_cs_precedes;\n\n  char p_sep_by_space;\n\n  char n_cs_precedes;\n\n  char n_sep_by_spa'
[#] parse_declaration, is_constructor=False, meet line: 'char *positive_sign;\n  char *negative_sign;\n  char int_frac_digits;\n  char frac_digits;\n\n  char p_cs_precedes;\n\n  char p_sep_by_space;\n\n  char n_cs_precedes;\n\n  char n_sep_by_space;\n\n\n\n\n\n\n  char p_sig'
[#] parse_declaration, is_constructor=False, meet line: 'char *negative_sign;\n  char int_frac_digits;\n  char frac_digits;\n\n  char p_cs_precedes;\n\n  char p_sep_by_space;\n\n  char n_cs_precedes;\n\n  char n_sep_by_space;\n\n\n\n\n\n\n  char p_sign_posn;\n  char n_sign_p'
[#] parse_declaration, is_constructor=False, meet line: 'char int_frac_digits;\n  char frac_digits;\n\n  char p_cs_precedes;\n\n  char p_sep_by_space;\n\n  char n_cs_precedes;\n\n  char n_sep_by_space;\n\n\n\n\n\n\n  char p_sign_posn;\n  char n_sign_posn;\n\n\n  char int_p_cs_'
[#] parse_declaration, is_constructor=False, meet line: 'char frac_digits;\n\n  char p_cs_precedes;\n\n  char p_sep_by_space;\n\n  char n_cs_precedes;\n\n  char n_sep_by_space;\n\n\n\n\n\n\n  char p_sign_posn;\n  char n_sign_posn;\n\n\n  char int_p_cs_precedes;\n\n  char int_p_'
[#] parse_declaration, is_constructor=False, meet line: 'char p_cs_precedes;\n\n  char p_sep_by_space;\n\n  char n_cs_precedes;\n\n  char n_sep_by_space;\n\n\n\n\n\n\n  char p_sign_posn;\n  char n_sign_posn;\n\n\n  char int_p_cs_precedes;\n\n  char int_p_sep_by_space;\n\n  char'
[#] parse_declaration, is_constructor=False, meet line: 'char p_sep_by_space;\n\n  char n_cs_precedes;\n\n  char n_sep_by_space;\n\n\n\n\n\n\n  char p_sign_posn;\n  char n_sign_posn;\n\n\n  char int_p_cs_precedes;\n\n  char int_p_sep_by_space;\n\n  char int_n_cs_precedes;\n\n  '
[#] parse_declaration, is_constructor=False, meet line: 'char n_cs_precedes;\n\n  char n_sep_by_space;\n\n\n\n\n\n\n  char p_sign_posn;\n  char n_sign_posn;\n\n\n  char int_p_cs_precedes;\n\n  char int_p_sep_by_space;\n\n  char int_n_cs_precedes;\n\n  char int_n_sep_by_space;'
[#] parse_declaration, is_constructor=False, meet line: 'char n_sep_by_space;\n\n\n\n\n\n\n  char p_sign_posn;\n  char n_sign_posn;\n\n\n  char int_p_cs_precedes;\n\n  char int_p_sep_by_space;\n\n  char int_n_cs_precedes;\n\n  char int_n_sep_by_space;\n\n\n\n\n\n\n  char int_p_sig'
[#] parse_declaration, is_constructor=False, meet line: 'char p_sign_posn;\n  char n_sign_posn;\n\n\n  char int_p_cs_precedes;\n\n  char int_p_sep_by_space;\n\n  char int_n_cs_precedes;\n\n  char int_n_sep_by_space;\n\n\n\n\n\n\n  char int_p_sign_posn;\n  char int_n_sign_pos'
[#] parse_declaration, is_constructor=False, meet line: 'char n_sign_posn;\n\n\n  char int_p_cs_precedes;\n\n  char int_p_sep_by_space;\n\n  char int_n_cs_precedes;\n\n  char int_n_sep_by_space;\n\n\n\n\n\n\n  char int_p_sign_posn;\n  char int_n_sign_posn;\n# 118 "/usr/inclu'
[#] parse_declaration, is_constructor=False, meet line: 'char int_p_cs_precedes;\n\n  char int_p_sep_by_space;\n\n  char int_n_cs_precedes;\n\n  char int_n_sep_by_space;\n\n\n\n\n\n\n  char int_p_sign_posn;\n  char int_n_sign_posn;\n# 118 "/usr/include/locale.h" 3 4\n};\n\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'char int_p_sep_by_space;\n\n  char int_n_cs_precedes;\n\n  char int_n_sep_by_space;\n\n\n\n\n\n\n  char int_p_sign_posn;\n  char int_n_sign_posn;\n# 118 "/usr/include/locale.h" 3 4\n};\n\n\n\nextern char *setlocale (in'
[#] parse_declaration, is_constructor=False, meet line: 'char int_n_cs_precedes;\n\n  char int_n_sep_by_space;\n\n\n\n\n\n\n  char int_p_sign_posn;\n  char int_n_sign_posn;\n# 118 "/usr/include/locale.h" 3 4\n};\n\n\n\nextern char *setlocale (int __category, const char *__'
[#] parse_declaration, is_constructor=False, meet line: 'char int_n_sep_by_space;\n\n\n\n\n\n\n  char int_p_sign_posn;\n  char int_n_sign_posn;\n# 118 "/usr/include/locale.h" 3 4\n};\n\n\n\nextern char *setlocale (int __category, const char *__locale) throw ();\n\n\nextern '
[#] parse_declaration, is_constructor=False, meet line: 'char int_p_sign_posn;\n  char int_n_sign_posn;\n# 118 "/usr/include/locale.h" 3 4\n};\n\n\n\nextern char *setlocale (int __category, const char *__locale) throw ();\n\n\nextern struct lconv *localeconv (void) t'
[#] parse_declaration, is_constructor=False, meet line: 'char int_n_sign_posn;\n# 118 "/usr/include/locale.h" 3 4\n};\n\n\n\nextern char *setlocale (int __category, const char *__locale) throw ();\n\n\nextern struct lconv *localeconv (void) throw ();\n# 141 "/usr/inc'
[#] parse_declaration, is_constructor=False, meet line: 'char *setlocale (int __category, const char *__locale) throw ();\n\n\nextern struct lconv *localeconv (void) throw ();\n# 141 "/usr/include/locale.h" 3 4\nextern locale_t newlocale (int __category_mask, co'
[#] parse_declaration, is_constructor=False, meet line: 'struct lconv *localeconv (void) throw ();\n# 141 "/usr/include/locale.h" 3 4\nextern locale_t newlocale (int __category_mask, const char *__locale,\n      locale_t __base) throw ();\n# 176 "/usr/include/l'
[#] parse_declaration, is_constructor=False, meet line: 'locale_t newlocale (int __category_mask, const char *__locale,\n      locale_t __base) throw ();\n# 176 "/usr/include/locale.h" 3 4\nextern locale_t duplocale (locale_t __dataset) throw ();\n\n\n\nextern voi'
[#] parse_declaration, is_constructor=False, meet line: 'locale_t duplocale (locale_t __dataset) throw ();\n\n\n\nextern void freelocale (locale_t __dataset) throw ();\n\n\n\n\n\n\nextern locale_t uselocale (locale_t __dataset) throw ();\n\n\n\n\n\n\n\n}\n# 43 "/usr/include/c+'
[#] parse_declaration, is_constructor=False, meet line: 'void freelocale (locale_t __dataset) throw ();\n\n\n\n\n\n\nextern locale_t uselocale (locale_t __dataset) throw ();\n\n\n\n\n\n\n\n}\n# 43 "/usr/include/c++/7/clocale" 2 3\n# 51 "/usr/include/c++/7/clocale" 3\nnamespa'
[#] parse_declaration, is_constructor=False, meet line: 'locale_t uselocale (locale_t __dataset) throw ();\n\n\n\n\n\n\n\n}\n# 43 "/usr/include/c++/7/clocale" 2 3\n# 51 "/usr/include/c++/7/clocale" 3\nnamespace std\n{\n  using ::lconv;\n  using ::setlocale;\n  using ::loc'
[#] parse_declaration, is_constructor=False, meet line: ' __typeof(uselocale) __uselocale;\n\n\n}\n\n\nnamespace std __attribute__ ((__visibility__ ("default")))\n{\n\n\n  typedef __locale_t __c_locale;\n\n\n\n\n\n  inline int\n  __convert_from_v(const __c_locale& __cloc __'
[#] parse_declaration, is_constructor=False, meet line: 'int\n  __convert_from_v(const __c_locale& __cloc __attribute__ ((__unused__)),\n     char* __out,\n     const int __size __attribute__ ((__unused__)),\n     const char* __fmt, ...)\n  {\n\n    __c_locale __o'
[#] parse_declaration, is_constructor=False, meet line: 'const unsigned short int **__ctype_b_loc (void)\n     throw () __attribute__ ((__const__));\nextern const __int32_t **__ctype_tolower_loc (void)\n     throw () __attribute__ ((__const__));\nextern const _'
[#] parse_declaration, is_constructor=False, meet line: 'const __int32_t **__ctype_tolower_loc (void)\n     throw () __attribute__ ((__const__));\nextern const __int32_t **__ctype_toupper_loc (void)\n     throw () __attribute__ ((__const__));\n# 108 "/usr/inclu'
[#] parse_declaration, is_constructor=False, meet line: 'const __int32_t **__ctype_toupper_loc (void)\n     throw () __attribute__ ((__const__));\n# 108 "/usr/include/ctype.h" 3 4\nextern int isalnum (int) throw ();\nextern int isalpha (int) throw ();\nextern in'
[#] parse_declaration, is_constructor=False, meet line: 'int isalnum (int) throw ();\nextern int isalpha (int) throw ();\nextern int iscntrl (int) throw ();\nextern int isdigit (int) throw ();\nextern int islower (int) throw ();\nextern int isgraph (int) throw ('
[#] parse_declaration, is_constructor=False, meet line: 'int isalpha (int) throw ();\nextern int iscntrl (int) throw ();\nextern int isdigit (int) throw ();\nextern int islower (int) throw ();\nextern int isgraph (int) throw ();\nextern int isprint (int) throw ('
[#] parse_declaration, is_constructor=False, meet line: 'int iscntrl (int) throw ();\nextern int isdigit (int) throw ();\nextern int islower (int) throw ();\nextern int isgraph (int) throw ();\nextern int isprint (int) throw ();\nextern int ispunct (int) throw ('
[#] parse_declaration, is_constructor=False, meet line: 'int isdigit (int) throw ();\nextern int islower (int) throw ();\nextern int isgraph (int) throw ();\nextern int isprint (int) throw ();\nextern int ispunct (int) throw ();\nextern int isspace (int) throw ('
[#] parse_declaration, is_constructor=False, meet line: 'int islower (int) throw ();\nextern int isgraph (int) throw ();\nextern int isprint (int) throw ();\nextern int ispunct (int) throw ();\nextern int isspace (int) throw ();\nextern int isupper (int) throw ('
[#] parse_declaration, is_constructor=False, meet line: 'int isgraph (int) throw ();\nextern int isprint (int) throw ();\nextern int ispunct (int) throw ();\nextern int isspace (int) throw ();\nextern int isupper (int) throw ();\nextern int isxdigit (int) throw '
[#] parse_declaration, is_constructor=False, meet line: 'int isprint (int) throw ();\nextern int ispunct (int) throw ();\nextern int isspace (int) throw ();\nextern int isupper (int) throw ();\nextern int isxdigit (int) throw ();\n\n\n\nextern int tolower (int __c)'
[#] parse_declaration, is_constructor=False, meet line: 'int ispunct (int) throw ();\nextern int isspace (int) throw ();\nextern int isupper (int) throw ();\nextern int isxdigit (int) throw ();\n\n\n\nextern int tolower (int __c) throw ();\n\n\nextern int toupper (in'
[#] parse_declaration, is_constructor=False, meet line: 'int isspace (int) throw ();\nextern int isupper (int) throw ();\nextern int isxdigit (int) throw ();\n\n\n\nextern int tolower (int __c) throw ();\n\n\nextern int toupper (int __c) throw ();\n\n\n\n\nextern int isb'
[#] parse_declaration, is_constructor=False, meet line: 'int isupper (int) throw ();\nextern int isxdigit (int) throw ();\n\n\n\nextern int tolower (int __c) throw ();\n\n\nextern int toupper (int __c) throw ();\n\n\n\n\nextern int isblank (int) throw ();\n\n\n\n\nextern int'
[#] parse_declaration, is_constructor=False, meet line: 'int isxdigit (int) throw ();\n\n\n\nextern int tolower (int __c) throw ();\n\n\nextern int toupper (int __c) throw ();\n\n\n\n\nextern int isblank (int) throw ();\n\n\n\n\nextern int isctype (int __c, int __mask) thro'
[#] parse_declaration, is_constructor=False, meet line: 'int tolower (int __c) throw ();\n\n\nextern int toupper (int __c) throw ();\n\n\n\n\nextern int isblank (int) throw ();\n\n\n\n\nextern int isctype (int __c, int __mask) throw ();\n\n\n\n\n\n\nextern int isascii (int __c'
[#] parse_declaration, is_constructor=False, meet line: 'int toupper (int __c) throw ();\n\n\n\n\nextern int isblank (int) throw ();\n\n\n\n\nextern int isctype (int __c, int __mask) throw ();\n\n\n\n\n\n\nextern int isascii (int __c) throw ();\n\n\n\nextern int toascii (int __'
[#] parse_declaration, is_constructor=False, meet line: 'int isblank (int) throw ();\n\n\n\n\nextern int isctype (int __c, int __mask) throw ();\n\n\n\n\n\n\nextern int isascii (int __c) throw ();\n\n\n\nextern int toascii (int __c) throw ();\n\n\n\nextern int _toupper (int) t'
[#] parse_declaration, is_constructor=False, meet line: 'int isctype (int __c, int __mask) throw ();\n\n\n\n\n\n\nextern int isascii (int __c) throw ();\n\n\n\nextern int toascii (int __c) throw ();\n\n\n\nextern int _toupper (int) throw ();\nextern int _tolower (int) thro'
[#] parse_declaration, is_constructor=False, meet line: 'int isascii (int __c) throw ();\n\n\n\nextern int toascii (int __c) throw ();\n\n\n\nextern int _toupper (int) throw ();\nextern int _tolower (int) throw ();\n# 251 "/usr/include/ctype.h" 3 4\nextern int isalnum'
[#] parse_declaration, is_constructor=False, meet line: 'int toascii (int __c) throw ();\n\n\n\nextern int _toupper (int) throw ();\nextern int _tolower (int) throw ();\n# 251 "/usr/include/ctype.h" 3 4\nextern int isalnum_l (int, locale_t) throw ();\nextern int is'
[#] parse_declaration, is_constructor=False, meet line: 'int _toupper (int) throw ();\nextern int _tolower (int) throw ();\n# 251 "/usr/include/ctype.h" 3 4\nextern int isalnum_l (int, locale_t) throw ();\nextern int isalpha_l (int, locale_t) throw ();\nextern i'
[#] parse_declaration, is_constructor=False, meet line: 'int _tolower (int) throw ();\n# 251 "/usr/include/ctype.h" 3 4\nextern int isalnum_l (int, locale_t) throw ();\nextern int isalpha_l (int, locale_t) throw ();\nextern int iscntrl_l (int, locale_t) throw ('
[#] parse_declaration, is_constructor=False, meet line: 'int isalnum_l (int, locale_t) throw ();\nextern int isalpha_l (int, locale_t) throw ();\nextern int iscntrl_l (int, locale_t) throw ();\nextern int isdigit_l (int, locale_t) throw ();\nextern int islower_'
[#] parse_declaration, is_constructor=False, meet line: 'int isalpha_l (int, locale_t) throw ();\nextern int iscntrl_l (int, locale_t) throw ();\nextern int isdigit_l (int, locale_t) throw ();\nextern int islower_l (int, locale_t) throw ();\nextern int isgraph_'
[#] parse_declaration, is_constructor=False, meet line: 'int iscntrl_l (int, locale_t) throw ();\nextern int isdigit_l (int, locale_t) throw ();\nextern int islower_l (int, locale_t) throw ();\nextern int isgraph_l (int, locale_t) throw ();\nextern int isprint_'
[#] parse_declaration, is_constructor=False, meet line: 'int isdigit_l (int, locale_t) throw ();\nextern int islower_l (int, locale_t) throw ();\nextern int isgraph_l (int, locale_t) throw ();\nextern int isprint_l (int, locale_t) throw ();\nextern int ispunct_'
[#] parse_declaration, is_constructor=False, meet line: 'int islower_l (int, locale_t) throw ();\nextern int isgraph_l (int, locale_t) throw ();\nextern int isprint_l (int, locale_t) throw ();\nextern int ispunct_l (int, locale_t) throw ();\nextern int isspace_'
[#] parse_declaration, is_constructor=False, meet line: 'int isgraph_l (int, locale_t) throw ();\nextern int isprint_l (int, locale_t) throw ();\nextern int ispunct_l (int, locale_t) throw ();\nextern int isspace_l (int, locale_t) throw ();\nextern int isupper_'
[#] parse_declaration, is_constructor=False, meet line: 'int isprint_l (int, locale_t) throw ();\nextern int ispunct_l (int, locale_t) throw ();\nextern int isspace_l (int, locale_t) throw ();\nextern int isupper_l (int, locale_t) throw ();\nextern int isxdigit'
[#] parse_declaration, is_constructor=False, meet line: 'int ispunct_l (int, locale_t) throw ();\nextern int isspace_l (int, locale_t) throw ();\nextern int isupper_l (int, locale_t) throw ();\nextern int isxdigit_l (int, locale_t) throw ();\n\nextern int isblan'
[#] parse_declaration, is_constructor=False, meet line: 'int isspace_l (int, locale_t) throw ();\nextern int isupper_l (int, locale_t) throw ();\nextern int isxdigit_l (int, locale_t) throw ();\n\nextern int isblank_l (int, locale_t) throw ();\n\n\n\nextern int __t'
[#] parse_declaration, is_constructor=False, meet line: 'int isupper_l (int, locale_t) throw ();\nextern int isxdigit_l (int, locale_t) throw ();\n\nextern int isblank_l (int, locale_t) throw ();\n\n\n\nextern int __tolower_l (int __c, locale_t __l) throw ();\nexte'
[#] parse_declaration, is_constructor=False, meet line: 'int isxdigit_l (int, locale_t) throw ();\n\nextern int isblank_l (int, locale_t) throw ();\n\n\n\nextern int __tolower_l (int __c, locale_t __l) throw ();\nextern int tolower_l (int __c, locale_t __l) throw '
[#] parse_declaration, is_constructor=False, meet line: 'int isblank_l (int, locale_t) throw ();\n\n\n\nextern int __tolower_l (int __c, locale_t __l) throw ();\nextern int tolower_l (int __c, locale_t __l) throw ();\n\n\nextern int __toupper_l (int __c, locale_t _'
[#] parse_declaration, is_constructor=False, meet line: 'int __tolower_l (int __c, locale_t __l) throw ();\nextern int tolower_l (int __c, locale_t __l) throw ();\n\n\nextern int __toupper_l (int __c, locale_t __l) throw ();\nextern int toupper_l (int __c, local'
[#] parse_declaration, is_constructor=False, meet line: 'int tolower_l (int __c, locale_t __l) throw ();\n\n\nextern int __toupper_l (int __c, locale_t __l) throw ();\nextern int toupper_l (int __c, locale_t __l) throw ();\n# 327 "/usr/include/ctype.h" 3 4\n}\n# 4'
[#] parse_declaration, is_constructor=False, meet line: 'int __toupper_l (int __c, locale_t __l) throw ();\nextern int toupper_l (int __c, locale_t __l) throw ();\n# 327 "/usr/include/ctype.h" 3 4\n}\n# 43 "/usr/include/c++/7/cctype" 2 3\n# 62 "/usr/include/c++/'
[#] parse_declaration, is_constructor=False, meet line: 'int toupper_l (int __c, locale_t __l) throw ();\n# 327 "/usr/include/ctype.h" 3 4\n}\n# 43 "/usr/include/c++/7/cctype" 2 3\n# 62 "/usr/include/c++/7/cctype" 3\nnamespace std\n{\n  using ::isalnum;\n  using ::'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    has_facet(const locale&) throw();\n\n  template<typename _Facet>\n    const _Facet&\n    use_facet(const locale&);\n\n\n  template<typename _CharT>\n    bool\n    isspace(_CharT, const locale&);\n\n  te'
[#] parse_declaration, is_constructor=False, meet line: '_Facet&\n    use_facet(const locale&);\n\n\n  template<typename _CharT>\n    bool\n    isspace(_CharT, const locale&);\n\n  template<typename _CharT>\n    bool\n    isprint(_CharT, const locale&);\n\n  template<t'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    isspace(_CharT, const locale&);\n\n  template<typename _CharT>\n    bool\n    isprint(_CharT, const locale&);\n\n  template<typename _CharT>\n    bool\n    iscntrl(_CharT, const locale&);\n\n  template'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    isprint(_CharT, const locale&);\n\n  template<typename _CharT>\n    bool\n    iscntrl(_CharT, const locale&);\n\n  template<typename _CharT>\n    bool\n    isupper(_CharT, const locale&);\n\n  template'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    iscntrl(_CharT, const locale&);\n\n  template<typename _CharT>\n    bool\n    isupper(_CharT, const locale&);\n\n  template<typename _CharT>\n    bool\n    islower(_CharT, const locale&);\n\n  template'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    isupper(_CharT, const locale&);\n\n  template<typename _CharT>\n    bool\n    islower(_CharT, const locale&);\n\n  template<typename _CharT>\n    bool\n    isalpha(_CharT, const locale&);\n\n  template'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    islower(_CharT, const locale&);\n\n  template<typename _CharT>\n    bool\n    isalpha(_CharT, const locale&);\n\n  template<typename _CharT>\n    bool\n    isdigit(_CharT, const locale&);\n\n  template'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    isalpha(_CharT, const locale&);\n\n  template<typename _CharT>\n    bool\n    isdigit(_CharT, const locale&);\n\n  template<typename _CharT>\n    bool\n    ispunct(_CharT, const locale&);\n\n  template'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    isdigit(_CharT, const locale&);\n\n  template<typename _CharT>\n    bool\n    ispunct(_CharT, const locale&);\n\n  template<typename _CharT>\n    bool\n    isxdigit(_CharT, const locale&);\n\n  templat'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    ispunct(_CharT, const locale&);\n\n  template<typename _CharT>\n    bool\n    isxdigit(_CharT, const locale&);\n\n  template<typename _CharT>\n    bool\n    isalnum(_CharT, const locale&);\n\n  templat'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    isxdigit(_CharT, const locale&);\n\n  template<typename _CharT>\n    bool\n    isalnum(_CharT, const locale&);\n\n  template<typename _CharT>\n    bool\n    isgraph(_CharT, const locale&);\n\n\n  templa'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    isalnum(_CharT, const locale&);\n\n  template<typename _CharT>\n    bool\n    isgraph(_CharT, const locale&);\n\n\n  template<typename _CharT>\n    bool\n    isblank(_CharT, const locale&);\n\n\n  templa'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    isgraph(_CharT, const locale&);\n\n\n  template<typename _CharT>\n    bool\n    isblank(_CharT, const locale&);\n\n\n  template<typename _CharT>\n    _CharT\n    toupper(_CharT, const locale&);\n\n  temp'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    isblank(_CharT, const locale&);\n\n\n  template<typename _CharT>\n    _CharT\n    toupper(_CharT, const locale&);\n\n  template<typename _CharT>\n    _CharT\n    tolower(_CharT, const locale&);\n\n\n  cl'
[#] parse_declaration, is_constructor=False, meet line: '_CharT\n    toupper(_CharT, const locale&);\n\n  template<typename _CharT>\n    _CharT\n    tolower(_CharT, const locale&);\n\n\n  class ctype_base;\n  template<typename _CharT>\n    class ctype;\n  template<> c'
[#] parse_declaration, is_constructor=False, meet line: '_CharT\n    tolower(_CharT, const locale&);\n\n\n  class ctype_base;\n  template<typename _CharT>\n    class ctype;\n  template<> class ctype<char>;\n\n  template<> class ctype<wchar_t>;\n\n  template<typename _'
[#] parse_declaration, is_constructor=True, meet line: '__forced_unwind() throw();\n\n\n    virtual void __pure_dummy() = 0;\n  };\n}\n\n\n#pragma GCC visibility pop\n# 37 "/usr/include/c++/7/bits/ostream_insert.h" 2 3\n\nnamespace std __attribute__ ((__visibility__ '
[#] parse_declaration, is_constructor=False, meet line: 'void __pure_dummy() = 0;\n  };\n}\n\n\n#pragma GCC visibility pop\n# 37 "/usr/include/c++/7/bits/ostream_insert.h" 2 3\n\nnamespace std __attribute__ ((__visibility__ ("default")))\n{\n\n\n  template<typename _Ch'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    __ostream_write(basic_ostream<_CharT, _Traits>& __out,\n      const _CharT* __s, streamsize __n)\n    {\n      typedef basic_ostream<_CharT, _Traits> __ostream_type;\n      typedef typename __ost'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    __ostream_fill(basic_ostream<_CharT, _Traits>& __out, streamsize __n)\n    {\n      typedef basic_ostream<_CharT, _Traits> __ostream_type;\n      typedef typename __ostream_type::ios_base __ios_'
[#] parse_declaration, is_constructor=False, meet line: 'basic_ostream<_CharT, _Traits>&\n    __ostream_insert(basic_ostream<_CharT, _Traits>& __out,\n       const _CharT* __s, streamsize __n)\n    {\n      typedef basic_ostream<_CharT, _Traits> __ostream_type;'
[#] parse_declaration, is_constructor=False, meet line: 'template ostream& __ostream_insert(ostream&, const char*, streamsize);\n\n\n  extern template wostream& __ostream_insert(wostream&, const wchar_t*,\n          streamsize);\n\n\n\n\n}\n# 45 "/usr/include/c++/7/s'
[#] parse_declaration, is_constructor=False, meet line: 'template wostream& __ostream_insert(wostream&, const wchar_t*,\n          streamsize);\n\n\n\n\n}\n# 45 "/usr/include/c++/7/string" 2 3\n\n\n\n# 1 "/usr/include/c++/7/bits/stl_function.h" 1 3\n# 63 "/usr/include/'
[#] parse_declaration, is_constructor=False, meet line: '_Tp\n      operator()(const _Tp& __x, const _Tp& __y) const\n      { return __x + __y; }\n    };\n\n\n  template<typename _Tp>\n    struct minus : public binary_function<_Tp, _Tp, _Tp>\n    {\n      constexpr\n'
[#] parse_declaration, is_constructor=False, meet line: '_Tp\n      operator()(const _Tp& __x, const _Tp& __y) const\n      { return __x - __y; }\n    };\n\n\n  template<typename _Tp>\n    struct multiplies : public binary_function<_Tp, _Tp, _Tp>\n    {\n      const'
[#] parse_declaration, is_constructor=False, meet line: '_Tp\n      operator()(const _Tp& __x, const _Tp& __y) const\n      { return __x * __y; }\n    };\n\n\n  template<typename _Tp>\n    struct divides : public binary_function<_Tp, _Tp, _Tp>\n    {\n      constexp'
[#] parse_declaration, is_constructor=False, meet line: '_Tp\n      operator()(const _Tp& __x, const _Tp& __y) const\n      { return __x / __y; }\n    };\n\n\n  template<typename _Tp>\n    struct modulus : public binary_function<_Tp, _Tp, _Tp>\n    {\n      constexp'
[#] parse_declaration, is_constructor=False, meet line: '_Tp\n      operator()(const _Tp& __x, const _Tp& __y) const\n      { return __x % __y; }\n    };\n\n\n  template<typename _Tp>\n    struct negate : public unary_function<_Tp, _Tp>\n    {\n      constexpr\n     '
[#] parse_declaration, is_constructor=False, meet line: '_Tp\n      operator()(const _Tp& __x) const\n      { return -__x; }\n    };\n\n\n\n\n\n  template<>\n    struct plus<void>\n    {\n      template <typename _Tp, typename _Up>\n constexpr\n auto\n operator()(_Tp&& __'
[#] parse_declaration, is_constructor=False, meet line: 'auto\n operator()(_Tp&& __t, _Up&& __u) const\n noexcept(noexcept(std::forward<_Tp>(__t) + std::forward<_Up>(__u)))\n -> decltype(std::forward<_Tp>(__t) + std::forward<_Up>(__u))\n { return std::forward<_'
[#] parse_declaration, is_constructor=False, meet line: 'auto\n operator()(_Tp&& __t, _Up&& __u) const\n noexcept(noexcept(std::forward<_Tp>(__t) - std::forward<_Up>(__u)))\n -> decltype(std::forward<_Tp>(__t) - std::forward<_Up>(__u))\n { return std::forward<_'
[#] parse_declaration, is_constructor=False, meet line: 'auto\n operator()(_Tp&& __t, _Up&& __u) const\n noexcept(noexcept(std::forward<_Tp>(__t) * std::forward<_Up>(__u)))\n -> decltype(std::forward<_Tp>(__t) * std::forward<_Up>(__u))\n { return std::forward<_'
[#] parse_declaration, is_constructor=False, meet line: 'auto\n operator()(_Tp&& __t, _Up&& __u) const\n noexcept(noexcept(std::forward<_Tp>(__t) / std::forward<_Up>(__u)))\n -> decltype(std::forward<_Tp>(__t) / std::forward<_Up>(__u))\n { return std::forward<_'
[#] parse_declaration, is_constructor=False, meet line: 'auto\n operator()(_Tp&& __t, _Up&& __u) const\n noexcept(noexcept(std::forward<_Tp>(__t) % std::forward<_Up>(__u)))\n -> decltype(std::forward<_Tp>(__t) % std::forward<_Up>(__u))\n { return std::forward<_'
[#] parse_declaration, is_constructor=False, meet line: 'auto\n operator()(_Tp&& __t) const\n noexcept(noexcept(-std::forward<_Tp>(__t)))\n -> decltype(-std::forward<_Tp>(__t))\n { return -std::forward<_Tp>(__t); }\n\n      typedef __is_transparent is_transparent'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      operator()(const _Tp& __x, const _Tp& __y) const\n      { return __x == __y; }\n    };\n\n\n  template<typename _Tp>\n    struct not_equal_to : public binary_function<_Tp, _Tp, bool>\n    {\n      '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      operator()(const _Tp& __x, const _Tp& __y) const\n      { return __x != __y; }\n    };\n\n\n  template<typename _Tp>\n    struct greater : public binary_function<_Tp, _Tp, bool>\n    {\n      const'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      operator()(const _Tp& __x, const _Tp& __y) const\n      { return __x > __y; }\n    };\n\n\n  template<typename _Tp>\n    struct less : public binary_function<_Tp, _Tp, bool>\n    {\n      constexpr'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      operator()(const _Tp& __x, const _Tp& __y) const\n      { return __x < __y; }\n    };\n\n\n  template<typename _Tp>\n    struct greater_equal : public binary_function<_Tp, _Tp, bool>\n    {\n      '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      operator()(const _Tp& __x, const _Tp& __y) const\n      { return __x >= __y; }\n    };\n\n\n  template<typename _Tp>\n    struct less_equal : public binary_function<_Tp, _Tp, bool>\n    {\n      co'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      operator()(const _Tp& __x, const _Tp& __y) const\n      { return __x <= __y; }\n    };\n\n\n\n  template<>\n    struct equal_to<void>\n    {\n      template <typename _Tp, typename _Up>\n constexpr\n '
[#] parse_declaration, is_constructor=False, meet line: 'auto\n operator()(_Tp&& __t, _Up&& __u) const\n noexcept(noexcept(std::forward<_Tp>(__t) == std::forward<_Up>(__u)))\n -> decltype(std::forward<_Tp>(__t) == std::forward<_Up>(__u))\n { return std::forward'
[#] parse_declaration, is_constructor=False, meet line: 'auto\n operator()(_Tp&& __t, _Up&& __u) const\n noexcept(noexcept(std::forward<_Tp>(__t) != std::forward<_Up>(__u)))\n -> decltype(std::forward<_Tp>(__t) != std::forward<_Up>(__u))\n { return std::forward'
[#] parse_declaration, is_constructor=False, meet line: 'auto\n operator()(_Tp&& __t, _Up&& __u) const\n noexcept(noexcept(std::forward<_Tp>(__t) > std::forward<_Up>(__u)))\n -> decltype(std::forward<_Tp>(__t) > std::forward<_Up>(__u))\n { return std::forward<_'
[#] parse_declaration, is_constructor=False, meet line: 'auto\n operator()(_Tp&& __t, _Up&& __u) const\n noexcept(noexcept(std::forward<_Tp>(__t) < std::forward<_Up>(__u)))\n -> decltype(std::forward<_Tp>(__t) < std::forward<_Up>(__u))\n { return std::forward<_'
[#] parse_declaration, is_constructor=False, meet line: 'auto\n operator()(_Tp&& __t, _Up&& __u) const\n noexcept(noexcept(std::forward<_Tp>(__t) >= std::forward<_Up>(__u)))\n -> decltype(std::forward<_Tp>(__t) >= std::forward<_Up>(__u))\n { return std::forward'
[#] parse_declaration, is_constructor=False, meet line: 'auto\n operator()(_Tp&& __t, _Up&& __u) const\n noexcept(noexcept(std::forward<_Tp>(__t) <= std::forward<_Up>(__u)))\n -> decltype(std::forward<_Tp>(__t) <= std::forward<_Up>(__u))\n { return std::forward'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      operator()(const _Tp& __x, const _Tp& __y) const\n      { return __x && __y; }\n    };\n\n\n  template<typename _Tp>\n    struct logical_or : public binary_function<_Tp, _Tp, bool>\n    {\n      co'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      operator()(const _Tp& __x, const _Tp& __y) const\n      { return __x || __y; }\n    };\n\n\n  template<typename _Tp>\n    struct logical_not : public unary_function<_Tp, bool>\n    {\n      constex'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      operator()(const _Tp& __x) const\n      { return !__x; }\n    };\n\n\n\n  template<>\n    struct logical_and<void>\n    {\n      template <typename _Tp, typename _Up>\n constexpr\n auto\n operator()(_T'
[#] parse_declaration, is_constructor=False, meet line: 'auto\n operator()(_Tp&& __t, _Up&& __u) const\n noexcept(noexcept(std::forward<_Tp>(__t) && std::forward<_Up>(__u)))\n -> decltype(std::forward<_Tp>(__t) && std::forward<_Up>(__u))\n { return std::forward'
[#] parse_declaration, is_constructor=False, meet line: 'auto\n operator()(_Tp&& __t, _Up&& __u) const\n noexcept(noexcept(std::forward<_Tp>(__t) || std::forward<_Up>(__u)))\n -> decltype(std::forward<_Tp>(__t) || std::forward<_Up>(__u))\n { return std::forward'
[#] parse_declaration, is_constructor=False, meet line: 'auto\n operator()(_Tp&& __t) const\n noexcept(noexcept(!std::forward<_Tp>(__t)))\n -> decltype(!std::forward<_Tp>(__t))\n { return !std::forward<_Tp>(__t); }\n\n      typedef __is_transparent is_transparent'
[#] parse_declaration, is_constructor=False, meet line: '_Tp\n      operator()(const _Tp& __x, const _Tp& __y) const\n      { return __x & __y; }\n    };\n\n  template<typename _Tp>\n    struct bit_or : public binary_function<_Tp, _Tp, _Tp>\n    {\n      constexpr\n'
[#] parse_declaration, is_constructor=False, meet line: '_Tp\n      operator()(const _Tp& __x, const _Tp& __y) const\n      { return __x | __y; }\n    };\n\n  template<typename _Tp>\n    struct bit_xor : public binary_function<_Tp, _Tp, _Tp>\n    {\n      constexpr'
[#] parse_declaration, is_constructor=False, meet line: '_Tp\n      operator()(const _Tp& __x, const _Tp& __y) const\n      { return __x ^ __y; }\n    };\n\n  template<typename _Tp>\n    struct bit_not : public unary_function<_Tp, _Tp>\n    {\n    constexpr\n      _'
[#] parse_declaration, is_constructor=False, meet line: '_Tp\n      operator()(const _Tp& __x) const\n      { return ~__x; }\n    };\n\n\n  template <>\n    struct bit_and<void>\n    {\n      template <typename _Tp, typename _Up>\n constexpr\n auto\n operator()(_Tp&& _'
[#] parse_declaration, is_constructor=False, meet line: 'auto\n operator()(_Tp&& __t, _Up&& __u) const\n noexcept(noexcept(std::forward<_Tp>(__t) & std::forward<_Up>(__u)))\n -> decltype(std::forward<_Tp>(__t) & std::forward<_Up>(__u))\n { return std::forward<_'
[#] parse_declaration, is_constructor=False, meet line: 'auto\n operator()(_Tp&& __t, _Up&& __u) const\n noexcept(noexcept(std::forward<_Tp>(__t) | std::forward<_Up>(__u)))\n -> decltype(std::forward<_Tp>(__t) | std::forward<_Up>(__u))\n { return std::forward<_'
[#] parse_declaration, is_constructor=False, meet line: 'auto\n operator()(_Tp&& __t, _Up&& __u) const\n noexcept(noexcept(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u)))\n -> decltype(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u))\n { return std::forward<_'
[#] parse_declaration, is_constructor=False, meet line: 'auto\n operator()(_Tp&& __t) const\n noexcept(noexcept(~std::forward<_Tp>(__t)))\n -> decltype(~std::forward<_Tp>(__t))\n { return ~std::forward<_Tp>(__t); }\n\n      typedef __is_transparent is_transparent'
[#] parse_declaration, is_constructor=False, meet line: '_Predicate _M_pred;\n\n    public:\n      constexpr\n      explicit\n      unary_negate(const _Predicate& __x) : _M_pred(__x) { }\n\n      constexpr\n      bool\n      operator()(const typename _Predicate::arg'
[#] parse_declaration, is_constructor=True, meet line: 'unary_negate(const _Predicate& __x) : _M_pred(__x) { }\n\n      constexpr\n      bool\n      operator()(const typename _Predicate::argument_type& __x) const\n      { return !_M_pred(__x); }\n    };\n\n\n  temp'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      operator()(const typename _Predicate::argument_type& __x) const\n      { return !_M_pred(__x); }\n    };\n\n\n  template<typename _Predicate>\n    constexpr\n    inline unary_negate<_Predicate>\n  '
[#] parse_declaration, is_constructor=False, meet line: 'unary_negate<_Predicate>\n    not1(const _Predicate& __pred)\n    { return unary_negate<_Predicate>(__pred); }\n\n\n  template<typename _Predicate>\n    class binary_negate\n    : public binary_function<type'
[#] parse_declaration, is_constructor=False, meet line: '_Predicate _M_pred;\n\n    public:\n      constexpr\n      explicit\n      binary_negate(const _Predicate& __x) : _M_pred(__x) { }\n\n      constexpr\n      bool\n      operator()(const typename _Predicate::fi'
[#] parse_declaration, is_constructor=True, meet line: 'binary_negate(const _Predicate& __x) : _M_pred(__x) { }\n\n      constexpr\n      bool\n      operator()(const typename _Predicate::first_argument_type& __x,\n   const typename _Predicate::second_argument_'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      operator()(const typename _Predicate::first_argument_type& __x,\n   const typename _Predicate::second_argument_type& __y) const\n      { return !_M_pred(__x, __y); }\n    };\n\n\n  template<typen'
[#] parse_declaration, is_constructor=False, meet line: 'binary_negate<_Predicate>\n    not2(const _Predicate& __pred)\n    { return binary_negate<_Predicate>(__pred); }\n# 817 "/usr/include/c++/7/bits/stl_function.h" 3\n  template<typename _Arg, typename _Resu'
[#] parse_declaration, is_constructor=False, meet line: '_Result (*_M_ptr)(_Arg);\n\n    public:\n      pointer_to_unary_function() { }\n\n      explicit\n      pointer_to_unary_function(_Result (*__x)(_Arg))\n      : _M_ptr(__x) { }\n\n      _Result\n      operator('
[#] parse_declaration, is_constructor=True, meet line: 'pointer_to_unary_function() { }\n\n      explicit\n      pointer_to_unary_function(_Result (*__x)(_Arg))\n      : _M_ptr(__x) { }\n\n      _Result\n      operator()(_Arg __x) const\n      { return _M_ptr(__x)'
[#] parse_declaration, is_constructor=True, meet line: 'pointer_to_unary_function(_Result (*__x)(_Arg))\n      : _M_ptr(__x) { }\n\n      _Result\n      operator()(_Arg __x) const\n      { return _M_ptr(__x); }\n    };\n\n\n  template<typename _Arg, typename _Resul'
[#] parse_declaration, is_constructor=False, meet line: '_Result\n      operator()(_Arg __x) const\n      { return _M_ptr(__x); }\n    };\n\n\n  template<typename _Arg, typename _Result>\n    inline pointer_to_unary_function<_Arg, _Result>\n    ptr_fun(_Result (*__'
[#] parse_declaration, is_constructor=False, meet line: 'pointer_to_unary_function<_Arg, _Result>\n    ptr_fun(_Result (*__x)(_Arg))\n    { return pointer_to_unary_function<_Arg, _Result>(__x); }\n\n\n  template<typename _Arg1, typename _Arg2, typename _Result>\n'
[#] parse_declaration, is_constructor=False, meet line: '_Result (*_M_ptr)(_Arg1, _Arg2);\n\n    public:\n      pointer_to_binary_function() { }\n\n      explicit\n      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))\n      : _M_ptr(__x) { }\n\n      _Resu'
[#] parse_declaration, is_constructor=True, meet line: 'pointer_to_binary_function() { }\n\n      explicit\n      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))\n      : _M_ptr(__x) { }\n\n      _Result\n      operator()(_Arg1 __x, _Arg2 __y) const\n    '
[#] parse_declaration, is_constructor=True, meet line: 'pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))\n      : _M_ptr(__x) { }\n\n      _Result\n      operator()(_Arg1 __x, _Arg2 __y) const\n      { return _M_ptr(__x, __y); }\n    };\n\n\n  template<type'
[#] parse_declaration, is_constructor=False, meet line: '_Result\n      operator()(_Arg1 __x, _Arg2 __y) const\n      { return _M_ptr(__x, __y); }\n    };\n\n\n  template<typename _Arg1, typename _Arg2, typename _Result>\n    inline pointer_to_binary_function<_Arg'
[#] parse_declaration, is_constructor=False, meet line: 'pointer_to_binary_function<_Arg1, _Arg2, _Result>\n    ptr_fun(_Result (*__x)(_Arg1, _Arg2))\n    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }\n\n\n  template<typename _Tp>\n    struct'
[#] parse_declaration, is_constructor=False, meet line: '_Tp&\n      operator()(_Tp& __x) const\n      { return __x; }\n\n      const _Tp&\n      operator()(const _Tp& __x) const\n      { return __x; }\n    };\n\n  template<typename _Pair>\n    struct _Select1st\n    '
[#] parse_declaration, is_constructor=False, meet line: '_Tp&\n      operator()(const _Tp& __x) const\n      { return __x; }\n    };\n\n  template<typename _Pair>\n    struct _Select1st\n    : public unary_function<_Pair, typename _Pair::first_type>\n    {\n      ty'
[#] parse_declaration, is_constructor=False, meet line: '_Pair::first_type&\n      operator()(_Pair& __x) const\n      { return __x.first; }\n\n      const typename _Pair::first_type&\n      operator()(const _Pair& __x) const\n      { return __x.first; }\n\n\n      '
[#] parse_declaration, is_constructor=False, meet line: '_Pair::first_type&\n      operator()(const _Pair& __x) const\n      { return __x.first; }\n\n\n      template<typename _Pair2>\n        typename _Pair2::first_type&\n        operator()(_Pair2& __x) const\n   '
[#] parse_declaration, is_constructor=False, meet line: '_Pair2::first_type&\n        operator()(_Pair2& __x) const\n        { return __x.first; }\n\n      template<typename _Pair2>\n        const typename _Pair2::first_type&\n        operator()(const _Pair2& __x'
[#] parse_declaration, is_constructor=False, meet line: '_Pair2::first_type&\n        operator()(const _Pair2& __x) const\n        { return __x.first; }\n\n    };\n\n  template<typename _Pair>\n    struct _Select2nd\n    : public unary_function<_Pair, typename _Pai'
[#] parse_declaration, is_constructor=False, meet line: '_Pair::second_type&\n      operator()(_Pair& __x) const\n      { return __x.second; }\n\n      const typename _Pair::second_type&\n      operator()(const _Pair& __x) const\n      { return __x.second; }\n    '
[#] parse_declaration, is_constructor=False, meet line: '_Pair::second_type&\n      operator()(const _Pair& __x) const\n      { return __x.second; }\n    };\n# 937 "/usr/include/c++/7/bits/stl_function.h" 3\n  template<typename _Ret, typename _Tp>\n    class mem_'
[#] parse_declaration, is_constructor=True, meet line: 'mem_fun_t(_Ret (_Tp::*__pf)())\n      : _M_f(__pf) { }\n\n      _Ret\n      operator()(_Tp* __p) const\n      { return (__p->*_M_f)(); }\n\n    private:\n      _Ret (_Tp::*_M_f)();\n    };\n\n\n\n  template<typena'
[#] parse_declaration, is_constructor=False, meet line: '_Ret\n      operator()(_Tp* __p) const\n      { return (__p->*_M_f)(); }\n\n    private:\n      _Ret (_Tp::*_M_f)();\n    };\n\n\n\n  template<typename _Ret, typename _Tp>\n    class const_mem_fun_t : public una'
[#] parse_declaration, is_constructor=False, meet line: '_Ret (_Tp::*_M_f)();\n    };\n\n\n\n  template<typename _Ret, typename _Tp>\n    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>\n    {\n    public:\n      explicit\n      const_mem_fun_t(_Ret ('
[#] parse_declaration, is_constructor=True, meet line: 'const_mem_fun_t(_Ret (_Tp::*__pf)() const)\n      : _M_f(__pf) { }\n\n      _Ret\n      operator()(const _Tp* __p) const\n      { return (__p->*_M_f)(); }\n\n    private:\n      _Ret (_Tp::*_M_f)() const;\n   '
[#] parse_declaration, is_constructor=False, meet line: '_Ret\n      operator()(const _Tp* __p) const\n      { return (__p->*_M_f)(); }\n\n    private:\n      _Ret (_Tp::*_M_f)() const;\n    };\n\n\n\n  template<typename _Ret, typename _Tp>\n    class mem_fun_ref_t : '
[#] parse_declaration, is_constructor=False, meet line: '_Ret (_Tp::*_M_f)() const;\n    };\n\n\n\n  template<typename _Ret, typename _Tp>\n    class mem_fun_ref_t : public unary_function<_Tp, _Ret>\n    {\n    public:\n      explicit\n      mem_fun_ref_t(_Ret (_Tp::'
[#] parse_declaration, is_constructor=True, meet line: 'mem_fun_ref_t(_Ret (_Tp::*__pf)())\n      : _M_f(__pf) { }\n\n      _Ret\n      operator()(_Tp& __r) const\n      { return (__r.*_M_f)(); }\n\n    private:\n      _Ret (_Tp::*_M_f)();\n  };\n\n\n\n  template<typen'
[#] parse_declaration, is_constructor=False, meet line: '_Ret\n      operator()(_Tp& __r) const\n      { return (__r.*_M_f)(); }\n\n    private:\n      _Ret (_Tp::*_M_f)();\n  };\n\n\n\n  template<typename _Ret, typename _Tp>\n    class const_mem_fun_ref_t : public un'
[#] parse_declaration, is_constructor=False, meet line: '_Ret (_Tp::*_M_f)();\n  };\n\n\n\n  template<typename _Ret, typename _Tp>\n    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>\n    {\n    public:\n      explicit\n      const_mem_fun_ref_t(_Ret (_'
[#] parse_declaration, is_constructor=True, meet line: 'const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)\n      : _M_f(__pf) { }\n\n      _Ret\n      operator()(const _Tp& __r) const\n      { return (__r.*_M_f)(); }\n\n    private:\n      _Ret (_Tp::*_M_f)() const;\n'
[#] parse_declaration, is_constructor=False, meet line: '_Ret\n      operator()(const _Tp& __r) const\n      { return (__r.*_M_f)(); }\n\n    private:\n      _Ret (_Tp::*_M_f)() const;\n    };\n\n\n\n  template<typename _Ret, typename _Tp, typename _Arg>\n    class me'
[#] parse_declaration, is_constructor=False, meet line: '_Ret (_Tp::*_M_f)() const;\n    };\n\n\n\n  template<typename _Ret, typename _Tp, typename _Arg>\n    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>\n    {\n    public:\n      explicit\n      mem_f'
[#] parse_declaration, is_constructor=True, meet line: 'mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))\n      : _M_f(__pf) { }\n\n      _Ret\n      operator()(_Tp* __p, _Arg __x) const\n      { return (__p->*_M_f)(__x); }\n\n    private:\n      _Ret (_Tp::*_M_f)(_Arg);\n    }'
[#] parse_declaration, is_constructor=False, meet line: '_Ret\n      operator()(_Tp* __p, _Arg __x) const\n      { return (__p->*_M_f)(__x); }\n\n    private:\n      _Ret (_Tp::*_M_f)(_Arg);\n    };\n\n\n\n  template<typename _Ret, typename _Tp, typename _Arg>\n    cl'
[#] parse_declaration, is_constructor=False, meet line: '_Ret (_Tp::*_M_f)(_Arg);\n    };\n\n\n\n  template<typename _Ret, typename _Tp, typename _Arg>\n    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>\n    {\n    public:\n      explicit\n '
[#] parse_declaration, is_constructor=True, meet line: 'const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)\n      : _M_f(__pf) { }\n\n      _Ret\n      operator()(const _Tp* __p, _Arg __x) const\n      { return (__p->*_M_f)(__x); }\n\n    private:\n      _Ret (_Tp::*'
[#] parse_declaration, is_constructor=False, meet line: '_Ret\n      operator()(const _Tp* __p, _Arg __x) const\n      { return (__p->*_M_f)(__x); }\n\n    private:\n      _Ret (_Tp::*_M_f)(_Arg) const;\n    };\n\n\n\n  template<typename _Ret, typename _Tp, typename '
[#] parse_declaration, is_constructor=False, meet line: '_Ret (_Tp::*_M_f)(_Arg) const;\n    };\n\n\n\n  template<typename _Ret, typename _Tp, typename _Arg>\n    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>\n    {\n    public:\n      explicit\n    '
[#] parse_declaration, is_constructor=True, meet line: 'mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))\n      : _M_f(__pf) { }\n\n      _Ret\n      operator()(_Tp& __r, _Arg __x) const\n      { return (__r.*_M_f)(__x); }\n\n    private:\n      _Ret (_Tp::*_M_f)(_Arg);\n  '
[#] parse_declaration, is_constructor=False, meet line: '_Ret\n      operator()(_Tp& __r, _Arg __x) const\n      { return (__r.*_M_f)(__x); }\n\n    private:\n      _Ret (_Tp::*_M_f)(_Arg);\n    };\n\n\n\n  template<typename _Ret, typename _Tp, typename _Arg>\n    cla'
[#] parse_declaration, is_constructor=False, meet line: '_Ret (_Tp::*_M_f)(_Arg);\n    };\n\n\n\n  template<typename _Ret, typename _Tp, typename _Arg>\n    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>\n    {\n    public:\n      explicit\n    '
[#] parse_declaration, is_constructor=True, meet line: 'const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)\n      : _M_f(__pf) { }\n\n      _Ret\n      operator()(const _Tp& __r, _Arg __x) const\n      { return (__r.*_M_f)(__x); }\n\n    private:\n      _Ret (_Tp'
[#] parse_declaration, is_constructor=False, meet line: '_Ret\n      operator()(const _Tp& __r, _Arg __x) const\n      { return (__r.*_M_f)(__x); }\n\n    private:\n      _Ret (_Tp::*_M_f)(_Arg) const;\n    };\n\n\n\n  template<typename _Ret, typename _Tp>\n    inline'
[#] parse_declaration, is_constructor=False, meet line: '_Ret (_Tp::*_M_f)(_Arg) const;\n    };\n\n\n\n  template<typename _Ret, typename _Tp>\n    inline mem_fun_t<_Ret, _Tp>\n    mem_fun(_Ret (_Tp::*__f)())\n    { return mem_fun_t<_Ret, _Tp>(__f); }\n\n  template<t'
[#] parse_declaration, is_constructor=False, meet line: 'mem_fun_t<_Ret, _Tp>\n    mem_fun(_Ret (_Tp::*__f)())\n    { return mem_fun_t<_Ret, _Tp>(__f); }\n\n  template<typename _Ret, typename _Tp>\n    inline const_mem_fun_t<_Ret, _Tp>\n    mem_fun(_Ret (_Tp::*__'
[#] parse_declaration, is_constructor=False, meet line: 'const_mem_fun_t<_Ret, _Tp>\n    mem_fun(_Ret (_Tp::*__f)() const)\n    { return const_mem_fun_t<_Ret, _Tp>(__f); }\n\n  template<typename _Ret, typename _Tp>\n    inline mem_fun_ref_t<_Ret, _Tp>\n    mem_fu'
[#] parse_declaration, is_constructor=False, meet line: 'mem_fun_ref_t<_Ret, _Tp>\n    mem_fun_ref(_Ret (_Tp::*__f)())\n    { return mem_fun_ref_t<_Ret, _Tp>(__f); }\n\n  template<typename _Ret, typename _Tp>\n    inline const_mem_fun_ref_t<_Ret, _Tp>\n    mem_fu'
[#] parse_declaration, is_constructor=False, meet line: 'const_mem_fun_ref_t<_Ret, _Tp>\n    mem_fun_ref(_Ret (_Tp::*__f)() const)\n    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }\n\n  template<typename _Ret, typename _Tp, typename _Arg>\n    inline mem_fun1'
[#] parse_declaration, is_constructor=False, meet line: 'mem_fun1_t<_Ret, _Tp, _Arg>\n    mem_fun(_Ret (_Tp::*__f)(_Arg))\n    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }\n\n  template<typename _Ret, typename _Tp, typename _Arg>\n    inline const_mem_fun1_t<_Re'
[#] parse_declaration, is_constructor=False, meet line: 'const_mem_fun1_t<_Ret, _Tp, _Arg>\n    mem_fun(_Ret (_Tp::*__f)(_Arg) const)\n    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }\n\n  template<typename _Ret, typename _Tp, typename _Arg>\n    inline me'
[#] parse_declaration, is_constructor=False, meet line: 'mem_fun1_ref_t<_Ret, _Tp, _Arg>\n    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))\n    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }\n\n  template<typename _Ret, typename _Tp, typename _Arg>\n    inline const_me'
[#] parse_declaration, is_constructor=False, meet line: 'const_mem_fun1_ref_t<_Ret, _Tp, _Arg>\n    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)\n    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }\n\n\n\n\n}\n\n\n# 1 "/usr/include/c++/7/backward/binders.h" 1 3\n#'
[#] parse_declaration, is_constructor=False, meet line: '_Operation op;\n      typename _Operation::first_argument_type value;\n\n    public:\n      binder1st(const _Operation& __x,\n  const typename _Operation::first_argument_type& __y)\n      : op(__x), value(_'
[#] parse_declaration, is_constructor=False, meet line: '_Operation::first_argument_type value;\n\n    public:\n      binder1st(const _Operation& __x,\n  const typename _Operation::first_argument_type& __y)\n      : op(__x), value(__y) { }\n\n      typename _Opera'
[#] parse_declaration, is_constructor=True, meet line: 'binder1st(const _Operation& __x,\n  const typename _Operation::first_argument_type& __y)\n      : op(__x), value(__y) { }\n\n      typename _Operation::result_type\n      operator()(const typename _Operati'
[#] parse_declaration, is_constructor=False, meet line: '_Operation::result_type\n      operator()(const typename _Operation::second_argument_type& __x) const\n      { return op(value, __x); }\n\n\n\n      typename _Operation::result_type\n      operator()(typenam'
[#] parse_declaration, is_constructor=False, meet line: '_Operation::result_type\n      operator()(typename _Operation::second_argument_type& __x) const\n      { return op(value, __x); }\n    } __attribute__ ((__deprecated__));\n\n\n  template<typename _Operation'
[#] parse_declaration, is_constructor=False, meet line: 'binder1st<_Operation>\n    bind1st(const _Operation& __fn, const _Tp& __x)\n    {\n      typedef typename _Operation::first_argument_type _Arg1_type;\n      return binder1st<_Operation>(__fn, _Arg1_type(_'
[#] parse_declaration, is_constructor=False, meet line: '_Operation op;\n      typename _Operation::second_argument_type value;\n\n    public:\n      binder2nd(const _Operation& __x,\n  const typename _Operation::second_argument_type& __y)\n      : op(__x), value'
[#] parse_declaration, is_constructor=False, meet line: '_Operation::second_argument_type value;\n\n    public:\n      binder2nd(const _Operation& __x,\n  const typename _Operation::second_argument_type& __y)\n      : op(__x), value(__y) { }\n\n      typename _Ope'
[#] parse_declaration, is_constructor=True, meet line: 'binder2nd(const _Operation& __x,\n  const typename _Operation::second_argument_type& __y)\n      : op(__x), value(__y) { }\n\n      typename _Operation::result_type\n      operator()(const typename _Operat'
[#] parse_declaration, is_constructor=False, meet line: '_Operation::result_type\n      operator()(const typename _Operation::first_argument_type& __x) const\n      { return op(__x, value); }\n\n\n\n      typename _Operation::result_type\n      operator()(typename'
[#] parse_declaration, is_constructor=False, meet line: '_Operation::result_type\n      operator()(typename _Operation::first_argument_type& __x) const\n      { return op(__x, value); }\n    } __attribute__ ((__deprecated__));\n\n\n  template<typename _Operation,'
[#] parse_declaration, is_constructor=False, meet line: 'binder2nd<_Operation>\n    bind2nd(const _Operation& __fn, const _Tp& __x)\n    {\n      typedef typename _Operation::second_argument_type _Arg2_type;\n      return binder2nd<_Operation>(__fn, _Arg2_type('
[#] parse_declaration, is_constructor=False, meet line: 'auto\n    begin(_Container& __cont) -> decltype(__cont.begin())\n    { return __cont.begin(); }\n\n\n\n\n\n\n  template<typename _Container>\n    inline auto\n    begin(const _Container& __cont) -> decltype(__co'
[#] parse_declaration, is_constructor=False, meet line: 'auto\n    begin(const _Container& __cont) -> decltype(__cont.begin())\n    { return __cont.begin(); }\n\n\n\n\n\n\n  template<typename _Container>\n    inline auto\n    end(_Container& __cont) -> decltype(__cont'
[#] parse_declaration, is_constructor=False, meet line: 'auto\n    end(_Container& __cont) -> decltype(__cont.end())\n    { return __cont.end(); }\n\n\n\n\n\n\n  template<typename _Container>\n    inline auto\n    end(const _Container& __cont) -> decltype(__cont.end()'
[#] parse_declaration, is_constructor=False, meet line: 'auto\n    end(const _Container& __cont) -> decltype(__cont.end())\n    { return __cont.end(); }\n\n\n\n\n\n  template<typename _Tp, size_t _Nm>\n    inline constexpr _Tp*\n    begin(_Tp (&__arr)[_Nm])\n    { ret'
[#] parse_declaration, is_constructor=False, meet line: '_Tp*\n    begin(_Tp (&__arr)[_Nm])\n    { return __arr; }\n\n\n\n\n\n\n  template<typename _Tp, size_t _Nm>\n    inline constexpr _Tp*\n    end(_Tp (&__arr)[_Nm])\n    { return __arr + _Nm; }\n\n\n\n  template<typena'
[#] parse_declaration, is_constructor=False, meet line: '_Tp*\n    end(_Tp (&__arr)[_Nm])\n    { return __arr + _Nm; }\n\n\n\n  template<typename _Tp> class valarray;\n\n  template<typename _Tp> _Tp* begin(valarray<_Tp>&);\n  template<typename _Tp> const _Tp* begin('
[#] parse_declaration, is_constructor=False, meet line: '_Tp* begin(valarray<_Tp>&);\n  template<typename _Tp> const _Tp* begin(const valarray<_Tp>&);\n  template<typename _Tp> _Tp* end(valarray<_Tp>&);\n  template<typename _Tp> const _Tp* end(const valarray<_'
[#] parse_declaration, is_constructor=False, meet line: '_Tp* begin(const valarray<_Tp>&);\n  template<typename _Tp> _Tp* end(valarray<_Tp>&);\n  template<typename _Tp> const _Tp* end(const valarray<_Tp>&);\n\n\n\n\n\n\n  template<typename _Container>\n    inline con'
[#] parse_declaration, is_constructor=False, meet line: '_Tp* end(valarray<_Tp>&);\n  template<typename _Tp> const _Tp* end(const valarray<_Tp>&);\n\n\n\n\n\n\n  template<typename _Container>\n    inline constexpr auto\n    cbegin(const _Container& __cont) noexcept(n'
[#] parse_declaration, is_constructor=False, meet line: '_Tp* end(const valarray<_Tp>&);\n\n\n\n\n\n\n  template<typename _Container>\n    inline constexpr auto\n    cbegin(const _Container& __cont) noexcept(noexcept(std::begin(__cont)))\n      -> decltype(std::begin'
[#] parse_declaration, is_constructor=False, meet line: 'auto\n    cbegin(const _Container& __cont) noexcept(noexcept(std::begin(__cont)))\n      -> decltype(std::begin(__cont))\n    { return std::begin(__cont); }\n\n\n\n\n\n\n  template<typename _Container>\n    inli'
[#] parse_declaration, is_constructor=False, meet line: 'auto\n    cend(const _Container& __cont) noexcept(noexcept(std::end(__cont)))\n      -> decltype(std::end(__cont))\n    { return std::end(__cont); }\n\n\n\n\n\n\n  template<typename _Container>\n    inline auto\n'
[#] parse_declaration, is_constructor=False, meet line: 'auto\n    rbegin(_Container& __cont) -> decltype(__cont.rbegin())\n    { return __cont.rbegin(); }\n\n\n\n\n\n\n  template<typename _Container>\n    inline auto\n    rbegin(const _Container& __cont) -> decltype('
[#] parse_declaration, is_constructor=False, meet line: 'auto\n    rbegin(const _Container& __cont) -> decltype(__cont.rbegin())\n    { return __cont.rbegin(); }\n\n\n\n\n\n\n  template<typename _Container>\n    inline auto\n    rend(_Container& __cont) -> decltype(__'
[#] parse_declaration, is_constructor=False, meet line: 'auto\n    rend(_Container& __cont) -> decltype(__cont.rend())\n    { return __cont.rend(); }\n\n\n\n\n\n\n  template<typename _Container>\n    inline auto\n    rend(const _Container& __cont) -> decltype(__cont.r'
[#] parse_declaration, is_constructor=False, meet line: 'auto\n    rend(const _Container& __cont) -> decltype(__cont.rend())\n    { return __cont.rend(); }\n\n\n\n\n\n\n  template<typename _Tp, size_t _Nm>\n    inline reverse_iterator<_Tp*>\n    rbegin(_Tp (&__arr)[_N'
[#] parse_declaration, is_constructor=False, meet line: 'reverse_iterator<_Tp*>\n    rbegin(_Tp (&__arr)[_Nm])\n    { return reverse_iterator<_Tp*>(__arr + _Nm); }\n\n\n\n\n\n\n  template<typename _Tp, size_t _Nm>\n    inline reverse_iterator<_Tp*>\n    rend(_Tp (&__a'
[#] parse_declaration, is_constructor=False, meet line: 'reverse_iterator<_Tp*>\n    rend(_Tp (&__arr)[_Nm])\n    { return reverse_iterator<_Tp*>(__arr); }\n\n\n\n\n\n\n  template<typename _Tp>\n    inline reverse_iterator<const _Tp*>\n    rbegin(initializer_list<_Tp>'
[#] parse_declaration, is_constructor=False, meet line: 'reverse_iterator<const _Tp*>\n    rbegin(initializer_list<_Tp> __il)\n    { return reverse_iterator<const _Tp*>(__il.end()); }\n\n\n\n\n\n\n  template<typename _Tp>\n    inline reverse_iterator<const _Tp*>\n    '
[#] parse_declaration, is_constructor=False, meet line: 'reverse_iterator<const _Tp*>\n    rend(initializer_list<_Tp> __il)\n    { return reverse_iterator<const _Tp*>(__il.begin()); }\n\n\n\n\n\n\n  template<typename _Container>\n    inline auto\n    crbegin(const _Co'
[#] parse_declaration, is_constructor=False, meet line: 'auto\n    crbegin(const _Container& __cont) -> decltype(std::rbegin(__cont))\n    { return std::rbegin(__cont); }\n\n\n\n\n\n\n  template<typename _Container>\n    inline auto\n    crend(const _Container& __cont'
[#] parse_declaration, is_constructor=False, meet line: 'auto\n    crend(const _Container& __cont) -> decltype(std::rend(__cont))\n    { return std::rend(__cont); }\n# 323 "/usr/include/c++/7/bits/range_access.h" 3\n\n}\n# 52 "/usr/include/c++/7/string" 2 3\n# 1 "'
[#] parse_declaration, is_constructor=False, meet line: 'int sched_priority;\n};\n\nextern "C" {\n\n\n\nextern int clone (int (*__fn) (void *__arg), void *__child_stack,\n    int __flags, void *__arg, ...) throw ();\n\n\nextern int unshare (int __flags) throw ();\n\n\nex'
[#] parse_declaration, is_constructor=False, meet line: 'int clone (int (*__fn) (void *__arg), void *__child_stack,\n    int __flags, void *__arg, ...) throw ();\n\n\nextern int unshare (int __flags) throw ();\n\n\nextern int sched_getcpu (void) throw ();\n\n\nextern'
[#] parse_declaration, is_constructor=False, meet line: 'int unshare (int __flags) throw ();\n\n\nextern int sched_getcpu (void) throw ();\n\n\nextern int setns (int __fd, int __nstype) throw ();\n\n\n}\n# 44 "/usr/include/sched.h" 2 3 4\n# 1 "/usr/include/x86_64-linu'
[#] parse_declaration, is_constructor=False, meet line: 'int sched_getcpu (void) throw ();\n\n\nextern int setns (int __fd, int __nstype) throw ();\n\n\n}\n# 44 "/usr/include/sched.h" 2 3 4\n# 1 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h" 1 3 4\n# 32 "/usr/includ'
[#] parse_declaration, is_constructor=False, meet line: 'int setns (int __fd, int __nstype) throw ();\n\n\n}\n# 44 "/usr/include/sched.h" 2 3 4\n# 1 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h" 1 3 4\n# 32 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h" 3 4\ntype'
[#] parse_declaration, is_constructor=False, meet line: 'int __sched_cpucount (size_t __setsize, const cpu_set_t *__setp)\n     throw ();\nextern cpu_set_t *__sched_cpualloc (size_t __count) throw () ;\nextern void __sched_cpufree (cpu_set_t *__set) throw ();\n'
[#] parse_declaration, is_constructor=False, meet line: 'cpu_set_t *__sched_cpualloc (size_t __count) throw () ;\nextern void __sched_cpufree (cpu_set_t *__set) throw ();\n\n}\n# 45 "/usr/include/sched.h" 2 3 4\n\n\n\n\n\n\nextern "C" {\n\n\nextern int sched_setparam (__'
[#] parse_declaration, is_constructor=False, meet line: 'void __sched_cpufree (cpu_set_t *__set) throw ();\n\n}\n# 45 "/usr/include/sched.h" 2 3 4\n\n\n\n\n\n\nextern "C" {\n\n\nextern int sched_setparam (__pid_t __pid, const struct sched_param *__param)\n     throw ();\n'
[#] parse_declaration, is_constructor=False, meet line: 'int sched_setparam (__pid_t __pid, const struct sched_param *__param)\n     throw ();\n\n\nextern int sched_getparam (__pid_t __pid, struct sched_param *__param) throw ();\n\n\nextern int sched_setscheduler '
[#] parse_declaration, is_constructor=False, meet line: 'int sched_getparam (__pid_t __pid, struct sched_param *__param) throw ();\n\n\nextern int sched_setscheduler (__pid_t __pid, int __policy,\n          const struct sched_param *__param) throw ();\n\n\nextern '
[#] parse_declaration, is_constructor=False, meet line: 'int sched_setscheduler (__pid_t __pid, int __policy,\n          const struct sched_param *__param) throw ();\n\n\nextern int sched_getscheduler (__pid_t __pid) throw ();\n\n\nextern int sched_yield (void) th'
[#] parse_declaration, is_constructor=False, meet line: 'int sched_getscheduler (__pid_t __pid) throw ();\n\n\nextern int sched_yield (void) throw ();\n\n\nextern int sched_get_priority_max (int __algorithm) throw ();\n\n\nextern int sched_get_priority_min (int __al'
[#] parse_declaration, is_constructor=False, meet line: 'int sched_yield (void) throw ();\n\n\nextern int sched_get_priority_max (int __algorithm) throw ();\n\n\nextern int sched_get_priority_min (int __algorithm) throw ();\n\n\nextern int sched_rr_get_interval (__p'
[#] parse_declaration, is_constructor=False, meet line: 'int sched_get_priority_max (int __algorithm) throw ();\n\n\nextern int sched_get_priority_min (int __algorithm) throw ();\n\n\nextern int sched_rr_get_interval (__pid_t __pid, struct timespec *__t) throw ()'
[#] parse_declaration, is_constructor=False, meet line: 'int sched_get_priority_min (int __algorithm) throw ();\n\n\nextern int sched_rr_get_interval (__pid_t __pid, struct timespec *__t) throw ();\n# 121 "/usr/include/sched.h" 3 4\nextern int sched_setaffinity '
[#] parse_declaration, is_constructor=False, meet line: 'int sched_rr_get_interval (__pid_t __pid, struct timespec *__t) throw ();\n# 121 "/usr/include/sched.h" 3 4\nextern int sched_setaffinity (__pid_t __pid, size_t __cpusetsize,\n         const cpu_set_t *_'
[#] parse_declaration, is_constructor=False, meet line: 'int sched_setaffinity (__pid_t __pid, size_t __cpusetsize,\n         const cpu_set_t *__cpuset) throw ();\n\n\nextern int sched_getaffinity (__pid_t __pid, size_t __cpusetsize,\n         cpu_set_t *__cpuse'
[#] parse_declaration, is_constructor=False, meet line: 'int sched_getaffinity (__pid_t __pid, size_t __cpusetsize,\n         cpu_set_t *__cpuset) throw ();\n\n\n}\n# 24 "/usr/include/pthread.h" 2 3 4\n# 1 "/usr/include/time.h" 1 3 4\n# 29 "/usr/include/time.h" 3 '
[#] parse_declaration, is_constructor=False, meet line: 'unsigned int modes;\n  __syscall_slong_t offset;\n  __syscall_slong_t freq;\n  __syscall_slong_t maxerror;\n  __syscall_slong_t esterror;\n  int status;\n  __syscall_slong_t constant;\n  __syscall_slong_t pr'
[#] parse_declaration, is_constructor=False, meet line: '__syscall_slong_t offset;\n  __syscall_slong_t freq;\n  __syscall_slong_t maxerror;\n  __syscall_slong_t esterror;\n  int status;\n  __syscall_slong_t constant;\n  __syscall_slong_t precision;\n  __syscall_s'
[#] parse_declaration, is_constructor=False, meet line: '__syscall_slong_t freq;\n  __syscall_slong_t maxerror;\n  __syscall_slong_t esterror;\n  int status;\n  __syscall_slong_t constant;\n  __syscall_slong_t precision;\n  __syscall_slong_t tolerance;\n  struct t'
[#] parse_declaration, is_constructor=False, meet line: '__syscall_slong_t maxerror;\n  __syscall_slong_t esterror;\n  int status;\n  __syscall_slong_t constant;\n  __syscall_slong_t precision;\n  __syscall_slong_t tolerance;\n  struct timeval time;\n  __syscall_s'
[#] parse_declaration, is_constructor=False, meet line: '__syscall_slong_t esterror;\n  int status;\n  __syscall_slong_t constant;\n  __syscall_slong_t precision;\n  __syscall_slong_t tolerance;\n  struct timeval time;\n  __syscall_slong_t tick;\n  __syscall_slong'
[#] parse_declaration, is_constructor=False, meet line: 'int status;\n  __syscall_slong_t constant;\n  __syscall_slong_t precision;\n  __syscall_slong_t tolerance;\n  struct timeval time;\n  __syscall_slong_t tick;\n  __syscall_slong_t ppsfreq;\n  __syscall_slong_'
[#] parse_declaration, is_constructor=False, meet line: '__syscall_slong_t constant;\n  __syscall_slong_t precision;\n  __syscall_slong_t tolerance;\n  struct timeval time;\n  __syscall_slong_t tick;\n  __syscall_slong_t ppsfreq;\n  __syscall_slong_t jitter;\n  in'
[#] parse_declaration, is_constructor=False, meet line: '__syscall_slong_t precision;\n  __syscall_slong_t tolerance;\n  struct timeval time;\n  __syscall_slong_t tick;\n  __syscall_slong_t ppsfreq;\n  __syscall_slong_t jitter;\n  int shift;\n  __syscall_slong_t s'
[#] parse_declaration, is_constructor=False, meet line: '__syscall_slong_t tolerance;\n  struct timeval time;\n  __syscall_slong_t tick;\n  __syscall_slong_t ppsfreq;\n  __syscall_slong_t jitter;\n  int shift;\n  __syscall_slong_t stabil;\n  __syscall_slong_t jitc'
[#] parse_declaration, is_constructor=False, meet line: '__syscall_slong_t tick;\n  __syscall_slong_t ppsfreq;\n  __syscall_slong_t jitter;\n  int shift;\n  __syscall_slong_t stabil;\n  __syscall_slong_t jitcnt;\n  __syscall_slong_t calcnt;\n  __syscall_slong_t er'
[#] parse_declaration, is_constructor=False, meet line: '__syscall_slong_t ppsfreq;\n  __syscall_slong_t jitter;\n  int shift;\n  __syscall_slong_t stabil;\n  __syscall_slong_t jitcnt;\n  __syscall_slong_t calcnt;\n  __syscall_slong_t errcnt;\n  __syscall_slong_t '
[#] parse_declaration, is_constructor=False, meet line: '__syscall_slong_t jitter;\n  int shift;\n  __syscall_slong_t stabil;\n  __syscall_slong_t jitcnt;\n  __syscall_slong_t calcnt;\n  __syscall_slong_t errcnt;\n  __syscall_slong_t stbcnt;\n\n  int tai;\n\n\n  int :'
[#] parse_declaration, is_constructor=False, meet line: 'int shift;\n  __syscall_slong_t stabil;\n  __syscall_slong_t jitcnt;\n  __syscall_slong_t calcnt;\n  __syscall_slong_t errcnt;\n  __syscall_slong_t stbcnt;\n\n  int tai;\n\n\n  int :32; int :32; int :32; int :3'
[#] parse_declaration, is_constructor=False, meet line: '__syscall_slong_t stabil;\n  __syscall_slong_t jitcnt;\n  __syscall_slong_t calcnt;\n  __syscall_slong_t errcnt;\n  __syscall_slong_t stbcnt;\n\n  int tai;\n\n\n  int :32; int :32; int :32; int :32;\n  int :32;'
[#] parse_declaration, is_constructor=False, meet line: '__syscall_slong_t jitcnt;\n  __syscall_slong_t calcnt;\n  __syscall_slong_t errcnt;\n  __syscall_slong_t stbcnt;\n\n  int tai;\n\n\n  int :32; int :32; int :32; int :32;\n  int :32; int :32; int :32; int :32;\n'
[#] parse_declaration, is_constructor=False, meet line: '__syscall_slong_t calcnt;\n  __syscall_slong_t errcnt;\n  __syscall_slong_t stbcnt;\n\n  int tai;\n\n\n  int :32; int :32; int :32; int :32;\n  int :32; int :32; int :32; int :32;\n  int :32; int :32; int :32;'
[#] parse_declaration, is_constructor=False, meet line: '__syscall_slong_t errcnt;\n  __syscall_slong_t stbcnt;\n\n  int tai;\n\n\n  int :32; int :32; int :32; int :32;\n  int :32; int :32; int :32; int :32;\n  int :32; int :32; int :32;\n};\n# 74 "/usr/include/x86_6'
[#] parse_declaration, is_constructor=False, meet line: '__syscall_slong_t stbcnt;\n\n  int tai;\n\n\n  int :32; int :32; int :32; int :32;\n  int :32; int :32; int :32; int :32;\n  int :32; int :32; int :32;\n};\n# 74 "/usr/include/x86_64-linux-gnu/bits/time.h" 2 3'
[#] parse_declaration, is_constructor=False, meet line: 'int tai;\n\n\n  int :32; int :32; int :32; int :32;\n  int :32; int :32; int :32; int :32;\n  int :32; int :32; int :32;\n};\n# 74 "/usr/include/x86_64-linux-gnu/bits/time.h" 2 3 4\n\nextern "C" {\n\n\nextern int'
[#] parse_declaration, is_constructor=False, meet line: 'int :32; int :32; int :32; int :32;\n  int :32; int :32; int :32; int :32;\n  int :32; int :32; int :32;\n};\n# 74 "/usr/include/x86_64-linux-gnu/bits/time.h" 2 3 4\n\nextern "C" {\n\n\nextern int clock_adjtim'
[#] parse_declaration, is_constructor=False, meet line: 'int :32; int :32; int :32;\n  int :32; int :32; int :32; int :32;\n  int :32; int :32; int :32;\n};\n# 74 "/usr/include/x86_64-linux-gnu/bits/time.h" 2 3 4\n\nextern "C" {\n\n\nextern int clock_adjtime (__cloc'
[#] parse_declaration, is_constructor=False, meet line: 'int :32; int :32;\n  int :32; int :32; int :32; int :32;\n  int :32; int :32; int :32;\n};\n# 74 "/usr/include/x86_64-linux-gnu/bits/time.h" 2 3 4\n\nextern "C" {\n\n\nextern int clock_adjtime (__clockid_t __c'
[#] parse_declaration, is_constructor=False, meet line: 'int :32;\n  int :32; int :32; int :32; int :32;\n  int :32; int :32; int :32;\n};\n# 74 "/usr/include/x86_64-linux-gnu/bits/time.h" 2 3 4\n\nextern "C" {\n\n\nextern int clock_adjtime (__clockid_t __clock_id, '
[#] parse_declaration, is_constructor=False, meet line: 'int :32; int :32; int :32; int :32;\n  int :32; int :32; int :32;\n};\n# 74 "/usr/include/x86_64-linux-gnu/bits/time.h" 2 3 4\n\nextern "C" {\n\n\nextern int clock_adjtime (__clockid_t __clock_id, struct time'
[#] parse_declaration, is_constructor=False, meet line: 'int :32; int :32; int :32;\n  int :32; int :32; int :32;\n};\n# 74 "/usr/include/x86_64-linux-gnu/bits/time.h" 2 3 4\n\nextern "C" {\n\n\nextern int clock_adjtime (__clockid_t __clock_id, struct timex *__utx)'
[#] parse_declaration, is_constructor=False, meet line: 'int :32; int :32;\n  int :32; int :32; int :32;\n};\n# 74 "/usr/include/x86_64-linux-gnu/bits/time.h" 2 3 4\n\nextern "C" {\n\n\nextern int clock_adjtime (__clockid_t __clock_id, struct timex *__utx) throw ()'
[#] parse_declaration, is_constructor=False, meet line: 'int :32;\n  int :32; int :32; int :32;\n};\n# 74 "/usr/include/x86_64-linux-gnu/bits/time.h" 2 3 4\n\nextern "C" {\n\n\nextern int clock_adjtime (__clockid_t __clock_id, struct timex *__utx) throw ();\n\n}\n# 34'
[#] parse_declaration, is_constructor=False, meet line: 'int :32; int :32; int :32;\n};\n# 74 "/usr/include/x86_64-linux-gnu/bits/time.h" 2 3 4\n\nextern "C" {\n\n\nextern int clock_adjtime (__clockid_t __clock_id, struct timex *__utx) throw ();\n\n}\n# 34 "/usr/incl'
[#] parse_declaration, is_constructor=False, meet line: 'int :32; int :32;\n};\n# 74 "/usr/include/x86_64-linux-gnu/bits/time.h" 2 3 4\n\nextern "C" {\n\n\nextern int clock_adjtime (__clockid_t __clock_id, struct timex *__utx) throw ();\n\n}\n# 34 "/usr/include/time.'
[#] parse_declaration, is_constructor=False, meet line: 'int :32;\n};\n# 74 "/usr/include/x86_64-linux-gnu/bits/time.h" 2 3 4\n\nextern "C" {\n\n\nextern int clock_adjtime (__clockid_t __clock_id, struct timex *__utx) throw ();\n\n}\n# 34 "/usr/include/time.h" 2 3 4\n'
[#] parse_declaration, is_constructor=False, meet line: 'int clock_adjtime (__clockid_t __clock_id, struct timex *__utx) throw ();\n\n}\n# 34 "/usr/include/time.h" 2 3 4\n\n\n\n\n\n# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h" 1 3 4\n\n\n\n\n\n\nstruct tm\n{\n  '
[#] parse_declaration, is_constructor=False, meet line: 'int tm_sec;\n  int tm_min;\n  int tm_hour;\n  int tm_mday;\n  int tm_mon;\n  int tm_year;\n  int tm_wday;\n  int tm_yday;\n  int tm_isdst;\n\n\n  long int tm_gmtoff;\n  const char *tm_zone;\n\n\n\n\n};\n# 40 "/usr/incl'
[#] parse_declaration, is_constructor=False, meet line: 'int tm_min;\n  int tm_hour;\n  int tm_mday;\n  int tm_mon;\n  int tm_year;\n  int tm_wday;\n  int tm_yday;\n  int tm_isdst;\n\n\n  long int tm_gmtoff;\n  const char *tm_zone;\n\n\n\n\n};\n# 40 "/usr/include/time.h" 2 '
[#] parse_declaration, is_constructor=False, meet line: 'int tm_hour;\n  int tm_mday;\n  int tm_mon;\n  int tm_year;\n  int tm_wday;\n  int tm_yday;\n  int tm_isdst;\n\n\n  long int tm_gmtoff;\n  const char *tm_zone;\n\n\n\n\n};\n# 40 "/usr/include/time.h" 2 3 4\n# 48 "/usr'
[#] parse_declaration, is_constructor=False, meet line: 'int tm_mday;\n  int tm_mon;\n  int tm_year;\n  int tm_wday;\n  int tm_yday;\n  int tm_isdst;\n\n\n  long int tm_gmtoff;\n  const char *tm_zone;\n\n\n\n\n};\n# 40 "/usr/include/time.h" 2 3 4\n# 48 "/usr/include/time.h'
[#] parse_declaration, is_constructor=False, meet line: 'int tm_mon;\n  int tm_year;\n  int tm_wday;\n  int tm_yday;\n  int tm_isdst;\n\n\n  long int tm_gmtoff;\n  const char *tm_zone;\n\n\n\n\n};\n# 40 "/usr/include/time.h" 2 3 4\n# 48 "/usr/include/time.h" 3 4\n# 1 "/usr'
[#] parse_declaration, is_constructor=False, meet line: 'int tm_year;\n  int tm_wday;\n  int tm_yday;\n  int tm_isdst;\n\n\n  long int tm_gmtoff;\n  const char *tm_zone;\n\n\n\n\n};\n# 40 "/usr/include/time.h" 2 3 4\n# 48 "/usr/include/time.h" 3 4\n# 1 "/usr/include/x86_6'
[#] parse_declaration, is_constructor=False, meet line: 'int tm_wday;\n  int tm_yday;\n  int tm_isdst;\n\n\n  long int tm_gmtoff;\n  const char *tm_zone;\n\n\n\n\n};\n# 40 "/usr/include/time.h" 2 3 4\n# 48 "/usr/include/time.h" 3 4\n# 1 "/usr/include/x86_64-linux-gnu/bit'
[#] parse_declaration, is_constructor=False, meet line: 'int tm_yday;\n  int tm_isdst;\n\n\n  long int tm_gmtoff;\n  const char *tm_zone;\n\n\n\n\n};\n# 40 "/usr/include/time.h" 2 3 4\n# 48 "/usr/include/time.h" 3 4\n# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_'
[#] parse_declaration, is_constructor=False, meet line: 'int tm_isdst;\n\n\n  long int tm_gmtoff;\n  const char *tm_zone;\n\n\n\n\n};\n# 40 "/usr/include/time.h" 2 3 4\n# 48 "/usr/include/time.h" 3 4\n# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h" 1'
[#] parse_declaration, is_constructor=False, meet line: 'long int tm_gmtoff;\n  const char *tm_zone;\n\n\n\n\n};\n# 40 "/usr/include/time.h" 2 3 4\n# 48 "/usr/include/time.h" 3 4\n# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h" 1 3 4\n\n\n\n\n\n\n\nstruct'
[#] parse_declaration, is_constructor=False, meet line: 'char *tm_zone;\n\n\n\n\n};\n# 40 "/usr/include/time.h" 2 3 4\n# 48 "/usr/include/time.h" 3 4\n# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h" 1 3 4\n\n\n\n\n\n\n\nstruct itimerspec\n  {\n    struct t'
[#] parse_declaration, is_constructor=False, meet line: 'clock_t clock (void) throw ();\n\n\nextern time_t time (time_t *__timer) throw ();\n\n\nextern double difftime (time_t __time1, time_t __time0)\n     throw () __attribute__ ((__const__));\n\n\nextern time_t mkt'
[#] parse_declaration, is_constructor=False, meet line: 'time_t time (time_t *__timer) throw ();\n\n\nextern double difftime (time_t __time1, time_t __time0)\n     throw () __attribute__ ((__const__));\n\n\nextern time_t mktime (struct tm *__tp) throw ();\n\n\n\n\n\next'
[#] parse_declaration, is_constructor=False, meet line: 'double difftime (time_t __time1, time_t __time0)\n     throw () __attribute__ ((__const__));\n\n\nextern time_t mktime (struct tm *__tp) throw ();\n\n\n\n\n\nextern size_t strftime (char *__restrict __s, size_t'
[#] parse_declaration, is_constructor=False, meet line: 'time_t mktime (struct tm *__tp) throw ();\n\n\n\n\n\nextern size_t strftime (char *__restrict __s, size_t __maxsize,\n   const char *__restrict __format,\n   const struct tm *__restrict __tp) throw ();\n\n\n\n\nex'
[#] parse_declaration, is_constructor=False, meet line: 'size_t strftime (char *__restrict __s, size_t __maxsize,\n   const char *__restrict __format,\n   const struct tm *__restrict __tp) throw ();\n\n\n\n\nextern char *strptime (const char *__restrict __s,\n     '
[#] parse_declaration, is_constructor=False, meet line: 'char *strptime (const char *__restrict __s,\n         const char *__restrict __fmt, struct tm *__tp)\n     throw ();\n\n\n\n\n\n\nextern size_t strftime_l (char *__restrict __s, size_t __maxsize,\n     const ch'
[#] parse_declaration, is_constructor=False, meet line: 'size_t strftime_l (char *__restrict __s, size_t __maxsize,\n     const char *__restrict __format,\n     const struct tm *__restrict __tp,\n     locale_t __loc) throw ();\n\n\n\nextern char *strptime_l (const'
[#] parse_declaration, is_constructor=False, meet line: 'char *strptime_l (const char *__restrict __s,\n    const char *__restrict __fmt, struct tm *__tp,\n    locale_t __loc) throw ();\n\n\n\n\n\nextern struct tm *gmtime (const time_t *__timer) throw ();\n\n\n\nextern'
[#] parse_declaration, is_constructor=False, meet line: 'struct tm *gmtime (const time_t *__timer) throw ();\n\n\n\nextern struct tm *localtime (const time_t *__timer) throw ();\n\n\n\n\nextern struct tm *gmtime_r (const time_t *__restrict __timer,\n       struct tm '
[#] parse_declaration, is_constructor=False, meet line: 'struct tm *localtime (const time_t *__timer) throw ();\n\n\n\n\nextern struct tm *gmtime_r (const time_t *__restrict __timer,\n       struct tm *__restrict __tp) throw ();\n\n\n\nextern struct tm *localtime_r ('
[#] parse_declaration, is_constructor=False, meet line: 'struct tm *gmtime_r (const time_t *__restrict __timer,\n       struct tm *__restrict __tp) throw ();\n\n\n\nextern struct tm *localtime_r (const time_t *__restrict __timer,\n          struct tm *__restrict '
[#] parse_declaration, is_constructor=False, meet line: 'struct tm *localtime_r (const time_t *__restrict __timer,\n          struct tm *__restrict __tp) throw ();\n\n\n\n\nextern char *asctime (const struct tm *__tp) throw ();\n\n\nextern char *ctime (const time_t '
[#] parse_declaration, is_constructor=False, meet line: 'char *asctime (const struct tm *__tp) throw ();\n\n\nextern char *ctime (const time_t *__timer) throw ();\n\n\n\n\n\n\nextern char *asctime_r (const struct tm *__restrict __tp,\n   char *__restrict __buf) throw '
[#] parse_declaration, is_constructor=False, meet line: 'char *ctime (const time_t *__timer) throw ();\n\n\n\n\n\n\nextern char *asctime_r (const struct tm *__restrict __tp,\n   char *__restrict __buf) throw ();\n\n\nextern char *ctime_r (const time_t *__restrict __ti'
[#] parse_declaration, is_constructor=False, meet line: 'char *asctime_r (const struct tm *__restrict __tp,\n   char *__restrict __buf) throw ();\n\n\nextern char *ctime_r (const time_t *__restrict __timer,\n        char *__restrict __buf) throw ();\n\n\n\n\nextern c'
[#] parse_declaration, is_constructor=False, meet line: 'char *ctime_r (const time_t *__restrict __timer,\n        char *__restrict __buf) throw ();\n\n\n\n\nextern char *__tzname[2];\nextern int __daylight;\nextern long int __timezone;\n\n\n\n\nextern char *tzname[2];\n'
[#] parse_declaration, is_constructor=False, meet line: 'char *__tzname[2];\nextern int __daylight;\nextern long int __timezone;\n\n\n\n\nextern char *tzname[2];\n\n\n\nextern void tzset (void) throw ();\n\n\n\nextern int daylight;\nextern long int timezone;\n\n\n\n\n\nextern in'
[#] parse_declaration, is_constructor=False, meet line: 'int __daylight;\nextern long int __timezone;\n\n\n\n\nextern char *tzname[2];\n\n\n\nextern void tzset (void) throw ();\n\n\n\nextern int daylight;\nextern long int timezone;\n\n\n\n\n\nextern int stime (const time_t *__w'
[#] parse_declaration, is_constructor=False, meet line: 'long int __timezone;\n\n\n\n\nextern char *tzname[2];\n\n\n\nextern void tzset (void) throw ();\n\n\n\nextern int daylight;\nextern long int timezone;\n\n\n\n\n\nextern int stime (const time_t *__when) throw ();\n# 196 "/'
[#] parse_declaration, is_constructor=False, meet line: 'char *tzname[2];\n\n\n\nextern void tzset (void) throw ();\n\n\n\nextern int daylight;\nextern long int timezone;\n\n\n\n\n\nextern int stime (const time_t *__when) throw ();\n# 196 "/usr/include/time.h" 3 4\nextern t'
[#] parse_declaration, is_constructor=False, meet line: 'void tzset (void) throw ();\n\n\n\nextern int daylight;\nextern long int timezone;\n\n\n\n\n\nextern int stime (const time_t *__when) throw ();\n# 196 "/usr/include/time.h" 3 4\nextern time_t timegm (struct tm *__'
[#] parse_declaration, is_constructor=False, meet line: 'int daylight;\nextern long int timezone;\n\n\n\n\n\nextern int stime (const time_t *__when) throw ();\n# 196 "/usr/include/time.h" 3 4\nextern time_t timegm (struct tm *__tp) throw ();\n\n\nextern time_t timeloca'
[#] parse_declaration, is_constructor=False, meet line: 'long int timezone;\n\n\n\n\n\nextern int stime (const time_t *__when) throw ();\n# 196 "/usr/include/time.h" 3 4\nextern time_t timegm (struct tm *__tp) throw ();\n\n\nextern time_t timelocal (struct tm *__tp) t'
[#] parse_declaration, is_constructor=False, meet line: 'int stime (const time_t *__when) throw ();\n# 196 "/usr/include/time.h" 3 4\nextern time_t timegm (struct tm *__tp) throw ();\n\n\nextern time_t timelocal (struct tm *__tp) throw ();\n\n\nextern int dysize (i'
[#] parse_declaration, is_constructor=False, meet line: 'time_t timegm (struct tm *__tp) throw ();\n\n\nextern time_t timelocal (struct tm *__tp) throw ();\n\n\nextern int dysize (int __year) throw () __attribute__ ((__const__));\n# 211 "/usr/include/time.h" 3 4\ne'
[#] parse_declaration, is_constructor=False, meet line: 'time_t timelocal (struct tm *__tp) throw ();\n\n\nextern int dysize (int __year) throw () __attribute__ ((__const__));\n# 211 "/usr/include/time.h" 3 4\nextern int nanosleep (const struct timespec *__reque'
[#] parse_declaration, is_constructor=False, meet line: 'int dysize (int __year) throw () __attribute__ ((__const__));\n# 211 "/usr/include/time.h" 3 4\nextern int nanosleep (const struct timespec *__requested_time,\n        struct timespec *__remaining);\n\n\n\ne'
[#] parse_declaration, is_constructor=False, meet line: 'int nanosleep (const struct timespec *__requested_time,\n        struct timespec *__remaining);\n\n\n\nextern int clock_getres (clockid_t __clock_id, struct timespec *__res) throw ();\n\n\nextern int clock_ge'
[#] parse_declaration, is_constructor=False, meet line: 'int clock_getres (clockid_t __clock_id, struct timespec *__res) throw ();\n\n\nextern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) throw ();\n\n\nextern int clock_settime (clockid_t __clo'
[#] parse_declaration, is_constructor=False, meet line: 'int clock_gettime (clockid_t __clock_id, struct timespec *__tp) throw ();\n\n\nextern int clock_settime (clockid_t __clock_id, const struct timespec *__tp)\n     throw ();\n\n\n\n\n\n\nextern int clock_nanosleep'
[#] parse_declaration, is_constructor=False, meet line: 'int clock_settime (clockid_t __clock_id, const struct timespec *__tp)\n     throw ();\n\n\n\n\n\n\nextern int clock_nanosleep (clockid_t __clock_id, int __flags,\n       const struct timespec *__req,\n       st'
[#] parse_declaration, is_constructor=False, meet line: 'int clock_nanosleep (clockid_t __clock_id, int __flags,\n       const struct timespec *__req,\n       struct timespec *__rem);\n\n\nextern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) throw'
[#] parse_declaration, is_constructor=False, meet line: 'int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) throw ();\n\n\n\n\nextern int timer_create (clockid_t __clock_id,\n    struct sigevent *__restrict __evp,\n    timer_t *__restrict __timerid) thro'
[#] parse_declaration, is_constructor=False, meet line: 'int timer_create (clockid_t __clock_id,\n    struct sigevent *__restrict __evp,\n    timer_t *__restrict __timerid) throw ();\n\n\nextern int timer_delete (timer_t __timerid) throw ();\n\n\nextern int timer_s'
[#] parse_declaration, is_constructor=False, meet line: 'int timer_delete (timer_t __timerid) throw ();\n\n\nextern int timer_settime (timer_t __timerid, int __flags,\n     const struct itimerspec *__restrict __value,\n     struct itimerspec *__restrict __ovalue'
[#] parse_declaration, is_constructor=False, meet line: 'int timer_settime (timer_t __timerid, int __flags,\n     const struct itimerspec *__restrict __value,\n     struct itimerspec *__restrict __ovalue) throw ();\n\n\nextern int timer_gettime (timer_t __timeri'
[#] parse_declaration, is_constructor=False, meet line: 'int timer_gettime (timer_t __timerid, struct itimerspec *__value)\n     throw ();\n\n\nextern int timer_getoverrun (timer_t __timerid) throw ();\n\n\n\n\n\nextern int timespec_get (struct timespec *__ts, int __'
[#] parse_declaration, is_constructor=False, meet line: 'int timer_getoverrun (timer_t __timerid) throw ();\n\n\n\n\n\nextern int timespec_get (struct timespec *__ts, int __base)\n     throw () __attribute__ ((__nonnull__ (1)));\n# 280 "/usr/include/time.h" 3 4\next'
[#] parse_declaration, is_constructor=False, meet line: 'int timespec_get (struct timespec *__ts, int __base)\n     throw () __attribute__ ((__nonnull__ (1)));\n# 280 "/usr/include/time.h" 3 4\nextern int getdate_err;\n# 289 "/usr/include/time.h" 3 4\nextern str'
[#] parse_declaration, is_constructor=False, meet line: 'int getdate_err;\n# 289 "/usr/include/time.h" 3 4\nextern struct tm *getdate (const char *__string);\n# 303 "/usr/include/time.h" 3 4\nextern int getdate_r (const char *__restrict __string,\n        struct'
[#] parse_declaration, is_constructor=False, meet line: 'struct tm *getdate (const char *__string);\n# 303 "/usr/include/time.h" 3 4\nextern int getdate_r (const char *__restrict __string,\n        struct tm *__restrict __resbufp);\n\n\n}\n# 25 "/usr/include/pthre'
[#] parse_declaration, is_constructor=False, meet line: 'int getdate_r (const char *__restrict __string,\n        struct tm *__restrict __resbufp);\n\n\n}\n# 25 "/usr/include/pthread.h" 2 3 4\n\n\n# 1 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 1 3 4\n# 26 "/usr/i'
[#] parse_declaration, is_constructor=False, meet line: 'void (*__routine) (void *);\n  void *__arg;\n  int __canceltype;\n  struct _pthread_cleanup_buffer *__prev;\n};\n\n\nenum\n{\n  PTHREAD_CANCEL_ENABLE,\n\n  PTHREAD_CANCEL_DISABLE\n\n};\nenum\n{\n  PTHREAD_CANCEL_DEFE'
[#] parse_declaration, is_constructor=False, meet line: 'void *__arg;\n  int __canceltype;\n  struct _pthread_cleanup_buffer *__prev;\n};\n\n\nenum\n{\n  PTHREAD_CANCEL_ENABLE,\n\n  PTHREAD_CANCEL_DISABLE\n\n};\nenum\n{\n  PTHREAD_CANCEL_DEFERRED,\n\n  PTHREAD_CANCEL_ASYNCH'
[#] parse_declaration, is_constructor=False, meet line: 'int __canceltype;\n  struct _pthread_cleanup_buffer *__prev;\n};\n\n\nenum\n{\n  PTHREAD_CANCEL_ENABLE,\n\n  PTHREAD_CANCEL_DISABLE\n\n};\nenum\n{\n  PTHREAD_CANCEL_DEFERRED,\n\n  PTHREAD_CANCEL_ASYNCHRONOUS\n\n};\n# 22'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_create (pthread_t *__restrict __newthread,\n      const pthread_attr_t *__restrict __attr,\n      void *(*__start_routine) (void *),\n      void *__restrict __arg) throw () __attribute__ ((__'
[#] parse_declaration, is_constructor=False, meet line: 'void pthread_exit (void *__retval) __attribute__ ((__noreturn__));\n\n\n\n\n\n\n\nextern int pthread_join (pthread_t __th, void **__thread_return);\n\n\n\n\nextern int pthread_tryjoin_np (pthread_t __th, void **__'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_join (pthread_t __th, void **__thread_return);\n\n\n\n\nextern int pthread_tryjoin_np (pthread_t __th, void **__thread_return) throw ();\n\n\n\n\n\n\n\nextern int pthread_timedjoin_np (pthread_t __th, '
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_tryjoin_np (pthread_t __th, void **__thread_return) throw ();\n\n\n\n\n\n\n\nextern int pthread_timedjoin_np (pthread_t __th, void **__thread_return,\n     const struct timespec *__abstime);\n\n\n\n\n\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_timedjoin_np (pthread_t __th, void **__thread_return,\n     const struct timespec *__abstime);\n\n\n\n\n\n\nextern int pthread_detach (pthread_t __th) throw ();\n\n\n\nextern pthread_t pthread_self (v'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_detach (pthread_t __th) throw ();\n\n\n\nextern pthread_t pthread_self (void) throw () __attribute__ ((__const__));\n\n\nextern int pthread_equal (pthread_t __thread1, pthread_t __thread2)\n  thro'
[#] parse_declaration, is_constructor=False, meet line: 'pthread_t pthread_self (void) throw () __attribute__ ((__const__));\n\n\nextern int pthread_equal (pthread_t __thread1, pthread_t __thread2)\n  throw () __attribute__ ((__const__));\n\n\n\n\n\n\n\nextern int pthr'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_equal (pthread_t __thread1, pthread_t __thread2)\n  throw () __attribute__ ((__const__));\n\n\n\n\n\n\n\nextern int pthread_attr_init (pthread_attr_t *__attr) throw () __attribute__ ((__nonnull__ ('
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_attr_init (pthread_attr_t *__attr) throw () __attribute__ ((__nonnull__ (1)));\n\n\nextern int pthread_attr_destroy (pthread_attr_t *__attr)\n     throw () __attribute__ ((__nonnull__ (1)));\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_attr_destroy (pthread_attr_t *__attr)\n     throw () __attribute__ ((__nonnull__ (1)));\n\n\nextern int pthread_attr_getdetachstate (const pthread_attr_t *__attr,\n     int *__detachstate)\n    '
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_attr_getdetachstate (const pthread_attr_t *__attr,\n     int *__detachstate)\n     throw () __attribute__ ((__nonnull__ (1, 2)));\n\n\nextern int pthread_attr_setdetachstate (pthread_attr_t *__'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_attr_setdetachstate (pthread_attr_t *__attr,\n     int __detachstate)\n     throw () __attribute__ ((__nonnull__ (1)));\n\n\n\nextern int pthread_attr_getguardsize (const pthread_attr_t *__attr,'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_attr_getguardsize (const pthread_attr_t *__attr,\n          size_t *__guardsize)\n     throw () __attribute__ ((__nonnull__ (1, 2)));\n\n\nextern int pthread_attr_setguardsize (pthread_attr_t *'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_attr_setguardsize (pthread_attr_t *__attr,\n          size_t __guardsize)\n     throw () __attribute__ ((__nonnull__ (1)));\n\n\n\nextern int pthread_attr_getschedparam (const pthread_attr_t *__'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_attr_getschedparam (const pthread_attr_t *__restrict __attr,\n           struct sched_param *__restrict __param)\n     throw () __attribute__ ((__nonnull__ (1, 2)));\n\n\nextern int pthread_att'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_attr_setschedparam (pthread_attr_t *__restrict __attr,\n           const struct sched_param *__restrict\n           __param) throw () __attribute__ ((__nonnull__ (1, 2)));\n\n\nextern int pthre'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_attr_getschedpolicy (const pthread_attr_t *__restrict\n     __attr, int *__restrict __policy)\n     throw () __attribute__ ((__nonnull__ (1, 2)));\n\n\nextern int pthread_attr_setschedpolicy (p'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_attr_setschedpolicy (pthread_attr_t *__attr, int __policy)\n     throw () __attribute__ ((__nonnull__ (1)));\n\n\nextern int pthread_attr_getinheritsched (const pthread_attr_t *__restrict\n    '
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_attr_getinheritsched (const pthread_attr_t *__restrict\n      __attr, int *__restrict __inherit)\n     throw () __attribute__ ((__nonnull__ (1, 2)));\n\n\nextern int pthread_attr_setinheritsche'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_attr_setinheritsched (pthread_attr_t *__attr,\n      int __inherit)\n     throw () __attribute__ ((__nonnull__ (1)));\n\n\n\nextern int pthread_attr_getscope (const pthread_attr_t *__restrict __'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_attr_getscope (const pthread_attr_t *__restrict __attr,\n      int *__restrict __scope)\n     throw () __attribute__ ((__nonnull__ (1, 2)));\n\n\nextern int pthread_attr_setscope (pthread_attr_'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_attr_setscope (pthread_attr_t *__attr, int __scope)\n     throw () __attribute__ ((__nonnull__ (1)));\n\n\nextern int pthread_attr_getstackaddr (const pthread_attr_t *__restrict\n          __at'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_attr_getstackaddr (const pthread_attr_t *__restrict\n          __attr, void **__restrict __stackaddr)\n     throw () __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__deprecated__));\n\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_attr_setstackaddr (pthread_attr_t *__attr,\n          void *__stackaddr)\n     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__));\n\n\nextern int pthread_attr_getstack'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_attr_getstacksize (const pthread_attr_t *__restrict\n          __attr, size_t *__restrict __stacksize)\n     throw () __attribute__ ((__nonnull__ (1, 2)));\n\n\n\n\nextern int pthread_attr_setsta'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_attr_setstacksize (pthread_attr_t *__attr,\n          size_t __stacksize)\n     throw () __attribute__ ((__nonnull__ (1)));\n\n\n\nextern int pthread_attr_getstack (const pthread_attr_t *__restr'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_attr_getstack (const pthread_attr_t *__restrict __attr,\n      void **__restrict __stackaddr,\n      size_t *__restrict __stacksize)\n     throw () __attribute__ ((__nonnull__ (1, 2, 3)));\n\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,\n      size_t __stacksize) throw () __attribute__ ((__nonnull__ (1)));\n\n\n\n\n\nextern int pthread_attr_setaffinity_np (pthread_attr_t '
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_attr_setaffinity_np (pthread_attr_t *__attr,\n     size_t __cpusetsize,\n     const cpu_set_t *__cpuset)\n     throw () __attribute__ ((__nonnull__ (1, 3)));\n\n\n\nextern int pthread_attr_getaff'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_attr_getaffinity_np (const pthread_attr_t *__attr,\n     size_t __cpusetsize,\n     cpu_set_t *__cpuset)\n     throw () __attribute__ ((__nonnull__ (1, 3)));\n\n\nextern int pthread_getattr_defa'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_getattr_default_np (pthread_attr_t *__attr)\n     throw () __attribute__ ((__nonnull__ (1)));\n\n\n\nextern int pthread_setattr_default_np (const pthread_attr_t *__attr)\n     throw () __attribu'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_setattr_default_np (const pthread_attr_t *__attr)\n     throw () __attribute__ ((__nonnull__ (1)));\n\n\n\n\nextern int pthread_getattr_np (pthread_t __th, pthread_attr_t *__attr)\n     throw () '
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_getattr_np (pthread_t __th, pthread_attr_t *__attr)\n     throw () __attribute__ ((__nonnull__ (2)));\n\n\n\n\n\n\n\nextern int pthread_setschedparam (pthread_t __target_thread, int __policy,\n     '
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_setschedparam (pthread_t __target_thread, int __policy,\n      const struct sched_param *__param)\n     throw () __attribute__ ((__nonnull__ (3)));\n\n\nextern int pthread_getschedparam (pthrea'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_getschedparam (pthread_t __target_thread,\n      int *__restrict __policy,\n      struct sched_param *__restrict __param)\n     throw () __attribute__ ((__nonnull__ (2, 3)));\n\n\nextern int pth'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_setschedprio (pthread_t __target_thread, int __prio)\n     throw ();\n\n\n\n\nextern int pthread_getname_np (pthread_t __target_thread, char *__buf,\n          size_t __buflen)\n     throw () __at'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_getname_np (pthread_t __target_thread, char *__buf,\n          size_t __buflen)\n     throw () __attribute__ ((__nonnull__ (2)));\n\n\nextern int pthread_setname_np (pthread_t __target_thread, '
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_setname_np (pthread_t __target_thread, const char *__name)\n     throw () __attribute__ ((__nonnull__ (2)));\n\n\n\n\n\nextern int pthread_getconcurrency (void) throw ();\n\n\nextern int pthread_set'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_getconcurrency (void) throw ();\n\n\nextern int pthread_setconcurrency (int __level) throw ();\n\n\n\n\n\n\n\nextern int pthread_yield (void) throw ();\n\n\n\n\nextern int pthread_setaffinity_np (pthread_'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_setconcurrency (int __level) throw ();\n\n\n\n\n\n\n\nextern int pthread_yield (void) throw ();\n\n\n\n\nextern int pthread_setaffinity_np (pthread_t __th, size_t __cpusetsize,\n       const cpu_set_t *'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_yield (void) throw ();\n\n\n\n\nextern int pthread_setaffinity_np (pthread_t __th, size_t __cpusetsize,\n       const cpu_set_t *__cpuset)\n     throw () __attribute__ ((__nonnull__ (3)));\n\n\nexte'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_setaffinity_np (pthread_t __th, size_t __cpusetsize,\n       const cpu_set_t *__cpuset)\n     throw () __attribute__ ((__nonnull__ (3)));\n\n\nextern int pthread_getaffinity_np (pthread_t __th,'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_getaffinity_np (pthread_t __th, size_t __cpusetsize,\n       cpu_set_t *__cpuset)\n     throw () __attribute__ ((__nonnull__ (3)));\n# 495 "/usr/include/pthread.h" 3 4\nextern int pthread_once'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_once (pthread_once_t *__once_control,\n    void (*__init_routine) (void)) __attribute__ ((__nonnull__ (1, 2)));\n# 507 "/usr/include/pthread.h" 3 4\nextern int pthread_setcancelstate (int __s'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_setcancelstate (int __state, int *__oldstate);\n\n\n\nextern int pthread_setcanceltype (int __type, int *__oldtype);\n\n\nextern int pthread_cancel (pthread_t __th);\n\n\n\n\nextern void pthread_testc'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_setcanceltype (int __type, int *__oldtype);\n\n\nextern int pthread_cancel (pthread_t __th);\n\n\n\n\nextern void pthread_testcancel (void);\n\n\n\n\ntypedef struct\n{\n  struct\n  {\n    __jmp_buf __cance'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_cancel (pthread_t __th);\n\n\n\n\nextern void pthread_testcancel (void);\n\n\n\n\ntypedef struct\n{\n  struct\n  {\n    __jmp_buf __cancel_jmp_buf;\n    int __mask_was_saved;\n  } __cancel_jmp_buf[1];\n  v'
[#] parse_declaration, is_constructor=False, meet line: 'void pthread_testcancel (void);\n\n\n\n\ntypedef struct\n{\n  struct\n  {\n    __jmp_buf __cancel_jmp_buf;\n    int __mask_was_saved;\n  } __cancel_jmp_buf[1];\n  void *__pad[4];\n} __pthread_unwind_buf_t __attrib'
[#] parse_declaration, is_constructor=False, meet line: 'void (*__cancel_routine) (void *);\n  void *__cancel_arg;\n  int __do_it;\n  int __cancel_type;\n};\n\n\n\n\nclass __pthread_cleanup_class\n{\n  void (*__cancel_routine) (void *);\n  void *__cancel_arg;\n  int __d'
[#] parse_declaration, is_constructor=False, meet line: 'void *__cancel_arg;\n  int __do_it;\n  int __cancel_type;\n};\n\n\n\n\nclass __pthread_cleanup_class\n{\n  void (*__cancel_routine) (void *);\n  void *__cancel_arg;\n  int __do_it;\n  int __cancel_type;\n\n public:\n'
[#] parse_declaration, is_constructor=False, meet line: 'int __do_it;\n  int __cancel_type;\n};\n\n\n\n\nclass __pthread_cleanup_class\n{\n  void (*__cancel_routine) (void *);\n  void *__cancel_arg;\n  int __do_it;\n  int __cancel_type;\n\n public:\n  __pthread_cleanup_cl'
[#] parse_declaration, is_constructor=False, meet line: 'int __cancel_type;\n};\n\n\n\n\nclass __pthread_cleanup_class\n{\n  void (*__cancel_routine) (void *);\n  void *__cancel_arg;\n  int __do_it;\n  int __cancel_type;\n\n public:\n  __pthread_cleanup_class (void (*__f'
[#] parse_declaration, is_constructor=False, meet line: 'void (*__cancel_routine) (void *);\n  void *__cancel_arg;\n  int __do_it;\n  int __cancel_type;\n\n public:\n  __pthread_cleanup_class (void (*__fct) (void *), void *__arg)\n    : __cancel_routine (__fct), _'
[#] parse_declaration, is_constructor=False, meet line: 'void *__cancel_arg;\n  int __do_it;\n  int __cancel_type;\n\n public:\n  __pthread_cleanup_class (void (*__fct) (void *), void *__arg)\n    : __cancel_routine (__fct), __cancel_arg (__arg), __do_it (1) { }\n'
[#] parse_declaration, is_constructor=False, meet line: 'int __do_it;\n  int __cancel_type;\n\n public:\n  __pthread_cleanup_class (void (*__fct) (void *), void *__arg)\n    : __cancel_routine (__fct), __cancel_arg (__arg), __do_it (1) { }\n  ~__pthread_cleanup_c'
[#] parse_declaration, is_constructor=False, meet line: 'int __cancel_type;\n\n public:\n  __pthread_cleanup_class (void (*__fct) (void *), void *__arg)\n    : __cancel_routine (__fct), __cancel_arg (__arg), __do_it (1) { }\n  ~__pthread_cleanup_class () { if (_'
[#] parse_declaration, is_constructor=True, meet line: '__pthread_cleanup_class (void (*__fct) (void *), void *__arg)\n    : __cancel_routine (__fct), __cancel_arg (__arg), __do_it (1) { }\n  ~__pthread_cleanup_class () { if (__do_it) __cancel_routine (__can'
[#] parse_declaration, is_constructor=True, meet line: '__pthread_cleanup_class () { if (__do_it) __cancel_routine (__cancel_arg); }\n  void __setdoit (int __newval) { __do_it = __newval; }\n  void __defer () { pthread_setcanceltype (PTHREAD_CANCEL_DEFERRED,'
[#] parse_declaration, is_constructor=False, meet line: 'void __setdoit (int __newval) { __do_it = __newval; }\n  void __defer () { pthread_setcanceltype (PTHREAD_CANCEL_DEFERRED,\n        &__cancel_type); }\n  void __restore () const { pthread_setcanceltype ('
[#] parse_declaration, is_constructor=False, meet line: 'void __defer () { pthread_setcanceltype (PTHREAD_CANCEL_DEFERRED,\n        &__cancel_type); }\n  void __restore () const { pthread_setcanceltype (__cancel_type, 0); }\n};\n# 743 "/usr/include/pthread.h" 3'
[#] parse_declaration, is_constructor=False, meet line: 'void __restore () const { pthread_setcanceltype (__cancel_type, 0); }\n};\n# 743 "/usr/include/pthread.h" 3 4\nstruct __jmp_buf_tag;\nextern int __sigsetjmp (struct __jmp_buf_tag *__env, int __savemask) t'
[#] parse_declaration, is_constructor=False, meet line: 'int __sigsetjmp (struct __jmp_buf_tag *__env, int __savemask) throw ();\n\n\n\n\n\nextern int pthread_mutex_init (pthread_mutex_t *__mutex,\n          const pthread_mutexattr_t *__mutexattr)\n     throw () __'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_mutex_init (pthread_mutex_t *__mutex,\n          const pthread_mutexattr_t *__mutexattr)\n     throw () __attribute__ ((__nonnull__ (1)));\n\n\nextern int pthread_mutex_destroy (pthread_mutex_t'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_mutex_destroy (pthread_mutex_t *__mutex)\n     throw () __attribute__ ((__nonnull__ (1)));\n\n\nextern int pthread_mutex_trylock (pthread_mutex_t *__mutex)\n     throw () __attribute__ ((__nonn'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_mutex_trylock (pthread_mutex_t *__mutex)\n     throw () __attribute__ ((__nonnull__ (1)));\n\n\nextern int pthread_mutex_lock (pthread_mutex_t *__mutex)\n     throw () __attribute__ ((__nonnull'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_mutex_lock (pthread_mutex_t *__mutex)\n     throw () __attribute__ ((__nonnull__ (1)));\n\n\n\nextern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,\n        const struct time'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,\n        const struct timespec *__restrict\n        __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));\n\n\n\nextern int pthread_mute'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_mutex_unlock (pthread_mutex_t *__mutex)\n     throw () __attribute__ ((__nonnull__ (1)));\n\n\n\nextern int pthread_mutex_getprioceiling (const pthread_mutex_t *\n      __restrict __mutex,\n     '
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_mutex_getprioceiling (const pthread_mutex_t *\n      __restrict __mutex,\n      int *__restrict __prioceiling)\n     throw () __attribute__ ((__nonnull__ (1, 2)));\n\n\n\nextern int pthread_mutex'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict __mutex,\n      int __prioceiling,\n      int *__restrict __old_ceiling)\n     throw () __attribute__ ((__nonnull__ (1, 3)));\n\n\n\n\nextern int '
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_mutex_consistent (pthread_mutex_t *__mutex)\n     throw () __attribute__ ((__nonnull__ (1)));\n\nextern int pthread_mutex_consistent_np (pthread_mutex_t *__mutex)\n     throw () __attribute__ '
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_mutex_consistent_np (pthread_mutex_t *__mutex)\n     throw () __attribute__ ((__nonnull__ (1)));\n# 807 "/usr/include/pthread.h" 3 4\nextern int pthread_mutexattr_init (pthread_mutexattr_t *_'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_mutexattr_init (pthread_mutexattr_t *__attr)\n     throw () __attribute__ ((__nonnull__ (1)));\n\n\nextern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)\n     throw () __attribute'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)\n     throw () __attribute__ ((__nonnull__ (1)));\n\n\nextern int pthread_mutexattr_getpshared (const pthread_mutexattr_t *\n      __restrict __a'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_mutexattr_getpshared (const pthread_mutexattr_t *\n      __restrict __attr,\n      int *__restrict __pshared)\n     throw () __attribute__ ((__nonnull__ (1, 2)));\n\n\nextern int pthread_mutexat'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,\n      int __pshared)\n     throw () __attribute__ ((__nonnull__ (1)));\n\n\n\nextern int pthread_mutexattr_gettype (const pthread_mutexattr_t '
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_mutexattr_gettype (const pthread_mutexattr_t *__restrict\n          __attr, int *__restrict __kind)\n     throw () __attribute__ ((__nonnull__ (1, 2)));\n\n\n\n\nextern int pthread_mutexattr_sett'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)\n     throw () __attribute__ ((__nonnull__ (1)));\n\n\n\nextern int pthread_mutexattr_getprotocol (const pthread_mutexattr_t *\n      '
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_mutexattr_getprotocol (const pthread_mutexattr_t *\n       __restrict __attr,\n       int *__restrict __protocol)\n     throw () __attribute__ ((__nonnull__ (1, 2)));\n\n\n\nextern int pthread_mu'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_mutexattr_setprotocol (pthread_mutexattr_t *__attr,\n       int __protocol)\n     throw () __attribute__ ((__nonnull__ (1)));\n\n\nextern int pthread_mutexattr_getprioceiling (const pthread_mut'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_mutexattr_getprioceiling (const pthread_mutexattr_t *\n          __restrict __attr,\n          int *__restrict __prioceiling)\n     throw () __attribute__ ((__nonnull__ (1, 2)));\n\n\nextern int'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_mutexattr_setprioceiling (pthread_mutexattr_t *__attr,\n          int __prioceiling)\n     throw () __attribute__ ((__nonnull__ (1)));\n\n\n\nextern int pthread_mutexattr_getrobust (const pthrea'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_mutexattr_getrobust (const pthread_mutexattr_t *__attr,\n     int *__robustness)\n     throw () __attribute__ ((__nonnull__ (1, 2)));\n\nextern int pthread_mutexattr_getrobust_np (const pthrea'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_mutexattr_getrobust_np (const pthread_mutexattr_t *__attr,\n        int *__robustness)\n     throw () __attribute__ ((__nonnull__ (1, 2)));\n\n\n\nextern int pthread_mutexattr_setrobust (pthread'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_mutexattr_setrobust (pthread_mutexattr_t *__attr,\n     int __robustness)\n     throw () __attribute__ ((__nonnull__ (1)));\n\nextern int pthread_mutexattr_setrobust_np (pthread_mutexattr_t *_'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_mutexattr_setrobust_np (pthread_mutexattr_t *__attr,\n        int __robustness)\n     throw () __attribute__ ((__nonnull__ (1)));\n# 889 "/usr/include/pthread.h" 3 4\nextern int pthread_rwlock'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,\n    const pthread_rwlockattr_t *__restrict\n    __attr) throw () __attribute__ ((__nonnull__ (1)));\n\n\nextern int pthread_rwlock_destroy ('
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock)\n     throw () __attribute__ ((__nonnull__ (1)));\n\n\nextern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)\n     throw () __attribute__ ((_'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)\n     throw () __attribute__ ((__nonnull__ (1)));\n\n\nextern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)\n  throw () __attribute__ ((__'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)\n  throw () __attribute__ ((__nonnull__ (1)));\n\n\n\nextern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,\n           cons'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,\n           const struct timespec *__restrict\n           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));\n\n\n\nextern int p'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock)\n     throw () __attribute__ ((__nonnull__ (1)));\n\n\nextern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)\n     throw () __attribute__ ('
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)\n     throw () __attribute__ ((__nonnull__ (1)));\n\n\n\nextern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,\n           c'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,\n           const struct timespec *__restrict\n           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));\n\n\n\nextern int p'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock)\n     throw () __attribute__ ((__nonnull__ (1)));\n\n\n\n\n\nextern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr)\n     throw () __attribute'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr)\n     throw () __attribute__ ((__nonnull__ (1)));\n\n\nextern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr)\n     throw () __attri'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr)\n     throw () __attribute__ ((__nonnull__ (1)));\n\n\nextern int pthread_rwlockattr_getpshared (const pthread_rwlockattr_t *\n       __restric'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_rwlockattr_getpshared (const pthread_rwlockattr_t *\n       __restrict __attr,\n       int *__restrict __pshared)\n     throw () __attribute__ ((__nonnull__ (1, 2)));\n\n\nextern int pthread_rwl'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,\n       int __pshared)\n     throw () __attribute__ ((__nonnull__ (1)));\n\n\nextern int pthread_rwlockattr_getkind_np (const pthread_rwlock'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_rwlockattr_getkind_np (const pthread_rwlockattr_t *\n       __restrict __attr,\n       int *__restrict __pref)\n     throw () __attribute__ ((__nonnull__ (1, 2)));\n\n\nextern int pthread_rwlock'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,\n       int __pref) throw () __attribute__ ((__nonnull__ (1)));\n\n\n\n\n\n\n\nextern int pthread_cond_init (pthread_cond_t *__restrict __cond,\n'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_cond_init (pthread_cond_t *__restrict __cond,\n         const pthread_condattr_t *__restrict __cond_attr)\n     throw () __attribute__ ((__nonnull__ (1)));\n\n\nextern int pthread_cond_destroy '
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_cond_destroy (pthread_cond_t *__cond)\n     throw () __attribute__ ((__nonnull__ (1)));\n\n\nextern int pthread_cond_signal (pthread_cond_t *__cond)\n     throw () __attribute__ ((__nonnull__ ('
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_cond_signal (pthread_cond_t *__cond)\n     throw () __attribute__ ((__nonnull__ (1)));\n\n\nextern int pthread_cond_broadcast (pthread_cond_t *__cond)\n     throw () __attribute__ ((__nonnull__'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_cond_broadcast (pthread_cond_t *__cond)\n     throw () __attribute__ ((__nonnull__ (1)));\n\n\n\n\n\n\nextern int pthread_cond_wait (pthread_cond_t *__restrict __cond,\n         pthread_mutex_t *__'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_cond_wait (pthread_cond_t *__restrict __cond,\n         pthread_mutex_t *__restrict __mutex)\n     __attribute__ ((__nonnull__ (1, 2)));\n# 1001 "/usr/include/pthread.h" 3 4\nextern int pthrea'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,\n       pthread_mutex_t *__restrict __mutex,\n       const struct timespec *__restrict __abstime)\n     __attribute__ ((__nonnull__ (1, 2, 3'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_condattr_init (pthread_condattr_t *__attr)\n     throw () __attribute__ ((__nonnull__ (1)));\n\n\nextern int pthread_condattr_destroy (pthread_condattr_t *__attr)\n     throw () __attribute__ ('
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_condattr_destroy (pthread_condattr_t *__attr)\n     throw () __attribute__ ((__nonnull__ (1)));\n\n\nextern int pthread_condattr_getpshared (const pthread_condattr_t *\n     __restrict __attr,\n'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_condattr_getpshared (const pthread_condattr_t *\n     __restrict __attr,\n     int *__restrict __pshared)\n     throw () __attribute__ ((__nonnull__ (1, 2)));\n\n\nextern int pthread_condattr_se'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_condattr_setpshared (pthread_condattr_t *__attr,\n     int __pshared) throw () __attribute__ ((__nonnull__ (1)));\n\n\n\nextern int pthread_condattr_getclock (const pthread_condattr_t *\n       '
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_condattr_getclock (const pthread_condattr_t *\n          __restrict __attr,\n          __clockid_t *__restrict __clock_id)\n     throw () __attribute__ ((__nonnull__ (1, 2)));\n\n\nextern int pt'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_condattr_setclock (pthread_condattr_t *__attr,\n          __clockid_t __clock_id)\n     throw () __attribute__ ((__nonnull__ (1)));\n# 1045 "/usr/include/pthread.h" 3 4\nextern int pthread_spi'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)\n     throw () __attribute__ ((__nonnull__ (1)));\n\n\nextern int pthread_spin_destroy (pthread_spinlock_t *__lock)\n     throw () __attrib'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_spin_destroy (pthread_spinlock_t *__lock)\n     throw () __attribute__ ((__nonnull__ (1)));\n\n\nextern int pthread_spin_lock (pthread_spinlock_t *__lock)\n     throw () __attribute__ ((__nonnu'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_spin_lock (pthread_spinlock_t *__lock)\n     throw () __attribute__ ((__nonnull__ (1)));\n\n\nextern int pthread_spin_trylock (pthread_spinlock_t *__lock)\n     throw () __attribute__ ((__nonnu'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_spin_trylock (pthread_spinlock_t *__lock)\n     throw () __attribute__ ((__nonnull__ (1)));\n\n\nextern int pthread_spin_unlock (pthread_spinlock_t *__lock)\n     throw () __attribute__ ((__non'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_spin_unlock (pthread_spinlock_t *__lock)\n     throw () __attribute__ ((__nonnull__ (1)));\n\n\n\n\n\n\nextern int pthread_barrier_init (pthread_barrier_t *__restrict __barrier,\n     const pthread'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_barrier_init (pthread_barrier_t *__restrict __barrier,\n     const pthread_barrierattr_t *__restrict\n     __attr, unsigned int __count)\n     throw () __attribute__ ((__nonnull__ (1)));\n\n\nex'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_barrier_destroy (pthread_barrier_t *__barrier)\n     throw () __attribute__ ((__nonnull__ (1)));\n\n\nextern int pthread_barrier_wait (pthread_barrier_t *__barrier)\n     throw () __attribute__'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_barrier_wait (pthread_barrier_t *__barrier)\n     throw () __attribute__ ((__nonnull__ (1)));\n\n\n\nextern int pthread_barrierattr_init (pthread_barrierattr_t *__attr)\n     throw () __attribut'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_barrierattr_init (pthread_barrierattr_t *__attr)\n     throw () __attribute__ ((__nonnull__ (1)));\n\n\nextern int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr)\n     throw () __a'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr)\n     throw () __attribute__ ((__nonnull__ (1)));\n\n\nextern int pthread_barrierattr_getpshared (const pthread_barrierattr_t *\n        __re'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_barrierattr_getpshared (const pthread_barrierattr_t *\n        __restrict __attr,\n        int *__restrict __pshared)\n     throw () __attribute__ ((__nonnull__ (1, 2)));\n\n\nextern int pthread'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,\n        int __pshared)\n     throw () __attribute__ ((__nonnull__ (1)));\n# 1112 "/usr/include/pthread.h" 3 4\nextern int pthread_key_cr'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_key_create (pthread_key_t *__key,\n          void (*__destr_function) (void *))\n     throw () __attribute__ ((__nonnull__ (1)));\n\n\nextern int pthread_key_delete (pthread_key_t __key) throw '
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_key_delete (pthread_key_t __key) throw ();\n\n\nextern void *pthread_getspecific (pthread_key_t __key) throw ();\n\n\nextern int pthread_setspecific (pthread_key_t __key,\n    const void *__point'
[#] parse_declaration, is_constructor=False, meet line: 'void *pthread_getspecific (pthread_key_t __key) throw ();\n\n\nextern int pthread_setspecific (pthread_key_t __key,\n    const void *__pointer) throw () ;\n\n\n\n\nextern int pthread_getcpuclockid (pthread_t _'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_setspecific (pthread_key_t __key,\n    const void *__pointer) throw () ;\n\n\n\n\nextern int pthread_getcpuclockid (pthread_t __thread_id,\n      __clockid_t *__clock_id)\n     throw () __attribut'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_getcpuclockid (pthread_t __thread_id,\n      __clockid_t *__clock_id)\n     throw () __attribute__ ((__nonnull__ (2)));\n# 1146 "/usr/include/pthread.h" 3 4\nextern int pthread_atfork (void (*'
[#] parse_declaration, is_constructor=False, meet line: 'int pthread_atfork (void (*__prepare) (void),\n      void (*__parent) (void),\n      void (*__child) (void)) throw ();\n# 1160 "/usr/include/pthread.h" 3 4\n}\n# 36 "/usr/include/x86_64-linux-gnu/c++/7/bit'
[#] parse_declaration, is_constructor=False, meet line: '__typeof(pthread_once) __gthrw_pthread_once __attribute__ ((__weakref__("pthread_once")));\nstatic __typeof(pthread_getspecific) __gthrw_pthread_getspecific __attribute__ ((__weakref__("pthread_getspec'
[#] parse_declaration, is_constructor=False, meet line: '__typeof(pthread_getspecific) __gthrw_pthread_getspecific __attribute__ ((__weakref__("pthread_getspecific")));\nstatic __typeof(pthread_setspecific) __gthrw_pthread_setspecific __attribute__ ((__weakr'
[#] parse_declaration, is_constructor=False, meet line: '__typeof(pthread_setspecific) __gthrw_pthread_setspecific __attribute__ ((__weakref__("pthread_setspecific")));\n\nstatic __typeof(pthread_create) __gthrw_pthread_create __attribute__ ((__weakref__("pth'
[#] parse_declaration, is_constructor=False, meet line: '__typeof(pthread_create) __gthrw_pthread_create __attribute__ ((__weakref__("pthread_create")));\nstatic __typeof(pthread_join) __gthrw_pthread_join __attribute__ ((__weakref__("pthread_join")));\nstati'
[#] parse_declaration, is_constructor=False, meet line: '__typeof(pthread_join) __gthrw_pthread_join __attribute__ ((__weakref__("pthread_join")));\nstatic __typeof(pthread_equal) __gthrw_pthread_equal __attribute__ ((__weakref__("pthread_equal")));\nstatic _'
[#] parse_declaration, is_constructor=False, meet line: '__typeof(pthread_equal) __gthrw_pthread_equal __attribute__ ((__weakref__("pthread_equal")));\nstatic __typeof(pthread_self) __gthrw_pthread_self __attribute__ ((__weakref__("pthread_self")));\nstatic _'
[#] parse_declaration, is_constructor=False, meet line: '__typeof(pthread_self) __gthrw_pthread_self __attribute__ ((__weakref__("pthread_self")));\nstatic __typeof(pthread_detach) __gthrw_pthread_detach __attribute__ ((__weakref__("pthread_detach")));\n\nstat'
[#] parse_declaration, is_constructor=False, meet line: '__typeof(pthread_detach) __gthrw_pthread_detach __attribute__ ((__weakref__("pthread_detach")));\n\nstatic __typeof(pthread_cancel) __gthrw_pthread_cancel __attribute__ ((__weakref__("pthread_cancel")))'
[#] parse_declaration, is_constructor=False, meet line: '__typeof(pthread_cancel) __gthrw_pthread_cancel __attribute__ ((__weakref__("pthread_cancel")));\n\nstatic __typeof(sched_yield) __gthrw_sched_yield __attribute__ ((__weakref__("sched_yield")));\n\nstatic'
[#] parse_declaration, is_constructor=False, meet line: '__typeof(sched_yield) __gthrw_sched_yield __attribute__ ((__weakref__("sched_yield")));\n\nstatic __typeof(pthread_mutex_lock) __gthrw_pthread_mutex_lock __attribute__ ((__weakref__("pthread_mutex_lock"'
[#] parse_declaration, is_constructor=False, meet line: '__typeof(pthread_mutex_lock) __gthrw_pthread_mutex_lock __attribute__ ((__weakref__("pthread_mutex_lock")));\nstatic __typeof(pthread_mutex_trylock) __gthrw_pthread_mutex_trylock __attribute__ ((__weak'
[#] parse_declaration, is_constructor=False, meet line: '__typeof(pthread_mutex_trylock) __gthrw_pthread_mutex_trylock __attribute__ ((__weakref__("pthread_mutex_trylock")));\n\nstatic __typeof(pthread_mutex_timedlock) __gthrw_pthread_mutex_timedlock __attrib'
[#] parse_declaration, is_constructor=False, meet line: '__typeof(pthread_mutex_timedlock) __gthrw_pthread_mutex_timedlock __attribute__ ((__weakref__("pthread_mutex_timedlock")));\n\nstatic __typeof(pthread_mutex_unlock) __gthrw_pthread_mutex_unlock __attrib'
[#] parse_declaration, is_constructor=False, meet line: '__typeof(pthread_mutex_unlock) __gthrw_pthread_mutex_unlock __attribute__ ((__weakref__("pthread_mutex_unlock")));\nstatic __typeof(pthread_mutex_init) __gthrw_pthread_mutex_init __attribute__ ((__weak'
[#] parse_declaration, is_constructor=False, meet line: '__typeof(pthread_mutex_init) __gthrw_pthread_mutex_init __attribute__ ((__weakref__("pthread_mutex_init")));\nstatic __typeof(pthread_mutex_destroy) __gthrw_pthread_mutex_destroy __attribute__ ((__weak'
[#] parse_declaration, is_constructor=False, meet line: '__typeof(pthread_mutex_destroy) __gthrw_pthread_mutex_destroy __attribute__ ((__weakref__("pthread_mutex_destroy")));\n\nstatic __typeof(pthread_cond_init) __gthrw_pthread_cond_init __attribute__ ((__we'
[#] parse_declaration, is_constructor=False, meet line: '__typeof(pthread_cond_init) __gthrw_pthread_cond_init __attribute__ ((__weakref__("pthread_cond_init")));\nstatic __typeof(pthread_cond_broadcast) __gthrw_pthread_cond_broadcast __attribute__ ((__weakr'
[#] parse_declaration, is_constructor=False, meet line: '__typeof(pthread_cond_broadcast) __gthrw_pthread_cond_broadcast __attribute__ ((__weakref__("pthread_cond_broadcast")));\nstatic __typeof(pthread_cond_signal) __gthrw_pthread_cond_signal __attribute__ '
[#] parse_declaration, is_constructor=False, meet line: '__typeof(pthread_cond_signal) __gthrw_pthread_cond_signal __attribute__ ((__weakref__("pthread_cond_signal")));\nstatic __typeof(pthread_cond_wait) __gthrw_pthread_cond_wait __attribute__ ((__weakref__'
[#] parse_declaration, is_constructor=False, meet line: '__typeof(pthread_cond_wait) __gthrw_pthread_cond_wait __attribute__ ((__weakref__("pthread_cond_wait")));\nstatic __typeof(pthread_cond_timedwait) __gthrw_pthread_cond_timedwait __attribute__ ((__weakr'
[#] parse_declaration, is_constructor=False, meet line: '__typeof(pthread_cond_timedwait) __gthrw_pthread_cond_timedwait __attribute__ ((__weakref__("pthread_cond_timedwait")));\nstatic __typeof(pthread_cond_destroy) __gthrw_pthread_cond_destroy __attribute_'
[#] parse_declaration, is_constructor=False, meet line: '__typeof(pthread_cond_destroy) __gthrw_pthread_cond_destroy __attribute__ ((__weakref__("pthread_cond_destroy")));\n\nstatic __typeof(pthread_key_create) __gthrw_pthread_key_create __attribute__ ((__wea'
[#] parse_declaration, is_constructor=False, meet line: '__typeof(pthread_key_create) __gthrw_pthread_key_create __attribute__ ((__weakref__("pthread_key_create")));\nstatic __typeof(pthread_key_delete) __gthrw_pthread_key_delete __attribute__ ((__weakref__('
[#] parse_declaration, is_constructor=False, meet line: '__typeof(pthread_key_delete) __gthrw_pthread_key_delete __attribute__ ((__weakref__("pthread_key_delete")));\nstatic __typeof(pthread_mutexattr_init) __gthrw_pthread_mutexattr_init __attribute__ ((__we'
[#] parse_declaration, is_constructor=False, meet line: '__typeof(pthread_mutexattr_init) __gthrw_pthread_mutexattr_init __attribute__ ((__weakref__("pthread_mutexattr_init")));\nstatic __typeof(pthread_mutexattr_settype) __gthrw_pthread_mutexattr_settype __'
[#] parse_declaration, is_constructor=False, meet line: '__typeof(pthread_mutexattr_settype) __gthrw_pthread_mutexattr_settype __attribute__ ((__weakref__("pthread_mutexattr_settype")));\nstatic __typeof(pthread_mutexattr_destroy) __gthrw_pthread_mutexattr_d'
[#] parse_declaration, is_constructor=False, meet line: '__typeof(pthread_mutexattr_destroy) __gthrw_pthread_mutexattr_destroy __attribute__ ((__weakref__("pthread_mutexattr_destroy")));\n# 236 "/usr/include/x86_64-linux-gnu/c++/7/bits/gthr-default.h" 3\nstat'
[#] parse_declaration, is_constructor=False, meet line: '__typeof(pthread_key_create) __gthrw___pthread_key_create __attribute__ ((__weakref__("__pthread_key_create")));\n# 246 "/usr/include/x86_64-linux-gnu/c++/7/bits/gthr-default.h" 3\nstatic inline int\n__g'
[#] parse_declaration, is_constructor=False, meet line: 'int\n__gthread_active_p (void)\n{\n  static void *const __gthread_active_ptr\n    = __extension__ (void *) &__gthrw___pthread_key_create;\n  return __gthread_active_ptr != 0;\n}\n# 658 "/usr/include/x86_64-l'
[#] parse_declaration, is_constructor=False, meet line: 'int\n__gthread_create (__gthread_t *__threadid, void *(*__func) (void*),\n    void *__args)\n{\n  return __gthrw_pthread_create (__threadid, __null, __func, __args);\n}\n\nstatic inline int\n__gthread_join (_'
[#] parse_declaration, is_constructor=False, meet line: 'int\n__gthread_join (__gthread_t __threadid, void **__value_ptr)\n{\n  return __gthrw_pthread_join (__threadid, __value_ptr);\n}\n\nstatic inline int\n__gthread_detach (__gthread_t __threadid)\n{\n  return __g'
[#] parse_declaration, is_constructor=False, meet line: 'int\n__gthread_detach (__gthread_t __threadid)\n{\n  return __gthrw_pthread_detach (__threadid);\n}\n\nstatic inline int\n__gthread_equal (__gthread_t __t1, __gthread_t __t2)\n{\n  return __gthrw_pthread_equal'
[#] parse_declaration, is_constructor=False, meet line: 'int\n__gthread_equal (__gthread_t __t1, __gthread_t __t2)\n{\n  return __gthrw_pthread_equal (__t1, __t2);\n}\n\nstatic inline __gthread_t\n__gthread_self (void)\n{\n  return __gthrw_pthread_self ();\n}\n\nstatic'
[#] parse_declaration, is_constructor=False, meet line: '__gthread_t\n__gthread_self (void)\n{\n  return __gthrw_pthread_self ();\n}\n\nstatic inline int\n__gthread_yield (void)\n{\n  return __gthrw_sched_yield ();\n}\n\nstatic inline int\n__gthread_once (__gthread_once'
[#] parse_declaration, is_constructor=False, meet line: 'int\n__gthread_yield (void)\n{\n  return __gthrw_sched_yield ();\n}\n\nstatic inline int\n__gthread_once (__gthread_once_t *__once, void (*__func) (void))\n{\n  if (__gthread_active_p ())\n    return __gthrw_pt'
[#] parse_declaration, is_constructor=False, meet line: 'int\n__gthread_once (__gthread_once_t *__once, void (*__func) (void))\n{\n  if (__gthread_active_p ())\n    return __gthrw_pthread_once (__once, __func);\n  else\n    return -1;\n}\n\nstatic inline int\n__gthre'
[#] parse_declaration, is_constructor=False, meet line: 'int\n__gthread_key_create (__gthread_key_t *__key, void (*__dtor) (void *))\n{\n  return __gthrw_pthread_key_create (__key, __dtor);\n}\n\nstatic inline int\n__gthread_key_delete (__gthread_key_t __key)\n{\n  '
[#] parse_declaration, is_constructor=False, meet line: 'int\n__gthread_key_delete (__gthread_key_t __key)\n{\n  return __gthrw_pthread_key_delete (__key);\n}\n\nstatic inline void *\n__gthread_getspecific (__gthread_key_t __key)\n{\n  return __gthrw_pthread_getspec'
[#] parse_declaration, is_constructor=False, meet line: 'void *\n__gthread_getspecific (__gthread_key_t __key)\n{\n  return __gthrw_pthread_getspecific (__key);\n}\n\nstatic inline int\n__gthread_setspecific (__gthread_key_t __key, const void *__ptr)\n{\n  return __'
[#] parse_declaration, is_constructor=False, meet line: 'int\n__gthread_setspecific (__gthread_key_t __key, const void *__ptr)\n{\n  return __gthrw_pthread_setspecific (__key, __ptr);\n}\n\nstatic inline void\n__gthread_mutex_init_function (__gthread_mutex_t *__mu'
[#] parse_declaration, is_constructor=False, meet line: 'void\n__gthread_mutex_init_function (__gthread_mutex_t *__mutex)\n{\n  if (__gthread_active_p ())\n    __gthrw_pthread_mutex_init (__mutex, __null);\n}\n\nstatic inline int\n__gthread_mutex_destroy (__gthread'
[#] parse_declaration, is_constructor=False, meet line: 'int\n__gthread_mutex_destroy (__gthread_mutex_t *__mutex)\n{\n  if (__gthread_active_p ())\n    return __gthrw_pthread_mutex_destroy (__mutex);\n  else\n    return 0;\n}\n\nstatic inline int\n__gthread_mutex_lo'
[#] parse_declaration, is_constructor=False, meet line: 'int\n__gthread_mutex_lock (__gthread_mutex_t *__mutex)\n{\n  if (__gthread_active_p ())\n    return __gthrw_pthread_mutex_lock (__mutex);\n  else\n    return 0;\n}\n\nstatic inline int\n__gthread_mutex_trylock '
[#] parse_declaration, is_constructor=False, meet line: 'int\n__gthread_mutex_trylock (__gthread_mutex_t *__mutex)\n{\n  if (__gthread_active_p ())\n    return __gthrw_pthread_mutex_trylock (__mutex);\n  else\n    return 0;\n}\n\n\nstatic inline int\n__gthread_mutex_t'
[#] parse_declaration, is_constructor=False, meet line: 'int\n__gthread_mutex_timedlock (__gthread_mutex_t *__mutex,\n      const __gthread_time_t *__abs_timeout)\n{\n  if (__gthread_active_p ())\n    return __gthrw_pthread_mutex_timedlock (__mutex, __abs_timeou'
[#] parse_declaration, is_constructor=False, meet line: 'int\n__gthread_mutex_unlock (__gthread_mutex_t *__mutex)\n{\n  if (__gthread_active_p ())\n    return __gthrw_pthread_mutex_unlock (__mutex);\n  else\n    return 0;\n}\n# 807 "/usr/include/x86_64-linux-gnu/c+'
[#] parse_declaration, is_constructor=False, meet line: 'int\n__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)\n{\n  return __gthread_mutex_lock (__mutex);\n}\n\nstatic inline int\n__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t'
[#] parse_declaration, is_constructor=False, meet line: 'int\n__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)\n{\n  return __gthread_mutex_trylock (__mutex);\n}\n\n\nstatic inline int\n__gthread_recursive_mutex_timedlock (__gthread_recursiv'
[#] parse_declaration, is_constructor=False, meet line: 'int\n__gthread_recursive_mutex_timedlock (__gthread_recursive_mutex_t *__mutex,\n         const __gthread_time_t *__abs_timeout)\n{\n  return __gthread_mutex_timedlock (__mutex, __abs_timeout);\n}\n\n\nstatic'
[#] parse_declaration, is_constructor=False, meet line: 'int\n__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)\n{\n  return __gthread_mutex_unlock (__mutex);\n}\n\nstatic inline int\n__gthread_recursive_mutex_destroy (__gthread_recursive_mut'
[#] parse_declaration, is_constructor=False, meet line: 'int\n__gthread_recursive_mutex_destroy (__gthread_recursive_mutex_t *__mutex)\n{\n  return __gthread_mutex_destroy (__mutex);\n}\n# 849 "/usr/include/x86_64-linux-gnu/c++/7/bits/gthr-default.h" 3\nstatic in'
[#] parse_declaration, is_constructor=False, meet line: 'int\n__gthread_cond_broadcast (__gthread_cond_t *__cond)\n{\n  return __gthrw_pthread_cond_broadcast (__cond);\n}\n\nstatic inline int\n__gthread_cond_signal (__gthread_cond_t *__cond)\n{\n  return __gthrw_pth'
[#] parse_declaration, is_constructor=False, meet line: 'int\n__gthread_cond_signal (__gthread_cond_t *__cond)\n{\n  return __gthrw_pthread_cond_signal (__cond);\n}\n\nstatic inline int\n__gthread_cond_wait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex)\n{\n'
[#] parse_declaration, is_constructor=False, meet line: 'int\n__gthread_cond_wait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex)\n{\n  return __gthrw_pthread_cond_wait (__cond, __mutex);\n}\n\nstatic inline int\n__gthread_cond_timedwait (__gthread_cond_t *'
[#] parse_declaration, is_constructor=False, meet line: 'int\n__gthread_cond_timedwait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex,\n     const __gthread_time_t *__abs_timeout)\n{\n  return __gthrw_pthread_cond_timedwait (__cond, __mutex, __abs_timeou'
[#] parse_declaration, is_constructor=False, meet line: 'int\n__gthread_cond_wait_recursive (__gthread_cond_t *__cond,\n          __gthread_recursive_mutex_t *__mutex)\n{\n  return __gthread_cond_wait (__cond, __mutex);\n}\n\nstatic inline int\n__gthread_cond_destr'
[#] parse_declaration, is_constructor=False, meet line: 'int\n__gthread_cond_destroy (__gthread_cond_t* __cond)\n{\n  return __gthrw_pthread_cond_destroy (__cond);\n}\n# 149 "/usr/include/x86_64-linux-gnu/c++/7/bits/gthr.h" 2 3\n\n\n#pragma GCC visibility pop\n# 36 '
[#] parse_declaration, is_constructor=False, meet line: '_Atomic_word\n  __exchange_and_add(volatile _Atomic_word* __mem, int __val)\n  { return __atomic_fetch_add(__mem, __val, 4); }\n\n  static inline void\n  __atomic_add(volatile _Atomic_word* __mem, int __va'
[#] parse_declaration, is_constructor=False, meet line: 'void\n  __atomic_add(volatile _Atomic_word* __mem, int __val)\n  { __atomic_fetch_add(__mem, __val, 4); }\n# 64 "/usr/include/c++/7/ext/atomicity.h" 3\n  static inline _Atomic_word\n  __exchange_and_add_si'
[#] parse_declaration, is_constructor=False, meet line: '_Atomic_word\n  __exchange_and_add_single(_Atomic_word* __mem, int __val)\n  {\n    _Atomic_word __result = *__mem;\n    *__mem += __val;\n    return __result;\n  }\n\n  static inline void\n  __atomic_add_sing'
[#] parse_declaration, is_constructor=False, meet line: 'void\n  __atomic_add_single(_Atomic_word* __mem, int __val)\n  { *__mem += __val; }\n\n  static inline _Atomic_word\n  __attribute__ ((__unused__))\n  __exchange_and_add_dispatch(_Atomic_word* __mem, int __'
[#] parse_declaration, is_constructor=False, meet line: '_Atomic_word\n  __attribute__ ((__unused__))\n  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)\n  {\n\n    if (__gthread_active_p())\n      return __exchange_and_add(__mem, __val);\n    else\n   '
[#] parse_declaration, is_constructor=False, meet line: 'void\n  __attribute__ ((__unused__))\n  __atomic_add_dispatch(_Atomic_word* __mem, int __val)\n  {\n\n    if (__gthread_active_p())\n      __atomic_add(__mem, __val);\n    else\n      __atomic_add_single(__me'
[#] parse_declaration, is_constructor=False, meet line: 'size_type npos = static_cast<size_type>(-1);\n\n    private:\n\n\n\n\n      typedef const_iterator __const_iterator;\n# 139 "/usr/include/c++/7/bits/basic_string.h" 3\n      struct _Alloc_hider : allocator_typ'
[#] parse_declaration, is_constructor=True, meet line: '_Alloc_hider(pointer __dat, const _Alloc& __a)\n : allocator_type(__a), _M_p(__dat) { }\n\n _Alloc_hider(pointer __dat, _Alloc&& __a = _Alloc())\n : allocator_type(std::move(__a)), _M_p(__dat) { }\n\n\n poin'
[#] parse_declaration, is_constructor=True, meet line: '_Alloc_hider(pointer __dat, _Alloc&& __a = _Alloc())\n : allocator_type(std::move(__a)), _M_p(__dat) { }\n\n\n pointer _M_p;\n      };\n\n      _Alloc_hider _M_dataplus;\n      size_type _M_string_length;\n\n  '
[#] parse_declaration, is_constructor=False, meet line: 'pointer _M_p;\n      };\n\n      _Alloc_hider _M_dataplus;\n      size_type _M_string_length;\n\n      enum { _S_local_capacity = 15 / sizeof(_CharT) };\n\n      union\n      {\n _CharT _M_local_buf[_S_local_ca'
[#] parse_declaration, is_constructor=False, meet line: '_Alloc_hider _M_dataplus;\n      size_type _M_string_length;\n\n      enum { _S_local_capacity = 15 / sizeof(_CharT) };\n\n      union\n      {\n _CharT _M_local_buf[_S_local_capacity + 1];\n size_type _M_all'
[#] parse_declaration, is_constructor=False, meet line: 'size_type _M_string_length;\n\n      enum { _S_local_capacity = 15 / sizeof(_CharT) };\n\n      union\n      {\n _CharT _M_local_buf[_S_local_capacity + 1];\n size_type _M_allocated_capacity;\n      };\n\n     '
[#] parse_declaration, is_constructor=False, meet line: '_CharT _M_local_buf[_S_local_capacity + 1];\n size_type _M_allocated_capacity;\n      };\n\n      void\n      _M_data(pointer __p)\n      { _M_dataplus._M_p = __p; }\n\n      void\n      _M_length(size_type __'
[#] parse_declaration, is_constructor=False, meet line: 'size_type _M_allocated_capacity;\n      };\n\n      void\n      _M_data(pointer __p)\n      { _M_dataplus._M_p = __p; }\n\n      void\n      _M_length(size_type __length)\n      { _M_string_length = __length; '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_data(pointer __p)\n      { _M_dataplus._M_p = __p; }\n\n      void\n      _M_length(size_type __length)\n      { _M_string_length = __length; }\n\n      pointer\n      _M_data() const\n      { re'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_length(size_type __length)\n      { _M_string_length = __length; }\n\n      pointer\n      _M_data() const\n      { return _M_dataplus._M_p; }\n\n      pointer\n      _M_local_data()\n      {\n\n r'
[#] parse_declaration, is_constructor=False, meet line: 'pointer\n      _M_data() const\n      { return _M_dataplus._M_p; }\n\n      pointer\n      _M_local_data()\n      {\n\n return std::pointer_traits<pointer>::pointer_to(*_M_local_buf);\n\n\n\n      }\n\n      const_'
[#] parse_declaration, is_constructor=False, meet line: 'pointer\n      _M_local_data()\n      {\n\n return std::pointer_traits<pointer>::pointer_to(*_M_local_buf);\n\n\n\n      }\n\n      const_pointer\n      _M_local_data() const\n      {\n\n return std::pointer_traits'
[#] parse_declaration, is_constructor=False, meet line: 'const_pointer\n      _M_local_data() const\n      {\n\n return std::pointer_traits<const_pointer>::pointer_to(*_M_local_buf);\n\n\n\n      }\n\n      void\n      _M_capacity(size_type __capacity)\n      { _M_allo'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_capacity(size_type __capacity)\n      { _M_allocated_capacity = __capacity; }\n\n      void\n      _M_set_length(size_type __n)\n      {\n _M_length(__n);\n traits_type::assign(_M_data()[__n], '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_set_length(size_type __n)\n      {\n _M_length(__n);\n traits_type::assign(_M_data()[__n], _CharT());\n      }\n\n      bool\n      _M_is_local() const\n      { return _M_data() == _M_local_data'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      _M_is_local() const\n      { return _M_data() == _M_local_data(); }\n\n\n      pointer\n      _M_create(size_type&, size_type);\n\n      void\n      _M_dispose()\n      {\n if (!_M_is_local())\n   _M_'
[#] parse_declaration, is_constructor=False, meet line: 'pointer\n      _M_create(size_type&, size_type);\n\n      void\n      _M_dispose()\n      {\n if (!_M_is_local())\n   _M_destroy(_M_allocated_capacity);\n      }\n\n      void\n      _M_destroy(size_type __size)'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_dispose()\n      {\n if (!_M_is_local())\n   _M_destroy(_M_allocated_capacity);\n      }\n\n      void\n      _M_destroy(size_type __size) throw()\n      { _Alloc_traits::deallocate(_M_get_alloc'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_destroy(size_type __size) throw()\n      { _Alloc_traits::deallocate(_M_get_allocator(), _M_data(), __size + 1); }\n\n\n\n      template<typename _InIterator>\n        void\n        _M_construc'
[#] parse_declaration, is_constructor=False, meet line: 'void\n        _M_construct_aux(_InIterator __beg, _InIterator __end,\n    std::__false_type)\n {\n          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;\n          _M_construct(__'
[#] parse_declaration, is_constructor=False, meet line: 'void\n        _M_construct_aux(_Integer __beg, _Integer __end, std::__true_type)\n { _M_construct_aux_2(static_cast<size_type>(__beg), __end); }\n\n      void\n      _M_construct_aux_2(size_type __req, _Ch'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_construct_aux_2(size_type __req, _CharT __c)\n      { _M_construct(__req, __c); }\n\n      template<typename _InIterator>\n        void\n        _M_construct(_InIterator __beg, _InIterator __'
[#] parse_declaration, is_constructor=False, meet line: 'void\n        _M_construct(_InIterator __beg, _InIterator __end)\n {\n   typedef typename std::__is_integer<_InIterator>::__type _Integral;\n   _M_construct_aux(__beg, __end, _Integral());\n        }\n\n\n   '
[#] parse_declaration, is_constructor=False, meet line: 'void\n        _M_construct(_InIterator __beg, _InIterator __end,\n       std::input_iterator_tag);\n\n\n\n      template<typename _FwdIterator>\n        void\n        _M_construct(_FwdIterator __beg, _FwdIter'
[#] parse_declaration, is_constructor=False, meet line: 'void\n        _M_construct(_FwdIterator __beg, _FwdIterator __end,\n       std::forward_iterator_tag);\n\n      void\n      _M_construct(size_type __req, _CharT __c);\n\n      allocator_type&\n      _M_get_al'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_construct(size_type __req, _CharT __c);\n\n      allocator_type&\n      _M_get_allocator()\n      { return _M_dataplus; }\n\n      const allocator_type&\n      _M_get_allocator() const\n      { '
[#] parse_declaration, is_constructor=False, meet line: 'allocator_type&\n      _M_get_allocator()\n      { return _M_dataplus; }\n\n      const allocator_type&\n      _M_get_allocator() const\n      { return _M_dataplus; }\n\n    private:\n# 298 "/usr/include/c++/7'
[#] parse_declaration, is_constructor=False, meet line: 'allocator_type&\n      _M_get_allocator() const\n      { return _M_dataplus; }\n\n    private:\n# 298 "/usr/include/c++/7/bits/basic_string.h" 3\n      size_type\n      _M_check(size_type __pos, const char* '
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      _M_check(size_type __pos, const char* __s) const\n      {\n if (__pos > this->size())\n   __throw_out_of_range_fmt(("%s: __pos (which is %zu) > " "this->size() (which is %zu)")\n          '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_check_length(size_type __n1, size_type __n2, const char* __s) const\n      {\n if (this->max_size() - (this->size() - __n1) < __n2)\n   __throw_length_error((__s));\n      }\n\n\n\n      size_ty'
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      _M_limit(size_type __pos, size_type __off) const noexcept\n      {\n const bool __testoff = __off < this->size() - __pos;\n return __testoff ? __off : this->size() - __pos;\n      }\n\n\n    '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      _M_disjunct(const _CharT* __s) const noexcept\n      {\n return (less<const _CharT*>()(__s, _M_data())\n  || less<const _CharT*>()(_M_data() + this->size(), __s));\n      }\n\n\n\n      static void'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _S_copy(_CharT* __d, const _CharT* __s, size_type __n)\n      {\n if (__n == 1)\n   traits_type::assign(*__d, *__s);\n else\n   traits_type::copy(__d, __s, __n);\n      }\n\n      static void\n     '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _S_move(_CharT* __d, const _CharT* __s, size_type __n)\n      {\n if (__n == 1)\n   traits_type::assign(*__d, *__s);\n else\n   traits_type::move(__d, __s, __n);\n      }\n\n      static void\n     '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _S_assign(_CharT* __d, size_type __n, _CharT __c)\n      {\n if (__n == 1)\n   traits_type::assign(*__d, __c);\n else\n   traits_type::assign(__d, __n, __c);\n      }\n\n\n\n      template<class _Ite'
[#] parse_declaration, is_constructor=False, meet line: 'void\n        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)\n        {\n   for (; __k1 != __k2; ++__k1, (void)++__p)\n     traits_type::assign(*__p, *__k1);\n }\n\n      static void\n      _S_cop'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2) noexcept\n      { _S_copy_chars(__p, __k1.base(), __k2.base()); }\n\n      static void\n      _S_copy_chars(_CharT* __p, const_iterator '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)\n      noexcept\n      { _S_copy_chars(__p, __k1.base(), __k2.base()); }\n\n      static void\n      _S_copy_chars(_CharT* __'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2) noexcept\n      { _S_copy(__p, __k1, __k2 - __k1); }\n\n      static void\n      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _Cha'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)\n      noexcept\n      { _S_copy(__p, __k1, __k2 - __k1); }\n\n      static int\n      _S_compare(size_type __n1, size_type __n'
[#] parse_declaration, is_constructor=False, meet line: 'int\n      _S_compare(size_type __n1, size_type __n2) noexcept\n      {\n const difference_type __d = difference_type(__n1 - __n2);\n\n if (__d > __gnu_cxx::__numeric_traits<int>::__max)\n   return __gnu_cx'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_assign(const basic_string&);\n\n      void\n      _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,\n  size_type __len2);\n\n      void\n      _M_erase(size_type __pos, size_type '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,\n  size_type __len2);\n\n      void\n      _M_erase(size_type __pos, size_type __n);\n\n    public:\n\n\n\n\n\n\n\n      basic_string()\n   '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_erase(size_type __pos, size_type __n);\n\n    public:\n\n\n\n\n\n\n\n      basic_string()\n      noexcept(is_nothrow_default_constructible<_Alloc>::value)\n      : _M_dataplus(_M_local_data())\n     '
[#] parse_declaration, is_constructor=True, meet line: 'basic_string()\n      noexcept(is_nothrow_default_constructible<_Alloc>::value)\n      : _M_dataplus(_M_local_data())\n      { _M_set_length(0); }\n\n\n\n\n      explicit\n      basic_string(const _Alloc& __a)'
[#] parse_declaration, is_constructor=True, meet line: 'basic_string(const _Alloc& __a) noexcept\n      : _M_dataplus(_M_local_data(), __a)\n      { _M_set_length(0); }\n\n\n\n\n\n      basic_string(const basic_string& __str)\n      : _M_dataplus(_M_local_data(),\n '
[#] parse_declaration, is_constructor=True, meet line: 'basic_string(const basic_string& __str)\n      : _M_dataplus(_M_local_data(),\n      _Alloc_traits::_S_select_on_copy(__str._M_get_allocator()))\n      { _M_construct(__str._M_data(), __str._M_data() + _'
[#] parse_declaration, is_constructor=True, meet line: 'basic_string(const basic_string& __str, size_type __pos,\n     const _Alloc& __a = _Alloc())\n      : _M_dataplus(_M_local_data(), __a)\n      {\n const _CharT* __start = __str._M_data()\n   + __str._M_che'
[#] parse_declaration, is_constructor=True, meet line: 'basic_string(const basic_string& __str, size_type __pos,\n     size_type __n)\n      : _M_dataplus(_M_local_data())\n      {\n const _CharT* __start = __str._M_data()\n   + __str._M_check(__pos, "basic_str'
[#] parse_declaration, is_constructor=True, meet line: 'basic_string(const basic_string& __str, size_type __pos,\n     size_type __n, const _Alloc& __a)\n      : _M_dataplus(_M_local_data(), __a)\n      {\n const _CharT* __start\n   = __str._M_data() + __str._M'
[#] parse_declaration, is_constructor=True, meet line: 'basic_string(const _CharT* __s, size_type __n,\n     const _Alloc& __a = _Alloc())\n      : _M_dataplus(_M_local_data(), __a)\n      { _M_construct(__s, __s + __n); }\n\n\n\n\n\n\n      basic_string(const _Char'
[#] parse_declaration, is_constructor=True, meet line: 'basic_string(const _CharT* __s, const _Alloc& __a = _Alloc())\n      : _M_dataplus(_M_local_data(), __a)\n      { _M_construct(__s, __s ? __s + traits_type::length(__s) : __s+npos); }\n\n\n\n\n\n\n\n      basic'
[#] parse_declaration, is_constructor=True, meet line: 'basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc())\n      : _M_dataplus(_M_local_data(), __a)\n      { _M_construct(__n, __c); }\n# 531 "/usr/include/c++/7/bits/basic_string.h" 3\n     '
[#] parse_declaration, is_constructor=True, meet line: 'basic_string(basic_string&& __str) noexcept\n      : _M_dataplus(_M_local_data(), std::move(__str._M_get_allocator()))\n      {\n if (__str._M_is_local())\n   {\n     traits_type::copy(_M_local_buf, __str.'
[#] parse_declaration, is_constructor=True, meet line: 'basic_string(initializer_list<_CharT> __l, const _Alloc& __a = _Alloc())\n      : _M_dataplus(_M_local_data(), __a)\n      { _M_construct(__l.begin(), __l.end()); }\n\n      basic_string(const basic_strin'
[#] parse_declaration, is_constructor=True, meet line: 'basic_string(const basic_string& __str, const _Alloc& __a)\n      : _M_dataplus(_M_local_data(), __a)\n      { _M_construct(__str.begin(), __str.end()); }\n\n      basic_string(basic_string&& __str, const'
[#] parse_declaration, is_constructor=True, meet line: 'basic_string(basic_string&& __str, const _Alloc& __a)\n      noexcept(_Alloc_traits::_S_always_equal())\n      : _M_dataplus(_M_local_data(), __a)\n      {\n if (__str._M_is_local())\n   {\n     traits_type'
[#] parse_declaration, is_constructor=True, meet line: 'basic_string(_InputIterator __beg, _InputIterator __end,\n       const _Alloc& __a = _Alloc())\n : _M_dataplus(_M_local_data(), __a)\n { _M_construct(__beg, __end); }\n# 646 "/usr/include/c++/7/bits/basic'
[#] parse_declaration, is_constructor=True, meet line: 'basic_string()\n      { _M_dispose(); }\n\n\n\n\n\n      basic_string&\n      operator=(const basic_string& __str)\n      {\n\n if (_Alloc_traits::_S_propagate_on_copy_assign())\n   {\n     if (!_Alloc_traits::_S_'
[#] parse_declaration, is_constructor=True, meet line: 'basic_string&\n      operator=(const basic_string& __str)\n      {\n\n if (_Alloc_traits::_S_propagate_on_copy_assign())\n   {\n     if (!_Alloc_traits::_S_always_equal() && !_M_is_local()\n  && _M_get_alloc'
[#] parse_declaration, is_constructor=True, meet line: 'basic_string&\n      operator=(const _CharT* __s)\n      { return this->assign(__s); }\n# 703 "/usr/include/c++/7/bits/basic_string.h" 3\n      basic_string&\n      operator=(_CharT __c)\n      {\n this->ass'
[#] parse_declaration, is_constructor=True, meet line: 'basic_string&\n      operator=(_CharT __c)\n      {\n this->assign(1, __c);\n return *this;\n      }\n# 721 "/usr/include/c++/7/bits/basic_string.h" 3\n      basic_string&\n      operator=(basic_string&& __st'
[#] parse_declaration, is_constructor=True, meet line: 'basic_string&\n      operator=(basic_string&& __str)\n      noexcept(_Alloc_traits::_S_nothrow_move())\n      {\n if (!_M_is_local() && _Alloc_traits::_S_propagate_on_move_assign()\n     && !_Alloc_traits:'
[#] parse_declaration, is_constructor=True, meet line: 'basic_string&\n      operator=(initializer_list<_CharT> __l)\n      {\n this->assign(__l.begin(), __l.size());\n return *this;\n      }\n# 815 "/usr/include/c++/7/bits/basic_string.h" 3\n      iterator\n     '
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      begin() noexcept\n      { return iterator(_M_data()); }\n\n\n\n\n\n      const_iterator\n      begin() const noexcept\n      { return const_iterator(_M_data()); }\n\n\n\n\n\n      iterator\n      end()'
[#] parse_declaration, is_constructor=False, meet line: 'const_iterator\n      begin() const noexcept\n      { return const_iterator(_M_data()); }\n\n\n\n\n\n      iterator\n      end() noexcept\n      { return iterator(_M_data() + this->size()); }\n\n\n\n\n\n      const_i'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      end() noexcept\n      { return iterator(_M_data() + this->size()); }\n\n\n\n\n\n      const_iterator\n      end() const noexcept\n      { return const_iterator(_M_data() + this->size()); }\n\n\n\n\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'const_iterator\n      end() const noexcept\n      { return const_iterator(_M_data() + this->size()); }\n\n\n\n\n\n\n      reverse_iterator\n      rbegin() noexcept\n      { return reverse_iterator(this->end()); '
[#] parse_declaration, is_constructor=False, meet line: 'reverse_iterator\n      rbegin() noexcept\n      { return reverse_iterator(this->end()); }\n\n\n\n\n\n\n      const_reverse_iterator\n      rbegin() const noexcept\n      { return const_reverse_iterator(this->en'
[#] parse_declaration, is_constructor=False, meet line: 'const_reverse_iterator\n      rbegin() const noexcept\n      { return const_reverse_iterator(this->end()); }\n\n\n\n\n\n\n      reverse_iterator\n      rend() noexcept\n      { return reverse_iterator(this->begi'
[#] parse_declaration, is_constructor=False, meet line: 'reverse_iterator\n      rend() noexcept\n      { return reverse_iterator(this->begin()); }\n\n\n\n\n\n\n      const_reverse_iterator\n      rend() const noexcept\n      { return const_reverse_iterator(this->begi'
[#] parse_declaration, is_constructor=False, meet line: 'const_reverse_iterator\n      rend() const noexcept\n      { return const_reverse_iterator(this->begin()); }\n\n\n\n\n\n\n      const_iterator\n      cbegin() const noexcept\n      { return const_iterator(this->'
[#] parse_declaration, is_constructor=False, meet line: 'const_iterator\n      cbegin() const noexcept\n      { return const_iterator(this->_M_data()); }\n\n\n\n\n\n      const_iterator\n      cend() const noexcept\n      { return const_iterator(this->_M_data() + thi'
[#] parse_declaration, is_constructor=False, meet line: 'const_iterator\n      cend() const noexcept\n      { return const_iterator(this->_M_data() + this->size()); }\n\n\n\n\n\n\n      const_reverse_iterator\n      crbegin() const noexcept\n      { return const_rever'
[#] parse_declaration, is_constructor=False, meet line: 'const_reverse_iterator\n      crbegin() const noexcept\n      { return const_reverse_iterator(this->end()); }\n\n\n\n\n\n\n      const_reverse_iterator\n      crend() const noexcept\n      { return const_reverse'
[#] parse_declaration, is_constructor=False, meet line: 'const_reverse_iterator\n      crend() const noexcept\n      { return const_reverse_iterator(this->begin()); }\n\n\n    public:\n\n\n\n      size_type\n      size() const noexcept\n      { return _M_string_length'
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      size() const noexcept\n      { return _M_string_length; }\n\n\n\n      size_type\n      length() const noexcept\n      { return _M_string_length; }\n\n\n      size_type\n      max_size() const no'
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      length() const noexcept\n      { return _M_string_length; }\n\n\n      size_type\n      max_size() const noexcept\n      { return (_Alloc_traits::max_size(_M_get_allocator()) - 1) / 2; }\n# 9'
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      max_size() const noexcept\n      { return (_Alloc_traits::max_size(_M_get_allocator()) - 1) / 2; }\n# 944 "/usr/include/c++/7/bits/basic_string.h" 3\n      void\n      resize(size_type __n'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      resize(size_type __n, _CharT __c);\n# 957 "/usr/include/c++/7/bits/basic_string.h" 3\n      void\n      resize(size_type __n)\n      { this->resize(__n, _CharT()); }\n\n\n\n      void\n      shrink_'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      resize(size_type __n)\n      { this->resize(__n, _CharT()); }\n\n\n\n      void\n      shrink_to_fit() noexcept\n      {\n\n if (capacity() > size())\n   {\n     try\n       { reserve(0); }\n     catch('
[#] parse_declaration, is_constructor=False, meet line: 'void\n      shrink_to_fit() noexcept\n      {\n\n if (capacity() > size())\n   {\n     try\n       { reserve(0); }\n     catch(...)\n       { }\n   }\n\n      }\n\n\n\n\n\n\n      size_type\n      capacity() const noexce'
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      capacity() const noexcept\n      {\n return _M_is_local() ? size_type(_S_local_capacity)\n                      : _M_allocated_capacity;\n      }\n# 1006 "/usr/include/c++/7/bits/basic_stri'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      reserve(size_type __res_arg = 0);\n\n\n\n\n      void\n      clear() noexcept\n      { _M_set_length(0); }\n\n\n\n\n\n      bool\n      empty() const noexcept\n      { return this->size() == 0; }\n# 1035 "'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      clear() noexcept\n      { _M_set_length(0); }\n\n\n\n\n\n      bool\n      empty() const noexcept\n      { return this->size() == 0; }\n# 1035 "/usr/include/c++/7/bits/basic_string.h" 3\n      const_r'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      empty() const noexcept\n      { return this->size() == 0; }\n# 1035 "/usr/include/c++/7/bits/basic_string.h" 3\n      const_reference\n      operator[] (size_type __pos) const noexcept\n      {\n'
[#] parse_declaration, is_constructor=False, meet line: 'const_reference\n      operator[] (size_type __pos) const noexcept\n      {\n ;\n return _M_data()[__pos];\n      }\n# 1052 "/usr/include/c++/7/bits/basic_string.h" 3\n      reference\n      operator[](size_t'
[#] parse_declaration, is_constructor=False, meet line: 'reference\n      operator[](size_type __pos)\n      {\n\n\n ;\n\n ;\n return _M_data()[__pos];\n      }\n# 1073 "/usr/include/c++/7/bits/basic_string.h" 3\n      const_reference\n      at(size_type __n) const\n   '
[#] parse_declaration, is_constructor=False, meet line: 'const_reference\n      at(size_type __n) const\n      {\n if (__n >= this->size())\n   __throw_out_of_range_fmt(("basic_string::at: __n " "(which is %zu) >= this->size() " "(which is %zu)")\n\n             '
[#] parse_declaration, is_constructor=False, meet line: 'reference\n      at(size_type __n)\n      {\n if (__n >= size())\n   __throw_out_of_range_fmt(("basic_string::at: __n " "(which is %zu) >= this->size() " "(which is %zu)")\n\n                            ,\n '
[#] parse_declaration, is_constructor=False, meet line: 'reference\n      front() noexcept\n      {\n ;\n return operator[](0);\n      }\n\n\n\n\n\n      const_reference\n      front() const noexcept\n      {\n ;\n return operator[](0);\n      }\n\n\n\n\n\n      reference\n      '
[#] parse_declaration, is_constructor=False, meet line: 'const_reference\n      front() const noexcept\n      {\n ;\n return operator[](0);\n      }\n\n\n\n\n\n      reference\n      back() noexcept\n      {\n ;\n return operator[](this->size() - 1);\n      }\n\n\n\n\n\n      co'
[#] parse_declaration, is_constructor=False, meet line: 'reference\n      back() noexcept\n      {\n ;\n return operator[](this->size() - 1);\n      }\n\n\n\n\n\n      const_reference\n      back() const noexcept\n      {\n ;\n return operator[](this->size() - 1);\n      }'
[#] parse_declaration, is_constructor=False, meet line: 'const_reference\n      back() const noexcept\n      {\n ;\n return operator[](this->size() - 1);\n      }\n# 1157 "/usr/include/c++/7/bits/basic_string.h" 3\n      basic_string&\n      operator+=(const basic_'
[#] parse_declaration, is_constructor=True, meet line: 'basic_string&\n      operator+=(const basic_string& __str)\n      { return this->append(__str); }\n\n\n\n\n\n\n      basic_string&\n      operator+=(const _CharT* __s)\n      { return this->append(__s); }\n\n\n\n\n\n\n'
[#] parse_declaration, is_constructor=True, meet line: 'basic_string&\n      operator+=(const _CharT* __s)\n      { return this->append(__s); }\n\n\n\n\n\n\n      basic_string&\n      operator+=(_CharT __c)\n      {\n this->push_back(__c);\n return *this;\n      }\n\n\n\n\n\n'
[#] parse_declaration, is_constructor=True, meet line: 'basic_string&\n      operator+=(_CharT __c)\n      {\n this->push_back(__c);\n return *this;\n      }\n\n\n\n\n\n\n\n      basic_string&\n      operator+=(initializer_list<_CharT> __l)\n      { return this->append(_'
[#] parse_declaration, is_constructor=True, meet line: 'basic_string&\n      operator+=(initializer_list<_CharT> __l)\n      { return this->append(__l.begin(), __l.size()); }\n# 1210 "/usr/include/c++/7/bits/basic_string.h" 3\n      basic_string&\n      append('
[#] parse_declaration, is_constructor=True, meet line: 'basic_string&\n      append(const basic_string& __str)\n      { return _M_append(__str._M_data(), __str.size()); }\n# 1227 "/usr/include/c++/7/bits/basic_string.h" 3\n      basic_string&\n      append(cons'
[#] parse_declaration, is_constructor=True, meet line: 'basic_string&\n      append(const basic_string& __str, size_type __pos, size_type __n = npos)\n      { return _M_append(__str._M_data()\n    + __str._M_check(__pos, "basic_string::append"),\n    __str._M_'
[#] parse_declaration, is_constructor=True, meet line: 'basic_string&\n      append(const _CharT* __s, size_type __n)\n      {\n ;\n _M_check_length(size_type(0), __n, "basic_string::append");\n return _M_append(__s, __n);\n      }\n\n\n\n\n\n\n      basic_string&\n    '
[#] parse_declaration, is_constructor=True, meet line: 'basic_string&\n      append(const _CharT* __s)\n      {\n ;\n const size_type __n = traits_type::length(__s);\n _M_check_length(size_type(0), __n, "basic_string::append");\n return _M_append(__s, __n);\n    '
[#] parse_declaration, is_constructor=True, meet line: 'basic_string&\n      append(size_type __n, _CharT __c)\n      { return _M_replace_aux(this->size(), size_type(0), __n, __c); }\n\n\n\n\n\n\n\n      basic_string&\n      append(initializer_list<_CharT> __l)\n     '
[#] parse_declaration, is_constructor=True, meet line: 'basic_string&\n      append(initializer_list<_CharT> __l)\n      { return this->append(__l.begin(), __l.size()); }\n# 1293 "/usr/include/c++/7/bits/basic_string.h" 3\n      template<class _InputIterator,\n'
[#] parse_declaration, is_constructor=True, meet line: 'basic_string&\n        append(_InputIterator __first, _InputIterator __last)\n        { return this->replace(end(), end(), __first, __last); }\n# 1338 "/usr/include/c++/7/bits/basic_string.h" 3\n      voi'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      push_back(_CharT __c)\n      {\n const size_type __size = this->size();\n if (__size + 1 > this->capacity())\n   this->_M_mutate(__size, size_type(0), 0, size_type(1));\n traits_type::assign(thi'
[#] parse_declaration, is_constructor=True, meet line: 'basic_string&\n      assign(const basic_string& __str)\n      {\n this->_M_assign(__str);\n return *this;\n      }\n# 1369 "/usr/include/c++/7/bits/basic_string.h" 3\n      basic_string&\n      assign(basic_s'
[#] parse_declaration, is_constructor=True, meet line: 'basic_string&\n      assign(basic_string&& __str)\n      noexcept(_Alloc_traits::_S_nothrow_move())\n      {\n\n\n return *this = std::move(__str);\n      }\n# 1392 "/usr/include/c++/7/bits/basic_string.h" 3\n'
[#] parse_declaration, is_constructor=True, meet line: 'basic_string&\n      assign(const basic_string& __str, size_type __pos, size_type __n = npos)\n      { return _M_replace(size_type(0), this->size(), __str._M_data()\n     + __str._M_check(__pos, "basic_s'
[#] parse_declaration, is_constructor=True, meet line: 'basic_string&\n      assign(const _CharT* __s, size_type __n)\n      {\n ;\n return _M_replace(size_type(0), this->size(), __s, __n);\n      }\n# 1424 "/usr/include/c++/7/bits/basic_string.h" 3\n      basic_'
[#] parse_declaration, is_constructor=True, meet line: 'basic_string&\n      assign(const _CharT* __s)\n      {\n ;\n return _M_replace(size_type(0), this->size(), __s,\n     traits_type::length(__s));\n      }\n# 1441 "/usr/include/c++/7/bits/basic_string.h" 3\n '
[#] parse_declaration, is_constructor=True, meet line: 'basic_string&\n      assign(size_type __n, _CharT __c)\n      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }\n# 1454 "/usr/include/c++/7/bits/basic_string.h" 3\n      template<class _Inp'
[#] parse_declaration, is_constructor=True, meet line: 'basic_string&\n        assign(_InputIterator __first, _InputIterator __last)\n        { return this->replace(begin(), end(), __first, __last); }\n\n\n\n\n\n\n\n      basic_string&\n      assign(initializer_list<'
[#] parse_declaration, is_constructor=True, meet line: 'basic_string&\n      assign(initializer_list<_CharT> __l)\n      { return this->assign(__l.begin(), __l.size()); }\n# 1522 "/usr/include/c++/7/bits/basic_string.h" 3\n      iterator\n      insert(const_ite'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      insert(const_iterator __p, size_type __n, _CharT __c)\n      {\n ;\n const size_type __pos = __p - begin();\n this->replace(__p, __p, __n, __c);\n return iterator(this->_M_data() + __pos);\n '
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n        insert(const_iterator __p, _InputIterator __beg, _InputIterator __end)\n        {\n   ;\n   const size_type __pos = __p - begin();\n   this->replace(__p, __p, __beg, __end);\n   return ite'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      insert(iterator __p, initializer_list<_CharT> __l)\n      {\n ;\n this->insert(__p - begin(), __l.begin(), __l.size());\n      }\n# 1620 "/usr/include/c++/7/bits/basic_string.h" 3\n      basic_st'
[#] parse_declaration, is_constructor=True, meet line: 'basic_string&\n      insert(size_type __pos1, const basic_string& __str)\n      { return this->replace(__pos1, size_type(0),\n        __str._M_data(), __str.size()); }\n# 1643 "/usr/include/c++/7/bits/bas'
[#] parse_declaration, is_constructor=True, meet line: 'basic_string&\n      insert(size_type __pos1, const basic_string& __str,\n      size_type __pos2, size_type __n = npos)\n      { return this->replace(__pos1, size_type(0), __str._M_data()\n        + __str'
[#] parse_declaration, is_constructor=True, meet line: 'basic_string&\n      insert(size_type __pos, const _CharT* __s, size_type __n)\n      { return this->replace(__pos, size_type(0), __s, __n); }\n# 1685 "/usr/include/c++/7/bits/basic_string.h" 3\n      bas'
[#] parse_declaration, is_constructor=True, meet line: 'basic_string&\n      insert(size_type __pos, const _CharT* __s)\n      {\n ;\n return this->replace(__pos, size_type(0), __s,\n        traits_type::length(__s));\n      }\n# 1709 "/usr/include/c++/7/bits/bas'
[#] parse_declaration, is_constructor=True, meet line: 'basic_string&\n      insert(size_type __pos, size_type __n, _CharT __c)\n      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),\n         size_type(0), __n, __c); }\n# 1727 "/usr/include/c'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      insert(__const_iterator __p, _CharT __c)\n      {\n ;\n const size_type __pos = __p - begin();\n _M_replace_aux(__pos, size_type(0), size_type(1), __c);\n return iterator(_M_data() + __pos);'
[#] parse_declaration, is_constructor=True, meet line: 'basic_string&\n      erase(size_type __pos = 0, size_type __n = npos)\n      {\n _M_check(__pos, "basic_string::erase");\n if (__n == npos)\n   this->_M_set_length(__pos);\n else if (__n != 0)\n   this->_M_e'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      erase(__const_iterator __position)\n      {\n\n                           ;\n const size_type __pos = __position - begin();\n this->_M_erase(__pos, size_type(1));\n return iterator(_M_data() '
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      erase(__const_iterator __first, __const_iterator __last)\n      {\n\n                        ;\n        const size_type __pos = __first - begin();\n if (__last == end())\n   this->_M_set_leng'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      pop_back() noexcept\n      {\n ;\n _M_erase(size() - 1, 1);\n      }\n# 1869 "/usr/include/c++/7/bits/basic_string.h" 3\n      basic_string&\n      replace(size_type __pos, size_type __n, const ba'
[#] parse_declaration, is_constructor=True, meet line: 'basic_string&\n      replace(size_type __pos, size_type __n, const basic_string& __str)\n      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }\n# 1891 "/usr/include/c++/7/bits/basic_'
[#] parse_declaration, is_constructor=True, meet line: 'basic_string&\n      replace(size_type __pos1, size_type __n1, const basic_string& __str,\n       size_type __pos2, size_type __n2 = npos)\n      { return this->replace(__pos1, __n1, __str._M_data()\n    '
[#] parse_declaration, is_constructor=True, meet line: 'basic_string&\n      replace(size_type __pos, size_type __n1, const _CharT* __s,\n       size_type __n2)\n      {\n ;\n return _M_replace(_M_check(__pos, "basic_string::replace"),\n     _M_limit(__pos, __n1'
[#] parse_declaration, is_constructor=True, meet line: 'basic_string&\n      replace(size_type __pos, size_type __n1, const _CharT* __s)\n      {\n ;\n return this->replace(__pos, __n1, __s, traits_type::length(__s));\n      }\n# 1965 "/usr/include/c++/7/bits/ba'
[#] parse_declaration, is_constructor=True, meet line: 'basic_string&\n      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)\n      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),\n         _M_limit(__pos, __n1), __n2, _'
[#] parse_declaration, is_constructor=True, meet line: 'basic_string&\n      replace(__const_iterator __i1, __const_iterator __i2,\n       const basic_string& __str)\n      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }\n# 2003 "/usr/incl'
[#] parse_declaration, is_constructor=True, meet line: 'basic_string&\n      replace(__const_iterator __i1, __const_iterator __i2,\n       const _CharT* __s, size_type __n)\n      {\n\n                      ;\n return this->replace(__i1 - begin(), __i2 - __i1, _'
[#] parse_declaration, is_constructor=True, meet line: 'basic_string&\n      replace(__const_iterator __i1, __const_iterator __i2, const _CharT* __s)\n      {\n ;\n return this->replace(__i1, __i2, __s, traits_type::length(__s));\n      }\n# 2046 "/usr/include/c'
[#] parse_declaration, is_constructor=True, meet line: 'basic_string&\n      replace(__const_iterator __i1, __const_iterator __i2, size_type __n,\n       _CharT __c)\n      {\n\n                      ;\n return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __'
[#] parse_declaration, is_constructor=True, meet line: 'basic_string&\n        replace(const_iterator __i1, const_iterator __i2,\n  _InputIterator __k1, _InputIterator __k2)\n        {\n  \n                        ;\n   ;\n   return this->_M_replace_dispatch(__i1'
[#] parse_declaration, is_constructor=True, meet line: 'basic_string&\n      replace(__const_iterator __i1, __const_iterator __i2,\n       _CharT* __k1, _CharT* __k2)\n      {\n\n                      ;\n ;\n return this->replace(__i1 - begin(), __i2 - __i1,\n    '
[#] parse_declaration, is_constructor=True, meet line: 'basic_string&\n      replace(__const_iterator __i1, __const_iterator __i2,\n       const _CharT* __k1, const _CharT* __k2)\n      {\n\n                      ;\n ;\n return this->replace(__i1 - begin(), __i2 '
[#] parse_declaration, is_constructor=True, meet line: 'basic_string&\n      replace(__const_iterator __i1, __const_iterator __i2,\n       iterator __k1, iterator __k2)\n      {\n\n                      ;\n ;\n return this->replace(__i1 - begin(), __i2 - __i1,\n  '
[#] parse_declaration, is_constructor=True, meet line: 'basic_string&\n      replace(__const_iterator __i1, __const_iterator __i2,\n       const_iterator __k1, const_iterator __k2)\n      {\n\n                      ;\n ;\n return this->replace(__i1 - begin(), __i'
[#] parse_declaration, is_constructor=True, meet line: 'basic_string& replace(const_iterator __i1, const_iterator __i2,\n       initializer_list<_CharT> __l)\n      { return this->replace(__i1, __i2, __l.begin(), __l.size()); }\n# 2221 "/usr/include/c++/7/bit'
[#] parse_declaration, is_constructor=True, meet line: 'basic_string&\n _M_replace_dispatch(const_iterator __i1, const_iterator __i2,\n       _Integer __n, _Integer __val, __true_type)\n        { return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __val);'
[#] parse_declaration, is_constructor=True, meet line: 'basic_string&\n _M_replace_dispatch(const_iterator __i1, const_iterator __i2,\n       _InputIterator __k1, _InputIterator __k2,\n       __false_type);\n\n      basic_string&\n      _M_replace_aux(size_type '
[#] parse_declaration, is_constructor=True, meet line: 'basic_string&\n      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,\n       _CharT __c);\n\n      basic_string&\n      _M_replace(size_type __pos, size_type __len1, const _CharT* __s,\n   '
[#] parse_declaration, is_constructor=True, meet line: 'basic_string&\n      _M_replace(size_type __pos, size_type __len1, const _CharT* __s,\n   const size_type __len2);\n\n      basic_string&\n      _M_append(const _CharT* __s, size_type __n);\n\n    public:\n# '
[#] parse_declaration, is_constructor=True, meet line: 'basic_string&\n      _M_append(const _CharT* __s, size_type __n);\n\n    public:\n# 2259 "/usr/include/c++/7/bits/basic_string.h" 3\n      size_type\n      copy(_CharT* __s, size_type __n, size_type __pos ='
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;\n# 2269 "/usr/include/c++/7/bits/basic_string.h" 3\n      void\n      swap(basic_string& __s) noexcept;\n# 2279 "/usr/include/c'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      swap(basic_string& __s) noexcept;\n# 2279 "/usr/include/c++/7/bits/basic_string.h" 3\n      const _CharT*\n      c_str() const noexcept\n      { return _M_data(); }\n# 2291 "/usr/include/c++/7/b'
[#] parse_declaration, is_constructor=False, meet line: '_CharT*\n      c_str() const noexcept\n      { return _M_data(); }\n# 2291 "/usr/include/c++/7/bits/basic_string.h" 3\n      const _CharT*\n      data() const noexcept\n      { return _M_data(); }\n# 2310 "/'
[#] parse_declaration, is_constructor=False, meet line: '_CharT*\n      data() const noexcept\n      { return _M_data(); }\n# 2310 "/usr/include/c++/7/bits/basic_string.h" 3\n      allocator_type\n      get_allocator() const noexcept\n      { return _M_get_alloca'
[#] parse_declaration, is_constructor=False, meet line: 'allocator_type\n      get_allocator() const noexcept\n      { return _M_get_allocator(); }\n# 2326 "/usr/include/c++/7/bits/basic_string.h" 3\n      size_type\n      find(const _CharT* __s, size_type __pos'
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      find(const _CharT* __s, size_type __pos, size_type __n) const\n      noexcept;\n# 2340 "/usr/include/c++/7/bits/basic_string.h" 3\n      size_type\n      find(const basic_string& __str, si'
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      find(const basic_string& __str, size_type __pos = 0) const\n      noexcept\n      { return this->find(__str.data(), __pos, __str.size()); }\n# 2372 "/usr/include/c++/7/bits/basic_string.h'
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      find(const _CharT* __s, size_type __pos = 0) const noexcept\n      {\n ;\n return this->find(__s, __pos, traits_type::length(__s));\n      }\n# 2389 "/usr/include/c++/7/bits/basic_string.h"'
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      find(_CharT __c, size_type __pos = 0) const noexcept;\n# 2402 "/usr/include/c++/7/bits/basic_string.h" 3\n      size_type\n      rfind(const basic_string& __str, size_type __pos = npos) c'
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      rfind(const basic_string& __str, size_type __pos = npos) const\n      noexcept\n      { return this->rfind(__str.data(), __pos, __str.size()); }\n# 2436 "/usr/include/c++/7/bits/basic_str'
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      rfind(const _CharT* __s, size_type __pos, size_type __n) const\n      noexcept;\n# 2450 "/usr/include/c++/7/bits/basic_string.h" 3\n      size_type\n      rfind(const _CharT* __s, size_typ'
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      rfind(const _CharT* __s, size_type __pos = npos) const\n      {\n ;\n return this->rfind(__s, __pos, traits_type::length(__s));\n      }\n# 2467 "/usr/include/c++/7/bits/basic_string.h" 3\n '
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      rfind(_CharT __c, size_type __pos = npos) const noexcept;\n# 2481 "/usr/include/c++/7/bits/basic_string.h" 3\n      size_type\n      find_first_of(const basic_string& __str, size_type __p'
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      find_first_of(const basic_string& __str, size_type __pos = 0) const\n      noexcept\n      { return this->find_first_of(__str.data(), __pos, __str.size()); }\n# 2516 "/usr/include/c++/7/b'
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const\n      noexcept;\n# 2530 "/usr/include/c++/7/bits/basic_string.h" 3\n      size_type\n      find_first_of(const _Char'
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      find_first_of(const _CharT* __s, size_type __pos = 0) const\n      noexcept\n      {\n ;\n return this->find_first_of(__s, __pos, traits_type::length(__s));\n      }\n# 2550 "/usr/include/c+'
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      find_first_of(_CharT __c, size_type __pos = 0) const noexcept\n      { return this->find(__c, __pos); }\n# 2565 "/usr/include/c++/7/bits/basic_string.h" 3\n      size_type\n      find_last'
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      find_last_of(const basic_string& __str, size_type __pos = npos) const\n      noexcept\n      { return this->find_last_of(__str.data(), __pos, __str.size()); }\n# 2600 "/usr/include/c++/7/'
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const\n      noexcept;\n# 2614 "/usr/include/c++/7/bits/basic_string.h" 3\n      size_type\n      find_last_of(const _CharT*'
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      find_last_of(const _CharT* __s, size_type __pos = npos) const\n      noexcept\n      {\n ;\n return this->find_last_of(__s, __pos, traits_type::length(__s));\n      }\n# 2634 "/usr/include/c'
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      find_last_of(_CharT __c, size_type __pos = npos) const noexcept\n      { return this->rfind(__c, __pos); }\n# 2648 "/usr/include/c++/7/bits/basic_string.h" 3\n      size_type\n      find_f'
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      find_first_not_of(const basic_string& __str, size_type __pos = 0) const\n      noexcept\n      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }\n# 2683 "/usr/include'
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      find_first_not_of(const _CharT* __s, size_type __pos,\n   size_type __n) const noexcept;\n# 2697 "/usr/include/c++/7/bits/basic_string.h" 3\n      size_type\n      find_first_not_of(const '
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      find_first_not_of(const _CharT* __s, size_type __pos = 0) const\n      noexcept\n      {\n ;\n return this->find_first_not_of(__s, __pos, traits_type::length(__s));\n      }\n# 2715 "/usr/in'
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      find_first_not_of(_CharT __c, size_type __pos = 0) const\n      noexcept;\n# 2730 "/usr/include/c++/7/bits/basic_string.h" 3\n      size_type\n      find_last_not_of(const basic_string& __'
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      find_last_not_of(const basic_string& __str, size_type __pos = npos) const\n      noexcept\n      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }\n# 2765 "/usr/includ'
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      find_last_not_of(const _CharT* __s, size_type __pos,\n         size_type __n) const noexcept;\n# 2779 "/usr/include/c++/7/bits/basic_string.h" 3\n      size_type\n      find_last_not_of(co'
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      find_last_not_of(const _CharT* __s, size_type __pos = npos) const\n      noexcept\n      {\n ;\n return this->find_last_not_of(__s, __pos, traits_type::length(__s));\n      }\n# 2797 "/usr/i'
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      find_last_not_of(_CharT __c, size_type __pos = npos) const\n      noexcept;\n# 2813 "/usr/include/c++/7/bits/basic_string.h" 3\n      basic_string\n      substr(size_type __pos = 0, size_t'
[#] parse_declaration, is_constructor=True, meet line: 'basic_string\n      substr(size_type __pos = 0, size_type __n = npos) const\n      { return basic_string(*this,\n       _M_check(__pos, "basic_string::substr"), __n); }\n# 2832 "/usr/include/c++/7/bits/ba'
[#] parse_declaration, is_constructor=False, meet line: 'int\n      compare(const basic_string& __str) const\n      {\n const size_type __size = this->size();\n const size_type __osize = __str.size();\n const size_type __len = std::min(__size, __osize);\n\n int __'
[#] parse_declaration, is_constructor=False, meet line: 'int\n      compare(size_type __pos, size_type __n, const basic_string& __str) const;\n# 2951 "/usr/include/c++/7/bits/basic_string.h" 3\n      int\n      compare(size_type __pos1, size_type __n1, const ba'
[#] parse_declaration, is_constructor=False, meet line: 'int\n      compare(size_type __pos1, size_type __n1, const basic_string& __str,\n       size_type __pos2, size_type __n2 = npos) const;\n# 2969 "/usr/include/c++/7/bits/basic_string.h" 3\n      int\n      '
[#] parse_declaration, is_constructor=False, meet line: 'int\n      compare(const _CharT* __s) const noexcept;\n# 2993 "/usr/include/c++/7/bits/basic_string.h" 3\n      int\n      compare(size_type __pos, size_type __n1, const _CharT* __s) const;\n# 3020 "/usr/i'
[#] parse_declaration, is_constructor=False, meet line: 'int\n      compare(size_type __pos, size_type __n1, const _CharT* __s) const;\n# 3020 "/usr/include/c++/7/bits/basic_string.h" 3\n      int\n      compare(size_type __pos, size_type __n1, const _CharT* __'
[#] parse_declaration, is_constructor=False, meet line: 'int\n      compare(size_type __pos, size_type __n1, const _CharT* __s,\n       size_type __n2) const;\n\n\n      template<typename, typename, typename> friend class basic_stringbuf;\n    };\n}\n# 5886 "/usr/i'
[#] parse_declaration, is_constructor=False, meet line: 'basic_string<_CharT, _Traits, _Alloc>\n    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n       const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    {\n      basic_string<_CharT, _Tra'
[#] parse_declaration, is_constructor=False, meet line: 'basic_string<_CharT,_Traits,_Alloc>\n    operator+(const _CharT* __lhs,\n       const basic_string<_CharT,_Traits,_Alloc>& __rhs);\n\n\n\n\n\n\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n '
[#] parse_declaration, is_constructor=False, meet line: 'basic_string<_CharT,_Traits,_Alloc>\n    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);\n\n\n\n\n\n\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline basi'
[#] parse_declaration, is_constructor=False, meet line: 'basic_string<_CharT, _Traits, _Alloc>\n    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n       const _CharT* __rhs)\n    {\n      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);\n    '
[#] parse_declaration, is_constructor=False, meet line: 'basic_string<_CharT, _Traits, _Alloc>\n    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)\n    {\n      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;\n      typ'
[#] parse_declaration, is_constructor=False, meet line: 'basic_string<_CharT, _Traits, _Alloc>\n    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,\n       const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    { return std::move(__lhs.append(__rhs)'
[#] parse_declaration, is_constructor=False, meet line: 'basic_string<_CharT, _Traits, _Alloc>\n    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n       basic_string<_CharT, _Traits, _Alloc>&& __rhs)\n    { return std::move(__rhs.insert(0, __l'
[#] parse_declaration, is_constructor=False, meet line: 'basic_string<_CharT, _Traits, _Alloc>\n    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,\n       basic_string<_CharT, _Traits, _Alloc>&& __rhs)\n    {\n      const auto __size = __lhs.size() + '
[#] parse_declaration, is_constructor=False, meet line: 'basic_string<_CharT, _Traits, _Alloc>\n    operator+(const _CharT* __lhs,\n       basic_string<_CharT, _Traits, _Alloc>&& __rhs)\n    { return std::move(__rhs.insert(0, __lhs)); }\n\n  template<typename _C'
[#] parse_declaration, is_constructor=False, meet line: 'basic_string<_CharT, _Traits, _Alloc>\n    operator+(_CharT __lhs,\n       basic_string<_CharT, _Traits, _Alloc>&& __rhs)\n    { return std::move(__rhs.insert(0, 1, __lhs)); }\n\n  template<typename _CharT'
[#] parse_declaration, is_constructor=False, meet line: 'basic_string<_CharT, _Traits, _Alloc>\n    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,\n       const _CharT* __rhs)\n    { return std::move(__lhs.append(__rhs)); }\n\n  template<typename _Char'
[#] parse_declaration, is_constructor=False, meet line: 'basic_string<_CharT, _Traits, _Alloc>\n    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,\n       _CharT __rhs)\n    { return std::move(__lhs.append(1, __rhs)); }\n# 6007 "/usr/include/c++/7/bit'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n        const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    noexcept\n    { return __lhs.compare(__rhs) == 0; }\n\n  template<t'
[#] parse_declaration, is_constructor=False, meet line: '__gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type\n    operator==(const basic_string<_CharT>& __lhs,\n        const basic_string<_CharT>& __rhs) noexcept\n    { return (__lhs.size() == __r'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator==(const _CharT* __lhs,\n        const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    { return __rhs.compare(__lhs) == 0; }\n\n\n\n\n\n\n\n  template<typename _CharT, typename _Traits, type'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n        const _CharT* __rhs)\n    { return __lhs.compare(__rhs) == 0; }\n# 6054 "/usr/include/c++/7/bits/basic_string.h" 3\n  templ'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n        const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    noexcept\n    { return !(__lhs == __rhs); }\n\n\n\n\n\n\n\n  template<typ'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator!=(const _CharT* __lhs,\n        const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    { return !(__lhs == __rhs); }\n\n\n\n\n\n\n\n  template<typename _CharT, typename _Traits, typename _Al'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n        const _CharT* __rhs)\n    { return !(__lhs == __rhs); }\n# 6092 "/usr/include/c++/7/bits/basic_string.h" 3\n  template<type'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n       const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    noexcept\n    { return __lhs.compare(__rhs) < 0; }\n\n\n\n\n\n\n\n  templat'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n       const _CharT* __rhs)\n    { return __lhs.compare(__rhs) < 0; }\n\n\n\n\n\n\n\n  template<typename _CharT, typename _Traits, typenam'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<(const _CharT* __lhs,\n       const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    { return __rhs.compare(__lhs) > 0; }\n# 6130 "/usr/include/c++/7/bits/basic_string.h" 3\n  template'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n       const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    noexcept\n    { return __lhs.compare(__rhs) > 0; }\n\n\n\n\n\n\n\n  templat'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n       const _CharT* __rhs)\n    { return __lhs.compare(__rhs) > 0; }\n\n\n\n\n\n\n\n  template<typename _CharT, typename _Traits, typenam'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>(const _CharT* __lhs,\n       const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    { return __rhs.compare(__lhs) < 0; }\n# 6168 "/usr/include/c++/7/bits/basic_string.h" 3\n  template'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n        const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    noexcept\n    { return __lhs.compare(__rhs) <= 0; }\n\n\n\n\n\n\n\n  temp'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n        const _CharT* __rhs)\n    { return __lhs.compare(__rhs) <= 0; }\n\n\n\n\n\n\n\n  template<typename _CharT, typename _Traits, type'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<=(const _CharT* __lhs,\n        const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    { return __rhs.compare(__lhs) >= 0; }\n# 6206 "/usr/include/c++/7/bits/basic_string.h" 3\n  templ'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n        const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    noexcept\n    { return __lhs.compare(__rhs) >= 0; }\n\n\n\n\n\n\n\n  temp'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n        const _CharT* __rhs)\n    { return __lhs.compare(__rhs) >= 0; }\n\n\n\n\n\n\n\n  template<typename _CharT, typename _Traits, type'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>=(const _CharT* __lhs,\n      const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    { return __rhs.compare(__lhs) <= 0; }\n# 6244 "/usr/include/c++/7/bits/basic_string.h" 3\n  templat'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,\n  basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    noexcept(noexcept(__lhs.swap(__rhs)))\n    { __lhs.swap(__rhs); }\n# 6264 "/usr/include/c+'
[#] parse_declaration, is_constructor=False, meet line: 'basic_istream<_CharT, _Traits>&\n    operator>>(basic_istream<_CharT, _Traits>& __is,\n        basic_string<_CharT, _Traits, _Alloc>& __str);\n\n  template<>\n    basic_istream<char>&\n    operator>>(basic_'
[#] parse_declaration, is_constructor=False, meet line: 'basic_istream<char>&\n    operator>>(basic_istream<char>& __is, basic_string<char>& __str);\n# 6282 "/usr/include/c++/7/bits/basic_string.h" 3\n  template<typename _CharT, typename _Traits, typename _All'
[#] parse_declaration, is_constructor=False, meet line: 'basic_ostream<_CharT, _Traits>&\n    operator<<(basic_ostream<_CharT, _Traits>& __os,\n        const basic_string<_CharT, _Traits, _Alloc>& __str)\n    {\n\n\n      return __ostream_insert(__os, __str.data('
[#] parse_declaration, is_constructor=False, meet line: 'basic_istream<_CharT, _Traits>&\n    getline(basic_istream<_CharT, _Traits>& __is,\n     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);\n# 6322 "/usr/include/c++/7/bits/basic_string.h" 3\n'
[#] parse_declaration, is_constructor=False, meet line: "basic_istream<_CharT, _Traits>&\n    getline(basic_istream<_CharT, _Traits>& __is,\n     basic_string<_CharT, _Traits, _Alloc>& __str)\n    { return std::getline(__is, __str, __is.widen('\\n')); }\n\n\n\n  te"
[#] parse_declaration, is_constructor=False, meet line: 'basic_istream<_CharT, _Traits>&\n    getline(basic_istream<_CharT, _Traits>&& __is,\n     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)\n    { return std::getline(__is, __str, __delim); }'
[#] parse_declaration, is_constructor=False, meet line: 'basic_istream<_CharT, _Traits>&\n    getline(basic_istream<_CharT, _Traits>&& __is,\n     basic_string<_CharT, _Traits, _Alloc>& __str)\n    { return std::getline(__is, __str); }\n\n\n  template<>\n    basic'
[#] parse_declaration, is_constructor=False, meet line: 'basic_istream<char>&\n    getline(basic_istream<char>& __in, basic_string<char>& __str,\n     char __delim);\n\n\n  template<>\n    basic_istream<wchar_t>&\n    getline(basic_istream<wchar_t>& __in, basic_st'
[#] parse_declaration, is_constructor=False, meet line: 'basic_istream<wchar_t>&\n    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,\n     wchar_t __delim);\n\n\n\n}\n\n\n\n# 1 "/usr/include/c++/7/ext/string_conversions.h" 1 3\n# 32 "/usr/include/'
[#] parse_declaration, is_constructor=False, meet line: 'int _pos;\n# 177 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4\n};\n\n\nenum __codecvt_result\n{\n  __codecvt_ok,\n  __codecvt_partial,\n  __codecvt_error,\n  __codecvt_noconv\n};\n# 245 "/usr/include/x86_64-l'
[#] parse_declaration, is_constructor=False, meet line: 'int _flags;\n\n\n\n\n  char* _IO_read_ptr;\n  char* _IO_read_end;\n  char* _IO_read_base;\n  char* _IO_write_base;\n  char* _IO_write_ptr;\n  char* _IO_write_end;\n  char* _IO_buf_base;\n  char* _IO_buf_end;\n\n  c'
[#] parse_declaration, is_constructor=False, meet line: 'char* _IO_read_ptr;\n  char* _IO_read_end;\n  char* _IO_read_base;\n  char* _IO_write_base;\n  char* _IO_write_ptr;\n  char* _IO_write_end;\n  char* _IO_buf_base;\n  char* _IO_buf_end;\n\n  char *_IO_save_base'
[#] parse_declaration, is_constructor=False, meet line: 'char* _IO_read_end;\n  char* _IO_read_base;\n  char* _IO_write_base;\n  char* _IO_write_ptr;\n  char* _IO_write_end;\n  char* _IO_buf_base;\n  char* _IO_buf_end;\n\n  char *_IO_save_base;\n  char *_IO_backup_b'
[#] parse_declaration, is_constructor=False, meet line: 'char* _IO_read_base;\n  char* _IO_write_base;\n  char* _IO_write_ptr;\n  char* _IO_write_end;\n  char* _IO_buf_base;\n  char* _IO_buf_end;\n\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_'
[#] parse_declaration, is_constructor=False, meet line: 'char* _IO_write_base;\n  char* _IO_write_ptr;\n  char* _IO_write_end;\n  char* _IO_buf_base;\n  char* _IO_buf_end;\n\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n\n  struct _IO_mark'
[#] parse_declaration, is_constructor=False, meet line: 'char* _IO_write_ptr;\n  char* _IO_write_end;\n  char* _IO_buf_base;\n  char* _IO_buf_end;\n\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n\n  struct _IO_marker *_markers;\n\n  struct '
[#] parse_declaration, is_constructor=False, meet line: 'char* _IO_write_end;\n  char* _IO_buf_base;\n  char* _IO_buf_end;\n\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n\n  struct _IO_marker *_markers;\n\n  struct _IO_FILE *_chain;\n\n  in'
[#] parse_declaration, is_constructor=False, meet line: 'char* _IO_buf_base;\n  char* _IO_buf_end;\n\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n\n  struct _IO_marker *_markers;\n\n  struct _IO_FILE *_chain;\n\n  int _fileno;\n\n\n\n  int _fl'
[#] parse_declaration, is_constructor=False, meet line: 'char* _IO_buf_end;\n\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n\n  struct _IO_marker *_markers;\n\n  struct _IO_FILE *_chain;\n\n  int _fileno;\n\n\n\n  int _flags2;\n\n  __off_t _old_'
[#] parse_declaration, is_constructor=False, meet line: 'char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n\n  struct _IO_marker *_markers;\n\n  struct _IO_FILE *_chain;\n\n  int _fileno;\n\n\n\n  int _flags2;\n\n  __off_t _old_offset;\n\n\n\n  unsigned '
[#] parse_declaration, is_constructor=False, meet line: 'char *_IO_backup_base;\n  char *_IO_save_end;\n\n  struct _IO_marker *_markers;\n\n  struct _IO_FILE *_chain;\n\n  int _fileno;\n\n\n\n  int _flags2;\n\n  __off_t _old_offset;\n\n\n\n  unsigned short _cur_column;\n  si'
[#] parse_declaration, is_constructor=False, meet line: 'char *_IO_save_end;\n\n  struct _IO_marker *_markers;\n\n  struct _IO_FILE *_chain;\n\n  int _fileno;\n\n\n\n  int _flags2;\n\n  __off_t _old_offset;\n\n\n\n  unsigned short _cur_column;\n  signed char _vtable_offset;'
[#] parse_declaration, is_constructor=False, meet line: 'int _fileno;\n\n\n\n  int _flags2;\n\n  __off_t _old_offset;\n\n\n\n  unsigned short _cur_column;\n  signed char _vtable_offset;\n  char _shortbuf[1];\n\n\n\n  _IO_lock_t *_lock;\n# 293 "/usr/include/x86_64-linux-gnu/'
[#] parse_declaration, is_constructor=False, meet line: 'int _flags2;\n\n  __off_t _old_offset;\n\n\n\n  unsigned short _cur_column;\n  signed char _vtable_offset;\n  char _shortbuf[1];\n\n\n\n  _IO_lock_t *_lock;\n# 293 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4\n'
[#] parse_declaration, is_constructor=False, meet line: '__off_t _old_offset;\n\n\n\n  unsigned short _cur_column;\n  signed char _vtable_offset;\n  char _shortbuf[1];\n\n\n\n  _IO_lock_t *_lock;\n# 293 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4\n  __off64_t _off'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned short _cur_column;\n  signed char _vtable_offset;\n  char _shortbuf[1];\n\n\n\n  _IO_lock_t *_lock;\n# 293 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4\n  __off64_t _offset;\n\n\n\n\n\n\n\n  void *__pad1'
[#] parse_declaration, is_constructor=False, meet line: 'signed char _vtable_offset;\n  char _shortbuf[1];\n\n\n\n  _IO_lock_t *_lock;\n# 293 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4\n  __off64_t _offset;\n\n\n\n\n\n\n\n  void *__pad1;\n  void *__pad2;\n  void *__pa'
[#] parse_declaration, is_constructor=False, meet line: 'char _shortbuf[1];\n\n\n\n  _IO_lock_t *_lock;\n# 293 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4\n  __off64_t _offset;\n\n\n\n\n\n\n\n  void *__pad1;\n  void *__pad2;\n  void *__pad3;\n  void *__pad4;\n\n  size_t '
[#] parse_declaration, is_constructor=False, meet line: '_IO_lock_t *_lock;\n# 293 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4\n  __off64_t _offset;\n\n\n\n\n\n\n\n  void *__pad1;\n  void *__pad2;\n  void *__pad3;\n  void *__pad4;\n\n  size_t __pad5;\n  int _mode;\n\n  '
[#] parse_declaration, is_constructor=False, meet line: '__off64_t _offset;\n\n\n\n\n\n\n\n  void *__pad1;\n  void *__pad2;\n  void *__pad3;\n  void *__pad4;\n\n  size_t __pad5;\n  int _mode;\n\n  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];\n\n}'
[#] parse_declaration, is_constructor=False, meet line: 'void *__pad1;\n  void *__pad2;\n  void *__pad3;\n  void *__pad4;\n\n  size_t __pad5;\n  int _mode;\n\n  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];\n\n};\n\n\n\n\n\nstruct _IO_FILE_plus;'
[#] parse_declaration, is_constructor=False, meet line: 'void *__pad2;\n  void *__pad3;\n  void *__pad4;\n\n  size_t __pad5;\n  int _mode;\n\n  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];\n\n};\n\n\n\n\n\nstruct _IO_FILE_plus;\n\nextern struct '
[#] parse_declaration, is_constructor=False, meet line: 'void *__pad3;\n  void *__pad4;\n\n  size_t __pad5;\n  int _mode;\n\n  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];\n\n};\n\n\n\n\n\nstruct _IO_FILE_plus;\n\nextern struct _IO_FILE_plus _I'
[#] parse_declaration, is_constructor=False, meet line: 'void *__pad4;\n\n  size_t __pad5;\n  int _mode;\n\n  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];\n\n};\n\n\n\n\n\nstruct _IO_FILE_plus;\n\nextern struct _IO_FILE_plus _IO_2_1_stdin_;\nex'
[#] parse_declaration, is_constructor=False, meet line: 'size_t __pad5;\n  int _mode;\n\n  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];\n\n};\n\n\n\n\n\nstruct _IO_FILE_plus;\n\nextern struct _IO_FILE_plus _IO_2_1_stdin_;\nextern struct _IO_F'
[#] parse_declaration, is_constructor=False, meet line: 'int _mode;\n\n  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];\n\n};\n\n\n\n\n\nstruct _IO_FILE_plus;\n\nextern struct _IO_FILE_plus _IO_2_1_stdin_;\nextern struct _IO_FILE_plus _IO_2_1_'
[#] parse_declaration, is_constructor=False, meet line: 'char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];\n\n};\n\n\n\n\n\nstruct _IO_FILE_plus;\n\nextern struct _IO_FILE_plus _IO_2_1_stdin_;\nextern struct _IO_FILE_plus _IO_2_1_stdout_;\nexter'
[#] parse_declaration, is_constructor=False, meet line: 'struct _IO_FILE_plus _IO_2_1_stdin_;\nextern struct _IO_FILE_plus _IO_2_1_stdout_;\nextern struct _IO_FILE_plus _IO_2_1_stderr_;\n# 337 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4\ntypedef __ssize_t '
[#] parse_declaration, is_constructor=False, meet line: 'struct _IO_FILE_plus _IO_2_1_stdout_;\nextern struct _IO_FILE_plus _IO_2_1_stderr_;\n# 337 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4\ntypedef __ssize_t __io_read_fn (void *__cookie, char *__buf, s'
[#] parse_declaration, is_constructor=False, meet line: 'struct _IO_FILE_plus _IO_2_1_stderr_;\n# 337 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4\ntypedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);\n\n\n\n\n\n\n\ntypedef __ssize_t __i'
[#] parse_declaration, is_constructor=False, meet line: 'void _IO_cookie_init (struct _IO_cookie_file *__cfile, int __read_write,\n        void *__cookie, _IO_cookie_io_functions_t __fns);\n\n\n\n\nextern "C" {\n\n\nextern int __underflow (_IO_FILE *);\nextern int __'
[#] parse_declaration, is_constructor=False, meet line: 'int __underflow (_IO_FILE *);\nextern int __uflow (_IO_FILE *);\nextern int __overflow (_IO_FILE *, int);\n# 433 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4\nextern int _IO_getc (_IO_FILE *__fp);\next'
[#] parse_declaration, is_constructor=False, meet line: 'int __uflow (_IO_FILE *);\nextern int __overflow (_IO_FILE *, int);\n# 433 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4\nextern int _IO_getc (_IO_FILE *__fp);\nextern int _IO_putc (int __c, _IO_FILE *'
[#] parse_declaration, is_constructor=False, meet line: 'int __overflow (_IO_FILE *, int);\n# 433 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4\nextern int _IO_getc (_IO_FILE *__fp);\nextern int _IO_putc (int __c, _IO_FILE *__fp);\nextern int _IO_feof (_IO_F'
[#] parse_declaration, is_constructor=False, meet line: 'int _IO_getc (_IO_FILE *__fp);\nextern int _IO_putc (int __c, _IO_FILE *__fp);\nextern int _IO_feof (_IO_FILE *__fp) throw ();\nextern int _IO_ferror (_IO_FILE *__fp) throw ();\n\nextern int _IO_peekc_lock'
[#] parse_declaration, is_constructor=False, meet line: 'int _IO_putc (int __c, _IO_FILE *__fp);\nextern int _IO_feof (_IO_FILE *__fp) throw ();\nextern int _IO_ferror (_IO_FILE *__fp) throw ();\n\nextern int _IO_peekc_locked (_IO_FILE *__fp);\n\n\n\n\n\nextern void '
[#] parse_declaration, is_constructor=False, meet line: 'int _IO_feof (_IO_FILE *__fp) throw ();\nextern int _IO_ferror (_IO_FILE *__fp) throw ();\n\nextern int _IO_peekc_locked (_IO_FILE *__fp);\n\n\n\n\n\nextern void _IO_flockfile (_IO_FILE *) throw ();\nextern voi'
[#] parse_declaration, is_constructor=False, meet line: 'int _IO_ferror (_IO_FILE *__fp) throw ();\n\nextern int _IO_peekc_locked (_IO_FILE *__fp);\n\n\n\n\n\nextern void _IO_flockfile (_IO_FILE *) throw ();\nextern void _IO_funlockfile (_IO_FILE *) throw ();\nextern'
[#] parse_declaration, is_constructor=False, meet line: 'int _IO_peekc_locked (_IO_FILE *__fp);\n\n\n\n\n\nextern void _IO_flockfile (_IO_FILE *) throw ();\nextern void _IO_funlockfile (_IO_FILE *) throw ();\nextern int _IO_ftrylockfile (_IO_FILE *) throw ();\n# 462'
[#] parse_declaration, is_constructor=False, meet line: 'void _IO_flockfile (_IO_FILE *) throw ();\nextern void _IO_funlockfile (_IO_FILE *) throw ();\nextern int _IO_ftrylockfile (_IO_FILE *) throw ();\n# 462 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4\ne'
[#] parse_declaration, is_constructor=False, meet line: 'void _IO_funlockfile (_IO_FILE *) throw ();\nextern int _IO_ftrylockfile (_IO_FILE *) throw ();\n# 462 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4\nextern int _IO_vfscanf (_IO_FILE * __restrict, con'
[#] parse_declaration, is_constructor=False, meet line: 'int _IO_ftrylockfile (_IO_FILE *) throw ();\n# 462 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4\nextern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,\n   __gnuc_va_list, int *__res'
[#] parse_declaration, is_constructor=False, meet line: 'int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,\n   __gnuc_va_list, int *__restrict);\nextern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,\n    __gnuc_va_list);\nextern'
[#] parse_declaration, is_constructor=False, meet line: 'int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,\n    __gnuc_va_list);\nextern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);\nextern size_t _IO_sgetn (_IO_FILE *, void *, size_t);\n\nexte'
[#] parse_declaration, is_constructor=False, meet line: '__ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);\nextern size_t _IO_sgetn (_IO_FILE *, void *, size_t);\n\nextern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);\nextern __off64_t _IO_seekpos (_I'
[#] parse_declaration, is_constructor=False, meet line: 'size_t _IO_sgetn (_IO_FILE *, void *, size_t);\n\nextern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);\nextern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);\n\nextern void _IO_free_backup_'
[#] parse_declaration, is_constructor=False, meet line: '__off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);\nextern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);\n\nextern void _IO_free_backup_area (_IO_FILE *) throw ();\n# 524 "/usr/include/x86_64-'
[#] parse_declaration, is_constructor=False, meet line: '__off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);\n\nextern void _IO_free_backup_area (_IO_FILE *) throw ();\n# 524 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4\n}\n# 42 "/usr/include/stdio.h" 2 3 4\n'
[#] parse_declaration, is_constructor=False, meet line: 'void _IO_free_backup_area (_IO_FILE *) throw ();\n# 524 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4\n}\n# 42 "/usr/include/stdio.h" 2 3 4\n\n\n\n\ntypedef __gnuc_va_list va_list;\n# 78 "/usr/include/stdio'
[#] parse_declaration, is_constructor=False, meet line: 'struct _IO_FILE *stdin;\nextern struct _IO_FILE *stdout;\nextern struct _IO_FILE *stderr;\n\n\n\n\n\n\nextern int remove (const char *__filename) throw ();\n\nextern int rename (const char *__old, const char *__'
[#] parse_declaration, is_constructor=False, meet line: 'struct _IO_FILE *stdout;\nextern struct _IO_FILE *stderr;\n\n\n\n\n\n\nextern int remove (const char *__filename) throw ();\n\nextern int rename (const char *__old, const char *__new) throw ();\n\n\n\nextern int re'
[#] parse_declaration, is_constructor=False, meet line: 'struct _IO_FILE *stderr;\n\n\n\n\n\n\nextern int remove (const char *__filename) throw ();\n\nextern int rename (const char *__old, const char *__new) throw ();\n\n\n\nextern int renameat (int __oldfd, const char '
[#] parse_declaration, is_constructor=False, meet line: 'int remove (const char *__filename) throw ();\n\nextern int rename (const char *__old, const char *__new) throw ();\n\n\n\nextern int renameat (int __oldfd, const char *__old, int __newfd,\n       const char'
[#] parse_declaration, is_constructor=False, meet line: 'int rename (const char *__old, const char *__new) throw ();\n\n\n\nextern int renameat (int __oldfd, const char *__old, int __newfd,\n       const char *__new) throw ();\n\n\n\n\n\n\n\nextern FILE *tmpfile (void) '
[#] parse_declaration, is_constructor=False, meet line: 'int renameat (int __oldfd, const char *__old, int __newfd,\n       const char *__new) throw ();\n\n\n\n\n\n\n\nextern FILE *tmpfile (void) ;\n# 169 "/usr/include/stdio.h" 3 4\nextern FILE *tmpfile64 (void) ;\n\n\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'FILE *tmpfile (void) ;\n# 169 "/usr/include/stdio.h" 3 4\nextern FILE *tmpfile64 (void) ;\n\n\n\nextern char *tmpnam (char *__s) throw () ;\n\n\n\n\nextern char *tmpnam_r (char *__s) throw () ;\n# 190 "/usr/inclu'
[#] parse_declaration, is_constructor=False, meet line: 'FILE *tmpfile64 (void) ;\n\n\n\nextern char *tmpnam (char *__s) throw () ;\n\n\n\n\nextern char *tmpnam_r (char *__s) throw () ;\n# 190 "/usr/include/stdio.h" 3 4\nextern char *tempnam (const char *__dir, const '
[#] parse_declaration, is_constructor=False, meet line: 'char *tmpnam (char *__s) throw () ;\n\n\n\n\nextern char *tmpnam_r (char *__s) throw () ;\n# 190 "/usr/include/stdio.h" 3 4\nextern char *tempnam (const char *__dir, const char *__pfx)\n     throw () __attrib'
[#] parse_declaration, is_constructor=False, meet line: 'char *tmpnam_r (char *__s) throw () ;\n# 190 "/usr/include/stdio.h" 3 4\nextern char *tempnam (const char *__dir, const char *__pfx)\n     throw () __attribute__ ((__malloc__)) ;\n\n\n\n\n\n\n\nextern int fclose'
[#] parse_declaration, is_constructor=False, meet line: 'char *tempnam (const char *__dir, const char *__pfx)\n     throw () __attribute__ ((__malloc__)) ;\n\n\n\n\n\n\n\nextern int fclose (FILE *__stream);\n\n\n\n\nextern int fflush (FILE *__stream);\n# 213 "/usr/include'
[#] parse_declaration, is_constructor=False, meet line: 'int fclose (FILE *__stream);\n\n\n\n\nextern int fflush (FILE *__stream);\n# 213 "/usr/include/stdio.h" 3 4\nextern int fflush_unlocked (FILE *__stream);\n# 223 "/usr/include/stdio.h" 3 4\nextern int fcloseall'
[#] parse_declaration, is_constructor=False, meet line: 'int fflush (FILE *__stream);\n# 213 "/usr/include/stdio.h" 3 4\nextern int fflush_unlocked (FILE *__stream);\n# 223 "/usr/include/stdio.h" 3 4\nextern int fcloseall (void);\n# 232 "/usr/include/stdio.h" 3 '
[#] parse_declaration, is_constructor=False, meet line: 'int fflush_unlocked (FILE *__stream);\n# 223 "/usr/include/stdio.h" 3 4\nextern int fcloseall (void);\n# 232 "/usr/include/stdio.h" 3 4\nextern FILE *fopen (const char *__restrict __filename,\n      const '
[#] parse_declaration, is_constructor=False, meet line: 'int fcloseall (void);\n# 232 "/usr/include/stdio.h" 3 4\nextern FILE *fopen (const char *__restrict __filename,\n      const char *__restrict __modes) ;\n\n\n\n\nextern FILE *freopen (const char *__restrict _'
[#] parse_declaration, is_constructor=False, meet line: 'FILE *fopen (const char *__restrict __filename,\n      const char *__restrict __modes) ;\n\n\n\n\nextern FILE *freopen (const char *__restrict __filename,\n        const char *__restrict __modes,\n        FIL'
[#] parse_declaration, is_constructor=False, meet line: 'FILE *freopen (const char *__restrict __filename,\n        const char *__restrict __modes,\n        FILE *__restrict __stream) ;\n# 256 "/usr/include/stdio.h" 3 4\nextern FILE *fopen64 (const char *__rest'
[#] parse_declaration, is_constructor=False, meet line: 'FILE *fopen64 (const char *__restrict __filename,\n        const char *__restrict __modes) ;\nextern FILE *freopen64 (const char *__restrict __filename,\n   const char *__restrict __modes,\n   FILE *__res'
[#] parse_declaration, is_constructor=False, meet line: 'FILE *freopen64 (const char *__restrict __filename,\n   const char *__restrict __modes,\n   FILE *__restrict __stream) ;\n\n\n\n\nextern FILE *fdopen (int __fd, const char *__modes) throw () ;\n\n\n\n\n\nextern FI'
[#] parse_declaration, is_constructor=False, meet line: 'FILE *fdopen (int __fd, const char *__modes) throw () ;\n\n\n\n\n\nextern FILE *fopencookie (void *__restrict __magic_cookie,\n     const char *__restrict __modes,\n     _IO_cookie_io_functions_t __io_funcs) '
[#] parse_declaration, is_constructor=False, meet line: 'FILE *fopencookie (void *__restrict __magic_cookie,\n     const char *__restrict __modes,\n     _IO_cookie_io_functions_t __io_funcs) throw () ;\n\n\n\n\nextern FILE *fmemopen (void *__s, size_t __len, const'
[#] parse_declaration, is_constructor=False, meet line: 'FILE *fmemopen (void *__s, size_t __len, const char *__modes)\n  throw () ;\n\n\n\n\nextern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) throw () ;\n\n\n\n\n\nextern void setbuf (FILE *__restrict __s'
[#] parse_declaration, is_constructor=False, meet line: 'FILE *open_memstream (char **__bufloc, size_t *__sizeloc) throw () ;\n\n\n\n\n\nextern void setbuf (FILE *__restrict __stream, char *__restrict __buf) throw ();\n\n\n\nextern int setvbuf (FILE *__restrict __str'
[#] parse_declaration, is_constructor=False, meet line: 'void setbuf (FILE *__restrict __stream, char *__restrict __buf) throw ();\n\n\n\nextern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,\n      int __modes, size_t __n) throw ();\n\n\n\n\nextern '
[#] parse_declaration, is_constructor=False, meet line: 'int setvbuf (FILE *__restrict __stream, char *__restrict __buf,\n      int __modes, size_t __n) throw ();\n\n\n\n\nextern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,\n         size_t _'
[#] parse_declaration, is_constructor=False, meet line: 'void setbuffer (FILE *__restrict __stream, char *__restrict __buf,\n         size_t __size) throw ();\n\n\nextern void setlinebuf (FILE *__stream) throw ();\n\n\n\n\n\n\n\nextern int fprintf (FILE *__restrict __s'
[#] parse_declaration, is_constructor=False, meet line: 'void setlinebuf (FILE *__stream) throw ();\n\n\n\n\n\n\n\nextern int fprintf (FILE *__restrict __stream,\n      const char *__restrict __format, ...);\n\n\n\n\nextern int printf (const char *__restrict __format, ..'
[#] parse_declaration, is_constructor=False, meet line: 'int fprintf (FILE *__restrict __stream,\n      const char *__restrict __format, ...);\n\n\n\n\nextern int printf (const char *__restrict __format, ...);\n\nextern int sprintf (char *__restrict __s,\n      cons'
[#] parse_declaration, is_constructor=False, meet line: 'int printf (const char *__restrict __format, ...);\n\nextern int sprintf (char *__restrict __s,\n      const char *__restrict __format, ...) throw ();\n\n\n\n\n\nextern int vfprintf (FILE *__restrict __s, cons'
[#] parse_declaration, is_constructor=False, meet line: 'int sprintf (char *__restrict __s,\n      const char *__restrict __format, ...) throw ();\n\n\n\n\n\nextern int vfprintf (FILE *__restrict __s, const char *__restrict __format,\n       __gnuc_va_list __arg);\n'
[#] parse_declaration, is_constructor=False, meet line: 'int vfprintf (FILE *__restrict __s, const char *__restrict __format,\n       __gnuc_va_list __arg);\n\n\n\n\nextern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);\n\nextern int vsprintf '
[#] parse_declaration, is_constructor=False, meet line: 'int vprintf (const char *__restrict __format, __gnuc_va_list __arg);\n\nextern int vsprintf (char *__restrict __s, const char *__restrict __format,\n       __gnuc_va_list __arg) throw ();\n\n\n\nextern int s'
[#] parse_declaration, is_constructor=False, meet line: 'int vsprintf (char *__restrict __s, const char *__restrict __format,\n       __gnuc_va_list __arg) throw ();\n\n\n\nextern int snprintf (char *__restrict __s, size_t __maxlen,\n       const char *__restrict'
[#] parse_declaration, is_constructor=False, meet line: 'int snprintf (char *__restrict __s, size_t __maxlen,\n       const char *__restrict __format, ...)\n     throw () __attribute__ ((__format__ (__printf__, 3, 4)));\n\nextern int vsnprintf (char *__restrict'
[#] parse_declaration, is_constructor=False, meet line: 'int vsnprintf (char *__restrict __s, size_t __maxlen,\n        const char *__restrict __format, __gnuc_va_list __arg)\n     throw () __attribute__ ((__format__ (__printf__, 3, 0)));\n\n\n\n\n\nextern int vasp'
[#] parse_declaration, is_constructor=False, meet line: 'int vasprintf (char **__restrict __ptr, const char *__restrict __f,\n        __gnuc_va_list __arg)\n     throw () __attribute__ ((__format__ (__printf__, 2, 0))) ;\nextern int __asprintf (char **__restri'
[#] parse_declaration, is_constructor=False, meet line: 'int __asprintf (char **__restrict __ptr,\n         const char *__restrict __fmt, ...)\n     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;\nextern int asprintf (char **__restrict __ptr,\n     '
[#] parse_declaration, is_constructor=False, meet line: 'int asprintf (char **__restrict __ptr,\n       const char *__restrict __fmt, ...)\n     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;\n\n\n\n\nextern int vdprintf (int __fd, const char *__restri'
[#] parse_declaration, is_constructor=False, meet line: 'int vdprintf (int __fd, const char *__restrict __fmt,\n       __gnuc_va_list __arg)\n     __attribute__ ((__format__ (__printf__, 2, 0)));\nextern int dprintf (int __fd, const char *__restrict __fmt, ...'
[#] parse_declaration, is_constructor=False, meet line: 'int dprintf (int __fd, const char *__restrict __fmt, ...)\n     __attribute__ ((__format__ (__printf__, 2, 3)));\n\n\n\n\n\n\n\nextern int fscanf (FILE *__restrict __stream,\n     const char *__restrict __forma'
[#] parse_declaration, is_constructor=False, meet line: 'int fscanf (FILE *__restrict __stream,\n     const char *__restrict __format, ...) ;\n\n\n\n\nextern int scanf (const char *__restrict __format, ...) ;\n\nextern int sscanf (const char *__restrict __s,\n     c'
[#] parse_declaration, is_constructor=False, meet line: 'int scanf (const char *__restrict __format, ...) ;\n\nextern int sscanf (const char *__restrict __s,\n     const char *__restrict __format, ...) throw ();\n# 420 "/usr/include/stdio.h" 3 4\nextern int vfsc'
[#] parse_declaration, is_constructor=False, meet line: 'int sscanf (const char *__restrict __s,\n     const char *__restrict __format, ...) throw ();\n# 420 "/usr/include/stdio.h" 3 4\nextern int vfscanf (FILE *__restrict __s, const char *__restrict __format,'
[#] parse_declaration, is_constructor=False, meet line: 'int vfscanf (FILE *__restrict __s, const char *__restrict __format,\n      __gnuc_va_list __arg)\n     __attribute__ ((__format__ (__scanf__, 2, 0))) ;\n\n\n\n\n\nextern int vscanf (const char *__restrict __f'
[#] parse_declaration, is_constructor=False, meet line: 'int vscanf (const char *__restrict __format, __gnuc_va_list __arg)\n     __attribute__ ((__format__ (__scanf__, 1, 0))) ;\n\n\nextern int vsscanf (const char *__restrict __s,\n      const char *__restrict '
[#] parse_declaration, is_constructor=False, meet line: 'int vsscanf (const char *__restrict __s,\n      const char *__restrict __format, __gnuc_va_list __arg)\n     throw () __attribute__ ((__format__ (__scanf__, 2, 0)));\n# 477 "/usr/include/stdio.h" 3 4\next'
[#] parse_declaration, is_constructor=False, meet line: 'int fgetc (FILE *__stream);\nextern int getc (FILE *__stream);\n\n\n\n\n\nextern int getchar (void);\n# 495 "/usr/include/stdio.h" 3 4\nextern int getc_unlocked (FILE *__stream);\nextern int getchar_unlocked (v'
[#] parse_declaration, is_constructor=False, meet line: 'int getc (FILE *__stream);\n\n\n\n\n\nextern int getchar (void);\n# 495 "/usr/include/stdio.h" 3 4\nextern int getc_unlocked (FILE *__stream);\nextern int getchar_unlocked (void);\n# 506 "/usr/include/stdio.h" '
[#] parse_declaration, is_constructor=False, meet line: 'int getchar (void);\n# 495 "/usr/include/stdio.h" 3 4\nextern int getc_unlocked (FILE *__stream);\nextern int getchar_unlocked (void);\n# 506 "/usr/include/stdio.h" 3 4\nextern int fgetc_unlocked (FILE *__'
[#] parse_declaration, is_constructor=False, meet line: 'int getc_unlocked (FILE *__stream);\nextern int getchar_unlocked (void);\n# 506 "/usr/include/stdio.h" 3 4\nextern int fgetc_unlocked (FILE *__stream);\n# 517 "/usr/include/stdio.h" 3 4\nextern int fputc ('
[#] parse_declaration, is_constructor=False, meet line: 'int getchar_unlocked (void);\n# 506 "/usr/include/stdio.h" 3 4\nextern int fgetc_unlocked (FILE *__stream);\n# 517 "/usr/include/stdio.h" 3 4\nextern int fputc (int __c, FILE *__stream);\nextern int putc ('
[#] parse_declaration, is_constructor=False, meet line: 'int fgetc_unlocked (FILE *__stream);\n# 517 "/usr/include/stdio.h" 3 4\nextern int fputc (int __c, FILE *__stream);\nextern int putc (int __c, FILE *__stream);\n\n\n\n\n\nextern int putchar (int __c);\n# 537 "/'
[#] parse_declaration, is_constructor=False, meet line: 'int fputc (int __c, FILE *__stream);\nextern int putc (int __c, FILE *__stream);\n\n\n\n\n\nextern int putchar (int __c);\n# 537 "/usr/include/stdio.h" 3 4\nextern int fputc_unlocked (int __c, FILE *__stream);'
[#] parse_declaration, is_constructor=False, meet line: 'int putc (int __c, FILE *__stream);\n\n\n\n\n\nextern int putchar (int __c);\n# 537 "/usr/include/stdio.h" 3 4\nextern int fputc_unlocked (int __c, FILE *__stream);\n\n\n\n\n\n\n\nextern int putc_unlocked (int __c, F'
[#] parse_declaration, is_constructor=False, meet line: 'int putchar (int __c);\n# 537 "/usr/include/stdio.h" 3 4\nextern int fputc_unlocked (int __c, FILE *__stream);\n\n\n\n\n\n\n\nextern int putc_unlocked (int __c, FILE *__stream);\nextern int putchar_unlocked (int'
[#] parse_declaration, is_constructor=False, meet line: 'int fputc_unlocked (int __c, FILE *__stream);\n\n\n\n\n\n\n\nextern int putc_unlocked (int __c, FILE *__stream);\nextern int putchar_unlocked (int __c);\n\n\n\n\n\n\nextern int getw (FILE *__stream);\n\n\nextern int put'
[#] parse_declaration, is_constructor=False, meet line: 'int putc_unlocked (int __c, FILE *__stream);\nextern int putchar_unlocked (int __c);\n\n\n\n\n\n\nextern int getw (FILE *__stream);\n\n\nextern int putw (int __w, FILE *__stream);\n\n\n\n\n\n\n\nextern char *fgets (char'
[#] parse_declaration, is_constructor=False, meet line: 'int putchar_unlocked (int __c);\n\n\n\n\n\n\nextern int getw (FILE *__stream);\n\n\nextern int putw (int __w, FILE *__stream);\n\n\n\n\n\n\n\nextern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream'
[#] parse_declaration, is_constructor=False, meet line: 'int getw (FILE *__stream);\n\n\nextern int putw (int __w, FILE *__stream);\n\n\n\n\n\n\n\nextern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)\n     ;\n# 587 "/usr/include/stdio.h" 3 4\next'
[#] parse_declaration, is_constructor=False, meet line: 'int putw (int __w, FILE *__stream);\n\n\n\n\n\n\n\nextern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)\n     ;\n# 587 "/usr/include/stdio.h" 3 4\nextern char *fgets_unlocked (char *__re'
[#] parse_declaration, is_constructor=False, meet line: 'char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)\n     ;\n# 587 "/usr/include/stdio.h" 3 4\nextern char *fgets_unlocked (char *__restrict __s, int __n,\n        FILE *__restrict __st'
[#] parse_declaration, is_constructor=False, meet line: 'char *fgets_unlocked (char *__restrict __s, int __n,\n        FILE *__restrict __stream) ;\n# 603 "/usr/include/stdio.h" 3 4\nextern __ssize_t __getdelim (char **__restrict __lineptr,\n          size_t *_'
[#] parse_declaration, is_constructor=False, meet line: '__ssize_t __getdelim (char **__restrict __lineptr,\n          size_t *__restrict __n, int __delimiter,\n          FILE *__restrict __stream) ;\nextern __ssize_t getdelim (char **__restrict __lineptr,\n   '
[#] parse_declaration, is_constructor=False, meet line: '__ssize_t getdelim (char **__restrict __lineptr,\n        size_t *__restrict __n, int __delimiter,\n        FILE *__restrict __stream) ;\n\n\n\n\n\n\n\nextern __ssize_t getline (char **__restrict __lineptr,\n   '
[#] parse_declaration, is_constructor=False, meet line: '__ssize_t getline (char **__restrict __lineptr,\n       size_t *__restrict __n,\n       FILE *__restrict __stream) ;\n\n\n\n\n\n\n\nextern int fputs (const char *__restrict __s, FILE *__restrict __stream);\n\n\n\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'int fputs (const char *__restrict __s, FILE *__restrict __stream);\n\n\n\n\n\nextern int puts (const char *__s);\n\n\n\n\n\n\nextern int ungetc (int __c, FILE *__stream);\n\n\n\n\n\n\nextern size_t fread (void *__restric'
[#] parse_declaration, is_constructor=False, meet line: 'int puts (const char *__s);\n\n\n\n\n\n\nextern int ungetc (int __c, FILE *__stream);\n\n\n\n\n\n\nextern size_t fread (void *__restrict __ptr, size_t __size,\n       size_t __n, FILE *__restrict __stream) ;\n\n\n\n\next'
[#] parse_declaration, is_constructor=False, meet line: 'int ungetc (int __c, FILE *__stream);\n\n\n\n\n\n\nextern size_t fread (void *__restrict __ptr, size_t __size,\n       size_t __n, FILE *__restrict __stream) ;\n\n\n\n\nextern size_t fwrite (const void *__restrict'
[#] parse_declaration, is_constructor=False, meet line: 'size_t fread (void *__restrict __ptr, size_t __size,\n       size_t __n, FILE *__restrict __stream) ;\n\n\n\n\nextern size_t fwrite (const void *__restrict __ptr, size_t __size,\n        size_t __n, FILE *__'
[#] parse_declaration, is_constructor=False, meet line: 'size_t fwrite (const void *__restrict __ptr, size_t __size,\n        size_t __n, FILE *__restrict __s);\n# 662 "/usr/include/stdio.h" 3 4\nextern int fputs_unlocked (const char *__restrict __s,\n      FIL'
[#] parse_declaration, is_constructor=False, meet line: 'int fputs_unlocked (const char *__restrict __s,\n      FILE *__restrict __stream);\n# 673 "/usr/include/stdio.h" 3 4\nextern size_t fread_unlocked (void *__restrict __ptr, size_t __size,\n         size_t '
[#] parse_declaration, is_constructor=False, meet line: 'size_t fread_unlocked (void *__restrict __ptr, size_t __size,\n         size_t __n, FILE *__restrict __stream) ;\nextern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,\n          si'
[#] parse_declaration, is_constructor=False, meet line: 'size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,\n          size_t __n, FILE *__restrict __stream);\n\n\n\n\n\n\n\nextern int fseek (FILE *__stream, long int __off, int __whence);\n\n\n\n\nexter'
[#] parse_declaration, is_constructor=False, meet line: 'int fseek (FILE *__stream, long int __off, int __whence);\n\n\n\n\nextern long int ftell (FILE *__stream) ;\n\n\n\n\nextern void rewind (FILE *__stream);\n# 707 "/usr/include/stdio.h" 3 4\nextern int fseeko (FILE'
[#] parse_declaration, is_constructor=False, meet line: 'long int ftell (FILE *__stream) ;\n\n\n\n\nextern void rewind (FILE *__stream);\n# 707 "/usr/include/stdio.h" 3 4\nextern int fseeko (FILE *__stream, __off_t __off, int __whence);\n\n\n\n\nextern __off_t ftello ('
[#] parse_declaration, is_constructor=False, meet line: 'void rewind (FILE *__stream);\n# 707 "/usr/include/stdio.h" 3 4\nextern int fseeko (FILE *__stream, __off_t __off, int __whence);\n\n\n\n\nextern __off_t ftello (FILE *__stream) ;\n# 731 "/usr/include/stdio.h'
[#] parse_declaration, is_constructor=False, meet line: 'int fseeko (FILE *__stream, __off_t __off, int __whence);\n\n\n\n\nextern __off_t ftello (FILE *__stream) ;\n# 731 "/usr/include/stdio.h" 3 4\nextern int fgetpos (FILE *__restrict __stream, fpos_t *__restric'
[#] parse_declaration, is_constructor=False, meet line: '__off_t ftello (FILE *__stream) ;\n# 731 "/usr/include/stdio.h" 3 4\nextern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);\n\n\n\n\nextern int fsetpos (FILE *__stream, const fpos_t *__pos'
[#] parse_declaration, is_constructor=False, meet line: 'int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);\n\n\n\n\nextern int fsetpos (FILE *__stream, const fpos_t *__pos);\n# 750 "/usr/include/stdio.h" 3 4\nextern int fseeko64 (FILE *__stream, _'
[#] parse_declaration, is_constructor=False, meet line: 'int fsetpos (FILE *__stream, const fpos_t *__pos);\n# 750 "/usr/include/stdio.h" 3 4\nextern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);\nextern __off64_t ftello64 (FILE *__stream) ;\nex'
[#] parse_declaration, is_constructor=False, meet line: 'int fseeko64 (FILE *__stream, __off64_t __off, int __whence);\nextern __off64_t ftello64 (FILE *__stream) ;\nextern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);\nextern int fset'
[#] parse_declaration, is_constructor=False, meet line: '__off64_t ftello64 (FILE *__stream) ;\nextern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);\nextern int fsetpos64 (FILE *__stream, const fpos64_t *__pos);\n\n\n\nextern void clearer'
[#] parse_declaration, is_constructor=False, meet line: 'int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);\nextern int fsetpos64 (FILE *__stream, const fpos64_t *__pos);\n\n\n\nextern void clearerr (FILE *__stream) throw ();\n\nextern int feof'
[#] parse_declaration, is_constructor=False, meet line: 'int fsetpos64 (FILE *__stream, const fpos64_t *__pos);\n\n\n\nextern void clearerr (FILE *__stream) throw ();\n\nextern int feof (FILE *__stream) throw () ;\n\nextern int ferror (FILE *__stream) throw () ;\n\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'void clearerr (FILE *__stream) throw ();\n\nextern int feof (FILE *__stream) throw () ;\n\nextern int ferror (FILE *__stream) throw () ;\n\n\n\nextern void clearerr_unlocked (FILE *__stream) throw ();\nextern '
[#] parse_declaration, is_constructor=False, meet line: 'int feof (FILE *__stream) throw () ;\n\nextern int ferror (FILE *__stream) throw () ;\n\n\n\nextern void clearerr_unlocked (FILE *__stream) throw ();\nextern int feof_unlocked (FILE *__stream) throw () ;\next'
[#] parse_declaration, is_constructor=False, meet line: 'int ferror (FILE *__stream) throw () ;\n\n\n\nextern void clearerr_unlocked (FILE *__stream) throw ();\nextern int feof_unlocked (FILE *__stream) throw () ;\nextern int ferror_unlocked (FILE *__stream) thro'
[#] parse_declaration, is_constructor=False, meet line: 'void clearerr_unlocked (FILE *__stream) throw ();\nextern int feof_unlocked (FILE *__stream) throw () ;\nextern int ferror_unlocked (FILE *__stream) throw () ;\n\n\n\n\n\n\n\nextern void perror (const char *__s'
[#] parse_declaration, is_constructor=False, meet line: 'int feof_unlocked (FILE *__stream) throw () ;\nextern int ferror_unlocked (FILE *__stream) throw () ;\n\n\n\n\n\n\n\nextern void perror (const char *__s);\n\n\n\n\n\n# 1 "/usr/include/x86_64-linux-gnu/bits/sys_errli'
[#] parse_declaration, is_constructor=False, meet line: 'int ferror_unlocked (FILE *__stream) throw () ;\n\n\n\n\n\n\n\nextern void perror (const char *__s);\n\n\n\n\n\n# 1 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 1 3 4\n# 26 "/usr/include/x86_64-linux-gnu/bits/'
[#] parse_declaration, is_constructor=False, meet line: 'void perror (const char *__s);\n\n\n\n\n\n# 1 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 1 3 4\n# 26 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 3 4\nextern int sys_nerr;\nextern const char *con'
[#] parse_declaration, is_constructor=False, meet line: 'int sys_nerr;\nextern const char *const sys_errlist[];\n\n\nextern int _sys_nerr;\nextern const char *const _sys_errlist[];\n# 782 "/usr/include/stdio.h" 2 3 4\n\n\n\n\nextern int fileno (FILE *__stream) throw ('
[#] parse_declaration, is_constructor=False, meet line: 'const char *const sys_errlist[];\n\n\nextern int _sys_nerr;\nextern const char *const _sys_errlist[];\n# 782 "/usr/include/stdio.h" 2 3 4\n\n\n\n\nextern int fileno (FILE *__stream) throw () ;\n\n\n\n\nextern int fi'
[#] parse_declaration, is_constructor=False, meet line: 'int _sys_nerr;\nextern const char *const _sys_errlist[];\n# 782 "/usr/include/stdio.h" 2 3 4\n\n\n\n\nextern int fileno (FILE *__stream) throw () ;\n\n\n\n\nextern int fileno_unlocked (FILE *__stream) throw () ;\n'
[#] parse_declaration, is_constructor=False, meet line: 'const char *const _sys_errlist[];\n# 782 "/usr/include/stdio.h" 2 3 4\n\n\n\n\nextern int fileno (FILE *__stream) throw () ;\n\n\n\n\nextern int fileno_unlocked (FILE *__stream) throw () ;\n# 800 "/usr/include/st'
[#] parse_declaration, is_constructor=False, meet line: 'int fileno (FILE *__stream) throw () ;\n\n\n\n\nextern int fileno_unlocked (FILE *__stream) throw () ;\n# 800 "/usr/include/stdio.h" 3 4\nextern FILE *popen (const char *__command, const char *__modes) ;\n\n\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'int fileno_unlocked (FILE *__stream) throw () ;\n# 800 "/usr/include/stdio.h" 3 4\nextern FILE *popen (const char *__command, const char *__modes) ;\n\n\n\n\n\nextern int pclose (FILE *__stream);\n\n\n\n\n\nextern '
[#] parse_declaration, is_constructor=False, meet line: 'FILE *popen (const char *__command, const char *__modes) ;\n\n\n\n\n\nextern int pclose (FILE *__stream);\n\n\n\n\n\nextern char *ctermid (char *__s) throw ();\n\n\n\n\n\nextern char *cuserid (char *__s);\n\n\n\n\nstruct ob'
[#] parse_declaration, is_constructor=False, meet line: 'int pclose (FILE *__stream);\n\n\n\n\n\nextern char *ctermid (char *__s) throw ();\n\n\n\n\n\nextern char *cuserid (char *__s);\n\n\n\n\nstruct obstack;\n\n\nextern int obstack_printf (struct obstack *__restrict __obstac'
[#] parse_declaration, is_constructor=False, meet line: 'char *ctermid (char *__s) throw ();\n\n\n\n\n\nextern char *cuserid (char *__s);\n\n\n\n\nstruct obstack;\n\n\nextern int obstack_printf (struct obstack *__restrict __obstack,\n      const char *__restrict __format,'
[#] parse_declaration, is_constructor=False, meet line: 'char *cuserid (char *__s);\n\n\n\n\nstruct obstack;\n\n\nextern int obstack_printf (struct obstack *__restrict __obstack,\n      const char *__restrict __format, ...)\n     throw () __attribute__ ((__format__ ('
[#] parse_declaration, is_constructor=False, meet line: 'int obstack_printf (struct obstack *__restrict __obstack,\n      const char *__restrict __format, ...)\n     throw () __attribute__ ((__format__ (__printf__, 2, 3)));\nextern int obstack_vprintf (struct '
[#] parse_declaration, is_constructor=False, meet line: 'int obstack_vprintf (struct obstack *__restrict __obstack,\n       const char *__restrict __format,\n       __gnuc_va_list __args)\n     throw () __attribute__ ((__format__ (__printf__, 2, 0)));\n\n\n\n\n\n\n\ne'
[#] parse_declaration, is_constructor=False, meet line: 'void flockfile (FILE *__stream) throw ();\n\n\n\nextern int ftrylockfile (FILE *__stream) throw () ;\n\n\nextern void funlockfile (FILE *__stream) throw ();\n# 868 "/usr/include/stdio.h" 3 4\n}\n# 43 "/usr/incl'
[#] parse_declaration, is_constructor=False, meet line: 'int ftrylockfile (FILE *__stream) throw () ;\n\n\nextern void funlockfile (FILE *__stream) throw ();\n# 868 "/usr/include/stdio.h" 3 4\n}\n# 43 "/usr/include/c++/7/cstdio" 2 3\n# 96 "/usr/include/c++/7/cstdi'
[#] parse_declaration, is_constructor=False, meet line: 'void funlockfile (FILE *__stream) throw ();\n# 868 "/usr/include/stdio.h" 3 4\n}\n# 43 "/usr/include/c++/7/cstdio" 2 3\n# 96 "/usr/include/c++/7/cstdio" 3\nnamespace std\n{\n  using ::FILE;\n  using ::fpos_t;'
[#] parse_declaration, is_constructor=False, meet line: 'int *__errno_location (void) throw () __attribute__ ((__const__));\n\n\n\n\n\n\n\nextern char *program_invocation_name;\nextern char *program_invocation_short_name;\n\n\n\n\n\ntypedef int error_t;\n\n\n\n\n}\n# 43 "/usr/i'
[#] parse_declaration, is_constructor=False, meet line: 'char *program_invocation_name;\nextern char *program_invocation_short_name;\n\n\n\n\n\ntypedef int error_t;\n\n\n\n\n}\n# 43 "/usr/include/c++/7/cerrno" 2 3\n# 45 "/usr/include/c++/7/ext/string_conversions.h" 2 3\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'char *program_invocation_short_name;\n\n\n\n\n\ntypedef int error_t;\n\n\n\n\n}\n# 43 "/usr/include/c++/7/cerrno" 2 3\n# 45 "/usr/include/c++/7/ext/string_conversions.h" 2 3\n\nnamespace __gnu_cxx __attribute__ ((__'
[#] parse_declaration, is_constructor=False, meet line: '_Ret\n    __stoa(_TRet (*__convf) (const _CharT*, _CharT**, _Base...),\n    const char* __name, const _CharT* __str, std::size_t* __idx,\n    _Base... __base)\n    {\n      _Ret __ret;\n\n      _CharT* __end'
[#] parse_declaration, is_constructor=False, meet line: '_String\n    __to_xstring(int (*__convf) (_CharT*, std::size_t, const _CharT*,\n     __builtin_va_list), std::size_t __n,\n   const _CharT* __fmt, ...)\n    {\n\n\n      _CharT* __s = static_cast<_CharT*>(__'
[#] parse_declaration, is_constructor=False, meet line: 'int\n  stoi(const string& __str, size_t* __idx = 0, int __base = 10)\n  { return __gnu_cxx::__stoa<long, int>(&std::strtol, "stoi", __str.c_str(),\n     __idx, __base); }\n\n  inline long\n  stol(const stri'
[#] parse_declaration, is_constructor=False, meet line: 'long\n  stol(const string& __str, size_t* __idx = 0, int __base = 10)\n  { return __gnu_cxx::__stoa(&std::strtol, "stol", __str.c_str(),\n        __idx, __base); }\n\n  inline unsigned long\n  stoul(const s'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned long\n  stoul(const string& __str, size_t* __idx = 0, int __base = 10)\n  { return __gnu_cxx::__stoa(&std::strtoul, "stoul", __str.c_str(),\n        __idx, __base); }\n\n  inline long long\n  stoll'
[#] parse_declaration, is_constructor=False, meet line: 'long long\n  stoll(const string& __str, size_t* __idx = 0, int __base = 10)\n  { return __gnu_cxx::__stoa(&std::strtoll, "stoll", __str.c_str(),\n        __idx, __base); }\n\n  inline unsigned long long\n  '
[#] parse_declaration, is_constructor=False, meet line: 'unsigned long long\n  stoull(const string& __str, size_t* __idx = 0, int __base = 10)\n  { return __gnu_cxx::__stoa(&std::strtoull, "stoull", __str.c_str(),\n        __idx, __base); }\n\n\n  inline float\n  '
[#] parse_declaration, is_constructor=False, meet line: 'float\n  stof(const string& __str, size_t* __idx = 0)\n  { return __gnu_cxx::__stoa(&std::strtof, "stof", __str.c_str(), __idx); }\n\n  inline double\n  stod(const string& __str, size_t* __idx = 0)\n  { ret'
[#] parse_declaration, is_constructor=False, meet line: 'double\n  stod(const string& __str, size_t* __idx = 0)\n  { return __gnu_cxx::__stoa(&std::strtod, "stod", __str.c_str(), __idx); }\n\n  inline long double\n  stold(const string& __str, size_t* __idx = 0)\n'
[#] parse_declaration, is_constructor=False, meet line: 'long double\n  stold(const string& __str, size_t* __idx = 0)\n  { return __gnu_cxx::__stoa(&std::strtold, "stold", __str.c_str(), __idx); }\n\n\n\n\n\n\n  inline string\n  to_string(int __val)\n  { return __gnu_'
[#] parse_declaration, is_constructor=False, meet line: 'string\n  to_string(int __val)\n  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, 4 * sizeof(int),\n        "%d", __val); }\n\n  inline string\n  to_string(unsigned __val)\n  { return __gnu_cxx::__'
[#] parse_declaration, is_constructor=False, meet line: 'string\n  to_string(unsigned __val)\n  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,\n        4 * sizeof(unsigned),\n        "%u", __val); }\n\n  inline string\n  to_string(long __val)\n  { return'
[#] parse_declaration, is_constructor=False, meet line: 'string\n  to_string(long __val)\n  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, 4 * sizeof(long),\n        "%ld", __val); }\n\n  inline string\n  to_string(unsigned long __val)\n  { return __gnu'
[#] parse_declaration, is_constructor=False, meet line: 'string\n  to_string(unsigned long __val)\n  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,\n        4 * sizeof(unsigned long),\n        "%lu", __val); }\n\n  inline string\n  to_string(long long _'
[#] parse_declaration, is_constructor=False, meet line: 'string\n  to_string(long long __val)\n  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,\n        4 * sizeof(long long),\n        "%lld", __val); }\n\n  inline string\n  to_string(unsigned long long'
[#] parse_declaration, is_constructor=False, meet line: 'string\n  to_string(unsigned long long __val)\n  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,\n        4 * sizeof(unsigned long long),\n        "%llu", __val); }\n\n  inline string\n  to_string('
[#] parse_declaration, is_constructor=False, meet line: 'string\n  to_string(float __val)\n  {\n    const int __n =\n      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;\n    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,\n        "%f", '
[#] parse_declaration, is_constructor=False, meet line: 'string\n  to_string(double __val)\n  {\n    const int __n =\n      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;\n    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,\n        "%f"'
[#] parse_declaration, is_constructor=False, meet line: 'string\n  to_string(long double __val)\n  {\n    const int __n =\n      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;\n    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,\n  '
[#] parse_declaration, is_constructor=False, meet line: 'int\n  stoi(const wstring& __str, size_t* __idx = 0, int __base = 10)\n  { return __gnu_cxx::__stoa<long, int>(&std::wcstol, "stoi", __str.c_str(),\n     __idx, __base); }\n\n  inline long\n  stol(const wst'
[#] parse_declaration, is_constructor=False, meet line: 'long\n  stol(const wstring& __str, size_t* __idx = 0, int __base = 10)\n  { return __gnu_cxx::__stoa(&std::wcstol, "stol", __str.c_str(),\n        __idx, __base); }\n\n  inline unsigned long\n  stoul(const '
[#] parse_declaration, is_constructor=False, meet line: 'unsigned long\n  stoul(const wstring& __str, size_t* __idx = 0, int __base = 10)\n  { return __gnu_cxx::__stoa(&std::wcstoul, "stoul", __str.c_str(),\n        __idx, __base); }\n\n  inline long long\n  stol'
[#] parse_declaration, is_constructor=False, meet line: 'long long\n  stoll(const wstring& __str, size_t* __idx = 0, int __base = 10)\n  { return __gnu_cxx::__stoa(&std::wcstoll, "stoll", __str.c_str(),\n        __idx, __base); }\n\n  inline unsigned long long\n '
[#] parse_declaration, is_constructor=False, meet line: 'unsigned long long\n  stoull(const wstring& __str, size_t* __idx = 0, int __base = 10)\n  { return __gnu_cxx::__stoa(&std::wcstoull, "stoull", __str.c_str(),\n        __idx, __base); }\n\n\n  inline float\n '
[#] parse_declaration, is_constructor=False, meet line: 'float\n  stof(const wstring& __str, size_t* __idx = 0)\n  { return __gnu_cxx::__stoa(&std::wcstof, "stof", __str.c_str(), __idx); }\n\n  inline double\n  stod(const wstring& __str, size_t* __idx = 0)\n  { r'
[#] parse_declaration, is_constructor=False, meet line: 'double\n  stod(const wstring& __str, size_t* __idx = 0)\n  { return __gnu_cxx::__stoa(&std::wcstod, "stod", __str.c_str(), __idx); }\n\n  inline long double\n  stold(const wstring& __str, size_t* __idx = 0'
[#] parse_declaration, is_constructor=False, meet line: 'long double\n  stold(const wstring& __str, size_t* __idx = 0)\n  { return __gnu_cxx::__stoa(&std::wcstold, "stold", __str.c_str(), __idx); }\n\n\n\n  inline wstring\n  to_wstring(int __val)\n  { return __gnu_'
[#] parse_declaration, is_constructor=False, meet line: 'wstring\n  to_wstring(int __val)\n  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(int),\n         L"%d", __val); }\n\n  inline wstring\n  to_wstring(unsigned __val)\n  { return __gnu_'
[#] parse_declaration, is_constructor=False, meet line: 'wstring\n  to_wstring(unsigned __val)\n  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,\n         4 * sizeof(unsigned),\n         L"%u", __val); }\n\n  inline wstring\n  to_wstring(long __val)\n  '
[#] parse_declaration, is_constructor=False, meet line: 'wstring\n  to_wstring(long __val)\n  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(long),\n         L"%ld", __val); }\n\n  inline wstring\n  to_wstring(unsigned long __val)\n  { retur'
[#] parse_declaration, is_constructor=False, meet line: 'wstring\n  to_wstring(unsigned long __val)\n  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,\n         4 * sizeof(unsigned long),\n         L"%lu", __val); }\n\n  inline wstring\n  to_wstring(lon'
[#] parse_declaration, is_constructor=False, meet line: 'wstring\n  to_wstring(long long __val)\n  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,\n         4 * sizeof(long long),\n         L"%lld", __val); }\n\n  inline wstring\n  to_wstring(unsigned l'
[#] parse_declaration, is_constructor=False, meet line: 'wstring\n  to_wstring(unsigned long long __val)\n  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,\n         4 * sizeof(unsigned long long),\n         L"%llu", __val); }\n\n  inline wstring\n  to_'
[#] parse_declaration, is_constructor=False, meet line: 'wstring\n  to_wstring(float __val)\n  {\n    const int __n =\n      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;\n    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,\n         L"'
[#] parse_declaration, is_constructor=False, meet line: 'wstring\n  to_wstring(double __val)\n  {\n    const int __n =\n      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;\n    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,\n         '
[#] parse_declaration, is_constructor=False, meet line: 'wstring\n  to_wstring(long double __val)\n  {\n    const int __n =\n      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;\n    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,'
[#] parse_declaration, is_constructor=False, meet line: 'bool __enable_hash_call = false;\n    private:\n\n      __poison_hash(__poison_hash&&);\n      ~__poison_hash();\n    };\n\n  template<typename _Tp>\n    struct __poison_hash<_Tp, __void_t<decltype(hash<_Tp>('
[#] parse_declaration, is_constructor=True, meet line: '__poison_hash(__poison_hash&&);\n      ~__poison_hash();\n    };\n\n  template<typename _Tp>\n    struct __poison_hash<_Tp, __void_t<decltype(hash<_Tp>()(declval<_Tp>()))>>\n    {\n      static constexpr boo'
[#] parse_declaration, is_constructor=True, meet line: '__poison_hash();\n    };\n\n  template<typename _Tp>\n    struct __poison_hash<_Tp, __void_t<decltype(hash<_Tp>()(declval<_Tp>()))>>\n    {\n      static constexpr bool __enable_hash_call = true;\n    };\n\n\n '
[#] parse_declaration, is_constructor=False, meet line: 'bool __enable_hash_call = true;\n    };\n\n\n  template<typename _Tp, bool = is_enum<_Tp>::value>\n    struct __hash_enum\n    {\n    private:\n\n      __hash_enum(__hash_enum&&);\n      ~__hash_enum();\n    };\n'
[#] parse_declaration, is_constructor=True, meet line: '__hash_enum(__hash_enum&&);\n      ~__hash_enum();\n    };\n\n\n  template<typename _Tp>\n    struct __hash_enum<_Tp, true> : public __hash_base<size_t, _Tp>\n    {\n      size_t\n      operator()(_Tp __val) c'
[#] parse_declaration, is_constructor=True, meet line: '__hash_enum();\n    };\n\n\n  template<typename _Tp>\n    struct __hash_enum<_Tp, true> : public __hash_base<size_t, _Tp>\n    {\n      size_t\n      operator()(_Tp __val) const noexcept\n      {\n       using '
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n      operator()(_Tp __val) const noexcept\n      {\n       using __type = typename underlying_type<_Tp>::type;\n       return hash<__type>{}(static_cast<__type>(__val));\n      }\n    };\n\n\n\n  templ'
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n      operator()(_Tp* __p) const noexcept\n      { return reinterpret_cast<size_t>(__p); }\n    };\n# 124 "/usr/include/c++/7/bits/functional_hash.h" 3\n  template<> struct hash<bool> : public __ha'
[#] parse_declaration, is_constructor=False, meet line: 'size_t operator()(bool __val) const noexcept { return static_cast<size_t>(__val); } };\n\n\n  template<> struct hash<char> : public __hash_base<size_t, char> { size_t operator()(char __val) const noexcep'
[#] parse_declaration, is_constructor=False, meet line: 'size_t operator()(char __val) const noexcept { return static_cast<size_t>(__val); } };\n\n\n  template<> struct hash<signed char> : public __hash_base<size_t, signed char> { size_t operator()(signed char'
[#] parse_declaration, is_constructor=False, meet line: 'size_t operator()(signed char __val) const noexcept { return static_cast<size_t>(__val); } };\n\n\n  template<> struct hash<unsigned char> : public __hash_base<size_t, unsigned char> { size_t operator()('
[#] parse_declaration, is_constructor=False, meet line: 'size_t operator()(unsigned char __val) const noexcept { return static_cast<size_t>(__val); } };\n\n\n  template<> struct hash<wchar_t> : public __hash_base<size_t, wchar_t> { size_t operator()(wchar_t __'
[#] parse_declaration, is_constructor=False, meet line: 'size_t operator()(wchar_t __val) const noexcept { return static_cast<size_t>(__val); } };\n\n\n  template<> struct hash<char16_t> : public __hash_base<size_t, char16_t> { size_t operator()(char16_t __val'
[#] parse_declaration, is_constructor=False, meet line: 'size_t operator()(char16_t __val) const noexcept { return static_cast<size_t>(__val); } };\n\n\n  template<> struct hash<char32_t> : public __hash_base<size_t, char32_t> { size_t operator()(char32_t __va'
[#] parse_declaration, is_constructor=False, meet line: 'size_t operator()(char32_t __val) const noexcept { return static_cast<size_t>(__val); } };\n\n\n  template<> struct hash<short> : public __hash_base<size_t, short> { size_t operator()(short __val) const '
[#] parse_declaration, is_constructor=False, meet line: 'size_t operator()(short __val) const noexcept { return static_cast<size_t>(__val); } };\n\n\n  template<> struct hash<int> : public __hash_base<size_t, int> { size_t operator()(int __val) const noexcept '
[#] parse_declaration, is_constructor=False, meet line: 'size_t operator()(int __val) const noexcept { return static_cast<size_t>(__val); } };\n\n\n  template<> struct hash<long> : public __hash_base<size_t, long> { size_t operator()(long __val) const noexcept'
[#] parse_declaration, is_constructor=False, meet line: 'size_t operator()(long __val) const noexcept { return static_cast<size_t>(__val); } };\n\n\n  template<> struct hash<long long> : public __hash_base<size_t, long long> { size_t operator()(long long __val'
[#] parse_declaration, is_constructor=False, meet line: 'size_t operator()(long long __val) const noexcept { return static_cast<size_t>(__val); } };\n\n\n  template<> struct hash<unsigned short> : public __hash_base<size_t, unsigned short> { size_t operator()('
[#] parse_declaration, is_constructor=False, meet line: 'size_t operator()(unsigned short __val) const noexcept { return static_cast<size_t>(__val); } };\n\n\n  template<> struct hash<unsigned int> : public __hash_base<size_t, unsigned int> { size_t operator()'
[#] parse_declaration, is_constructor=False, meet line: 'size_t operator()(unsigned int __val) const noexcept { return static_cast<size_t>(__val); } };\n\n\n  template<> struct hash<unsigned long> : public __hash_base<size_t, unsigned long> { size_t operator()'
[#] parse_declaration, is_constructor=False, meet line: 'size_t operator()(unsigned long __val) const noexcept { return static_cast<size_t>(__val); } };\n\n\n  template<> struct hash<unsigned long long> : public __hash_base<size_t, unsigned long long> { size_t'
[#] parse_declaration, is_constructor=False, meet line: 'size_t operator()(unsigned long long __val) const noexcept { return static_cast<size_t>(__val); } };\n\n\n  template<> struct hash<__int128> : public __hash_base<size_t, __int128> { size_t operator()(__i'
[#] parse_declaration, is_constructor=False, meet line: 'size_t operator()(__int128 __val) const noexcept { return static_cast<size_t>(__val); } };\n  template<> struct hash<__int128 unsigned> : public __hash_base<size_t, __int128 unsigned> { size_t operator'
[#] parse_declaration, is_constructor=False, meet line: 'size_t operator()(__int128 unsigned __val) const noexcept { return static_cast<size_t>(__val); } };\n# 187 "/usr/include/c++/7/bits/functional_hash.h" 3\n  struct _Hash_impl\n  {\n    static size_t\n    ha'
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n    hash(const void* __ptr, size_t __clength,\n  size_t __seed = static_cast<size_t>(0xc70f6907UL))\n    { return _Hash_bytes(__ptr, __clength, __seed); }\n\n    template<typename _Tp>\n      static'
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n      hash(const _Tp& __val)\n      { return hash(&__val, sizeof(__val)); }\n\n    template<typename _Tp>\n      static size_t\n      __hash_combine(const _Tp& __val, size_t __hash)\n      { return h'
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n      __hash_combine(const _Tp& __val, size_t __hash)\n      { return hash(&__val, sizeof(__val), __hash); }\n  };\n\n\n  struct _Fnv_hash_impl\n  {\n    static size_t\n    hash(const void* __ptr, size'
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n    hash(const void* __ptr, size_t __clength,\n  size_t __seed = static_cast<size_t>(2166136261UL))\n    { return _Fnv_hash_bytes(__ptr, __clength, __seed); }\n\n    template<typename _Tp>\n      st'
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n      hash(const _Tp& __val)\n      { return hash(&__val, sizeof(__val)); }\n\n    template<typename _Tp>\n      static size_t\n      __hash_combine(const _Tp& __val, size_t __hash)\n      { return h'
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n      __hash_combine(const _Tp& __val, size_t __hash)\n      { return hash(&__val, sizeof(__val), __hash); }\n  };\n\n\n  template<>\n    struct hash<float> : public __hash_base<size_t, float>\n    {\n'
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n      operator()(float __val) const noexcept\n      {\n\n return __val != 0.0f ? std::_Hash_impl::hash(__val) : 0;\n      }\n    };\n\n\n  template<>\n    struct hash<double> : public __hash_base<size_t'
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n      operator()(double __val) const noexcept\n      {\n\n return __val != 0.0 ? std::_Hash_impl::hash(__val) : 0;\n      }\n    };\n\n\n  template<>\n    struct hash<long double>\n    : public __hash_ba'
[#] parse_declaration, is_constructor=False, meet line: '__attribute__ ((__pure__)) size_t\n      operator()(long double __val) const noexcept;\n    };\n\n\n\n\n\n\n\n  template<typename _Hash>\n    struct __is_fast_hash : public std::true_type\n    { };\n\n  template<>\n'
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n      operator()(const string& __s) const noexcept\n      { return std::_Hash_impl::hash(__s.data(), __s.length()); }\n    };\n\n  template<>\n    struct __is_fast_hash<hash<string>> : std::false_ty'
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n      operator()(const wstring& __s) const noexcept\n      { return std::_Hash_impl::hash(__s.data(),\n                                     __s.length() * sizeof(wchar_t)); }\n    };\n\n  template<>'
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n      operator()(const u16string& __s) const noexcept\n      { return std::_Hash_impl::hash(__s.data(),\n                                     __s.length() * sizeof(char16_t)); }\n    };\n\n  templat'
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n      operator()(const u32string& __s) const noexcept\n      { return std::_Hash_impl::hash(__s.data(),\n                                     __s.length() * sizeof(char32_t)); }\n    };\n\n  templat'
[#] parse_declaration, is_constructor=False, meet line: 'basic_string<char>\n    operator""s(const char* __str, size_t __len)\n    { return basic_string<char>{__str, __len}; }\n\n\n    __attribute ((__abi_tag__ ("cxx11")))\n    inline basic_string<wchar_t>\n    op'
[#] parse_declaration, is_constructor=False, meet line: 'basic_string<wchar_t>\n    operator""s(const wchar_t* __str, size_t __len)\n    { return basic_string<wchar_t>{__str, __len}; }\n\n\n\n    __attribute ((__abi_tag__ ("cxx11")))\n    inline basic_string<char1'
[#] parse_declaration, is_constructor=False, meet line: 'basic_string<char16_t>\n    operator""s(const char16_t* __str, size_t __len)\n    { return basic_string<char16_t>{__str, __len}; }\n\n    __attribute ((__abi_tag__ ("cxx11")))\n    inline basic_string<char'
[#] parse_declaration, is_constructor=False, meet line: 'basic_string<char32_t>\n    operator""s(const char32_t* __str, size_t __len)\n    { return basic_string<char32_t>{__str, __len}; }\n\n\n\n  }\n  }\n\n\n\n}\n# 53 "/usr/include/c++/7/string" 2 3\n# 1 "/usr/include/'
[#] parse_declaration, is_constructor=False, meet line: 'basic_string<_CharT, _Traits, _Alloc>::size_type\n    basic_string<_CharT, _Traits, _Alloc>::npos;\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    void\n    basic_string<_CharT, _Tra'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    basic_string<_CharT, _Traits, _Alloc>::\n    swap(basic_string& __s) noexcept\n    {\n      if (this == &__s)\n return;\n\n      _Alloc_traits::_S_on_swap(_M_get_allocator(), __s._M_get_allocator()'
[#] parse_declaration, is_constructor=False, meet line: 'basic_string<_CharT, _Traits, _Alloc>::pointer\n    basic_string<_CharT, _Traits, _Alloc>::\n    _M_create(size_type& __capacity, size_type __old_capacity)\n    {\n\n\n      if (__capacity > max_size())\n st'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      basic_string<_CharT, _Traits, _Alloc>::\n      _M_construct(_InIterator __beg, _InIterator __end,\n     std::input_iterator_tag)\n      {\n size_type __len = 0;\n size_type __capacity = size_typ'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      basic_string<_CharT, _Traits, _Alloc>::\n      _M_construct(_InIterator __beg, _InIterator __end,\n     std::forward_iterator_tag)\n      {\n\n if (__gnu_cxx::__is_null_pointer(__beg) && __beg !'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    basic_string<_CharT, _Traits, _Alloc>::\n    _M_construct(size_type __n, _CharT __c)\n    {\n      if (__n > size_type(_S_local_capacity))\n {\n   _M_data(_M_create(__n, size_type(0)));\n   _M_capa'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    basic_string<_CharT, _Traits, _Alloc>::\n    _M_assign(const basic_string& __str)\n    {\n      if (this != &__str)\n {\n   const size_type __rsize = __str.length();\n   const size_type __capacity '
[#] parse_declaration, is_constructor=False, meet line: 'void\n    basic_string<_CharT, _Traits, _Alloc>::\n    reserve(size_type __res)\n    {\n\n      if (__res < length())\n __res = length();\n\n      const size_type __capacity = capacity();\n      if (__res != _'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    basic_string<_CharT, _Traits, _Alloc>::\n    _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,\n       size_type __len2)\n    {\n      const size_type __how_much = length() - __pos '
[#] parse_declaration, is_constructor=False, meet line: 'void\n    basic_string<_CharT, _Traits, _Alloc>::\n    _M_erase(size_type __pos, size_type __n)\n    {\n      const size_type __how_much = length() - __pos - __n;\n\n      if (__how_much && __n)\n this->_S_m'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    basic_string<_CharT, _Traits, _Alloc>::\n    resize(size_type __n, _CharT __c)\n    {\n      const size_type __size = this->size();\n      if (__size < __n)\n this->append(__n - __size, __c);\n    '
[#] parse_declaration, is_constructor=False, meet line: 'basic_string<_CharT, _Traits, _Alloc>&\n    basic_string<_CharT, _Traits, _Alloc>::\n    _M_append(const _CharT* __s, size_type __n)\n    {\n      const size_type __len = __n + this->size();\n\n      if (__'
[#] parse_declaration, is_constructor=False, meet line: 'basic_string<_CharT, _Traits, _Alloc>&\n      basic_string<_CharT, _Traits, _Alloc>::\n      _M_replace_dispatch(const_iterator __i1, const_iterator __i2,\n     _InputIterator __k1, _InputIterator __k2,\n'
[#] parse_declaration, is_constructor=False, meet line: 'basic_string<_CharT, _Traits, _Alloc>&\n    basic_string<_CharT, _Traits, _Alloc>::\n    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,\n     _CharT __c)\n    {\n      _M_check_length(__n'
[#] parse_declaration, is_constructor=False, meet line: 'basic_string<_CharT, _Traits, _Alloc>&\n    basic_string<_CharT, _Traits, _Alloc>::\n    _M_replace(size_type __pos, size_type __len1, const _CharT* __s,\n        const size_type __len2)\n    {\n      _M_c'
[#] parse_declaration, is_constructor=False, meet line: 'basic_string<_CharT, _Traits, _Alloc>::size_type\n    basic_string<_CharT, _Traits, _Alloc>::\n    copy(_CharT* __s, size_type __n, size_type __pos) const\n    {\n      _M_check(__pos, "basic_string::copy'
[#] parse_declaration, is_constructor=False, meet line: 'basic_string<_CharT, _Traits, _Alloc>\n    operator+(const _CharT* __lhs,\n       const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    {\n      ;\n      typedef basic_string<_CharT, _Traits, _Alloc> __'
[#] parse_declaration, is_constructor=False, meet line: 'basic_string<_CharT, _Traits, _Alloc>\n    operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    {\n      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;\n      typ'
[#] parse_declaration, is_constructor=False, meet line: 'basic_string<_CharT, _Traits, _Alloc>::size_type\n    basic_string<_CharT, _Traits, _Alloc>::\n    find(const _CharT* __s, size_type __pos, size_type __n) const\n    noexcept\n    {\n      ;\n      const si'
[#] parse_declaration, is_constructor=False, meet line: 'basic_string<_CharT, _Traits, _Alloc>::size_type\n    basic_string<_CharT, _Traits, _Alloc>::\n    find(_CharT __c, size_type __pos) const noexcept\n    {\n      size_type __ret = npos;\n      const size_t'
[#] parse_declaration, is_constructor=False, meet line: 'basic_string<_CharT, _Traits, _Alloc>::size_type\n    basic_string<_CharT, _Traits, _Alloc>::\n    rfind(const _CharT* __s, size_type __pos, size_type __n) const\n    noexcept\n    {\n      ;\n      const s'
[#] parse_declaration, is_constructor=False, meet line: 'basic_string<_CharT, _Traits, _Alloc>::size_type\n    basic_string<_CharT, _Traits, _Alloc>::\n    rfind(_CharT __c, size_type __pos) const noexcept\n    {\n      size_type __size = this->size();\n      if'
[#] parse_declaration, is_constructor=False, meet line: 'basic_string<_CharT, _Traits, _Alloc>::size_type\n    basic_string<_CharT, _Traits, _Alloc>::\n    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const\n    noexcept\n    {\n      ;\n     '
[#] parse_declaration, is_constructor=False, meet line: 'basic_string<_CharT, _Traits, _Alloc>::size_type\n    basic_string<_CharT, _Traits, _Alloc>::\n    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const\n    noexcept\n    {\n      ;\n      '
[#] parse_declaration, is_constructor=False, meet line: 'basic_string<_CharT, _Traits, _Alloc>::size_type\n    basic_string<_CharT, _Traits, _Alloc>::\n    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const\n    noexcept\n    {\n      ;\n '
[#] parse_declaration, is_constructor=False, meet line: 'basic_string<_CharT, _Traits, _Alloc>::size_type\n    basic_string<_CharT, _Traits, _Alloc>::\n    find_first_not_of(_CharT __c, size_type __pos) const noexcept\n    {\n      for (; __pos < this->size(); '
[#] parse_declaration, is_constructor=False, meet line: 'basic_string<_CharT, _Traits, _Alloc>::size_type\n    basic_string<_CharT, _Traits, _Alloc>::\n    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const\n    noexcept\n    {\n      ;\n  '
[#] parse_declaration, is_constructor=False, meet line: 'basic_string<_CharT, _Traits, _Alloc>::size_type\n    basic_string<_CharT, _Traits, _Alloc>::\n    find_last_not_of(_CharT __c, size_type __pos) const noexcept\n    {\n      size_type __size = this->size('
[#] parse_declaration, is_constructor=False, meet line: 'int\n    basic_string<_CharT, _Traits, _Alloc>::\n    compare(size_type __pos, size_type __n, const basic_string& __str) const\n    {\n      _M_check(__pos, "basic_string::compare");\n      __n = _M_limit('
[#] parse_declaration, is_constructor=False, meet line: 'int\n    basic_string<_CharT, _Traits, _Alloc>::\n    compare(size_type __pos1, size_type __n1, const basic_string& __str,\n     size_type __pos2, size_type __n2) const\n    {\n      _M_check(__pos1, "basi'
[#] parse_declaration, is_constructor=False, meet line: 'int\n    basic_string<_CharT, _Traits, _Alloc>::\n    compare(const _CharT* __s) const noexcept\n    {\n      ;\n      const size_type __size = this->size();\n      const size_type __osize = traits_type::le'
[#] parse_declaration, is_constructor=False, meet line: 'int\n    basic_string <_CharT, _Traits, _Alloc>::\n    compare(size_type __pos, size_type __n1, const _CharT* __s) const\n    {\n      ;\n      _M_check(__pos, "basic_string::compare");\n      __n1 = _M_lim'
[#] parse_declaration, is_constructor=False, meet line: 'int\n    basic_string <_CharT, _Traits, _Alloc>::\n    compare(size_type __pos, size_type __n1, const _CharT* __s,\n     size_type __n2) const\n    {\n      ;\n      _M_check(__pos, "basic_string::compare")'
[#] parse_declaration, is_constructor=False, meet line: 'basic_istream<_CharT, _Traits>&\n    operator>>(basic_istream<_CharT, _Traits>& __in,\n        basic_string<_CharT, _Traits, _Alloc>& __str)\n    {\n      typedef basic_istream<_CharT, _Traits> __istream_'
[#] parse_declaration, is_constructor=False, meet line: 'basic_istream<_CharT, _Traits>&\n    getline(basic_istream<_CharT, _Traits>& __in,\n     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)\n    {\n      typedef basic_istream<_CharT, _Traits> '
[#] parse_declaration, is_constructor=False, meet line: 'template class basic_string<char>;\n\n\n\n\n\n\n\n  extern template\n    basic_istream<char>&\n    operator>>(basic_istream<char>&, string&);\n  extern template\n    basic_ostream<char>&\n    operator<<(basic_ostr'
[#] parse_declaration, is_constructor=False, meet line: 'template\n    basic_istream<char>&\n    operator>>(basic_istream<char>&, string&);\n  extern template\n    basic_ostream<char>&\n    operator<<(basic_ostream<char>&, const string&);\n  extern template\n    b'
[#] parse_declaration, is_constructor=False, meet line: 'template\n    basic_ostream<char>&\n    operator<<(basic_ostream<char>&, const string&);\n  extern template\n    basic_istream<char>&\n    getline(basic_istream<char>&, string&, char);\n  extern template\n  '
[#] parse_declaration, is_constructor=False, meet line: 'template\n    basic_istream<char>&\n    getline(basic_istream<char>&, string&, char);\n  extern template\n    basic_istream<char>&\n    getline(basic_istream<char>&, string&);\n\n\n\n  extern template class ba'
[#] parse_declaration, is_constructor=False, meet line: 'template\n    basic_istream<char>&\n    getline(basic_istream<char>&, string&);\n\n\n\n  extern template class basic_string<wchar_t>;\n\n\n\n\n\n  extern template\n    basic_istream<wchar_t>&\n    operator>>(basic_'
[#] parse_declaration, is_constructor=False, meet line: 'template class basic_string<wchar_t>;\n\n\n\n\n\n  extern template\n    basic_istream<wchar_t>&\n    operator>>(basic_istream<wchar_t>&, wstring&);\n  extern template\n    basic_ostream<wchar_t>&\n    operator<<'
[#] parse_declaration, is_constructor=False, meet line: 'template\n    basic_istream<wchar_t>&\n    operator>>(basic_istream<wchar_t>&, wstring&);\n  extern template\n    basic_ostream<wchar_t>&\n    operator<<(basic_ostream<wchar_t>&, const wstring&);\n  extern '
[#] parse_declaration, is_constructor=False, meet line: 'template\n    basic_ostream<wchar_t>&\n    operator<<(basic_ostream<wchar_t>&, const wstring&);\n  extern template\n    basic_istream<wchar_t>&\n    getline(basic_istream<wchar_t>&, wstring&, wchar_t);\n  e'
[#] parse_declaration, is_constructor=False, meet line: 'template\n    basic_istream<wchar_t>&\n    getline(basic_istream<wchar_t>&, wstring&, wchar_t);\n  extern template\n    basic_istream<wchar_t>&\n    getline(basic_istream<wchar_t>&, wstring&);\n\n\n\n\n}\n# 54 "'
[#] parse_declaration, is_constructor=False, meet line: 'template\n    basic_istream<wchar_t>&\n    getline(basic_istream<wchar_t>&, wstring&);\n\n\n\n\n}\n# 54 "/usr/include/c++/7/string" 2 3\n# 48 "/usr/include/c++/7/bitset" 2 3\n# 60 "/usr/include/c++/7/bitset" 3\n'
[#] parse_declaration, is_constructor=False, meet line: '_WordT _M_w[_Nw];\n\n      constexpr _Base_bitset() noexcept\n      : _M_w() { }\n\n\n      constexpr _Base_bitset(unsigned long long __val) noexcept\n      : _M_w{ _WordT(__val)\n\n\n\n       } { }\n\n\n\n\n\n\n      '
[#] parse_declaration, is_constructor=True, meet line: '_Base_bitset() noexcept\n      : _M_w() { }\n\n\n      constexpr _Base_bitset(unsigned long long __val) noexcept\n      : _M_w{ _WordT(__val)\n\n\n\n       } { }\n\n\n\n\n\n\n      static constexpr size_t\n      _S_wh'
[#] parse_declaration, is_constructor=True, meet line: '_Base_bitset(unsigned long long __val) noexcept\n      : _M_w{ _WordT(__val)\n\n\n\n       } { }\n\n\n\n\n\n\n      static constexpr size_t\n      _S_whichword(size_t __pos) noexcept\n      { return __pos / (8 * 8)'
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n      _S_whichword(size_t __pos) noexcept\n      { return __pos / (8 * 8); }\n\n      static constexpr size_t\n      _S_whichbyte(size_t __pos) noexcept\n      { return (__pos % (8 * 8)) / 8; }\n\n   '
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n      _S_whichbyte(size_t __pos) noexcept\n      { return (__pos % (8 * 8)) / 8; }\n\n      static constexpr size_t\n      _S_whichbit(size_t __pos) noexcept\n      { return __pos % (8 * 8); }\n\n    '
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n      _S_whichbit(size_t __pos) noexcept\n      { return __pos % (8 * 8); }\n\n      static constexpr _WordT\n      _S_maskbit(size_t __pos) noexcept\n      { return (static_cast<_WordT>(1)) << _S_w'
[#] parse_declaration, is_constructor=False, meet line: '_WordT\n      _S_maskbit(size_t __pos) noexcept\n      { return (static_cast<_WordT>(1)) << _S_whichbit(__pos); }\n\n      _WordT&\n      _M_getword(size_t __pos) noexcept\n      { return _M_w[_S_whichword('
[#] parse_declaration, is_constructor=False, meet line: '_WordT&\n      _M_getword(size_t __pos) noexcept\n      { return _M_w[_S_whichword(__pos)]; }\n\n      constexpr _WordT\n      _M_getword(size_t __pos) const noexcept\n      { return _M_w[_S_whichword(__pos'
[#] parse_declaration, is_constructor=False, meet line: '_WordT\n      _M_getword(size_t __pos) const noexcept\n      { return _M_w[_S_whichword(__pos)]; }\n\n\n      const _WordT*\n      _M_getdata() const noexcept\n      { return _M_w; }\n\n\n      _WordT&\n      _M'
[#] parse_declaration, is_constructor=False, meet line: '_WordT*\n      _M_getdata() const noexcept\n      { return _M_w; }\n\n\n      _WordT&\n      _M_hiword() noexcept\n      { return _M_w[_Nw - 1]; }\n\n      constexpr _WordT\n      _M_hiword() const noexcept\n   '
[#] parse_declaration, is_constructor=False, meet line: '_WordT&\n      _M_hiword() noexcept\n      { return _M_w[_Nw - 1]; }\n\n      constexpr _WordT\n      _M_hiword() const noexcept\n      { return _M_w[_Nw - 1]; }\n\n      void\n      _M_do_and(const _Base_bits'
[#] parse_declaration, is_constructor=False, meet line: '_WordT\n      _M_hiword() const noexcept\n      { return _M_w[_Nw - 1]; }\n\n      void\n      _M_do_and(const _Base_bitset<_Nw>& __x) noexcept\n      {\n for (size_t __i = 0; __i < _Nw; __i++)\n   _M_w[__i] '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_do_and(const _Base_bitset<_Nw>& __x) noexcept\n      {\n for (size_t __i = 0; __i < _Nw; __i++)\n   _M_w[__i] &= __x._M_w[__i];\n      }\n\n      void\n      _M_do_or(const _Base_bitset<_Nw>& _'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_do_or(const _Base_bitset<_Nw>& __x) noexcept\n      {\n for (size_t __i = 0; __i < _Nw; __i++)\n   _M_w[__i] |= __x._M_w[__i];\n      }\n\n      void\n      _M_do_xor(const _Base_bitset<_Nw>& _'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_do_xor(const _Base_bitset<_Nw>& __x) noexcept\n      {\n for (size_t __i = 0; __i < _Nw; __i++)\n   _M_w[__i] ^= __x._M_w[__i];\n      }\n\n      void\n      _M_do_left_shift(size_t __shift) no'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_do_left_shift(size_t __shift) noexcept;\n\n      void\n      _M_do_right_shift(size_t __shift) noexcept;\n\n      void\n      _M_do_flip() noexcept\n      {\n for (size_t __i = 0; __i < _Nw; __i'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_do_right_shift(size_t __shift) noexcept;\n\n      void\n      _M_do_flip() noexcept\n      {\n for (size_t __i = 0; __i < _Nw; __i++)\n   _M_w[__i] = ~_M_w[__i];\n      }\n\n      void\n      _M_d'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_do_flip() noexcept\n      {\n for (size_t __i = 0; __i < _Nw; __i++)\n   _M_w[__i] = ~_M_w[__i];\n      }\n\n      void\n      _M_do_set() noexcept\n      {\n for (size_t __i = 0; __i < _Nw; __i+'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_do_set() noexcept\n      {\n for (size_t __i = 0; __i < _Nw; __i++)\n   _M_w[__i] = ~static_cast<_WordT>(0);\n      }\n\n      void\n      _M_do_reset() noexcept\n      { __builtin_memset(_M_w, '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_do_reset() noexcept\n      { __builtin_memset(_M_w, 0, _Nw * sizeof(_WordT)); }\n\n      bool\n      _M_is_equal(const _Base_bitset<_Nw>& __x) const noexcept\n      {\n for (size_t __i = 0; __'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      _M_is_equal(const _Base_bitset<_Nw>& __x) const noexcept\n      {\n for (size_t __i = 0; __i < _Nw; ++__i)\n   if (_M_w[__i] != __x._M_w[__i])\n     return false;\n return true;\n      }\n\n      t'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n        _M_are_all() const noexcept\n        {\n   for (size_t __i = 0; __i < _Nw - 1; __i++)\n     if (_M_w[__i] != ~static_cast<_WordT>(0))\n       return false;\n   return _M_hiword() == (~static_c'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      _M_is_any() const noexcept\n      {\n for (size_t __i = 0; __i < _Nw; __i++)\n   if (_M_w[__i] != static_cast<_WordT>(0))\n     return true;\n return false;\n      }\n\n      size_t\n      _M_do_cou'
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n      _M_do_count() const noexcept\n      {\n size_t __result = 0;\n for (size_t __i = 0; __i < _Nw; __i++)\n   __result += __builtin_popcountl(_M_w[__i]);\n return __result;\n      }\n\n      unsigned'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned long\n      _M_do_to_ulong() const;\n\n\n      unsigned long long\n      _M_do_to_ullong() const;\n\n\n\n      size_t\n      _M_do_find_first(size_t) const noexcept;\n\n\n      size_t\n      _M_do_find_nex'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned long long\n      _M_do_to_ullong() const;\n\n\n\n      size_t\n      _M_do_find_first(size_t) const noexcept;\n\n\n      size_t\n      _M_do_find_next(size_t, size_t) const noexcept;\n    };\n\n\n  templat'
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n      _M_do_find_first(size_t) const noexcept;\n\n\n      size_t\n      _M_do_find_next(size_t, size_t) const noexcept;\n    };\n\n\n  template<size_t _Nw>\n    void\n    _Base_bitset<_Nw>::_M_do_left_sh'
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n      _M_do_find_next(size_t, size_t) const noexcept;\n    };\n\n\n  template<size_t _Nw>\n    void\n    _Base_bitset<_Nw>::_M_do_left_shift(size_t __shift) noexcept\n    {\n      if (__builtin_expect('
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _Base_bitset<_Nw>::_M_do_left_shift(size_t __shift) noexcept\n    {\n      if (__builtin_expect(__shift != 0, 1))\n {\n   const size_t __wshift = __shift / (8 * 8);\n   const size_t __offset = __s'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _Base_bitset<_Nw>::_M_do_right_shift(size_t __shift) noexcept\n    {\n      if (__builtin_expect(__shift != 0, 1))\n {\n   const size_t __wshift = __shift / (8 * 8);\n   const size_t __offset = __'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned long\n    _Base_bitset<_Nw>::_M_do_to_ulong() const\n    {\n      for (size_t __i = 1; __i < _Nw; ++__i)\n if (_M_w[__i])\n   __throw_overflow_error(("_Base_bitset::_M_do_to_ulong"));\n      return'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned long long\n    _Base_bitset<_Nw>::_M_do_to_ullong() const\n    {\n      const bool __dw = sizeof(unsigned long long) > sizeof(unsigned long);\n      for (size_t __i = 1 + __dw; __i < _Nw; ++__i)\n'
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n    _Base_bitset<_Nw>::\n    _M_do_find_first(size_t __not_found) const noexcept\n    {\n      for (size_t __i = 0; __i < _Nw; __i++)\n {\n   _WordT __thisword = _M_w[__i];\n   if (__thisword != stat'
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n    _Base_bitset<_Nw>::\n    _M_do_find_next(size_t __prev, size_t __not_found) const noexcept\n    {\n\n      ++__prev;\n\n\n      if (__prev >= _Nw * (8 * 8))\n return __not_found;\n\n\n      size_t __i'
[#] parse_declaration, is_constructor=False, meet line: '_WordT _M_w;\n\n      constexpr _Base_bitset() noexcept\n      : _M_w(0)\n      { }\n\n\n      constexpr _Base_bitset(unsigned long long __val) noexcept\n\n\n\n      : _M_w(__val)\n      { }\n\n      static constex'
[#] parse_declaration, is_constructor=True, meet line: '_Base_bitset() noexcept\n      : _M_w(0)\n      { }\n\n\n      constexpr _Base_bitset(unsigned long long __val) noexcept\n\n\n\n      : _M_w(__val)\n      { }\n\n      static constexpr size_t\n      _S_whichword(s'
[#] parse_declaration, is_constructor=True, meet line: '_Base_bitset(unsigned long long __val) noexcept\n\n\n\n      : _M_w(__val)\n      { }\n\n      static constexpr size_t\n      _S_whichword(size_t __pos) noexcept\n      { return __pos / (8 * 8); }\n\n      stati'
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n      _S_whichword(size_t __pos) noexcept\n      { return __pos / (8 * 8); }\n\n      static constexpr size_t\n      _S_whichbyte(size_t __pos) noexcept\n      { return (__pos % (8 * 8)) / 8; }\n\n   '
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n      _S_whichbyte(size_t __pos) noexcept\n      { return (__pos % (8 * 8)) / 8; }\n\n      static constexpr size_t\n      _S_whichbit(size_t __pos) noexcept\n      { return __pos % (8 * 8); }\n\n    '
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n      _S_whichbit(size_t __pos) noexcept\n      { return __pos % (8 * 8); }\n\n      static constexpr _WordT\n      _S_maskbit(size_t __pos) noexcept\n      { return (static_cast<_WordT>(1)) << _S_w'
[#] parse_declaration, is_constructor=False, meet line: '_WordT\n      _S_maskbit(size_t __pos) noexcept\n      { return (static_cast<_WordT>(1)) << _S_whichbit(__pos); }\n\n      _WordT&\n      _M_getword(size_t) noexcept\n      { return _M_w; }\n\n      constexpr'
[#] parse_declaration, is_constructor=False, meet line: '_WordT&\n      _M_getword(size_t) noexcept\n      { return _M_w; }\n\n      constexpr _WordT\n      _M_getword(size_t) const noexcept\n      { return _M_w; }\n\n\n      const _WordT*\n      _M_getdata() const n'
[#] parse_declaration, is_constructor=False, meet line: '_WordT\n      _M_getword(size_t) const noexcept\n      { return _M_w; }\n\n\n      const _WordT*\n      _M_getdata() const noexcept\n      { return &_M_w; }\n\n\n      _WordT&\n      _M_hiword() noexcept\n      {'
[#] parse_declaration, is_constructor=False, meet line: '_WordT*\n      _M_getdata() const noexcept\n      { return &_M_w; }\n\n\n      _WordT&\n      _M_hiword() noexcept\n      { return _M_w; }\n\n      constexpr _WordT\n      _M_hiword() const noexcept\n      { ret'
[#] parse_declaration, is_constructor=False, meet line: '_WordT&\n      _M_hiword() noexcept\n      { return _M_w; }\n\n      constexpr _WordT\n      _M_hiword() const noexcept\n      { return _M_w; }\n\n      void\n      _M_do_and(const _Base_bitset<1>& __x) noexce'
[#] parse_declaration, is_constructor=False, meet line: '_WordT\n      _M_hiword() const noexcept\n      { return _M_w; }\n\n      void\n      _M_do_and(const _Base_bitset<1>& __x) noexcept\n      { _M_w &= __x._M_w; }\n\n      void\n      _M_do_or(const _Base_bitse'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_do_and(const _Base_bitset<1>& __x) noexcept\n      { _M_w &= __x._M_w; }\n\n      void\n      _M_do_or(const _Base_bitset<1>& __x) noexcept\n      { _M_w |= __x._M_w; }\n\n      void\n      _M_d'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_do_or(const _Base_bitset<1>& __x) noexcept\n      { _M_w |= __x._M_w; }\n\n      void\n      _M_do_xor(const _Base_bitset<1>& __x) noexcept\n      { _M_w ^= __x._M_w; }\n\n      void\n      _M_d'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_do_xor(const _Base_bitset<1>& __x) noexcept\n      { _M_w ^= __x._M_w; }\n\n      void\n      _M_do_left_shift(size_t __shift) noexcept\n      { _M_w <<= __shift; }\n\n      void\n      _M_do_ri'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_do_left_shift(size_t __shift) noexcept\n      { _M_w <<= __shift; }\n\n      void\n      _M_do_right_shift(size_t __shift) noexcept\n      { _M_w >>= __shift; }\n\n      void\n      _M_do_flip()'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_do_right_shift(size_t __shift) noexcept\n      { _M_w >>= __shift; }\n\n      void\n      _M_do_flip() noexcept\n      { _M_w = ~_M_w; }\n\n      void\n      _M_do_set() noexcept\n      { _M_w = '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_do_flip() noexcept\n      { _M_w = ~_M_w; }\n\n      void\n      _M_do_set() noexcept\n      { _M_w = ~static_cast<_WordT>(0); }\n\n      void\n      _M_do_reset() noexcept\n      { _M_w = 0; }\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_do_set() noexcept\n      { _M_w = ~static_cast<_WordT>(0); }\n\n      void\n      _M_do_reset() noexcept\n      { _M_w = 0; }\n\n      bool\n      _M_is_equal(const _Base_bitset<1>& __x) const n'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_do_reset() noexcept\n      { _M_w = 0; }\n\n      bool\n      _M_is_equal(const _Base_bitset<1>& __x) const noexcept\n      { return _M_w == __x._M_w; }\n\n      template<size_t _Nb>\n        bo'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      _M_is_equal(const _Base_bitset<1>& __x) const noexcept\n      { return _M_w == __x._M_w; }\n\n      template<size_t _Nb>\n        bool\n        _M_are_all() const noexcept\n        { return _M_w '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n        _M_are_all() const noexcept\n        { return _M_w == (~static_cast<_WordT>(0)\n     >> ((8 * 8) - _Nb)); }\n\n      bool\n      _M_is_any() const noexcept\n      { return _M_w != 0; }\n\n      s'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      _M_is_any() const noexcept\n      { return _M_w != 0; }\n\n      size_t\n      _M_do_count() const noexcept\n      { return __builtin_popcountl(_M_w); }\n\n      unsigned long\n      _M_do_to_ulong'
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n      _M_do_count() const noexcept\n      { return __builtin_popcountl(_M_w); }\n\n      unsigned long\n      _M_do_to_ulong() const noexcept\n      { return _M_w; }\n\n\n      unsigned long long\n     '
[#] parse_declaration, is_constructor=False, meet line: 'unsigned long\n      _M_do_to_ulong() const noexcept\n      { return _M_w; }\n\n\n      unsigned long long\n      _M_do_to_ullong() const noexcept\n      { return _M_w; }\n\n\n      size_t\n      _M_do_find_firs'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned long long\n      _M_do_to_ullong() const noexcept\n      { return _M_w; }\n\n\n      size_t\n      _M_do_find_first(size_t __not_found) const noexcept\n      {\n        if (_M_w != 0)\n          retur'
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n      _M_do_find_first(size_t __not_found) const noexcept\n      {\n        if (_M_w != 0)\n          return __builtin_ctzl(_M_w);\n        else\n          return __not_found;\n      }\n\n\n      size_t'
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n      _M_do_find_next(size_t __prev, size_t __not_found) const\n noexcept\n      {\n ++__prev;\n if (__prev >= ((size_t) (8 * 8)))\n   return __not_found;\n\n _WordT __x = _M_w >> __prev;\n if (__x != '
[#] parse_declaration, is_constructor=True, meet line: '_Base_bitset() noexcept\n      { }\n\n\n      constexpr _Base_bitset(unsigned long long) noexcept\n\n\n\n      { }\n\n      static constexpr size_t\n      _S_whichword(size_t __pos) noexcept\n      { return __pos'
[#] parse_declaration, is_constructor=True, meet line: '_Base_bitset(unsigned long long) noexcept\n\n\n\n      { }\n\n      static constexpr size_t\n      _S_whichword(size_t __pos) noexcept\n      { return __pos / (8 * 8); }\n\n      static constexpr size_t\n      _'
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n      _S_whichword(size_t __pos) noexcept\n      { return __pos / (8 * 8); }\n\n      static constexpr size_t\n      _S_whichbyte(size_t __pos) noexcept\n      { return (__pos % (8 * 8)) / 8; }\n\n   '
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n      _S_whichbyte(size_t __pos) noexcept\n      { return (__pos % (8 * 8)) / 8; }\n\n      static constexpr size_t\n      _S_whichbit(size_t __pos) noexcept\n      { return __pos % (8 * 8); }\n\n    '
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n      _S_whichbit(size_t __pos) noexcept\n      { return __pos % (8 * 8); }\n\n      static constexpr _WordT\n      _S_maskbit(size_t __pos) noexcept\n      { return (static_cast<_WordT>(1)) << _S_w'
[#] parse_declaration, is_constructor=False, meet line: '_WordT\n      _S_maskbit(size_t __pos) noexcept\n      { return (static_cast<_WordT>(1)) << _S_whichbit(__pos); }\n# 556 "/usr/include/c++/7/bitset" 3\n      _WordT&\n      _M_getword(size_t) noexcept\n    '
[#] parse_declaration, is_constructor=False, meet line: '_WordT&\n      _M_getword(size_t) noexcept\n      {\n __throw_out_of_range(("_Base_bitset::_M_getword"));\n return *new _WordT;\n      }\n\n      constexpr _WordT\n      _M_getword(size_t __pos) const noexcep'
[#] parse_declaration, is_constructor=False, meet line: '_WordT\n      _M_getword(size_t __pos) const noexcept\n      { return 0; }\n\n      constexpr _WordT\n      _M_hiword() const noexcept\n      { return 0; }\n\n      void\n      _M_do_and(const _Base_bitset<0>&'
[#] parse_declaration, is_constructor=False, meet line: '_WordT\n      _M_hiword() const noexcept\n      { return 0; }\n\n      void\n      _M_do_and(const _Base_bitset<0>&) noexcept\n      { }\n\n      void\n      _M_do_or(const _Base_bitset<0>&) noexcept\n      { }'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_do_and(const _Base_bitset<0>&) noexcept\n      { }\n\n      void\n      _M_do_or(const _Base_bitset<0>&) noexcept\n      { }\n\n      void\n      _M_do_xor(const _Base_bitset<0>&) noexcept\n     '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_do_or(const _Base_bitset<0>&) noexcept\n      { }\n\n      void\n      _M_do_xor(const _Base_bitset<0>&) noexcept\n      { }\n\n      void\n      _M_do_left_shift(size_t) noexcept\n      { }\n\n   '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_do_xor(const _Base_bitset<0>&) noexcept\n      { }\n\n      void\n      _M_do_left_shift(size_t) noexcept\n      { }\n\n      void\n      _M_do_right_shift(size_t) noexcept\n      { }\n\n      void'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_do_left_shift(size_t) noexcept\n      { }\n\n      void\n      _M_do_right_shift(size_t) noexcept\n      { }\n\n      void\n      _M_do_flip() noexcept\n      { }\n\n      void\n      _M_do_set() no'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_do_right_shift(size_t) noexcept\n      { }\n\n      void\n      _M_do_flip() noexcept\n      { }\n\n      void\n      _M_do_set() noexcept\n      { }\n\n      void\n      _M_do_reset() noexcept\n    '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_do_flip() noexcept\n      { }\n\n      void\n      _M_do_set() noexcept\n      { }\n\n      void\n      _M_do_reset() noexcept\n      { }\n\n\n\n\n      bool\n      _M_is_equal(const _Base_bitset<0>&) '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_do_set() noexcept\n      { }\n\n      void\n      _M_do_reset() noexcept\n      { }\n\n\n\n\n      bool\n      _M_is_equal(const _Base_bitset<0>&) const noexcept\n      { return true; }\n\n      templ'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_do_reset() noexcept\n      { }\n\n\n\n\n      bool\n      _M_is_equal(const _Base_bitset<0>&) const noexcept\n      { return true; }\n\n      template<size_t _Nb>\n        bool\n        _M_are_all()'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      _M_is_equal(const _Base_bitset<0>&) const noexcept\n      { return true; }\n\n      template<size_t _Nb>\n        bool\n        _M_are_all() const noexcept\n        { return true; }\n\n      bool\n '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n        _M_are_all() const noexcept\n        { return true; }\n\n      bool\n      _M_is_any() const noexcept\n      { return false; }\n\n      size_t\n      _M_do_count() const noexcept\n      { return 0'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      _M_is_any() const noexcept\n      { return false; }\n\n      size_t\n      _M_do_count() const noexcept\n      { return 0; }\n\n      unsigned long\n      _M_do_to_ulong() const noexcept\n      { re'
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n      _M_do_count() const noexcept\n      { return 0; }\n\n      unsigned long\n      _M_do_to_ulong() const noexcept\n      { return 0; }\n\n\n      unsigned long long\n      _M_do_to_ullong() const no'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned long\n      _M_do_to_ulong() const noexcept\n      { return 0; }\n\n\n      unsigned long long\n      _M_do_to_ullong() const noexcept\n      { return 0; }\n\n\n\n\n      size_t\n      _M_do_find_first(si'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned long long\n      _M_do_to_ullong() const noexcept\n      { return 0; }\n\n\n\n\n      size_t\n      _M_do_find_first(size_t) const noexcept\n      { return 0; }\n\n      size_t\n      _M_do_find_next(siz'
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n      _M_do_find_first(size_t) const noexcept\n      { return 0; }\n\n      size_t\n      _M_do_find_next(size_t, size_t) const noexcept\n      { return 0; }\n    };\n\n\n\n  template<size_t _Extrabits>\n'
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n      _M_do_find_next(size_t, size_t) const noexcept\n      { return 0; }\n    };\n\n\n\n  template<size_t _Extrabits>\n    struct _Sanitize\n    {\n      typedef unsigned long _WordT;\n\n      static voi'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _S_do_sanitize(_WordT& __val) noexcept\n      { __val &= ~((~static_cast<_WordT>(0)) << _Extrabits); }\n    };\n\n  template<>\n    struct _Sanitize<0>\n    {\n      typedef unsigned long _WordT;\n'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _S_do_sanitize(_WordT) noexcept { }\n    };\n\n\n  template<size_t _Nb, bool = (_Nb < (8 * 8))>\n    struct _Sanitize_val\n    {\n      static constexpr unsigned long long\n      _S_do_sanitize_val'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned long long\n      _S_do_sanitize_val(unsigned long long __val)\n      { return __val; }\n    };\n\n  template<size_t _Nb>\n    struct _Sanitize_val<_Nb, true>\n    {\n      static constexpr unsigned l'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned long long\n      _S_do_sanitize_val(unsigned long long __val)\n      { return __val & ~((~static_cast<unsigned long long>(0)) << _Nb); }\n    };\n# 746 "/usr/include/c++/7/bitset" 3\n  template<si'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_check_initial_position(const std::basic_string<_CharT, _Traits, _Alloc>& __s,\n    size_t __position) const\n      {\n if (__position > __s.size())\n   __throw_out_of_range_fmt(("bitset::bit'
[#] parse_declaration, is_constructor=False, meet line: 'void _M_check(size_t __position, const char *__s) const\n      {\n if (__position >= _Nb)\n   __throw_out_of_range_fmt(("%s: __position (which is %zu) " ">= _Nb (which is %zu)")\n                         '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_do_sanitize() noexcept\n      {\n typedef _Sanitize<_Nb % (8 * 8)> __sanitize_type;\n __sanitize_type::_S_do_sanitize(this->_M_hiword());\n      }\n\n\n      template<typename> friend struct ha'
[#] parse_declaration, is_constructor=False, meet line: '_WordT* _M_wp;\n size_t _M_bpos;\n\n\n reference();\n\n      public:\n reference(bitset& __b, size_t __pos) noexcept\n {\n   _M_wp = &__b._M_getword(__pos);\n   _M_bpos = _Base::_S_whichbit(__pos);\n }\n\n ~refere'
[#] parse_declaration, is_constructor=False, meet line: 'size_t _M_bpos;\n\n\n reference();\n\n      public:\n reference(bitset& __b, size_t __pos) noexcept\n {\n   _M_wp = &__b._M_getword(__pos);\n   _M_bpos = _Base::_S_whichbit(__pos);\n }\n\n ~reference() noexcept\n '
[#] parse_declaration, is_constructor=True, meet line: 'reference();\n\n      public:\n reference(bitset& __b, size_t __pos) noexcept\n {\n   _M_wp = &__b._M_getword(__pos);\n   _M_bpos = _Base::_S_whichbit(__pos);\n }\n\n ~reference() noexcept\n { }\n\n\n reference&\n '
[#] parse_declaration, is_constructor=True, meet line: 'reference(bitset& __b, size_t __pos) noexcept\n {\n   _M_wp = &__b._M_getword(__pos);\n   _M_bpos = _Base::_S_whichbit(__pos);\n }\n\n ~reference() noexcept\n { }\n\n\n reference&\n operator=(bool __x) noexcept\n'
[#] parse_declaration, is_constructor=True, meet line: 'reference() noexcept\n { }\n\n\n reference&\n operator=(bool __x) noexcept\n {\n   if (__x)\n     *_M_wp |= _Base::_S_maskbit(_M_bpos);\n   else\n     *_M_wp &= ~_Base::_S_maskbit(_M_bpos);\n   return *this;\n }\n'
[#] parse_declaration, is_constructor=True, meet line: 'reference&\n operator=(bool __x) noexcept\n {\n   if (__x)\n     *_M_wp |= _Base::_S_maskbit(_M_bpos);\n   else\n     *_M_wp &= ~_Base::_S_maskbit(_M_bpos);\n   return *this;\n }\n\n\n reference&\n operator=(cons'
[#] parse_declaration, is_constructor=True, meet line: 'reference&\n operator=(const reference& __j) noexcept\n {\n   if ((*(__j._M_wp) & _Base::_S_maskbit(__j._M_bpos)))\n     *_M_wp |= _Base::_S_maskbit(_M_bpos);\n   else\n     *_M_wp &= ~_Base::_S_maskbit(_M_'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n operator~() const noexcept\n { return (*(_M_wp) & _Base::_S_maskbit(_M_bpos)) == 0; }\n\n\n operator bool() const noexcept\n { return (*(_M_wp) & _Base::_S_maskbit(_M_bpos)) != 0; }\n\n\n reference&\n fl'
[#] parse_declaration, is_constructor=False, meet line: 'operator bool() const noexcept\n { return (*(_M_wp) & _Base::_S_maskbit(_M_bpos)) != 0; }\n\n\n reference&\n flip() noexcept\n {\n   *_M_wp ^= _Base::_S_maskbit(_M_bpos);\n   return *this;\n }\n      };\n      f'
[#] parse_declaration, is_constructor=True, meet line: 'reference&\n flip() noexcept\n {\n   *_M_wp ^= _Base::_S_maskbit(_M_bpos);\n   return *this;\n }\n      };\n      friend class reference;\n\n\n\n      constexpr bitset() noexcept\n      { }\n\n\n\n      constexpr bit'
[#] parse_declaration, is_constructor=True, meet line: 'bitset() noexcept\n      { }\n\n\n\n      constexpr bitset(unsigned long long __val) noexcept\n      : _Base(_Sanitize_val<_Nb>::_S_do_sanitize_val(__val)) { }\n# 883 "/usr/include/c++/7/bitset" 3\n      temp'
[#] parse_declaration, is_constructor=True, meet line: 'bitset(unsigned long long __val) noexcept\n      : _Base(_Sanitize_val<_Nb>::_S_do_sanitize_val(__val)) { }\n# 883 "/usr/include/c++/7/bitset" 3\n      template<class _CharT, class _Traits, class _Alloc>'
[#] parse_declaration, is_constructor=True, meet line: 'bitset(const std::basic_string<_CharT, _Traits, _Alloc>& __s,\n        size_t __position = 0)\n : _Base()\n {\n   _M_check_initial_position(__s, __position);\n   _M_copy_from_string(__s, __position,\n      '
[#] parse_declaration, is_constructor=True, meet line: 'bitset(const std::basic_string<_CharT, _Traits, _Alloc>& __s,\n        size_t __position, size_t __n)\n : _Base()\n {\n   _M_check_initial_position(__s, __position);\n   _M_copy_from_string(__s, __position'
[#] parse_declaration, is_constructor=True, meet line: "bitset(const std::basic_string<_CharT, _Traits, _Alloc>& __s,\n        size_t __position, size_t __n,\n        _CharT __zero, _CharT __one = _CharT('1'))\n : _Base()\n {\n   _M_check_initial_position(__s, "
[#] parse_declaration, is_constructor=True, meet line: "bitset(const _CharT* __str,\n        typename std::basic_string<_CharT>::size_type __n\n        = std::basic_string<_CharT>::npos,\n        _CharT __zero = _CharT('0'), _CharT __one = _CharT('1'))\n      "
[#] parse_declaration, is_constructor=True, meet line: 'bitset<_Nb>&\n      operator&=(const bitset<_Nb>& __rhs) noexcept\n      {\n this->_M_do_and(__rhs);\n return *this;\n      }\n\n      bitset<_Nb>&\n      operator|=(const bitset<_Nb>& __rhs) noexcept\n      {'
[#] parse_declaration, is_constructor=True, meet line: 'bitset<_Nb>&\n      operator|=(const bitset<_Nb>& __rhs) noexcept\n      {\n this->_M_do_or(__rhs);\n return *this;\n      }\n\n      bitset<_Nb>&\n      operator^=(const bitset<_Nb>& __rhs) noexcept\n      {\n'
[#] parse_declaration, is_constructor=True, meet line: 'bitset<_Nb>&\n      operator^=(const bitset<_Nb>& __rhs) noexcept\n      {\n this->_M_do_xor(__rhs);\n return *this;\n      }\n# 992 "/usr/include/c++/7/bitset" 3\n      bitset<_Nb>&\n      operator<<=(size_t'
[#] parse_declaration, is_constructor=True, meet line: 'bitset<_Nb>&\n      operator<<=(size_t __position) noexcept\n      {\n if (__builtin_expect(__position < _Nb, 1))\n   {\n     this->_M_do_left_shift(__position);\n     this->_M_do_sanitize();\n   }\n else\n   '
[#] parse_declaration, is_constructor=False, meet line: 'void\n _M_copy_from_string(const std::basic_string<_CharT,\n       _Traits, _Alloc>& __s, size_t __pos, size_t __n,\n       _CharT __zero, _CharT __one)\n { _M_copy_from_ptr<_CharT, _Traits>(__s.data(), _'
[#] parse_declaration, is_constructor=False, meet line: 'void\n        _M_copy_to_string(std::basic_string<_CharT, _Traits, _Alloc>&,\n     _CharT, _CharT) const;\n\n\n      template<class _CharT, class _Traits, class _Alloc>\n void\n _M_copy_from_string(const std'
[#] parse_declaration, is_constructor=False, meet line: "void\n _M_copy_from_string(const std::basic_string<_CharT,\n       _Traits, _Alloc>& __s, size_t __pos, size_t __n)\n { _M_copy_from_string(__s, __pos, __n, _CharT('0'), _CharT('1')); }\n\n      template<c"
[#] parse_declaration, is_constructor=False, meet line: "void\n        _M_copy_to_string(std::basic_string<_CharT, _Traits,_Alloc>& __s) const\n { _M_copy_to_string(__s, _CharT('0'), _CharT('1')); }\n\n\n      size_t\n      count() const noexcept\n      { return t"
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n      count() const noexcept\n      { return this->_M_do_count(); }\n\n\n      constexpr size_t\n      size() const noexcept\n      { return _Nb; }\n\n\n\n      bool\n      operator==(const bitset<_Nb>& _'
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n      size() const noexcept\n      { return _Nb; }\n\n\n\n      bool\n      operator==(const bitset<_Nb>& __rhs) const noexcept\n      { return this->_M_is_equal(__rhs); }\n\n      bool\n      operator!='
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      operator==(const bitset<_Nb>& __rhs) const noexcept\n      { return this->_M_is_equal(__rhs); }\n\n      bool\n      operator!=(const bitset<_Nb>& __rhs) const noexcept\n      { return !this->_M'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      operator!=(const bitset<_Nb>& __rhs) const noexcept\n      { return !this->_M_is_equal(__rhs); }\n# 1312 "/usr/include/c++/7/bitset" 3\n      bool\n      test(size_t __position) const\n      {\n '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      test(size_t __position) const\n      {\n this->_M_check(__position, ("bitset::test"));\n return _Unchecked_test(__position);\n      }\n\n\n\n\n\n\n\n      bool\n      all() const noexcept\n      { return'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      all() const noexcept\n      { return this->template _M_are_all<_Nb>(); }\n\n\n\n\n\n      bool\n      any() const noexcept\n      { return this->_M_is_any(); }\n\n\n\n\n\n      bool\n      none() const noe'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      any() const noexcept\n      { return this->_M_is_any(); }\n\n\n\n\n\n      bool\n      none() const noexcept\n      { return !this->_M_is_any(); }\n\n\n\n      bitset<_Nb>\n      operator<<(size_t __posi'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      none() const noexcept\n      { return !this->_M_is_any(); }\n\n\n\n      bitset<_Nb>\n      operator<<(size_t __position) const noexcept\n      { return bitset<_Nb>(*this) <<= __position; }\n\n     '
[#] parse_declaration, is_constructor=True, meet line: 'bitset<_Nb>\n      operator<<(size_t __position) const noexcept\n      { return bitset<_Nb>(*this) <<= __position; }\n\n      bitset<_Nb>\n      operator>>(size_t __position) const noexcept\n      { return '
[#] parse_declaration, is_constructor=True, meet line: 'bitset<_Nb>\n      operator>>(size_t __position) const noexcept\n      { return bitset<_Nb>(*this) >>= __position; }\n# 1362 "/usr/include/c++/7/bitset" 3\n      size_t\n      _Find_first() const noexcept\n'
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n      _Find_first() const noexcept\n      { return this->_M_do_find_first(_Nb); }\n# 1373 "/usr/include/c++/7/bitset" 3\n      size_t\n      _Find_next(size_t __prev) const noexcept\n      { return '
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n      _Find_next(size_t __prev) const noexcept\n      { return this->_M_do_find_next(__prev, _Nb); }\n    };\n\n\n  template<size_t _Nb>\n    template<class _CharT, class _Traits>\n      void\n      bi'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      bitset<_Nb>::\n      _M_copy_from_ptr(const _CharT* __s, size_t __len,\n         size_t __pos, size_t __n, _CharT __zero, _CharT __one)\n      {\n reset();\n const size_t __nbits = std::min(_Nb,'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      bitset<_Nb>::\n      _M_copy_to_string(std::basic_string<_CharT, _Traits, _Alloc>& __s,\n   _CharT __zero, _CharT __one) const\n      {\n __s.assign(_Nb, __zero);\n for (size_t __i = _Nb; __i > '
[#] parse_declaration, is_constructor=False, meet line: 'bitset<_Nb>\n    operator&(const bitset<_Nb>& __x, const bitset<_Nb>& __y) noexcept\n    {\n      bitset<_Nb> __result(__x);\n      __result &= __y;\n      return __result;\n    }\n\n  template<size_t _Nb>\n  '
[#] parse_declaration, is_constructor=False, meet line: 'bitset<_Nb>\n    operator|(const bitset<_Nb>& __x, const bitset<_Nb>& __y) noexcept\n    {\n      bitset<_Nb> __result(__x);\n      __result |= __y;\n      return __result;\n    }\n\n  template <size_t _Nb>\n '
[#] parse_declaration, is_constructor=False, meet line: 'bitset<_Nb>\n    operator^(const bitset<_Nb>& __x, const bitset<_Nb>& __y) noexcept\n    {\n      bitset<_Nb> __result(__x);\n      __result ^= __y;\n      return __result;\n    }\n# 1460 "/usr/include/c++/7'
[#] parse_declaration, is_constructor=False, meet line: 'std::basic_istream<_CharT, _Traits>&\n    operator>>(std::basic_istream<_CharT, _Traits>& __is, bitset<_Nb>& __x)\n    {\n      typedef typename _Traits::char_type char_type;\n      typedef std::basic_ist'
[#] parse_declaration, is_constructor=False, meet line: 'std::basic_ostream<_CharT, _Traits>&\n    operator<<(std::basic_ostream<_CharT, _Traits>& __os,\n        const bitset<_Nb>& __x)\n    {\n      std::basic_string<_CharT, _Traits> __tmp;\n\n\n\n      const ctyp'
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n      operator()(const std::bitset<_Nb>& __b) const noexcept\n      {\n const size_t __clength = (_Nb + 8 - 1) / 8;\n return std::_Hash_impl::hash(__b._M_getdata(), __clength);\n      }\n    };\n\n  t'
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n      operator()(const std::bitset<0>&) const noexcept\n      { return 0; }\n    };\n\n\n}\n# 40 "/usr/include/c++/7/regex" 2 3\n\n\n\n# 1 "/usr/include/c++/7/iterator" 1 3\n# 58 "/usr/include/c++/7/itera'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      has_facet(const locale&) throw();\n\n    template<typename _Facet>\n      friend const _Facet&\n      use_facet(const locale&);\n\n    template<typename _Cache>\n      friend struct __use_cache;\n#'
[#] parse_declaration, is_constructor=False, meet line: '_Facet&\n      use_facet(const locale&);\n\n    template<typename _Cache>\n      friend struct __use_cache;\n# 98 "/usr/include/c++/7/bits/locale_classes.h" 3\n    static const category none = 0;\n    static'
[#] parse_declaration, is_constructor=False, meet line: 'category none = 0;\n    static const category ctype = 1L << 0;\n    static const category numeric = 1L << 1;\n    static const category collate = 1L << 2;\n    static const category time = 1L << 3;\n    st'
[#] parse_declaration, is_constructor=False, meet line: 'category ctype = 1L << 0;\n    static const category numeric = 1L << 1;\n    static const category collate = 1L << 2;\n    static const category time = 1L << 3;\n    static const category monetary = 1L <<'
[#] parse_declaration, is_constructor=False, meet line: 'category numeric = 1L << 1;\n    static const category collate = 1L << 2;\n    static const category time = 1L << 3;\n    static const category monetary = 1L << 4;\n    static const category messages = 1L'
[#] parse_declaration, is_constructor=False, meet line: 'category collate = 1L << 2;\n    static const category time = 1L << 3;\n    static const category monetary = 1L << 4;\n    static const category messages = 1L << 5;\n    static const category all = (ctype'
[#] parse_declaration, is_constructor=False, meet line: 'category time = 1L << 3;\n    static const category monetary = 1L << 4;\n    static const category messages = 1L << 5;\n    static const category all = (ctype | numeric | collate |\n        time | monetar'
[#] parse_declaration, is_constructor=False, meet line: 'category monetary = 1L << 4;\n    static const category messages = 1L << 5;\n    static const category all = (ctype | numeric | collate |\n        time | monetary | messages);\n# 117 "/usr/include/c++/7/b'
[#] parse_declaration, is_constructor=False, meet line: 'category messages = 1L << 5;\n    static const category all = (ctype | numeric | collate |\n        time | monetary | messages);\n# 117 "/usr/include/c++/7/bits/locale_classes.h" 3\n    locale() throw();\n'
[#] parse_declaration, is_constructor=False, meet line: 'category all = (ctype | numeric | collate |\n        time | monetary | messages);\n# 117 "/usr/include/c++/7/bits/locale_classes.h" 3\n    locale() throw();\n# 126 "/usr/include/c++/7/bits/locale_classes.'
[#] parse_declaration, is_constructor=True, meet line: 'locale() throw();\n# 126 "/usr/include/c++/7/bits/locale_classes.h" 3\n    locale(const locale& __other) throw();\n# 136 "/usr/include/c++/7/bits/locale_classes.h" 3\n    explicit\n    locale(const char* _'
[#] parse_declaration, is_constructor=True, meet line: 'locale(const locale& __other) throw();\n# 136 "/usr/include/c++/7/bits/locale_classes.h" 3\n    explicit\n    locale(const char* __s);\n# 151 "/usr/include/c++/7/bits/locale_classes.h" 3\n    locale(const '
[#] parse_declaration, is_constructor=True, meet line: 'locale(const char* __s);\n# 151 "/usr/include/c++/7/bits/locale_classes.h" 3\n    locale(const locale& __base, const char* __s, category __cat);\n# 162 "/usr/include/c++/7/bits/locale_classes.h" 3\n    ex'
[#] parse_declaration, is_constructor=True, meet line: 'locale(const locale& __base, const char* __s, category __cat);\n# 162 "/usr/include/c++/7/bits/locale_classes.h" 3\n    explicit\n    locale(const std::string& __s) : locale(__s.c_str()) { }\n# 177 "/usr/'
[#] parse_declaration, is_constructor=True, meet line: 'locale(const std::string& __s) : locale(__s.c_str()) { }\n# 177 "/usr/include/c++/7/bits/locale_classes.h" 3\n    locale(const locale& __base, const std::string& __s, category __cat)\n    : locale(__base'
[#] parse_declaration, is_constructor=True, meet line: 'locale(const locale& __base, const std::string& __s, category __cat)\n    : locale(__base, __s.c_str(), __cat) { }\n# 192 "/usr/include/c++/7/bits/locale_classes.h" 3\n    locale(const locale& __base, co'
[#] parse_declaration, is_constructor=True, meet line: 'locale(const locale& __base, const locale& __add, category __cat);\n# 205 "/usr/include/c++/7/bits/locale_classes.h" 3\n    template<typename _Facet>\n      locale(const locale& __other, _Facet* __f);\n\n\n'
[#] parse_declaration, is_constructor=True, meet line: 'locale(const locale& __other, _Facet* __f);\n\n\n    ~locale() throw();\n# 219 "/usr/include/c++/7/bits/locale_classes.h" 3\n    const locale&\n    operator=(const locale& __other) throw();\n# 234 "/usr/incl'
[#] parse_declaration, is_constructor=True, meet line: 'locale() throw();\n# 219 "/usr/include/c++/7/bits/locale_classes.h" 3\n    const locale&\n    operator=(const locale& __other) throw();\n# 234 "/usr/include/c++/7/bits/locale_classes.h" 3\n    template<typ'
[#] parse_declaration, is_constructor=True, meet line: 'locale&\n    operator=(const locale& __other) throw();\n# 234 "/usr/include/c++/7/bits/locale_classes.h" 3\n    template<typename _Facet>\n      locale\n      combine(const locale& __other) const;\n\n\n\n\n\n\n  '
[#] parse_declaration, is_constructor=True, meet line: 'locale\n      combine(const locale& __other) const;\n\n\n\n\n\n\n    __attribute ((__abi_tag__ ("cxx11")))\n    string\n    name() const;\n# 254 "/usr/include/c++/7/bits/locale_classes.h" 3\n    bool\n    operator'
[#] parse_declaration, is_constructor=False, meet line: 'string\n    name() const;\n# 254 "/usr/include/c++/7/bits/locale_classes.h" 3\n    bool\n    operator==(const locale& __other) const throw();\n\n\n\n\n\n\n\n    bool\n    operator!=(const locale& __other) const th'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator==(const locale& __other) const throw();\n\n\n\n\n\n\n\n    bool\n    operator!=(const locale& __other) const throw()\n    { return !(this->operator==(__other)); }\n# 282 "/usr/include/c++/7/bit'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator!=(const locale& __other) const throw()\n    { return !(this->operator==(__other)); }\n# 282 "/usr/include/c++/7/bits/locale_classes.h" 3\n    template<typename _Char, typename _Traits, '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      operator()(const basic_string<_Char, _Traits, _Alloc>& __s1,\n   const basic_string<_Char, _Traits, _Alloc>& __s2) const;\n# 298 "/usr/include/c++/7/bits/locale_classes.h" 3\n    static locale'
[#] parse_declaration, is_constructor=True, meet line: 'locale\n    global(const locale& __loc);\n\n\n\n\n    static const locale&\n    classic();\n\n  private:\n\n    _Impl* _M_impl;\n\n\n    static _Impl* _S_classic;\n\n\n    static _Impl* _S_global;\n\n\n\n\n\n    static cons'
[#] parse_declaration, is_constructor=True, meet line: 'locale&\n    classic();\n\n  private:\n\n    _Impl* _M_impl;\n\n\n    static _Impl* _S_classic;\n\n\n    static _Impl* _S_global;\n\n\n\n\n\n    static const char* const* const _S_categories;\n# 333 "/usr/include/c++/7'
[#] parse_declaration, is_constructor=False, meet line: '_Impl* _M_impl;\n\n\n    static _Impl* _S_classic;\n\n\n    static _Impl* _S_global;\n\n\n\n\n\n    static const char* const* const _S_categories;\n# 333 "/usr/include/c++/7/bits/locale_classes.h" 3\n    enum { _S_'
[#] parse_declaration, is_constructor=False, meet line: '_Impl* _S_classic;\n\n\n    static _Impl* _S_global;\n\n\n\n\n\n    static const char* const* const _S_categories;\n# 333 "/usr/include/c++/7/bits/locale_classes.h" 3\n    enum { _S_categories_size = 6 + 6 };\n\n\n'
[#] parse_declaration, is_constructor=False, meet line: '_Impl* _S_global;\n\n\n\n\n\n    static const char* const* const _S_categories;\n# 333 "/usr/include/c++/7/bits/locale_classes.h" 3\n    enum { _S_categories_size = 6 + 6 };\n\n\n    static __gthread_once_t _S_o'
[#] parse_declaration, is_constructor=False, meet line: 'char* const* const _S_categories;\n# 333 "/usr/include/c++/7/bits/locale_classes.h" 3\n    enum { _S_categories_size = 6 + 6 };\n\n\n    static __gthread_once_t _S_once;\n\n\n    explicit\n    locale(_Impl*) t'
[#] parse_declaration, is_constructor=False, meet line: '__gthread_once_t _S_once;\n\n\n    explicit\n    locale(_Impl*) throw();\n\n    static void\n    _S_initialize();\n\n    static void\n    _S_initialize_once() throw();\n\n    static category\n    _S_normalize_cate'
[#] parse_declaration, is_constructor=True, meet line: 'locale(_Impl*) throw();\n\n    static void\n    _S_initialize();\n\n    static void\n    _S_initialize_once() throw();\n\n    static category\n    _S_normalize_category(category);\n\n    void\n    _M_coalesce(con'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _S_initialize();\n\n    static void\n    _S_initialize_once() throw();\n\n    static category\n    _S_normalize_category(category);\n\n    void\n    _M_coalesce(const locale& __base, const locale& __a'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _S_initialize_once() throw();\n\n    static category\n    _S_normalize_category(category);\n\n    void\n    _M_coalesce(const locale& __base, const locale& __add, category __cat);\n\n\n    static cons'
[#] parse_declaration, is_constructor=False, meet line: 'category\n    _S_normalize_category(category);\n\n    void\n    _M_coalesce(const locale& __base, const locale& __add, category __cat);\n\n\n    static const id* const _S_twinned_facets[];\n\n  };\n# 371 "/usr/'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _M_coalesce(const locale& __base, const locale& __add, category __cat);\n\n\n    static const id* const _S_twinned_facets[];\n\n  };\n# 371 "/usr/include/c++/7/bits/locale_classes.h" 3\n  class loca'
[#] parse_declaration, is_constructor=False, meet line: 'id* const _S_twinned_facets[];\n\n  };\n# 371 "/usr/include/c++/7/bits/locale_classes.h" 3\n  class locale::facet\n  {\n  private:\n    friend class locale;\n    friend class locale::_Impl;\n\n    mutable _Atom'
[#] parse_declaration, is_constructor=False, meet line: '_Atomic_word _M_refcount;\n\n\n    static __c_locale _S_c_locale;\n\n\n    static const char _S_c_name[2];\n\n\n    static __gthread_once_t _S_once;\n\n\n    static void\n    _S_initialize_once();\n\n  protected:\n# '
[#] parse_declaration, is_constructor=False, meet line: '__c_locale _S_c_locale;\n\n\n    static const char _S_c_name[2];\n\n\n    static __gthread_once_t _S_once;\n\n\n    static void\n    _S_initialize_once();\n\n  protected:\n# 402 "/usr/include/c++/7/bits/locale_cla'
[#] parse_declaration, is_constructor=False, meet line: 'char _S_c_name[2];\n\n\n    static __gthread_once_t _S_once;\n\n\n    static void\n    _S_initialize_once();\n\n  protected:\n# 402 "/usr/include/c++/7/bits/locale_classes.h" 3\n    explicit\n    facet(size_t __r'
[#] parse_declaration, is_constructor=False, meet line: '__gthread_once_t _S_once;\n\n\n    static void\n    _S_initialize_once();\n\n  protected:\n# 402 "/usr/include/c++/7/bits/locale_classes.h" 3\n    explicit\n    facet(size_t __refs = 0) throw() : _M_refcount(_'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _S_initialize_once();\n\n  protected:\n# 402 "/usr/include/c++/7/bits/locale_classes.h" 3\n    explicit\n    facet(size_t __refs = 0) throw() : _M_refcount(__refs ? 1 : 0)\n    { }\n\n\n    virtual\n  '
[#] parse_declaration, is_constructor=False, meet line: 'facet(size_t __refs = 0) throw() : _M_refcount(__refs ? 1 : 0)\n    { }\n\n\n    virtual\n    ~facet();\n\n    static void\n    _S_create_c_locale(__c_locale& __cloc, const char* __s,\n         __c_locale __ol'
[#] parse_declaration, is_constructor=False, meet line: 'facet();\n\n    static void\n    _S_create_c_locale(__c_locale& __cloc, const char* __s,\n         __c_locale __old = 0);\n\n    static __c_locale\n    _S_clone_c_locale(__c_locale& __cloc) throw();\n\n    sta'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _S_create_c_locale(__c_locale& __cloc, const char* __s,\n         __c_locale __old = 0);\n\n    static __c_locale\n    _S_clone_c_locale(__c_locale& __cloc) throw();\n\n    static void\n    _S_destr'
[#] parse_declaration, is_constructor=False, meet line: '__c_locale\n    _S_clone_c_locale(__c_locale& __cloc) throw();\n\n    static void\n    _S_destroy_c_locale(__c_locale& __cloc);\n\n    static __c_locale\n    _S_lc_ctype_c_locale(__c_locale __cloc, const cha'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _S_destroy_c_locale(__c_locale& __cloc);\n\n    static __c_locale\n    _S_lc_ctype_c_locale(__c_locale __cloc, const char* __s);\n\n\n\n    static __c_locale\n    _S_get_c_locale();\n\n    __attribute_'
[#] parse_declaration, is_constructor=False, meet line: '__c_locale\n    _S_lc_ctype_c_locale(__c_locale __cloc, const char* __s);\n\n\n\n    static __c_locale\n    _S_get_c_locale();\n\n    __attribute__ ((__const__)) static const char*\n    _S_get_c_name() throw()'
[#] parse_declaration, is_constructor=False, meet line: '__c_locale\n    _S_get_c_locale();\n\n    __attribute__ ((__const__)) static const char*\n    _S_get_c_name() throw();\n# 438 "/usr/include/c++/7/bits/locale_classes.h" 3\n    facet(const facet&) = delete;\n'
[#] parse_declaration, is_constructor=False, meet line: '__attribute__ ((__const__)) static const char*\n    _S_get_c_name() throw();\n# 438 "/usr/include/c++/7/bits/locale_classes.h" 3\n    facet(const facet&) = delete;\n\n    facet&\n    operator=(const facet&)'
[#] parse_declaration, is_constructor=False, meet line: 'facet(const facet&) = delete;\n\n    facet&\n    operator=(const facet&) = delete;\n\n\n  private:\n    void\n    _M_add_reference() const throw()\n    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }\n\n '
[#] parse_declaration, is_constructor=False, meet line: 'facet&\n    operator=(const facet&) = delete;\n\n\n  private:\n    void\n    _M_add_reference() const throw()\n    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }\n\n    void\n    _M_remove_reference() c'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _M_add_reference() const throw()\n    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }\n\n    void\n    _M_remove_reference() const throw()\n    {\n\n      ;\n      if (__gnu_cxx::__exchange_an'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _M_remove_reference() const throw()\n    {\n\n      ;\n      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)\n {\n          ;\n   try\n     { delete this; }\n   catch(...)\n     { }\n'
[#] parse_declaration, is_constructor=False, meet line: 'facet* _M_sso_shim(const id*) const;\n    const facet* _M_cow_shim(const id*) const;\n\n  protected:\n    class __shim;\n  };\n# 483 "/usr/include/c++/7/bits/locale_classes.h" 3\n  class locale::id\n  {\n  pri'
[#] parse_declaration, is_constructor=False, meet line: 'facet* _M_cow_shim(const id*) const;\n\n  protected:\n    class __shim;\n  };\n# 483 "/usr/include/c++/7/bits/locale_classes.h" 3\n  class locale::id\n  {\n  private:\n    friend class locale;\n    friend class'
[#] parse_declaration, is_constructor=False, meet line: '_Facet&\n      use_facet(const locale&);\n\n    template<typename _Facet>\n      friend bool\n      has_facet(const locale&) throw();\n\n\n\n\n    mutable size_t _M_index;\n\n\n    static _Atomic_word _S_refcount;'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      has_facet(const locale&) throw();\n\n\n\n\n    mutable size_t _M_index;\n\n\n    static _Atomic_word _S_refcount;\n\n    void\n    operator=(const id&);\n\n    id(const id&);\n\n  public:\n\n\n\n    id() { }\n'
[#] parse_declaration, is_constructor=False, meet line: 'size_t _M_index;\n\n\n    static _Atomic_word _S_refcount;\n\n    void\n    operator=(const id&);\n\n    id(const id&);\n\n  public:\n\n\n\n    id() { }\n\n    size_t\n    _M_id() const throw();\n  };\n\n\n\n  class locale'
[#] parse_declaration, is_constructor=False, meet line: '_Atomic_word _S_refcount;\n\n    void\n    operator=(const id&);\n\n    id(const id&);\n\n  public:\n\n\n\n    id() { }\n\n    size_t\n    _M_id() const throw();\n  };\n\n\n\n  class locale::_Impl\n  {\n  public:\n\n    fri'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    operator=(const id&);\n\n    id(const id&);\n\n  public:\n\n\n\n    id() { }\n\n    size_t\n    _M_id() const throw();\n  };\n\n\n\n  class locale::_Impl\n  {\n  public:\n\n    friend class locale;\n    friend cl'
[#] parse_declaration, is_constructor=False, meet line: 'id(const id&);\n\n  public:\n\n\n\n    id() { }\n\n    size_t\n    _M_id() const throw();\n  };\n\n\n\n  class locale::_Impl\n  {\n  public:\n\n    friend class locale;\n    friend class locale::facet;\n\n    template<typ'
[#] parse_declaration, is_constructor=False, meet line: 'id() { }\n\n    size_t\n    _M_id() const throw();\n  };\n\n\n\n  class locale::_Impl\n  {\n  public:\n\n    friend class locale;\n    friend class locale::facet;\n\n    template<typename _Facet>\n      friend bool\n '
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n    _M_id() const throw();\n  };\n\n\n\n  class locale::_Impl\n  {\n  public:\n\n    friend class locale;\n    friend class locale::facet;\n\n    template<typename _Facet>\n      friend bool\n      has_facet'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      has_facet(const locale&) throw();\n\n    template<typename _Facet>\n      friend const _Facet&\n      use_facet(const locale&);\n\n    template<typename _Cache>\n      friend struct __use_cache;\n\n'
[#] parse_declaration, is_constructor=False, meet line: '_Facet&\n      use_facet(const locale&);\n\n    template<typename _Cache>\n      friend struct __use_cache;\n\n  private:\n\n    _Atomic_word _M_refcount;\n    const facet** _M_facets;\n    size_t _M_facets_siz'
[#] parse_declaration, is_constructor=False, meet line: '_Atomic_word _M_refcount;\n    const facet** _M_facets;\n    size_t _M_facets_size;\n    const facet** _M_caches;\n    char** _M_names;\n    static const locale::id* const _S_id_ctype[];\n    static const l'
[#] parse_declaration, is_constructor=False, meet line: 'facet** _M_facets;\n    size_t _M_facets_size;\n    const facet** _M_caches;\n    char** _M_names;\n    static const locale::id* const _S_id_ctype[];\n    static const locale::id* const _S_id_numeric[];\n  '
[#] parse_declaration, is_constructor=False, meet line: 'size_t _M_facets_size;\n    const facet** _M_caches;\n    char** _M_names;\n    static const locale::id* const _S_id_ctype[];\n    static const locale::id* const _S_id_numeric[];\n    static const locale::'
[#] parse_declaration, is_constructor=False, meet line: 'facet** _M_caches;\n    char** _M_names;\n    static const locale::id* const _S_id_ctype[];\n    static const locale::id* const _S_id_numeric[];\n    static const locale::id* const _S_id_collate[];\n    st'
[#] parse_declaration, is_constructor=False, meet line: 'char** _M_names;\n    static const locale::id* const _S_id_ctype[];\n    static const locale::id* const _S_id_numeric[];\n    static const locale::id* const _S_id_collate[];\n    static const locale::id* '
[#] parse_declaration, is_constructor=True, meet line: 'locale::id* const _S_id_ctype[];\n    static const locale::id* const _S_id_numeric[];\n    static const locale::id* const _S_id_collate[];\n    static const locale::id* const _S_id_time[];\n    static con'
[#] parse_declaration, is_constructor=True, meet line: 'locale::id* const _S_id_numeric[];\n    static const locale::id* const _S_id_collate[];\n    static const locale::id* const _S_id_time[];\n    static const locale::id* const _S_id_monetary[];\n    static '
[#] parse_declaration, is_constructor=True, meet line: 'locale::id* const _S_id_collate[];\n    static const locale::id* const _S_id_time[];\n    static const locale::id* const _S_id_monetary[];\n    static const locale::id* const _S_id_messages[];\n    static'
[#] parse_declaration, is_constructor=True, meet line: 'locale::id* const _S_id_time[];\n    static const locale::id* const _S_id_monetary[];\n    static const locale::id* const _S_id_messages[];\n    static const locale::id* const* const _S_facet_categories['
[#] parse_declaration, is_constructor=True, meet line: 'locale::id* const _S_id_monetary[];\n    static const locale::id* const _S_id_messages[];\n    static const locale::id* const* const _S_facet_categories[];\n\n    void\n    _M_add_reference() throw()\n    {'
[#] parse_declaration, is_constructor=True, meet line: 'locale::id* const _S_id_messages[];\n    static const locale::id* const* const _S_facet_categories[];\n\n    void\n    _M_add_reference() throw()\n    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }'
[#] parse_declaration, is_constructor=True, meet line: 'locale::id* const* const _S_facet_categories[];\n\n    void\n    _M_add_reference() throw()\n    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }\n\n    void\n    _M_remove_reference() throw()\n    {\n\n '
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _M_add_reference() throw()\n    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }\n\n    void\n    _M_remove_reference() throw()\n    {\n\n      ;\n      if (__gnu_cxx::__exchange_and_add_dispat'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _M_remove_reference() throw()\n    {\n\n      ;\n      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)\n {\n          ;\n   try\n     { delete this; }\n   catch(...)\n     { }\n }\n   '
[#] parse_declaration, is_constructor=False, meet line: '_Impl(const _Impl&, size_t);\n    _Impl(const char*, size_t);\n    _Impl(size_t) throw();\n\n   ~_Impl() throw();\n\n    _Impl(const _Impl&);\n\n    void\n    operator=(const _Impl&);\n\n    bool\n    _M_check_sa'
[#] parse_declaration, is_constructor=False, meet line: '_Impl(const char*, size_t);\n    _Impl(size_t) throw();\n\n   ~_Impl() throw();\n\n    _Impl(const _Impl&);\n\n    void\n    operator=(const _Impl&);\n\n    bool\n    _M_check_same_name()\n    {\n      bool __ret '
[#] parse_declaration, is_constructor=False, meet line: '_Impl(size_t) throw();\n\n   ~_Impl() throw();\n\n    _Impl(const _Impl&);\n\n    void\n    operator=(const _Impl&);\n\n    bool\n    _M_check_same_name()\n    {\n      bool __ret = true;\n      if (_M_names[1])\n\n'
[#] parse_declaration, is_constructor=False, meet line: '_Impl() throw();\n\n    _Impl(const _Impl&);\n\n    void\n    operator=(const _Impl&);\n\n    bool\n    _M_check_same_name()\n    {\n      bool __ret = true;\n      if (_M_names[1])\n\n for (size_t __i = 0; __ret '
[#] parse_declaration, is_constructor=False, meet line: '_Impl(const _Impl&);\n\n    void\n    operator=(const _Impl&);\n\n    bool\n    _M_check_same_name()\n    {\n      bool __ret = true;\n      if (_M_names[1])\n\n for (size_t __i = 0; __ret && __i < _S_categories'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    operator=(const _Impl&);\n\n    bool\n    _M_check_same_name()\n    {\n      bool __ret = true;\n      if (_M_names[1])\n\n for (size_t __i = 0; __ret && __i < _S_categories_size - 1; ++__i)\n   __ret'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    _M_check_same_name()\n    {\n      bool __ret = true;\n      if (_M_names[1])\n\n for (size_t __i = 0; __ret && __i < _S_categories_size - 1; ++__i)\n   __ret = __builtin_strcmp(_M_names[__i], _M_n'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _M_replace_categories(const _Impl*, category);\n\n    void\n    _M_replace_category(const _Impl*, const locale::id* const*);\n\n    void\n    _M_replace_facet(const _Impl*, const locale::id*);\n\n   '
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _M_replace_category(const _Impl*, const locale::id* const*);\n\n    void\n    _M_replace_facet(const _Impl*, const locale::id*);\n\n    void\n    _M_install_facet(const locale::id*, const facet*);\n'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _M_replace_facet(const _Impl*, const locale::id*);\n\n    void\n    _M_install_facet(const locale::id*, const facet*);\n\n    template<typename _Facet>\n      void\n      _M_init_facet(_Facet* __fac'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _M_install_facet(const locale::id*, const facet*);\n\n    template<typename _Facet>\n      void\n      _M_init_facet(_Facet* __facet)\n      { _M_install_facet(&_Facet::id, __facet); }\n\n    templa'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_init_facet(_Facet* __facet)\n      { _M_install_facet(&_Facet::id, __facet); }\n\n    template<typename _Facet>\n      void\n      _M_init_facet_unchecked(_Facet* __facet)\n      {\n __facet->_'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_init_facet_unchecked(_Facet* __facet)\n      {\n __facet->_M_add_reference();\n _M_facets[_Facet::id._M_id()] = __facet;\n      }\n\n    void\n    _M_install_cache(const facet*, size_t);\n\n    v'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _M_install_cache(const facet*, size_t);\n\n    void _M_init_extra(facet**);\n    void _M_init_extra(void*, void*, const char*, const char*);\n  };\n# 641 "/usr/include/c++/7/bits/locale_classes.h"'
[#] parse_declaration, is_constructor=False, meet line: 'void _M_init_extra(facet**);\n    void _M_init_extra(void*, void*, const char*, const char*);\n  };\n# 641 "/usr/include/c++/7/bits/locale_classes.h" 3\n  template<typename _CharT>\n    class __cxx11:: col'
[#] parse_declaration, is_constructor=False, meet line: 'void _M_init_extra(void*, void*, const char*, const char*);\n  };\n# 641 "/usr/include/c++/7/bits/locale_classes.h" 3\n  template<typename _CharT>\n    class __cxx11:: collate : public locale::facet\n    {'
[#] parse_declaration, is_constructor=False, meet line: '__c_locale _M_c_locale_collate;\n\n    public:\n\n      static locale::id id;\n# 668 "/usr/include/c++/7/bits/locale_classes.h" 3\n      explicit\n      collate(size_t __refs = 0)\n      : facet(__refs), _M_c'
[#] parse_declaration, is_constructor=False, meet line: 'locale::id id;\n# 668 "/usr/include/c++/7/bits/locale_classes.h" 3\n      explicit\n      collate(size_t __refs = 0)\n      : facet(__refs), _M_c_locale_collate(_S_get_c_locale())\n      { }\n# 682 "/usr/in'
[#] parse_declaration, is_constructor=False, meet line: 'collate(size_t __refs = 0)\n      : facet(__refs), _M_c_locale_collate(_S_get_c_locale())\n      { }\n# 682 "/usr/include/c++/7/bits/locale_classes.h" 3\n      explicit\n      collate(__c_locale __cloc, si'
[#] parse_declaration, is_constructor=False, meet line: 'collate(__c_locale __cloc, size_t __refs = 0)\n      : facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc))\n      { }\n# 699 "/usr/include/c++/7/bits/locale_classes.h" 3\n      int\n      compare'
[#] parse_declaration, is_constructor=False, meet line: 'int\n      compare(const _CharT* __lo1, const _CharT* __hi1,\n       const _CharT* __lo2, const _CharT* __hi2) const\n      { return this->do_compare(__lo1, __hi1, __lo2, __hi2); }\n# 718 "/usr/include/c+'
[#] parse_declaration, is_constructor=False, meet line: 'string_type\n      transform(const _CharT* __lo, const _CharT* __hi) const\n      { return this->do_transform(__lo, __hi); }\n# 732 "/usr/include/c++/7/bits/locale_classes.h" 3\n      long\n      hash(cons'
[#] parse_declaration, is_constructor=False, meet line: 'long\n      hash(const _CharT* __lo, const _CharT* __hi) const\n      { return this->do_hash(__lo, __hi); }\n\n\n      int\n      _M_compare(const _CharT*, const _CharT*) const throw();\n\n      size_t\n      '
[#] parse_declaration, is_constructor=False, meet line: 'int\n      _M_compare(const _CharT*, const _CharT*) const throw();\n\n      size_t\n      _M_transform(_CharT*, const _CharT*, size_t) const throw();\n\n  protected:\n\n      virtual\n      ~collate()\n      { '
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n      _M_transform(_CharT*, const _CharT*, size_t) const throw();\n\n  protected:\n\n      virtual\n      ~collate()\n      { _S_destroy_c_locale(_M_c_locale_collate); }\n# 761 "/usr/include/c++/7/bit'
[#] parse_declaration, is_constructor=False, meet line: 'collate()\n      { _S_destroy_c_locale(_M_c_locale_collate); }\n# 761 "/usr/include/c++/7/bits/locale_classes.h" 3\n      virtual int\n      do_compare(const _CharT* __lo1, const _CharT* __hi1,\n   const _'
[#] parse_declaration, is_constructor=False, meet line: 'int\n      do_compare(const _CharT* __lo1, const _CharT* __hi1,\n   const _CharT* __lo2, const _CharT* __hi2) const;\n# 775 "/usr/include/c++/7/bits/locale_classes.h" 3\n      virtual string_type\n      do'
[#] parse_declaration, is_constructor=False, meet line: 'string_type\n      do_transform(const _CharT* __lo, const _CharT* __hi) const;\n# 788 "/usr/include/c++/7/bits/locale_classes.h" 3\n      virtual long\n      do_hash(const _CharT* __lo, const _CharT* __hi'
[#] parse_declaration, is_constructor=False, meet line: 'long\n      do_hash(const _CharT* __lo, const _CharT* __hi) const;\n    };\n\n  template<typename _CharT>\n    locale::id collate<_CharT>::id;\n\n\n  template<>\n    int\n    collate<char>::_M_compare(const cha'
[#] parse_declaration, is_constructor=False, meet line: 'locale::id collate<_CharT>::id;\n\n\n  template<>\n    int\n    collate<char>::_M_compare(const char*, const char*) const throw();\n\n  template<>\n    size_t\n    collate<char>::_M_transform(char*, const char'
[#] parse_declaration, is_constructor=False, meet line: 'int\n    collate<char>::_M_compare(const char*, const char*) const throw();\n\n  template<>\n    size_t\n    collate<char>::_M_transform(char*, const char*, size_t) const throw();\n\n\n  template<>\n    int\n  '
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n    collate<char>::_M_transform(char*, const char*, size_t) const throw();\n\n\n  template<>\n    int\n    collate<wchar_t>::_M_compare(const wchar_t*, const wchar_t*) const throw();\n\n  template<>\n '
[#] parse_declaration, is_constructor=False, meet line: 'int\n    collate<wchar_t>::_M_compare(const wchar_t*, const wchar_t*) const throw();\n\n  template<>\n    size_t\n    collate<wchar_t>::_M_transform(wchar_t*, const wchar_t*, size_t) const throw();\n\n\n\n  te'
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n    collate<wchar_t>::_M_transform(wchar_t*, const wchar_t*, size_t) const throw();\n\n\n\n  template<typename _CharT>\n    class __cxx11:: collate_byname : public collate<_CharT>\n    {\n    public:\n'
[#] parse_declaration, is_constructor=False, meet line: 'collate_byname(const char* __s, size_t __refs = 0)\n      : collate<_CharT>(__refs)\n      {\n if (__builtin_strcmp(__s, "C") != 0\n     && __builtin_strcmp(__s, "POSIX") != 0)\n   {\n     this->_S_destroy_'
[#] parse_declaration, is_constructor=False, meet line: 'collate_byname(const string& __s, size_t __refs = 0)\n      : collate_byname(__s.c_str(), __refs) { }\n\n\n    protected:\n      virtual\n      ~collate_byname() { }\n    };\n\n\n}\n\n# 1 "/usr/include/c++/7/bits'
[#] parse_declaration, is_constructor=False, meet line: 'collate_byname() { }\n    };\n\n\n}\n\n# 1 "/usr/include/c++/7/bits/locale_classes.tcc" 1 3\n# 37 "/usr/include/c++/7/bits/locale_classes.tcc" 3\n       \n# 38 "/usr/include/c++/7/bits/locale_classes.tcc" 3\n\nn'
[#] parse_declaration, is_constructor=False, meet line: 'locale::\n    locale(const locale& __other, _Facet* __f)\n    {\n      _M_impl = new _Impl(*__other._M_impl, 1);\n\n      try\n { _M_impl->_M_install_facet(&_Facet::id, __f); }\n      catch(...)\n {\n   _M_imp'
[#] parse_declaration, is_constructor=False, meet line: 'locale\n    locale::\n    combine(const locale& __other) const\n    {\n      _Impl* __tmp = new _Impl(*_M_impl, 1);\n      try\n {\n   __tmp->_M_replace_facet(__other._M_impl, &_Facet::id);\n }\n      catch(..'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    locale::\n    operator()(const basic_string<_CharT, _Traits, _Alloc>& __s1,\n        const basic_string<_CharT, _Traits, _Alloc>& __s2) const\n    {\n      typedef std::collate<_CharT> __collate_'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    has_facet(const locale& __loc) throw()\n    {\n      const size_t __i = _Facet::id._M_id();\n      const locale::facet** __facets = __loc._M_impl->_M_facets;\n      return (__i < __loc._M_impl->_'
[#] parse_declaration, is_constructor=False, meet line: '_Facet&\n    use_facet(const locale& __loc)\n    {\n      const size_t __i = _Facet::id._M_id();\n      const locale::facet** __facets = __loc._M_impl->_M_facets;\n      if (__i >= __loc._M_impl->_M_facets'
[#] parse_declaration, is_constructor=False, meet line: 'int\n    collate<_CharT>::_M_compare(const _CharT*, const _CharT*) const throw ()\n    { return 0; }\n\n\n  template<typename _CharT>\n    size_t\n    collate<_CharT>::_M_transform(_CharT*, const _CharT*, si'
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n    collate<_CharT>::_M_transform(_CharT*, const _CharT*, size_t) const throw ()\n    { return 0; }\n\n  template<typename _CharT>\n    int\n    collate<_CharT>::\n    do_compare(const _CharT* __lo1,'
[#] parse_declaration, is_constructor=False, meet line: 'int\n    collate<_CharT>::\n    do_compare(const _CharT* __lo1, const _CharT* __hi1,\n        const _CharT* __lo2, const _CharT* __hi2) const\n    {\n\n\n      const string_type __one(__lo1, __hi1);\n      co'
[#] parse_declaration, is_constructor=False, meet line: 'collate<_CharT>::string_type\n    collate<_CharT>::\n    do_transform(const _CharT* __lo, const _CharT* __hi) const\n    {\n      string_type __ret;\n\n\n      const string_type __str(__lo, __hi);\n\n      con'
[#] parse_declaration, is_constructor=False, meet line: 'long\n    collate<_CharT>::\n    do_hash(const _CharT* __lo, const _CharT* __hi) const\n    {\n      unsigned long __val = 0;\n      for (; __lo < __hi; ++__lo)\n __val =\n   *__lo + ((__val << 7)\n     | (__'
[#] parse_declaration, is_constructor=False, meet line: 'template class collate<char>;\n  extern template class collate_byname<char>;\n\n  extern template\n    const collate<char>&\n    use_facet<collate<char> >(const locale&);\n\n  extern template\n    bool\n    ha'
[#] parse_declaration, is_constructor=False, meet line: 'template class collate_byname<char>;\n\n  extern template\n    const collate<char>&\n    use_facet<collate<char> >(const locale&);\n\n  extern template\n    bool\n    has_facet<collate<char> >(const locale&);'
[#] parse_declaration, is_constructor=False, meet line: 'template\n    const collate<char>&\n    use_facet<collate<char> >(const locale&);\n\n  extern template\n    bool\n    has_facet<collate<char> >(const locale&);\n\n\n  extern template class collate<wchar_t>;\n  '
[#] parse_declaration, is_constructor=False, meet line: 'template\n    bool\n    has_facet<collate<char> >(const locale&);\n\n\n  extern template class collate<wchar_t>;\n  extern template class collate_byname<wchar_t>;\n\n  extern template\n    const collate<wchar_'
[#] parse_declaration, is_constructor=False, meet line: 'template class collate<wchar_t>;\n  extern template class collate_byname<wchar_t>;\n\n  extern template\n    const collate<wchar_t>&\n    use_facet<collate<wchar_t> >(const locale&);\n\n  extern template\n   '
[#] parse_declaration, is_constructor=False, meet line: 'template class collate_byname<wchar_t>;\n\n  extern template\n    const collate<wchar_t>&\n    use_facet<collate<wchar_t> >(const locale&);\n\n  extern template\n    bool\n    has_facet<collate<wchar_t> >(con'
[#] parse_declaration, is_constructor=False, meet line: 'template\n    const collate<wchar_t>&\n    use_facet<collate<wchar_t> >(const locale&);\n\n  extern template\n    bool\n    has_facet<collate<wchar_t> >(const locale&);\n\n\n\n\n}\n# 852 "/usr/include/c++/7/bits/'
[#] parse_declaration, is_constructor=False, meet line: 'template\n    bool\n    has_facet<collate<wchar_t> >(const locale&);\n\n\n\n\n}\n# 852 "/usr/include/c++/7/bits/locale_classes.h" 2 3\n# 42 "/usr/include/c++/7/bits/ios_base.h" 2 3\n\n\n\n\n# 1 "/usr/include/c++/7/'
[#] parse_declaration, is_constructor=False, meet line: 'char* _M_p;\n      char _M_bytes[sizeof(const char*)];\n    };\n\n    __cow_string();\n    __cow_string(const std::string&);\n    __cow_string(const char*, size_t);\n    __cow_string(const __cow_string&) noe'
[#] parse_declaration, is_constructor=False, meet line: 'char _M_bytes[sizeof(const char*)];\n    };\n\n    __cow_string();\n    __cow_string(const std::string&);\n    __cow_string(const char*, size_t);\n    __cow_string(const __cow_string&) noexcept;\n    __cow_s'
[#] parse_declaration, is_constructor=True, meet line: '__cow_string();\n    __cow_string(const std::string&);\n    __cow_string(const char*, size_t);\n    __cow_string(const __cow_string&) noexcept;\n    __cow_string& operator=(const __cow_string&) noexcept;\n'
[#] parse_declaration, is_constructor=True, meet line: '__cow_string(const std::string&);\n    __cow_string(const char*, size_t);\n    __cow_string(const __cow_string&) noexcept;\n    __cow_string& operator=(const __cow_string&) noexcept;\n    ~__cow_string();'
[#] parse_declaration, is_constructor=True, meet line: '__cow_string(const char*, size_t);\n    __cow_string(const __cow_string&) noexcept;\n    __cow_string& operator=(const __cow_string&) noexcept;\n    ~__cow_string();\n\n    __cow_string(__cow_string&&) noe'
[#] parse_declaration, is_constructor=True, meet line: '__cow_string(const __cow_string&) noexcept;\n    __cow_string& operator=(const __cow_string&) noexcept;\n    ~__cow_string();\n\n    __cow_string(__cow_string&&) noexcept;\n    __cow_string& operator=(__co'
[#] parse_declaration, is_constructor=True, meet line: '__cow_string& operator=(const __cow_string&) noexcept;\n    ~__cow_string();\n\n    __cow_string(__cow_string&&) noexcept;\n    __cow_string& operator=(__cow_string&&) noexcept;\n\n  };\n\n  typedef basic_str'
[#] parse_declaration, is_constructor=True, meet line: '__cow_string();\n\n    __cow_string(__cow_string&&) noexcept;\n    __cow_string& operator=(__cow_string&&) noexcept;\n\n  };\n\n  typedef basic_string<char> __sso_string;\n# 113 "/usr/include/c++/7/stdexcept"'
[#] parse_declaration, is_constructor=True, meet line: '__cow_string(__cow_string&&) noexcept;\n    __cow_string& operator=(__cow_string&&) noexcept;\n\n  };\n\n  typedef basic_string<char> __sso_string;\n# 113 "/usr/include/c++/7/stdexcept" 3\n  class logic_erro'
[#] parse_declaration, is_constructor=True, meet line: '__cow_string& operator=(__cow_string&&) noexcept;\n\n  };\n\n  typedef basic_string<char> __sso_string;\n# 113 "/usr/include/c++/7/stdexcept" 3\n  class logic_error : public exception\n  {\n    __cow_string _'
[#] parse_declaration, is_constructor=False, meet line: '__cow_string _M_msg;\n\n  public:\n\n    explicit\n    logic_error(const string& __arg) ;\n\n\n    explicit\n    logic_error(const char*) ;\n\n\n\n    logic_error(const logic_error&) noexcept;\n    logic_error& ope'
[#] parse_declaration, is_constructor=True, meet line: 'logic_error(const string& __arg) ;\n\n\n    explicit\n    logic_error(const char*) ;\n\n\n\n    logic_error(const logic_error&) noexcept;\n    logic_error& operator=(const logic_error&) noexcept;\n\n\n    virtual'
[#] parse_declaration, is_constructor=True, meet line: 'logic_error(const char*) ;\n\n\n\n    logic_error(const logic_error&) noexcept;\n    logic_error& operator=(const logic_error&) noexcept;\n\n\n    virtual ~logic_error() noexcept;\n\n\n\n    virtual const char*\n '
[#] parse_declaration, is_constructor=True, meet line: 'logic_error(const logic_error&) noexcept;\n    logic_error& operator=(const logic_error&) noexcept;\n\n\n    virtual ~logic_error() noexcept;\n\n\n\n    virtual const char*\n    what() const noexcept;\n\n\n\n\n\n  }'
[#] parse_declaration, is_constructor=True, meet line: 'logic_error& operator=(const logic_error&) noexcept;\n\n\n    virtual ~logic_error() noexcept;\n\n\n\n    virtual const char*\n    what() const noexcept;\n\n\n\n\n\n  };\n\n\n\n  class domain_error : public logic_error'
[#] parse_declaration, is_constructor=True, meet line: 'logic_error() noexcept;\n\n\n\n    virtual const char*\n    what() const noexcept;\n\n\n\n\n\n  };\n\n\n\n  class domain_error : public logic_error\n  {\n  public:\n    explicit domain_error(const string& __arg) ;\n\n   '
[#] parse_declaration, is_constructor=False, meet line: 'char*\n    what() const noexcept;\n\n\n\n\n\n  };\n\n\n\n  class domain_error : public logic_error\n  {\n  public:\n    explicit domain_error(const string& __arg) ;\n\n    explicit domain_error(const char*) ;\n\n    vi'
[#] parse_declaration, is_constructor=True, meet line: 'domain_error(const string& __arg) ;\n\n    explicit domain_error(const char*) ;\n\n    virtual ~domain_error() noexcept;\n  };\n\n\n  class invalid_argument : public logic_error\n  {\n  public:\n    explicit inv'
[#] parse_declaration, is_constructor=True, meet line: 'domain_error(const char*) ;\n\n    virtual ~domain_error() noexcept;\n  };\n\n\n  class invalid_argument : public logic_error\n  {\n  public:\n    explicit invalid_argument(const string& __arg) ;\n\n    explicit'
[#] parse_declaration, is_constructor=True, meet line: 'domain_error() noexcept;\n  };\n\n\n  class invalid_argument : public logic_error\n  {\n  public:\n    explicit invalid_argument(const string& __arg) ;\n\n    explicit invalid_argument(const char*) ;\n\n    virt'
[#] parse_declaration, is_constructor=True, meet line: 'invalid_argument(const string& __arg) ;\n\n    explicit invalid_argument(const char*) ;\n\n    virtual ~invalid_argument() noexcept;\n  };\n\n\n\n  class length_error : public logic_error\n  {\n  public:\n    exp'
[#] parse_declaration, is_constructor=True, meet line: 'invalid_argument(const char*) ;\n\n    virtual ~invalid_argument() noexcept;\n  };\n\n\n\n  class length_error : public logic_error\n  {\n  public:\n    explicit length_error(const string& __arg) ;\n\n    explici'
[#] parse_declaration, is_constructor=True, meet line: 'invalid_argument() noexcept;\n  };\n\n\n\n  class length_error : public logic_error\n  {\n  public:\n    explicit length_error(const string& __arg) ;\n\n    explicit length_error(const char*) ;\n\n    virtual ~le'
[#] parse_declaration, is_constructor=True, meet line: 'length_error(const string& __arg) ;\n\n    explicit length_error(const char*) ;\n\n    virtual ~length_error() noexcept;\n  };\n\n\n\n  class out_of_range : public logic_error\n  {\n  public:\n    explicit out_of'
[#] parse_declaration, is_constructor=True, meet line: 'length_error(const char*) ;\n\n    virtual ~length_error() noexcept;\n  };\n\n\n\n  class out_of_range : public logic_error\n  {\n  public:\n    explicit out_of_range(const string& __arg) ;\n\n    explicit out_of'
[#] parse_declaration, is_constructor=True, meet line: 'length_error() noexcept;\n  };\n\n\n\n  class out_of_range : public logic_error\n  {\n  public:\n    explicit out_of_range(const string& __arg) ;\n\n    explicit out_of_range(const char*) ;\n\n    virtual ~out_of'
[#] parse_declaration, is_constructor=True, meet line: 'out_of_range(const string& __arg) ;\n\n    explicit out_of_range(const char*) ;\n\n    virtual ~out_of_range() noexcept;\n  };\n\n\n\n\n\n\n  class runtime_error : public exception\n  {\n    __cow_string _M_msg;\n\n '
[#] parse_declaration, is_constructor=True, meet line: 'out_of_range(const char*) ;\n\n    virtual ~out_of_range() noexcept;\n  };\n\n\n\n\n\n\n  class runtime_error : public exception\n  {\n    __cow_string _M_msg;\n\n  public:\n\n    explicit\n    runtime_error(const str'
[#] parse_declaration, is_constructor=True, meet line: 'out_of_range() noexcept;\n  };\n\n\n\n\n\n\n  class runtime_error : public exception\n  {\n    __cow_string _M_msg;\n\n  public:\n\n    explicit\n    runtime_error(const string& __arg) ;\n\n\n    explicit\n    runtime_e'
[#] parse_declaration, is_constructor=False, meet line: '__cow_string _M_msg;\n\n  public:\n\n    explicit\n    runtime_error(const string& __arg) ;\n\n\n    explicit\n    runtime_error(const char*) ;\n\n\n\n    runtime_error(const runtime_error&) noexcept;\n    runtime_'
[#] parse_declaration, is_constructor=True, meet line: 'runtime_error(const string& __arg) ;\n\n\n    explicit\n    runtime_error(const char*) ;\n\n\n\n    runtime_error(const runtime_error&) noexcept;\n    runtime_error& operator=(const runtime_error&) noexcept;\n\n'
[#] parse_declaration, is_constructor=True, meet line: 'runtime_error(const char*) ;\n\n\n\n    runtime_error(const runtime_error&) noexcept;\n    runtime_error& operator=(const runtime_error&) noexcept;\n\n\n    virtual ~runtime_error() noexcept;\n\n\n\n    virtual c'
[#] parse_declaration, is_constructor=True, meet line: 'runtime_error(const runtime_error&) noexcept;\n    runtime_error& operator=(const runtime_error&) noexcept;\n\n\n    virtual ~runtime_error() noexcept;\n\n\n\n    virtual const char*\n    what() const noexcept'
[#] parse_declaration, is_constructor=True, meet line: 'runtime_error& operator=(const runtime_error&) noexcept;\n\n\n    virtual ~runtime_error() noexcept;\n\n\n\n    virtual const char*\n    what() const noexcept;\n\n\n\n\n\n  };\n\n\n  class range_error : public runtime'
[#] parse_declaration, is_constructor=True, meet line: 'runtime_error() noexcept;\n\n\n\n    virtual const char*\n    what() const noexcept;\n\n\n\n\n\n  };\n\n\n  class range_error : public runtime_error\n  {\n  public:\n    explicit range_error(const string& __arg) ;\n\n  '
[#] parse_declaration, is_constructor=False, meet line: 'char*\n    what() const noexcept;\n\n\n\n\n\n  };\n\n\n  class range_error : public runtime_error\n  {\n  public:\n    explicit range_error(const string& __arg) ;\n\n    explicit range_error(const char*) ;\n\n    virt'
[#] parse_declaration, is_constructor=True, meet line: 'range_error(const string& __arg) ;\n\n    explicit range_error(const char*) ;\n\n    virtual ~range_error() noexcept;\n  };\n\n\n  class overflow_error : public runtime_error\n  {\n  public:\n    explicit overfl'
[#] parse_declaration, is_constructor=True, meet line: 'range_error(const char*) ;\n\n    virtual ~range_error() noexcept;\n  };\n\n\n  class overflow_error : public runtime_error\n  {\n  public:\n    explicit overflow_error(const string& __arg) ;\n\n    explicit ove'
[#] parse_declaration, is_constructor=True, meet line: 'range_error() noexcept;\n  };\n\n\n  class overflow_error : public runtime_error\n  {\n  public:\n    explicit overflow_error(const string& __arg) ;\n\n    explicit overflow_error(const char*) ;\n\n    virtual ~'
[#] parse_declaration, is_constructor=True, meet line: 'overflow_error(const string& __arg) ;\n\n    explicit overflow_error(const char*) ;\n\n    virtual ~overflow_error() noexcept;\n  };\n\n\n  class underflow_error : public runtime_error\n  {\n  public:\n    expli'
[#] parse_declaration, is_constructor=True, meet line: 'overflow_error(const char*) ;\n\n    virtual ~overflow_error() noexcept;\n  };\n\n\n  class underflow_error : public runtime_error\n  {\n  public:\n    explicit underflow_error(const string& __arg) ;\n\n    expl'
[#] parse_declaration, is_constructor=True, meet line: 'overflow_error() noexcept;\n  };\n\n\n  class underflow_error : public runtime_error\n  {\n  public:\n    explicit underflow_error(const string& __arg) ;\n\n    explicit underflow_error(const char*) ;\n\n    vir'
[#] parse_declaration, is_constructor=True, meet line: 'underflow_error(const string& __arg) ;\n\n    explicit underflow_error(const char*) ;\n\n    virtual ~underflow_error() noexcept;\n  };\n\n\n\n\n}\n# 42 "/usr/include/c++/7/system_error" 2 3\n\nnamespace std __att'
[#] parse_declaration, is_constructor=True, meet line: 'underflow_error(const char*) ;\n\n    virtual ~underflow_error() noexcept;\n  };\n\n\n\n\n}\n# 42 "/usr/include/c++/7/system_error" 2 3\n\nnamespace std __attribute__ ((__visibility__ ("default")))\n{\n\n\n  class e'
[#] parse_declaration, is_constructor=True, meet line: 'underflow_error() noexcept;\n  };\n\n\n\n\n}\n# 42 "/usr/include/c++/7/system_error" 2 3\n\nnamespace std __attribute__ ((__visibility__ ("default")))\n{\n\n\n  class error_code;\n  class error_condition;\n  class s'
[#] parse_declaration, is_constructor=True, meet line: 'error_category() noexcept = default;\n\n    virtual ~error_category();\n\n    error_category(const error_category&) = delete;\n    error_category& operator=(const error_category&) = delete;\n\n    virtual co'
[#] parse_declaration, is_constructor=True, meet line: 'error_category();\n\n    error_category(const error_category&) = delete;\n    error_category& operator=(const error_category&) = delete;\n\n    virtual const char*\n    name() const noexcept = 0;\n\n\n\n\n\n\n  pr'
[#] parse_declaration, is_constructor=True, meet line: 'error_category(const error_category&) = delete;\n    error_category& operator=(const error_category&) = delete;\n\n    virtual const char*\n    name() const noexcept = 0;\n\n\n\n\n\n\n  private:\n    __attribute '
[#] parse_declaration, is_constructor=True, meet line: 'error_category& operator=(const error_category&) = delete;\n\n    virtual const char*\n    name() const noexcept = 0;\n\n\n\n\n\n\n  private:\n    __attribute ((__abi_tag__ ("cxx11")))\n    virtual __cow_string\n '
[#] parse_declaration, is_constructor=False, meet line: 'char*\n    name() const noexcept = 0;\n\n\n\n\n\n\n  private:\n    __attribute ((__abi_tag__ ("cxx11")))\n    virtual __cow_string\n    _M_message(int) const;\n\n  public:\n    __attribute ((__abi_tag__ ("cxx11")))'
[#] parse_declaration, is_constructor=False, meet line: '__cow_string\n    _M_message(int) const;\n\n  public:\n    __attribute ((__abi_tag__ ("cxx11")))\n    virtual string\n    message(int) const = 0;\n# 110 "/usr/include/c++/7/system_error" 3\n  public:\n    virt'
[#] parse_declaration, is_constructor=False, meet line: 'string\n    message(int) const = 0;\n# 110 "/usr/include/c++/7/system_error" 3\n  public:\n    virtual error_condition\n    default_error_condition(int __i) const noexcept;\n\n    virtual bool\n    equivalent'
[#] parse_declaration, is_constructor=False, meet line: 'error_condition\n    default_error_condition(int __i) const noexcept;\n\n    virtual bool\n    equivalent(int __i, const error_condition& __cond) const noexcept;\n\n    virtual bool\n    equivalent(const err'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    equivalent(int __i, const error_condition& __cond) const noexcept;\n\n    virtual bool\n    equivalent(const error_code& __code, int __i) const noexcept;\n\n    bool\n    operator<(const error_cate'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    equivalent(const error_code& __code, int __i) const noexcept;\n\n    bool\n    operator<(const error_category& __other) const noexcept\n    { return less<const error_category*>()(this, &__other);'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<(const error_category& __other) const noexcept\n    { return less<const error_category*>()(this, &__other); }\n\n    bool\n    operator==(const error_category& __other) const noexcept\n  '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator==(const error_category& __other) const noexcept\n    { return this == &__other; }\n\n    bool\n    operator!=(const error_category& __other) const noexcept\n    { return this != &__other;'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator!=(const error_category& __other) const noexcept\n    { return this != &__other; }\n  };\n\n\n  __attribute__ ((__const__)) const error_category& system_category() noexcept;\n  __attribute_'
[#] parse_declaration, is_constructor=False, meet line: '__attribute__ ((__const__)) const error_category& system_category() noexcept;\n  __attribute__ ((__const__)) const error_category& generic_category() noexcept;\n\n  }\n\n  error_code make_error_code(errc) '
[#] parse_declaration, is_constructor=False, meet line: '__attribute__ ((__const__)) const error_category& generic_category() noexcept;\n\n  }\n\n  error_code make_error_code(errc) noexcept;\n\n  template<typename _Tp>\n    struct hash;\n\n\n\n  struct error_code\n  {\n'
[#] parse_declaration, is_constructor=False, meet line: 'error_code make_error_code(errc) noexcept;\n\n  template<typename _Tp>\n    struct hash;\n\n\n\n  struct error_code\n  {\n    error_code() noexcept\n    : _M_value(0), _M_cat(&system_category()) { }\n\n    error_'
[#] parse_declaration, is_constructor=True, meet line: 'error_code() noexcept\n    : _M_value(0), _M_cat(&system_category()) { }\n\n    error_code(int __v, const error_category& __cat) noexcept\n    : _M_value(__v), _M_cat(&__cat) { }\n\n    template<typename _E'
[#] parse_declaration, is_constructor=True, meet line: 'error_code(int __v, const error_category& __cat) noexcept\n    : _M_value(__v), _M_cat(&__cat) { }\n\n    template<typename _ErrorCodeEnum, typename = typename\n      enable_if<is_error_code_enum<_ErrorCo'
[#] parse_declaration, is_constructor=True, meet line: 'error_code(_ErrorCodeEnum __e) noexcept\n      { *this = make_error_code(__e); }\n\n    void\n    assign(int __v, const error_category& __cat) noexcept\n    {\n      _M_value = __v;\n      _M_cat = &__cat;\n '
[#] parse_declaration, is_constructor=False, meet line: 'void\n    assign(int __v, const error_category& __cat) noexcept\n    {\n      _M_value = __v;\n      _M_cat = &__cat;\n    }\n\n    void\n    clear() noexcept\n    { assign(0, system_category()); }\n\n\n    templ'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    clear() noexcept\n    { assign(0, system_category()); }\n\n\n    template<typename _ErrorCodeEnum>\n      typename enable_if<is_error_code_enum<_ErrorCodeEnum>::value,\n    error_code&>::type\n     '
[#] parse_declaration, is_constructor=False, meet line: 'enable_if<is_error_code_enum<_ErrorCodeEnum>::value,\n    error_code&>::type\n      operator=(_ErrorCodeEnum __e) noexcept\n      { return *this = make_error_code(__e); }\n\n    int\n    value() const noexc'
[#] parse_declaration, is_constructor=False, meet line: 'int\n    value() const noexcept { return _M_value; }\n\n    const error_category&\n    category() const noexcept { return *_M_cat; }\n\n    error_condition\n    default_error_condition() const noexcept;\n\n   '
[#] parse_declaration, is_constructor=False, meet line: 'error_category&\n    category() const noexcept { return *_M_cat; }\n\n    error_condition\n    default_error_condition() const noexcept;\n\n    __attribute ((__abi_tag__ ("cxx11")))\n    string\n    message()'
[#] parse_declaration, is_constructor=False, meet line: 'error_condition\n    default_error_condition() const noexcept;\n\n    __attribute ((__abi_tag__ ("cxx11")))\n    string\n    message() const\n    { return category().message(value()); }\n\n    explicit operat'
[#] parse_declaration, is_constructor=False, meet line: 'string\n    message() const\n    { return category().message(value()); }\n\n    explicit operator bool() const noexcept\n    { return _M_value != 0; }\n\n\n  private:\n    friend class hash<error_code>;\n\n    i'
[#] parse_declaration, is_constructor=False, meet line: 'operator bool() const noexcept\n    { return _M_value != 0; }\n\n\n  private:\n    friend class hash<error_code>;\n\n    int _M_value;\n    const error_category* _M_cat;\n  };\n\n\n  inline error_code\n  make_erro'
[#] parse_declaration, is_constructor=False, meet line: 'int _M_value;\n    const error_category* _M_cat;\n  };\n\n\n  inline error_code\n  make_error_code(errc __e) noexcept\n  { return error_code(static_cast<int>(__e), generic_category()); }\n\n  inline bool\n  ope'
[#] parse_declaration, is_constructor=False, meet line: 'error_category* _M_cat;\n  };\n\n\n  inline error_code\n  make_error_code(errc __e) noexcept\n  { return error_code(static_cast<int>(__e), generic_category()); }\n\n  inline bool\n  operator<(const error_code&'
[#] parse_declaration, is_constructor=False, meet line: 'error_code\n  make_error_code(errc __e) noexcept\n  { return error_code(static_cast<int>(__e), generic_category()); }\n\n  inline bool\n  operator<(const error_code& __lhs, const error_code& __rhs) noexcep'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n  operator<(const error_code& __lhs, const error_code& __rhs) noexcept\n  {\n    return (__lhs.category() < __rhs.category()\n     || (__lhs.category() == __rhs.category()\n  && __lhs.value() < __rhs'
[#] parse_declaration, is_constructor=False, meet line: "basic_ostream<_CharT, _Traits>&\n    operator<<(basic_ostream<_CharT, _Traits>& __os, const error_code& __e)\n    { return (__os << __e.category().name() << ':' << __e.value()); }\n\n  error_condition mak"
[#] parse_declaration, is_constructor=False, meet line: 'error_condition make_error_condition(errc) noexcept;\n\n\n\n  struct error_condition\n  {\n    error_condition() noexcept\n    : _M_value(0), _M_cat(&generic_category()) { }\n\n    error_condition(int __v, con'
[#] parse_declaration, is_constructor=True, meet line: 'error_condition() noexcept\n    : _M_value(0), _M_cat(&generic_category()) { }\n\n    error_condition(int __v, const error_category& __cat) noexcept\n    : _M_value(__v), _M_cat(&__cat) { }\n\n    template<'
[#] parse_declaration, is_constructor=True, meet line: 'error_condition(int __v, const error_category& __cat) noexcept\n    : _M_value(__v), _M_cat(&__cat) { }\n\n    template<typename _ErrorConditionEnum, typename = typename\n  enable_if<is_error_condition_en'
[#] parse_declaration, is_constructor=True, meet line: 'error_condition(_ErrorConditionEnum __e) noexcept\n      { *this = make_error_condition(__e); }\n\n    void\n    assign(int __v, const error_category& __cat) noexcept\n    {\n      _M_value = __v;\n      _M_'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    assign(int __v, const error_category& __cat) noexcept\n    {\n      _M_value = __v;\n      _M_cat = &__cat;\n    }\n\n\n    template<typename _ErrorConditionEnum>\n      typename enable_if<is_error_c'
[#] parse_declaration, is_constructor=False, meet line: 'enable_if<is_error_condition_enum\n    <_ErrorConditionEnum>::value, error_condition&>::type\n      operator=(_ErrorConditionEnum __e) noexcept\n      { return *this = make_error_condition(__e); }\n\n    v'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    clear() noexcept\n    { assign(0, generic_category()); }\n\n\n    int\n    value() const noexcept { return _M_value; }\n\n    const error_category&\n    category() const noexcept { return *_M_cat; }\n'
[#] parse_declaration, is_constructor=False, meet line: 'int\n    value() const noexcept { return _M_value; }\n\n    const error_category&\n    category() const noexcept { return *_M_cat; }\n\n    __attribute ((__abi_tag__ ("cxx11")))\n    string\n    message() con'
[#] parse_declaration, is_constructor=False, meet line: 'error_category&\n    category() const noexcept { return *_M_cat; }\n\n    __attribute ((__abi_tag__ ("cxx11")))\n    string\n    message() const\n    { return category().message(value()); }\n\n    explicit op'
[#] parse_declaration, is_constructor=False, meet line: 'string\n    message() const\n    { return category().message(value()); }\n\n    explicit operator bool() const noexcept\n    { return _M_value != 0; }\n\n\n  private:\n    int _M_value;\n    const error_categor'
[#] parse_declaration, is_constructor=False, meet line: 'operator bool() const noexcept\n    { return _M_value != 0; }\n\n\n  private:\n    int _M_value;\n    const error_category* _M_cat;\n  };\n\n\n  inline error_condition\n  make_error_condition(errc __e) noexcept\n'
[#] parse_declaration, is_constructor=False, meet line: 'int _M_value;\n    const error_category* _M_cat;\n  };\n\n\n  inline error_condition\n  make_error_condition(errc __e) noexcept\n  { return error_condition(static_cast<int>(__e), generic_category()); }\n\n  in'
[#] parse_declaration, is_constructor=False, meet line: 'error_category* _M_cat;\n  };\n\n\n  inline error_condition\n  make_error_condition(errc __e) noexcept\n  { return error_condition(static_cast<int>(__e), generic_category()); }\n\n  inline bool\n  operator<(co'
[#] parse_declaration, is_constructor=False, meet line: 'error_condition\n  make_error_condition(errc __e) noexcept\n  { return error_condition(static_cast<int>(__e), generic_category()); }\n\n  inline bool\n  operator<(const error_condition& __lhs,\n     const e'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n  operator<(const error_condition& __lhs,\n     const error_condition& __rhs) noexcept\n  {\n    return (__lhs.category() < __rhs.category()\n     || (__lhs.category() == __rhs.category()\n  && __lhs.'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n  operator==(const error_code& __lhs, const error_code& __rhs) noexcept\n  { return (__lhs.category() == __rhs.category()\n     && __lhs.value() == __rhs.value()); }\n\n  inline bool\n  operator==(con'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n  operator==(const error_code& __lhs, const error_condition& __rhs) noexcept\n  {\n    return (__lhs.category().equivalent(__lhs.value(), __rhs)\n     || __rhs.category().equivalent(__lhs, __rhs.val'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n  operator==(const error_condition& __lhs, const error_code& __rhs) noexcept\n  {\n    return (__rhs.category().equivalent(__rhs.value(), __lhs)\n     || __lhs.category().equivalent(__rhs, __lhs.val'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n  operator==(const error_condition& __lhs,\n      const error_condition& __rhs) noexcept\n  {\n    return (__lhs.category() == __rhs.category()\n     && __lhs.value() == __rhs.value());\n  }\n\n  inline'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n  operator!=(const error_code& __lhs, const error_code& __rhs) noexcept\n  { return !(__lhs == __rhs); }\n\n  inline bool\n  operator!=(const error_code& __lhs, const error_condition& __rhs) noexcept'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n  operator!=(const error_code& __lhs, const error_condition& __rhs) noexcept\n  { return !(__lhs == __rhs); }\n\n  inline bool\n  operator!=(const error_condition& __lhs, const error_code& __rhs) noe'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n  operator!=(const error_condition& __lhs, const error_code& __rhs) noexcept\n  { return !(__lhs == __rhs); }\n\n  inline bool\n  operator!=(const error_condition& __lhs,\n      const error_condition&'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n  operator!=(const error_condition& __lhs,\n      const error_condition& __rhs) noexcept\n  { return !(__lhs == __rhs); }\n\n\n\n\n\n\n\n  class system_error : public std::runtime_error\n  {\n  private:\n    '
[#] parse_declaration, is_constructor=False, meet line: 'error_code _M_code;\n\n  public:\n    system_error(error_code __ec = error_code())\n    : runtime_error(__ec.message()), _M_code(__ec) { }\n\n    system_error(error_code __ec, const string& __what)\n    : ru'
[#] parse_declaration, is_constructor=True, meet line: 'system_error(error_code __ec = error_code())\n    : runtime_error(__ec.message()), _M_code(__ec) { }\n\n    system_error(error_code __ec, const string& __what)\n    : runtime_error(__what + ": " + __ec.me'
[#] parse_declaration, is_constructor=True, meet line: 'system_error(error_code __ec, const string& __what)\n    : runtime_error(__what + ": " + __ec.message()), _M_code(__ec) { }\n\n    system_error(error_code __ec, const char* __what)\n    : runtime_error(__'
[#] parse_declaration, is_constructor=True, meet line: 'system_error(error_code __ec, const char* __what)\n    : runtime_error(__what + (": " + __ec.message())), _M_code(__ec) { }\n\n    system_error(int __v, const error_category& __ecat, const char* __what)\n'
[#] parse_declaration, is_constructor=True, meet line: 'system_error(int __v, const error_category& __ecat, const char* __what)\n    : system_error(error_code(__v, __ecat), __what) { }\n\n    system_error(int __v, const error_category& __ecat)\n    : runtime_e'
[#] parse_declaration, is_constructor=True, meet line: 'system_error(int __v, const error_category& __ecat)\n    : runtime_error(error_code(__v, __ecat).message()),\n      _M_code(__v, __ecat) { }\n\n    system_error(int __v, const error_category& __ecat, cons'
[#] parse_declaration, is_constructor=True, meet line: 'system_error(int __v, const error_category& __ecat, const string& __what)\n    : runtime_error(__what + ": " + error_code(__v, __ecat).message()),\n      _M_code(__v, __ecat) { }\n\n    virtual ~system_er'
[#] parse_declaration, is_constructor=True, meet line: 'system_error() noexcept;\n\n    const error_code&\n    code() const noexcept { return _M_code; }\n  };\n\n\n}\n\n\n\nnamespace std __attribute__ ((__visibility__ ("default")))\n{\n\n\n\n\n\n  template<>\n    struct hash'
[#] parse_declaration, is_constructor=False, meet line: 'error_code&\n    code() const noexcept { return _M_code; }\n  };\n\n\n}\n\n\n\nnamespace std __attribute__ ((__visibility__ ("default")))\n{\n\n\n\n\n\n  template<>\n    struct hash<error_code>\n    : public __hash_bas'
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n      operator()(const error_code& __e) const noexcept\n      {\n const size_t __tmp = std::_Hash_impl::hash(__e._M_value);\n return std::_Hash_impl::__hash_combine(__e._M_cat, __tmp);\n      }\n   '
[#] parse_declaration, is_constructor=False, meet line: '_Ios_Fmtflags\n  operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b)\n  { return _Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b)); }\n\n  inline constexpr _Ios_Fmtflags\n  operator|(_Ios_Fmtflags _'
[#] parse_declaration, is_constructor=False, meet line: '_Ios_Fmtflags\n  operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b)\n  { return _Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b)); }\n\n  inline constexpr _Ios_Fmtflags\n  operator^(_Ios_Fmtflags _'
[#] parse_declaration, is_constructor=False, meet line: '_Ios_Fmtflags\n  operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b)\n  { return _Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b)); }\n\n  inline constexpr _Ios_Fmtflags\n  operator~(_Ios_Fmtflags _'
[#] parse_declaration, is_constructor=False, meet line: '_Ios_Fmtflags\n  operator~(_Ios_Fmtflags __a)\n  { return _Ios_Fmtflags(~static_cast<int>(__a)); }\n\n  inline const _Ios_Fmtflags&\n  operator|=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)\n  { return __a = __a'
[#] parse_declaration, is_constructor=False, meet line: '_Ios_Fmtflags&\n  operator|=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)\n  { return __a = __a | __b; }\n\n  inline const _Ios_Fmtflags&\n  operator&=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)\n  { return __a = __a'
[#] parse_declaration, is_constructor=False, meet line: '_Ios_Fmtflags&\n  operator&=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)\n  { return __a = __a & __b; }\n\n  inline const _Ios_Fmtflags&\n  operator^=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)\n  { return __a = __a'
[#] parse_declaration, is_constructor=False, meet line: '_Ios_Fmtflags&\n  operator^=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)\n  { return __a = __a ^ __b; }\n\n\n  enum _Ios_Openmode\n    {\n      _S_app = 1L << 0,\n      _S_ate = 1L << 1,\n      _S_bin = 1L << 2,\n  '
[#] parse_declaration, is_constructor=False, meet line: '_Ios_Openmode\n  operator&(_Ios_Openmode __a, _Ios_Openmode __b)\n  { return _Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b)); }\n\n  inline constexpr _Ios_Openmode\n  operator|(_Ios_Openmode _'
[#] parse_declaration, is_constructor=False, meet line: '_Ios_Openmode\n  operator|(_Ios_Openmode __a, _Ios_Openmode __b)\n  { return _Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b)); }\n\n  inline constexpr _Ios_Openmode\n  operator^(_Ios_Openmode _'
[#] parse_declaration, is_constructor=False, meet line: '_Ios_Openmode\n  operator^(_Ios_Openmode __a, _Ios_Openmode __b)\n  { return _Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b)); }\n\n  inline constexpr _Ios_Openmode\n  operator~(_Ios_Openmode _'
[#] parse_declaration, is_constructor=False, meet line: '_Ios_Openmode\n  operator~(_Ios_Openmode __a)\n  { return _Ios_Openmode(~static_cast<int>(__a)); }\n\n  inline const _Ios_Openmode&\n  operator|=(_Ios_Openmode& __a, _Ios_Openmode __b)\n  { return __a = __a'
[#] parse_declaration, is_constructor=False, meet line: '_Ios_Openmode&\n  operator|=(_Ios_Openmode& __a, _Ios_Openmode __b)\n  { return __a = __a | __b; }\n\n  inline const _Ios_Openmode&\n  operator&=(_Ios_Openmode& __a, _Ios_Openmode __b)\n  { return __a = __a'
[#] parse_declaration, is_constructor=False, meet line: '_Ios_Openmode&\n  operator&=(_Ios_Openmode& __a, _Ios_Openmode __b)\n  { return __a = __a & __b; }\n\n  inline const _Ios_Openmode&\n  operator^=(_Ios_Openmode& __a, _Ios_Openmode __b)\n  { return __a = __a'
[#] parse_declaration, is_constructor=False, meet line: '_Ios_Openmode&\n  operator^=(_Ios_Openmode& __a, _Ios_Openmode __b)\n  { return __a = __a ^ __b; }\n\n\n  enum _Ios_Iostate\n    {\n      _S_goodbit = 0,\n      _S_badbit = 1L << 0,\n      _S_eofbit = 1L << 1,'
[#] parse_declaration, is_constructor=False, meet line: '_Ios_Iostate\n  operator&(_Ios_Iostate __a, _Ios_Iostate __b)\n  { return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b)); }\n\n  inline constexpr _Ios_Iostate\n  operator|(_Ios_Iostate __a, _I'
[#] parse_declaration, is_constructor=False, meet line: '_Ios_Iostate\n  operator|(_Ios_Iostate __a, _Ios_Iostate __b)\n  { return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b)); }\n\n  inline constexpr _Ios_Iostate\n  operator^(_Ios_Iostate __a, _I'
[#] parse_declaration, is_constructor=False, meet line: '_Ios_Iostate\n  operator^(_Ios_Iostate __a, _Ios_Iostate __b)\n  { return _Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b)); }\n\n  inline constexpr _Ios_Iostate\n  operator~(_Ios_Iostate __a)\n  '
[#] parse_declaration, is_constructor=False, meet line: '_Ios_Iostate\n  operator~(_Ios_Iostate __a)\n  { return _Ios_Iostate(~static_cast<int>(__a)); }\n\n  inline const _Ios_Iostate&\n  operator|=(_Ios_Iostate& __a, _Ios_Iostate __b)\n  { return __a = __a | __b'
[#] parse_declaration, is_constructor=False, meet line: '_Ios_Iostate&\n  operator|=(_Ios_Iostate& __a, _Ios_Iostate __b)\n  { return __a = __a | __b; }\n\n  inline const _Ios_Iostate&\n  operator&=(_Ios_Iostate& __a, _Ios_Iostate __b)\n  { return __a = __a & __b'
[#] parse_declaration, is_constructor=False, meet line: '_Ios_Iostate&\n  operator&=(_Ios_Iostate& __a, _Ios_Iostate __b)\n  { return __a = __a & __b; }\n\n  inline const _Ios_Iostate&\n  operator^=(_Ios_Iostate& __a, _Ios_Iostate __b)\n  { return __a = __a ^ __b'
[#] parse_declaration, is_constructor=False, meet line: '_Ios_Iostate&\n  operator^=(_Ios_Iostate& __a, _Ios_Iostate __b)\n  { return __a = __a ^ __b; }\n\n\n  enum _Ios_Seekdir\n    {\n      _S_beg = 0,\n      _S_cur = 1,\n      _S_end = 2,\n      _S_ios_seekdir_end'
[#] parse_declaration, is_constructor=False, meet line: 'error_category& iostream_category() noexcept;\n\n  inline error_code\n  make_error_code(io_errc __e) noexcept\n  { return error_code(static_cast<int>(__e), iostream_category()); }\n\n  inline error_conditio'
[#] parse_declaration, is_constructor=False, meet line: 'error_code\n  make_error_code(io_errc __e) noexcept\n  { return error_code(static_cast<int>(__e), iostream_category()); }\n\n  inline error_condition\n  make_error_condition(io_errc __e) noexcept\n  { retur'
[#] parse_declaration, is_constructor=False, meet line: 'error_condition\n  make_error_condition(io_errc __e) noexcept\n  { return error_condition(static_cast<int>(__e), iostream_category()); }\n# 228 "/usr/include/c++/7/bits/ios_base.h" 3\n  class ios_base\n  {'
[#] parse_declaration, is_constructor=True, meet line: 'failure(const string& __str);\n\n\n      explicit\n      failure(const string&, const error_code&);\n\n      explicit\n      failure(const char*, const error_code& = io_errc::stream);\n\n\n      virtual\n      ~'
[#] parse_declaration, is_constructor=True, meet line: 'failure(const string&, const error_code&);\n\n      explicit\n      failure(const char*, const error_code& = io_errc::stream);\n\n\n      virtual\n      ~failure() throw();\n\n      virtual const char*\n      w'
[#] parse_declaration, is_constructor=True, meet line: 'failure(const char*, const error_code& = io_errc::stream);\n\n\n      virtual\n      ~failure() throw();\n\n      virtual const char*\n      what() const throw();\n    };\n# 323 "/usr/include/c++/7/bits/ios_ba'
[#] parse_declaration, is_constructor=True, meet line: 'failure() throw();\n\n      virtual const char*\n      what() const throw();\n    };\n# 323 "/usr/include/c++/7/bits/ios_base.h" 3\n    typedef _Ios_Fmtflags fmtflags;\n\n\n    static const fmtflags boolalpha '
[#] parse_declaration, is_constructor=False, meet line: 'char*\n      what() const throw();\n    };\n# 323 "/usr/include/c++/7/bits/ios_base.h" 3\n    typedef _Ios_Fmtflags fmtflags;\n\n\n    static const fmtflags boolalpha = _S_boolalpha;\n\n\n    static const fmtfl'
[#] parse_declaration, is_constructor=False, meet line: 'fmtflags boolalpha = _S_boolalpha;\n\n\n    static const fmtflags dec = _S_dec;\n\n\n    static const fmtflags fixed = _S_fixed;\n\n\n    static const fmtflags hex = _S_hex;\n\n\n\n\n    static const fmtflags inter'
[#] parse_declaration, is_constructor=False, meet line: 'fmtflags dec = _S_dec;\n\n\n    static const fmtflags fixed = _S_fixed;\n\n\n    static const fmtflags hex = _S_hex;\n\n\n\n\n    static const fmtflags internal = _S_internal;\n\n\n\n    static const fmtflags left ='
[#] parse_declaration, is_constructor=False, meet line: 'fmtflags fixed = _S_fixed;\n\n\n    static const fmtflags hex = _S_hex;\n\n\n\n\n    static const fmtflags internal = _S_internal;\n\n\n\n    static const fmtflags left = _S_left;\n\n\n    static const fmtflags oct '
[#] parse_declaration, is_constructor=False, meet line: 'fmtflags hex = _S_hex;\n\n\n\n\n    static const fmtflags internal = _S_internal;\n\n\n\n    static const fmtflags left = _S_left;\n\n\n    static const fmtflags oct = _S_oct;\n\n\n\n    static const fmtflags right ='
[#] parse_declaration, is_constructor=False, meet line: 'fmtflags internal = _S_internal;\n\n\n\n    static const fmtflags left = _S_left;\n\n\n    static const fmtflags oct = _S_oct;\n\n\n\n    static const fmtflags right = _S_right;\n\n\n    static const fmtflags scien'
[#] parse_declaration, is_constructor=False, meet line: 'fmtflags left = _S_left;\n\n\n    static const fmtflags oct = _S_oct;\n\n\n\n    static const fmtflags right = _S_right;\n\n\n    static const fmtflags scientific = _S_scientific;\n\n\n\n    static const fmtflags s'
[#] parse_declaration, is_constructor=False, meet line: 'fmtflags oct = _S_oct;\n\n\n\n    static const fmtflags right = _S_right;\n\n\n    static const fmtflags scientific = _S_scientific;\n\n\n\n    static const fmtflags showbase = _S_showbase;\n\n\n\n    static const f'
[#] parse_declaration, is_constructor=False, meet line: 'fmtflags right = _S_right;\n\n\n    static const fmtflags scientific = _S_scientific;\n\n\n\n    static const fmtflags showbase = _S_showbase;\n\n\n\n    static const fmtflags showpoint = _S_showpoint;\n\n\n    sta'
[#] parse_declaration, is_constructor=False, meet line: 'fmtflags scientific = _S_scientific;\n\n\n\n    static const fmtflags showbase = _S_showbase;\n\n\n\n    static const fmtflags showpoint = _S_showpoint;\n\n\n    static const fmtflags showpos = _S_showpos;\n\n\n   '
[#] parse_declaration, is_constructor=False, meet line: 'fmtflags showbase = _S_showbase;\n\n\n\n    static const fmtflags showpoint = _S_showpoint;\n\n\n    static const fmtflags showpos = _S_showpos;\n\n\n    static const fmtflags skipws = _S_skipws;\n\n\n    static c'
[#] parse_declaration, is_constructor=False, meet line: 'fmtflags showpoint = _S_showpoint;\n\n\n    static const fmtflags showpos = _S_showpos;\n\n\n    static const fmtflags skipws = _S_skipws;\n\n\n    static const fmtflags unitbuf = _S_unitbuf;\n\n\n\n    static con'
[#] parse_declaration, is_constructor=False, meet line: 'fmtflags showpos = _S_showpos;\n\n\n    static const fmtflags skipws = _S_skipws;\n\n\n    static const fmtflags unitbuf = _S_unitbuf;\n\n\n\n    static const fmtflags uppercase = _S_uppercase;\n\n\n    static con'
[#] parse_declaration, is_constructor=False, meet line: 'fmtflags skipws = _S_skipws;\n\n\n    static const fmtflags unitbuf = _S_unitbuf;\n\n\n\n    static const fmtflags uppercase = _S_uppercase;\n\n\n    static const fmtflags adjustfield = _S_adjustfield;\n\n\n    st'
[#] parse_declaration, is_constructor=False, meet line: 'fmtflags unitbuf = _S_unitbuf;\n\n\n\n    static const fmtflags uppercase = _S_uppercase;\n\n\n    static const fmtflags adjustfield = _S_adjustfield;\n\n\n    static const fmtflags basefield = _S_basefield;\n\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'fmtflags uppercase = _S_uppercase;\n\n\n    static const fmtflags adjustfield = _S_adjustfield;\n\n\n    static const fmtflags basefield = _S_basefield;\n\n\n    static const fmtflags floatfield = _S_floatfiel'
[#] parse_declaration, is_constructor=False, meet line: 'fmtflags adjustfield = _S_adjustfield;\n\n\n    static const fmtflags basefield = _S_basefield;\n\n\n    static const fmtflags floatfield = _S_floatfield;\n# 398 "/usr/include/c++/7/bits/ios_base.h" 3\n    ty'
[#] parse_declaration, is_constructor=False, meet line: 'fmtflags basefield = _S_basefield;\n\n\n    static const fmtflags floatfield = _S_floatfield;\n# 398 "/usr/include/c++/7/bits/ios_base.h" 3\n    typedef _Ios_Iostate iostate;\n\n\n\n    static const iostate ba'
[#] parse_declaration, is_constructor=False, meet line: 'fmtflags floatfield = _S_floatfield;\n# 398 "/usr/include/c++/7/bits/ios_base.h" 3\n    typedef _Ios_Iostate iostate;\n\n\n\n    static const iostate badbit = _S_badbit;\n\n\n    static const iostate eofbit = '
[#] parse_declaration, is_constructor=False, meet line: 'iostate badbit = _S_badbit;\n\n\n    static const iostate eofbit = _S_eofbit;\n\n\n\n\n    static const iostate failbit = _S_failbit;\n\n\n    static const iostate goodbit = _S_goodbit;\n# 429 "/usr/include/c++/7'
[#] parse_declaration, is_constructor=False, meet line: 'iostate eofbit = _S_eofbit;\n\n\n\n\n    static const iostate failbit = _S_failbit;\n\n\n    static const iostate goodbit = _S_goodbit;\n# 429 "/usr/include/c++/7/bits/ios_base.h" 3\n    typedef _Ios_Openmode o'
[#] parse_declaration, is_constructor=False, meet line: 'iostate failbit = _S_failbit;\n\n\n    static const iostate goodbit = _S_goodbit;\n# 429 "/usr/include/c++/7/bits/ios_base.h" 3\n    typedef _Ios_Openmode openmode;\n\n\n    static const openmode app = _S_app'
[#] parse_declaration, is_constructor=False, meet line: 'iostate goodbit = _S_goodbit;\n# 429 "/usr/include/c++/7/bits/ios_base.h" 3\n    typedef _Ios_Openmode openmode;\n\n\n    static const openmode app = _S_app;\n\n\n    static const openmode ate = _S_ate;\n\n\n\n\n '
[#] parse_declaration, is_constructor=False, meet line: 'openmode app = _S_app;\n\n\n    static const openmode ate = _S_ate;\n\n\n\n\n    static const openmode binary = _S_bin;\n\n\n    static const openmode in = _S_in;\n\n\n    static const openmode out = _S_out;\n\n\n    '
[#] parse_declaration, is_constructor=False, meet line: 'openmode ate = _S_ate;\n\n\n\n\n    static const openmode binary = _S_bin;\n\n\n    static const openmode in = _S_in;\n\n\n    static const openmode out = _S_out;\n\n\n    static const openmode trunc = _S_trunc;\n# '
[#] parse_declaration, is_constructor=False, meet line: 'openmode binary = _S_bin;\n\n\n    static const openmode in = _S_in;\n\n\n    static const openmode out = _S_out;\n\n\n    static const openmode trunc = _S_trunc;\n# 461 "/usr/include/c++/7/bits/ios_base.h" 3\n '
[#] parse_declaration, is_constructor=False, meet line: 'openmode in = _S_in;\n\n\n    static const openmode out = _S_out;\n\n\n    static const openmode trunc = _S_trunc;\n# 461 "/usr/include/c++/7/bits/ios_base.h" 3\n    typedef _Ios_Seekdir seekdir;\n\n\n    static'
[#] parse_declaration, is_constructor=False, meet line: 'openmode out = _S_out;\n\n\n    static const openmode trunc = _S_trunc;\n# 461 "/usr/include/c++/7/bits/ios_base.h" 3\n    typedef _Ios_Seekdir seekdir;\n\n\n    static const seekdir beg = _S_beg;\n\n\n    stati'
[#] parse_declaration, is_constructor=False, meet line: 'openmode trunc = _S_trunc;\n# 461 "/usr/include/c++/7/bits/ios_base.h" 3\n    typedef _Ios_Seekdir seekdir;\n\n\n    static const seekdir beg = _S_beg;\n\n\n    static const seekdir cur = _S_cur;\n\n\n    static'
[#] parse_declaration, is_constructor=False, meet line: 'seekdir beg = _S_beg;\n\n\n    static const seekdir cur = _S_cur;\n\n\n    static const seekdir end = _S_end;\n\n\n    typedef int io_state;\n    typedef int open_mode;\n    typedef int seek_dir;\n\n    typedef st'
[#] parse_declaration, is_constructor=False, meet line: 'seekdir cur = _S_cur;\n\n\n    static const seekdir end = _S_end;\n\n\n    typedef int io_state;\n    typedef int open_mode;\n    typedef int seek_dir;\n\n    typedef std::streampos streampos;\n    typedef std::'
[#] parse_declaration, is_constructor=False, meet line: 'seekdir end = _S_end;\n\n\n    typedef int io_state;\n    typedef int open_mode;\n    typedef int seek_dir;\n\n    typedef std::streampos streampos;\n    typedef std::streamoff streamoff;\n# 487 "/usr/include/'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    register_callback(event_callback __fn, int __index);\n\n  protected:\n    streamsize _M_precision;\n    streamsize _M_width;\n    fmtflags _M_flags;\n    iostate _M_exception;\n    iostate _M_stream'
[#] parse_declaration, is_constructor=False, meet line: 'streamsize _M_precision;\n    streamsize _M_width;\n    fmtflags _M_flags;\n    iostate _M_exception;\n    iostate _M_streambuf_state;\n\n\n\n    struct _Callback_list\n    {\n\n      _Callback_list* _M_next;\n  '
[#] parse_declaration, is_constructor=False, meet line: 'streamsize _M_width;\n    fmtflags _M_flags;\n    iostate _M_exception;\n    iostate _M_streambuf_state;\n\n\n\n    struct _Callback_list\n    {\n\n      _Callback_list* _M_next;\n      ios_base::event_callback '
[#] parse_declaration, is_constructor=False, meet line: 'fmtflags _M_flags;\n    iostate _M_exception;\n    iostate _M_streambuf_state;\n\n\n\n    struct _Callback_list\n    {\n\n      _Callback_list* _M_next;\n      ios_base::event_callback _M_fn;\n      int _M_index'
[#] parse_declaration, is_constructor=False, meet line: 'iostate _M_exception;\n    iostate _M_streambuf_state;\n\n\n\n    struct _Callback_list\n    {\n\n      _Callback_list* _M_next;\n      ios_base::event_callback _M_fn;\n      int _M_index;\n      _Atomic_word _M'
[#] parse_declaration, is_constructor=False, meet line: 'iostate _M_streambuf_state;\n\n\n\n    struct _Callback_list\n    {\n\n      _Callback_list* _M_next;\n      ios_base::event_callback _M_fn;\n      int _M_index;\n      _Atomic_word _M_refcount;\n\n      _Callbac'
[#] parse_declaration, is_constructor=True, meet line: '_Callback_list* _M_next;\n      ios_base::event_callback _M_fn;\n      int _M_index;\n      _Atomic_word _M_refcount;\n\n      _Callback_list(ios_base::event_callback __fn, int __index,\n       _Callback_li'
[#] parse_declaration, is_constructor=False, meet line: 'ios_base::event_callback _M_fn;\n      int _M_index;\n      _Atomic_word _M_refcount;\n\n      _Callback_list(ios_base::event_callback __fn, int __index,\n       _Callback_list* __cb)\n      : _M_next(__cb)'
[#] parse_declaration, is_constructor=False, meet line: 'int _M_index;\n      _Atomic_word _M_refcount;\n\n      _Callback_list(ios_base::event_callback __fn, int __index,\n       _Callback_list* __cb)\n      : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_r'
[#] parse_declaration, is_constructor=False, meet line: '_Atomic_word _M_refcount;\n\n      _Callback_list(ios_base::event_callback __fn, int __index,\n       _Callback_list* __cb)\n      : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) { }\n\n    '
[#] parse_declaration, is_constructor=True, meet line: '_Callback_list(ios_base::event_callback __fn, int __index,\n       _Callback_list* __cb)\n      : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) { }\n\n      void\n      _M_add_reference() {'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_add_reference() { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }\n\n\n      int\n      _M_remove_reference()\n      {\n\n        ;\n        int __res = __gnu_cxx::__exchange_and_add_dispat'
[#] parse_declaration, is_constructor=False, meet line: 'int\n      _M_remove_reference()\n      {\n\n        ;\n        int __res = __gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1);\n        if (__res == 0)\n          {\n            ;\n          }\n        r'
[#] parse_declaration, is_constructor=False, meet line: '_Callback_list* _M_callbacks;\n\n    void\n    _M_call_callbacks(event __ev) throw();\n\n    void\n    _M_dispose_callbacks(void) throw();\n\n\n    struct _Words\n    {\n      void* _M_pword;\n      long _M_iword'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _M_call_callbacks(event __ev) throw();\n\n    void\n    _M_dispose_callbacks(void) throw();\n\n\n    struct _Words\n    {\n      void* _M_pword;\n      long _M_iword;\n      _Words() : _M_pword(0), _M_'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _M_dispose_callbacks(void) throw();\n\n\n    struct _Words\n    {\n      void* _M_pword;\n      long _M_iword;\n      _Words() : _M_pword(0), _M_iword(0) { }\n    };\n\n\n    _Words _M_word_zero;\n\n\n\n   '
[#] parse_declaration, is_constructor=False, meet line: 'void* _M_pword;\n      long _M_iword;\n      _Words() : _M_pword(0), _M_iword(0) { }\n    };\n\n\n    _Words _M_word_zero;\n\n\n\n    enum { _S_local_word_size = 8 };\n    _Words _M_local_word[_S_local_word_size'
[#] parse_declaration, is_constructor=False, meet line: 'long _M_iword;\n      _Words() : _M_pword(0), _M_iword(0) { }\n    };\n\n\n    _Words _M_word_zero;\n\n\n\n    enum { _S_local_word_size = 8 };\n    _Words _M_local_word[_S_local_word_size];\n\n\n    int _M_word_s'
[#] parse_declaration, is_constructor=True, meet line: '_Words() : _M_pword(0), _M_iword(0) { }\n    };\n\n\n    _Words _M_word_zero;\n\n\n\n    enum { _S_local_word_size = 8 };\n    _Words _M_local_word[_S_local_word_size];\n\n\n    int _M_word_size;\n    _Words* _M_w'
[#] parse_declaration, is_constructor=False, meet line: '_Words _M_word_zero;\n\n\n\n    enum { _S_local_word_size = 8 };\n    _Words _M_local_word[_S_local_word_size];\n\n\n    int _M_word_size;\n    _Words* _M_word;\n\n    _Words&\n    _M_grow_words(int __index, bool'
[#] parse_declaration, is_constructor=False, meet line: '_Words _M_local_word[_S_local_word_size];\n\n\n    int _M_word_size;\n    _Words* _M_word;\n\n    _Words&\n    _M_grow_words(int __index, bool __iword);\n\n\n    locale _M_ios_locale;\n\n    void\n    _M_init() th'
[#] parse_declaration, is_constructor=False, meet line: 'int _M_word_size;\n    _Words* _M_word;\n\n    _Words&\n    _M_grow_words(int __index, bool __iword);\n\n\n    locale _M_ios_locale;\n\n    void\n    _M_init() throw();\n\n  public:\n\n\n\n\n\n    class Init\n    {\n    '
[#] parse_declaration, is_constructor=False, meet line: '_Words* _M_word;\n\n    _Words&\n    _M_grow_words(int __index, bool __iword);\n\n\n    locale _M_ios_locale;\n\n    void\n    _M_init() throw();\n\n  public:\n\n\n\n\n\n    class Init\n    {\n      friend class ios_bas'
[#] parse_declaration, is_constructor=False, meet line: '_Words&\n    _M_grow_words(int __index, bool __iword);\n\n\n    locale _M_ios_locale;\n\n    void\n    _M_init() throw();\n\n  public:\n\n\n\n\n\n    class Init\n    {\n      friend class ios_base;\n    public:\n      I'
[#] parse_declaration, is_constructor=False, meet line: 'locale _M_ios_locale;\n\n    void\n    _M_init() throw();\n\n  public:\n\n\n\n\n\n    class Init\n    {\n      friend class ios_base;\n    public:\n      Init();\n      ~Init();\n\n    private:\n      static _Atomic_wor'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _M_init() throw();\n\n  public:\n\n\n\n\n\n    class Init\n    {\n      friend class ios_base;\n    public:\n      Init();\n      ~Init();\n\n    private:\n      static _Atomic_word _S_refcount;\n      static'
[#] parse_declaration, is_constructor=True, meet line: 'Init();\n      ~Init();\n\n    private:\n      static _Atomic_word _S_refcount;\n      static bool _S_synced_with_stdio;\n    };\n\n\n\n\n\n\n    fmtflags\n    flags() const\n    { return _M_flags; }\n# 629 "/usr/inc'
[#] parse_declaration, is_constructor=True, meet line: 'Init();\n\n    private:\n      static _Atomic_word _S_refcount;\n      static bool _S_synced_with_stdio;\n    };\n\n\n\n\n\n\n    fmtflags\n    flags() const\n    { return _M_flags; }\n# 629 "/usr/include/c++/7/bits'
[#] parse_declaration, is_constructor=False, meet line: '_Atomic_word _S_refcount;\n      static bool _S_synced_with_stdio;\n    };\n\n\n\n\n\n\n    fmtflags\n    flags() const\n    { return _M_flags; }\n# 629 "/usr/include/c++/7/bits/ios_base.h" 3\n    fmtflags\n    fla'
[#] parse_declaration, is_constructor=False, meet line: 'bool _S_synced_with_stdio;\n    };\n\n\n\n\n\n\n    fmtflags\n    flags() const\n    { return _M_flags; }\n# 629 "/usr/include/c++/7/bits/ios_base.h" 3\n    fmtflags\n    flags(fmtflags __fmtfl)\n    {\n      fmtfla'
[#] parse_declaration, is_constructor=False, meet line: 'fmtflags\n    flags() const\n    { return _M_flags; }\n# 629 "/usr/include/c++/7/bits/ios_base.h" 3\n    fmtflags\n    flags(fmtflags __fmtfl)\n    {\n      fmtflags __old = _M_flags;\n      _M_flags = __fmtf'
[#] parse_declaration, is_constructor=False, meet line: 'fmtflags\n    flags(fmtflags __fmtfl)\n    {\n      fmtflags __old = _M_flags;\n      _M_flags = __fmtfl;\n      return __old;\n    }\n# 645 "/usr/include/c++/7/bits/ios_base.h" 3\n    fmtflags\n    setf(fmtfl'
[#] parse_declaration, is_constructor=False, meet line: 'fmtflags\n    setf(fmtflags __fmtfl)\n    {\n      fmtflags __old = _M_flags;\n      _M_flags |= __fmtfl;\n      return __old;\n    }\n# 662 "/usr/include/c++/7/bits/ios_base.h" 3\n    fmtflags\n    setf(fmtfl'
[#] parse_declaration, is_constructor=False, meet line: 'fmtflags\n    setf(fmtflags __fmtfl, fmtflags __mask)\n    {\n      fmtflags __old = _M_flags;\n      _M_flags &= ~__mask;\n      _M_flags |= (__fmtfl & __mask);\n      return __old;\n    }\n\n\n\n\n\n\n\n    void\n '
[#] parse_declaration, is_constructor=False, meet line: 'void\n    unsetf(fmtflags __mask)\n    { _M_flags &= ~__mask; }\n# 688 "/usr/include/c++/7/bits/ios_base.h" 3\n    streamsize\n    precision() const\n    { return _M_precision; }\n\n\n\n\n\n\n    streamsize\n    pr'
[#] parse_declaration, is_constructor=False, meet line: 'streamsize\n    precision() const\n    { return _M_precision; }\n\n\n\n\n\n\n    streamsize\n    precision(streamsize __prec)\n    {\n      streamsize __old = _M_precision;\n      _M_precision = __prec;\n      retu'
[#] parse_declaration, is_constructor=False, meet line: 'streamsize\n    precision(streamsize __prec)\n    {\n      streamsize __old = _M_precision;\n      _M_precision = __prec;\n      return __old;\n    }\n\n\n\n\n\n\n\n    streamsize\n    width() const\n    { return _M_'
[#] parse_declaration, is_constructor=False, meet line: 'streamsize\n    width() const\n    { return _M_width; }\n\n\n\n\n\n\n    streamsize\n    width(streamsize __wide)\n    {\n      streamsize __old = _M_width;\n      _M_width = __wide;\n      return __old;\n    }\n# 73'
[#] parse_declaration, is_constructor=False, meet line: 'streamsize\n    width(streamsize __wide)\n    {\n      streamsize __old = _M_width;\n      _M_width = __wide;\n      return __old;\n    }\n# 739 "/usr/include/c++/7/bits/ios_base.h" 3\n    static bool\n    syn'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    sync_with_stdio(bool __sync = true);\n# 751 "/usr/include/c++/7/bits/ios_base.h" 3\n    locale\n    imbue(const locale& __loc) throw();\n# 762 "/usr/include/c++/7/bits/ios_base.h" 3\n    locale\n  '
[#] parse_declaration, is_constructor=False, meet line: 'locale\n    imbue(const locale& __loc) throw();\n# 762 "/usr/include/c++/7/bits/ios_base.h" 3\n    locale\n    getloc() const\n    { return _M_ios_locale; }\n# 773 "/usr/include/c++/7/bits/ios_base.h" 3\n   '
[#] parse_declaration, is_constructor=False, meet line: 'locale\n    getloc() const\n    { return _M_ios_locale; }\n# 773 "/usr/include/c++/7/bits/ios_base.h" 3\n    const locale&\n    _M_getloc() const\n    { return _M_ios_locale; }\n# 792 "/usr/include/c++/7/bit'
[#] parse_declaration, is_constructor=False, meet line: 'locale&\n    _M_getloc() const\n    { return _M_ios_locale; }\n# 792 "/usr/include/c++/7/bits/ios_base.h" 3\n    static int\n    xalloc() throw();\n# 808 "/usr/include/c++/7/bits/ios_base.h" 3\n    long&\n   '
[#] parse_declaration, is_constructor=False, meet line: 'int\n    xalloc() throw();\n# 808 "/usr/include/c++/7/bits/ios_base.h" 3\n    long&\n    iword(int __ix)\n    {\n      _Words& __word = (__ix < _M_word_size)\n   ? _M_word[__ix] : _M_grow_words(__ix, true);\n'
[#] parse_declaration, is_constructor=False, meet line: 'long&\n    iword(int __ix)\n    {\n      _Words& __word = (__ix < _M_word_size)\n   ? _M_word[__ix] : _M_grow_words(__ix, true);\n      return __word._M_iword;\n    }\n# 829 "/usr/include/c++/7/bits/ios_base'
[#] parse_declaration, is_constructor=False, meet line: 'void*&\n    pword(int __ix)\n    {\n      _Words& __word = (__ix < _M_word_size)\n   ? _M_word[__ix] : _M_grow_words(__ix, false);\n      return __word._M_pword;\n    }\n# 846 "/usr/include/c++/7/bits/ios_ba'
[#] parse_declaration, is_constructor=True, meet line: 'ios_base();\n\n  protected:\n    ios_base() throw ();\n# 860 "/usr/include/c++/7/bits/ios_base.h" 3\n  public:\n    ios_base(const ios_base&) = delete;\n\n    ios_base&\n    operator=(const ios_base&) = delete'
[#] parse_declaration, is_constructor=True, meet line: 'ios_base() throw ();\n# 860 "/usr/include/c++/7/bits/ios_base.h" 3\n  public:\n    ios_base(const ios_base&) = delete;\n\n    ios_base&\n    operator=(const ios_base&) = delete;\n\n  protected:\n    void\n    _'
[#] parse_declaration, is_constructor=True, meet line: 'ios_base(const ios_base&) = delete;\n\n    ios_base&\n    operator=(const ios_base&) = delete;\n\n  protected:\n    void\n    _M_move(ios_base&) noexcept;\n\n    void\n    _M_swap(ios_base& __rhs) noexcept;\n\n  '
[#] parse_declaration, is_constructor=True, meet line: 'ios_base&\n    operator=(const ios_base&) = delete;\n\n  protected:\n    void\n    _M_move(ios_base&) noexcept;\n\n    void\n    _M_swap(ios_base& __rhs) noexcept;\n\n  };\n\n\n\n  inline ios_base&\n  boolalpha(ios_'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _M_move(ios_base&) noexcept;\n\n    void\n    _M_swap(ios_base& __rhs) noexcept;\n\n  };\n\n\n\n  inline ios_base&\n  boolalpha(ios_base& __base)\n  {\n    __base.setf(ios_base::boolalpha);\n    return __'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _M_swap(ios_base& __rhs) noexcept;\n\n  };\n\n\n\n  inline ios_base&\n  boolalpha(ios_base& __base)\n  {\n    __base.setf(ios_base::boolalpha);\n    return __base;\n  }\n\n\n  inline ios_base&\n  noboolalph'
[#] parse_declaration, is_constructor=False, meet line: 'ios_base&\n  boolalpha(ios_base& __base)\n  {\n    __base.setf(ios_base::boolalpha);\n    return __base;\n  }\n\n\n  inline ios_base&\n  noboolalpha(ios_base& __base)\n  {\n    __base.unsetf(ios_base::boolalpha)'
[#] parse_declaration, is_constructor=False, meet line: 'ios_base&\n  noboolalpha(ios_base& __base)\n  {\n    __base.unsetf(ios_base::boolalpha);\n    return __base;\n  }\n\n\n  inline ios_base&\n  showbase(ios_base& __base)\n  {\n    __base.setf(ios_base::showbase);\n'
[#] parse_declaration, is_constructor=False, meet line: 'ios_base&\n  showbase(ios_base& __base)\n  {\n    __base.setf(ios_base::showbase);\n    return __base;\n  }\n\n\n  inline ios_base&\n  noshowbase(ios_base& __base)\n  {\n    __base.unsetf(ios_base::showbase);\n  '
[#] parse_declaration, is_constructor=False, meet line: 'ios_base&\n  noshowbase(ios_base& __base)\n  {\n    __base.unsetf(ios_base::showbase);\n    return __base;\n  }\n\n\n  inline ios_base&\n  showpoint(ios_base& __base)\n  {\n    __base.setf(ios_base::showpoint);\n'
[#] parse_declaration, is_constructor=False, meet line: 'ios_base&\n  showpoint(ios_base& __base)\n  {\n    __base.setf(ios_base::showpoint);\n    return __base;\n  }\n\n\n  inline ios_base&\n  noshowpoint(ios_base& __base)\n  {\n    __base.unsetf(ios_base::showpoint)'
[#] parse_declaration, is_constructor=False, meet line: 'ios_base&\n  noshowpoint(ios_base& __base)\n  {\n    __base.unsetf(ios_base::showpoint);\n    return __base;\n  }\n\n\n  inline ios_base&\n  showpos(ios_base& __base)\n  {\n    __base.setf(ios_base::showpos);\n  '
[#] parse_declaration, is_constructor=False, meet line: 'ios_base&\n  showpos(ios_base& __base)\n  {\n    __base.setf(ios_base::showpos);\n    return __base;\n  }\n\n\n  inline ios_base&\n  noshowpos(ios_base& __base)\n  {\n    __base.unsetf(ios_base::showpos);\n    re'
[#] parse_declaration, is_constructor=False, meet line: 'ios_base&\n  noshowpos(ios_base& __base)\n  {\n    __base.unsetf(ios_base::showpos);\n    return __base;\n  }\n\n\n  inline ios_base&\n  skipws(ios_base& __base)\n  {\n    __base.setf(ios_base::skipws);\n    retu'
[#] parse_declaration, is_constructor=False, meet line: 'ios_base&\n  skipws(ios_base& __base)\n  {\n    __base.setf(ios_base::skipws);\n    return __base;\n  }\n\n\n  inline ios_base&\n  noskipws(ios_base& __base)\n  {\n    __base.unsetf(ios_base::skipws);\n    return'
[#] parse_declaration, is_constructor=False, meet line: 'ios_base&\n  noskipws(ios_base& __base)\n  {\n    __base.unsetf(ios_base::skipws);\n    return __base;\n  }\n\n\n  inline ios_base&\n  uppercase(ios_base& __base)\n  {\n    __base.setf(ios_base::uppercase);\n    '
[#] parse_declaration, is_constructor=False, meet line: 'ios_base&\n  uppercase(ios_base& __base)\n  {\n    __base.setf(ios_base::uppercase);\n    return __base;\n  }\n\n\n  inline ios_base&\n  nouppercase(ios_base& __base)\n  {\n    __base.unsetf(ios_base::uppercase)'
[#] parse_declaration, is_constructor=False, meet line: 'ios_base&\n  nouppercase(ios_base& __base)\n  {\n    __base.unsetf(ios_base::uppercase);\n    return __base;\n  }\n\n\n  inline ios_base&\n  unitbuf(ios_base& __base)\n  {\n     __base.setf(ios_base::unitbuf);\n '
[#] parse_declaration, is_constructor=False, meet line: 'ios_base&\n  unitbuf(ios_base& __base)\n  {\n     __base.setf(ios_base::unitbuf);\n     return __base;\n  }\n\n\n  inline ios_base&\n  nounitbuf(ios_base& __base)\n  {\n     __base.unsetf(ios_base::unitbuf);\n   '
[#] parse_declaration, is_constructor=False, meet line: 'ios_base&\n  nounitbuf(ios_base& __base)\n  {\n     __base.unsetf(ios_base::unitbuf);\n     return __base;\n  }\n\n\n\n  inline ios_base&\n  internal(ios_base& __base)\n  {\n     __base.setf(ios_base::internal, i'
[#] parse_declaration, is_constructor=False, meet line: 'ios_base&\n  internal(ios_base& __base)\n  {\n     __base.setf(ios_base::internal, ios_base::adjustfield);\n     return __base;\n  }\n\n\n  inline ios_base&\n  left(ios_base& __base)\n  {\n    __base.setf(ios_ba'
[#] parse_declaration, is_constructor=False, meet line: 'ios_base&\n  left(ios_base& __base)\n  {\n    __base.setf(ios_base::left, ios_base::adjustfield);\n    return __base;\n  }\n\n\n  inline ios_base&\n  right(ios_base& __base)\n  {\n    __base.setf(ios_base::right'
[#] parse_declaration, is_constructor=False, meet line: 'ios_base&\n  right(ios_base& __base)\n  {\n    __base.setf(ios_base::right, ios_base::adjustfield);\n    return __base;\n  }\n\n\n\n  inline ios_base&\n  dec(ios_base& __base)\n  {\n    __base.setf(ios_base::dec,'
[#] parse_declaration, is_constructor=False, meet line: 'ios_base&\n  dec(ios_base& __base)\n  {\n    __base.setf(ios_base::dec, ios_base::basefield);\n    return __base;\n  }\n\n\n  inline ios_base&\n  hex(ios_base& __base)\n  {\n    __base.setf(ios_base::hex, ios_ba'
[#] parse_declaration, is_constructor=False, meet line: 'ios_base&\n  hex(ios_base& __base)\n  {\n    __base.setf(ios_base::hex, ios_base::basefield);\n    return __base;\n  }\n\n\n  inline ios_base&\n  oct(ios_base& __base)\n  {\n    __base.setf(ios_base::oct, ios_ba'
[#] parse_declaration, is_constructor=False, meet line: 'ios_base&\n  oct(ios_base& __base)\n  {\n    __base.setf(ios_base::oct, ios_base::basefield);\n    return __base;\n  }\n\n\n\n  inline ios_base&\n  fixed(ios_base& __base)\n  {\n    __base.setf(ios_base::fixed, i'
[#] parse_declaration, is_constructor=False, meet line: 'ios_base&\n  fixed(ios_base& __base)\n  {\n    __base.setf(ios_base::fixed, ios_base::floatfield);\n    return __base;\n  }\n\n\n  inline ios_base&\n  scientific(ios_base& __base)\n  {\n    __base.setf(ios_base:'
[#] parse_declaration, is_constructor=False, meet line: 'ios_base&\n  scientific(ios_base& __base)\n  {\n    __base.setf(ios_base::scientific, ios_base::floatfield);\n    return __base;\n  }\n\n\n\n\n\n\n  inline ios_base&\n  hexfloat(ios_base& __base)\n  {\n    __base.se'
[#] parse_declaration, is_constructor=False, meet line: 'ios_base&\n  hexfloat(ios_base& __base)\n  {\n    __base.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield);\n    return __base;\n  }\n\n\n  inline ios_base&\n  defaultfloat(ios_base& __base)\n '
[#] parse_declaration, is_constructor=False, meet line: 'ios_base&\n  defaultfloat(ios_base& __base)\n  {\n    __base.unsetf(ios_base::floatfield);\n    return __base;\n  }\n\n\n\n}\n# 43 "/usr/include/c++/7/ios" 2 3\n# 1 "/usr/include/c++/7/streambuf" 1 3\n# 36 "/usr/'
[#] parse_declaration, is_constructor=False, meet line: 'streamsize\n    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>*,\n     basic_streambuf<_CharT, _Traits>*, bool&);\n# 119 "/usr/include/c++/7/streambuf" 3\n  template<typename _CharT, typename _Tra'
[#] parse_declaration, is_constructor=False, meet line: 'streamsize\n      __copy_streambufs_eof<>(basic_streambuf*, basic_streambuf*, bool&);\n\n      template<bool _IsMove, typename _CharT2>\n        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::'
[#] parse_declaration, is_constructor=False, meet line: '__gnu_cxx::__enable_if<__is_char<_CharT2>::__value,\n            _CharT2*>::__type\n        __copy_move_a2(istreambuf_iterator<_CharT2>,\n         istreambuf_iterator<_CharT2>, _CharT2*);\n\n      template'
[#] parse_declaration, is_constructor=False, meet line: '__gnu_cxx::__enable_if<__is_char<_CharT2>::__value,\n      istreambuf_iterator<_CharT2> >::__type\n        find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,\n      const _CharT2&);\n\n      '
[#] parse_declaration, is_constructor=False, meet line: 'basic_istream<_CharT2, _Traits2>&\n        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2*);\n\n      template<typename _CharT2, typename _Traits2, typename _Alloc>\n        friend basic_istream<_C'
[#] parse_declaration, is_constructor=False, meet line: 'basic_istream<_CharT2, _Traits2>&\n        operator>>(basic_istream<_CharT2, _Traits2>&,\n     basic_string<_CharT2, _Traits2, _Alloc>&);\n\n      template<typename _CharT2, typename _Traits2, typename _A'
[#] parse_declaration, is_constructor=False, meet line: 'basic_istream<_CharT2, _Traits2>&\n        getline(basic_istream<_CharT2, _Traits2>&,\n  basic_string<_CharT2, _Traits2, _Alloc>&, _CharT2);\n\n    protected:\n\n\n\n\n\n\n\n      char_type* _M_in_beg;\n      char'
[#] parse_declaration, is_constructor=False, meet line: 'char_type* _M_in_beg;\n      char_type* _M_in_cur;\n      char_type* _M_in_end;\n      char_type* _M_out_beg;\n      char_type* _M_out_cur;\n      char_type* _M_out_end;\n\n\n      locale _M_buf_locale;\n\n  pu'
[#] parse_declaration, is_constructor=False, meet line: 'char_type* _M_in_cur;\n      char_type* _M_in_end;\n      char_type* _M_out_beg;\n      char_type* _M_out_cur;\n      char_type* _M_out_end;\n\n\n      locale _M_buf_locale;\n\n  public:\n\n      virtual\n      ~'
[#] parse_declaration, is_constructor=False, meet line: 'char_type* _M_in_end;\n      char_type* _M_out_beg;\n      char_type* _M_out_cur;\n      char_type* _M_out_end;\n\n\n      locale _M_buf_locale;\n\n  public:\n\n      virtual\n      ~basic_streambuf()\n      { }\n'
[#] parse_declaration, is_constructor=False, meet line: 'char_type* _M_out_beg;\n      char_type* _M_out_cur;\n      char_type* _M_out_end;\n\n\n      locale _M_buf_locale;\n\n  public:\n\n      virtual\n      ~basic_streambuf()\n      { }\n# 208 "/usr/include/c++/7/st'
[#] parse_declaration, is_constructor=False, meet line: 'char_type* _M_out_cur;\n      char_type* _M_out_end;\n\n\n      locale _M_buf_locale;\n\n  public:\n\n      virtual\n      ~basic_streambuf()\n      { }\n# 208 "/usr/include/c++/7/streambuf" 3\n      locale\n     '
[#] parse_declaration, is_constructor=False, meet line: 'char_type* _M_out_end;\n\n\n      locale _M_buf_locale;\n\n  public:\n\n      virtual\n      ~basic_streambuf()\n      { }\n# 208 "/usr/include/c++/7/streambuf" 3\n      locale\n      pubimbue(const locale& __loc'
[#] parse_declaration, is_constructor=False, meet line: 'locale _M_buf_locale;\n\n  public:\n\n      virtual\n      ~basic_streambuf()\n      { }\n# 208 "/usr/include/c++/7/streambuf" 3\n      locale\n      pubimbue(const locale& __loc)\n      {\n locale __tmp(this->g'
[#] parse_declaration, is_constructor=True, meet line: 'basic_streambuf()\n      { }\n# 208 "/usr/include/c++/7/streambuf" 3\n      locale\n      pubimbue(const locale& __loc)\n      {\n locale __tmp(this->getloc());\n this->imbue(__loc);\n _M_buf_locale = __loc;\n'
[#] parse_declaration, is_constructor=False, meet line: 'locale\n      pubimbue(const locale& __loc)\n      {\n locale __tmp(this->getloc());\n this->imbue(__loc);\n _M_buf_locale = __loc;\n return __tmp;\n      }\n# 225 "/usr/include/c++/7/streambuf" 3\n      local'
[#] parse_declaration, is_constructor=False, meet line: 'locale\n      getloc() const\n      { return _M_buf_locale; }\n# 238 "/usr/include/c++/7/streambuf" 3\n      basic_streambuf*\n      pubsetbuf(char_type* __s, streamsize __n)\n      { return this->setbuf(__'
[#] parse_declaration, is_constructor=True, meet line: 'basic_streambuf*\n      pubsetbuf(char_type* __s, streamsize __n)\n      { return this->setbuf(__s, __n); }\n# 250 "/usr/include/c++/7/streambuf" 3\n      pos_type\n      pubseekoff(off_type __off, ios_bas'
[#] parse_declaration, is_constructor=False, meet line: 'pos_type\n      pubseekoff(off_type __off, ios_base::seekdir __way,\n   ios_base::openmode __mode = ios_base::in | ios_base::out)\n      { return this->seekoff(__off, __way, __mode); }\n# 262 "/usr/includ'
[#] parse_declaration, is_constructor=False, meet line: 'pos_type\n      pubseekpos(pos_type __sp,\n   ios_base::openmode __mode = ios_base::in | ios_base::out)\n      { return this->seekpos(__sp, __mode); }\n\n\n\n\n      int\n      pubsync() { return this->sync();'
[#] parse_declaration, is_constructor=False, meet line: 'int\n      pubsync() { return this->sync(); }\n# 283 "/usr/include/c++/7/streambuf" 3\n      streamsize\n      in_avail()\n      {\n const streamsize __ret = this->egptr() - this->gptr();\n return __ret ? __'
[#] parse_declaration, is_constructor=False, meet line: 'streamsize\n      in_avail()\n      {\n const streamsize __ret = this->egptr() - this->gptr();\n return __ret ? __ret : this->showmanyc();\n      }\n# 297 "/usr/include/c++/7/streambuf" 3\n      int_type\n   '
[#] parse_declaration, is_constructor=False, meet line: 'int_type\n      snextc()\n      {\n int_type __ret = traits_type::eof();\n if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(),\n             __ret), true))\n   __ret = this->sgetc();\n return __re'
[#] parse_declaration, is_constructor=False, meet line: 'int_type\n      sbumpc()\n      {\n int_type __ret;\n if (__builtin_expect(this->gptr() < this->egptr(), true))\n   {\n     __ret = traits_type::to_int_type(*this->gptr());\n     this->gbump(1);\n   }\n else\n '
[#] parse_declaration, is_constructor=False, meet line: 'int_type\n      sgetc()\n      {\n int_type __ret;\n if (__builtin_expect(this->gptr() < this->egptr(), true))\n   __ret = traits_type::to_int_type(*this->gptr());\n else\n   __ret = this->underflow();\n retu'
[#] parse_declaration, is_constructor=False, meet line: 'streamsize\n      sgetn(char_type* __s, streamsize __n)\n      { return this->xsgetn(__s, __n); }\n# 371 "/usr/include/c++/7/streambuf" 3\n      int_type\n      sputbackc(char_type __c)\n      {\n int_type _'
[#] parse_declaration, is_constructor=False, meet line: 'int_type\n      sputbackc(char_type __c)\n      {\n int_type __ret;\n const bool __testpos = this->eback() < this->gptr();\n if (__builtin_expect(!__testpos ||\n        !traits_type::eq(__c, this->gptr()[-1'
[#] parse_declaration, is_constructor=False, meet line: 'int_type\n      sungetc()\n      {\n int_type __ret;\n if (__builtin_expect(this->eback() < this->gptr(), true))\n   {\n     this->gbump(-1);\n     __ret = traits_type::to_int_type(*this->gptr());\n   }\n else'
[#] parse_declaration, is_constructor=False, meet line: 'int_type\n      sputc(char_type __c)\n      {\n int_type __ret;\n if (__builtin_expect(this->pptr() < this->epptr(), true))\n   {\n     *this->pptr() = __c;\n     this->pbump(1);\n     __ret = traits_type::to'
[#] parse_declaration, is_constructor=False, meet line: 'streamsize\n      sputn(const char_type* __s, streamsize __n)\n      { return this->xsputn(__s, __n); }\n\n    protected:\n# 463 "/usr/include/c++/7/streambuf" 3\n      basic_streambuf()\n      : _M_in_beg(0'
[#] parse_declaration, is_constructor=True, meet line: 'basic_streambuf()\n      : _M_in_beg(0), _M_in_cur(0), _M_in_end(0),\n      _M_out_beg(0), _M_out_cur(0), _M_out_end(0),\n      _M_buf_locale(locale())\n      { }\n# 481 "/usr/include/c++/7/streambuf" 3\n  '
[#] parse_declaration, is_constructor=False, meet line: 'char_type*\n      eback() const { return _M_in_beg; }\n\n      char_type*\n      gptr() const { return _M_in_cur; }\n\n      char_type*\n      egptr() const { return _M_in_end; }\n# 497 "/usr/include/c++/7/st'
[#] parse_declaration, is_constructor=False, meet line: 'char_type*\n      gptr() const { return _M_in_cur; }\n\n      char_type*\n      egptr() const { return _M_in_end; }\n# 497 "/usr/include/c++/7/streambuf" 3\n      void\n      gbump(int __n) { _M_in_cur += __'
[#] parse_declaration, is_constructor=False, meet line: 'char_type*\n      egptr() const { return _M_in_end; }\n# 497 "/usr/include/c++/7/streambuf" 3\n      void\n      gbump(int __n) { _M_in_cur += __n; }\n# 508 "/usr/include/c++/7/streambuf" 3\n      void\n    '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      gbump(int __n) { _M_in_cur += __n; }\n# 508 "/usr/include/c++/7/streambuf" 3\n      void\n      setg(char_type* __gbeg, char_type* __gnext, char_type* __gend)\n      {\n _M_in_beg = __gbeg;\n _M_'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      setg(char_type* __gbeg, char_type* __gnext, char_type* __gend)\n      {\n _M_in_beg = __gbeg;\n _M_in_cur = __gnext;\n _M_in_end = __gend;\n      }\n# 528 "/usr/include/c++/7/streambuf" 3\n      c'
[#] parse_declaration, is_constructor=False, meet line: 'char_type*\n      pbase() const { return _M_out_beg; }\n\n      char_type*\n      pptr() const { return _M_out_cur; }\n\n      char_type*\n      epptr() const { return _M_out_end; }\n# 544 "/usr/include/c++/7'
[#] parse_declaration, is_constructor=False, meet line: 'char_type*\n      pptr() const { return _M_out_cur; }\n\n      char_type*\n      epptr() const { return _M_out_end; }\n# 544 "/usr/include/c++/7/streambuf" 3\n      void\n      pbump(int __n) { _M_out_cur +='
[#] parse_declaration, is_constructor=False, meet line: 'char_type*\n      epptr() const { return _M_out_end; }\n# 544 "/usr/include/c++/7/streambuf" 3\n      void\n      pbump(int __n) { _M_out_cur += __n; }\n# 554 "/usr/include/c++/7/streambuf" 3\n      void\n  '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      pbump(int __n) { _M_out_cur += __n; }\n# 554 "/usr/include/c++/7/streambuf" 3\n      void\n      setp(char_type* __pbeg, char_type* __pend)\n      {\n _M_out_beg = _M_out_cur = __pbeg;\n _M_out_e'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      setp(char_type* __pbeg, char_type* __pend)\n      {\n _M_out_beg = _M_out_cur = __pbeg;\n _M_out_end = __pend;\n      }\n# 575 "/usr/include/c++/7/streambuf" 3\n      virtual void\n      imbue(con'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      imbue(const locale& __loc)\n      { }\n# 590 "/usr/include/c++/7/streambuf" 3\n      virtual basic_streambuf<char_type,_Traits>*\n      setbuf(char_type*, streamsize)\n      { return this; }\n# 6'
[#] parse_declaration, is_constructor=True, meet line: 'basic_streambuf<char_type,_Traits>*\n      setbuf(char_type*, streamsize)\n      { return this; }\n# 601 "/usr/include/c++/7/streambuf" 3\n      virtual pos_type\n      seekoff(off_type, ios_base::seekdir,'
[#] parse_declaration, is_constructor=False, meet line: 'pos_type\n      seekoff(off_type, ios_base::seekdir,\n       ios_base::openmode = ios_base::in | ios_base::out)\n      { return pos_type(off_type(-1)); }\n# 613 "/usr/include/c++/7/streambuf" 3\n      virt'
[#] parse_declaration, is_constructor=False, meet line: 'pos_type\n      seekpos(pos_type,\n       ios_base::openmode = ios_base::in | ios_base::out)\n      { return pos_type(off_type(-1)); }\n# 626 "/usr/include/c++/7/streambuf" 3\n      virtual int\n      sync('
[#] parse_declaration, is_constructor=False, meet line: 'int\n      sync() { return 0; }\n# 648 "/usr/include/c++/7/streambuf" 3\n      virtual streamsize\n      showmanyc() { return 0; }\n# 664 "/usr/include/c++/7/streambuf" 3\n      virtual streamsize\n      xsg'
[#] parse_declaration, is_constructor=False, meet line: 'streamsize\n      showmanyc() { return 0; }\n# 664 "/usr/include/c++/7/streambuf" 3\n      virtual streamsize\n      xsgetn(char_type* __s, streamsize __n);\n# 686 "/usr/include/c++/7/streambuf" 3\n      vi'
[#] parse_declaration, is_constructor=False, meet line: 'streamsize\n      xsgetn(char_type* __s, streamsize __n);\n# 686 "/usr/include/c++/7/streambuf" 3\n      virtual int_type\n      underflow()\n      { return traits_type::eof(); }\n# 699 "/usr/include/c++/7/'
[#] parse_declaration, is_constructor=False, meet line: 'int_type\n      underflow()\n      { return traits_type::eof(); }\n# 699 "/usr/include/c++/7/streambuf" 3\n      virtual int_type\n      uflow()\n      {\n int_type __ret = traits_type::eof();\n const bool __'
[#] parse_declaration, is_constructor=False, meet line: 'int_type\n      uflow()\n      {\n int_type __ret = traits_type::eof();\n const bool __testeof = traits_type::eq_int_type(this->underflow(),\n       __ret);\n if (!__testeof)\n   {\n     __ret = traits_type::'
[#] parse_declaration, is_constructor=False, meet line: 'int_type\n      pbackfail(int_type __c = traits_type::eof())\n      { return traits_type::eof(); }\n# 741 "/usr/include/c++/7/streambuf" 3\n      virtual streamsize\n      xsputn(const char_type* __s, stre'
[#] parse_declaration, is_constructor=False, meet line: 'streamsize\n      xsputn(const char_type* __s, streamsize __n);\n# 767 "/usr/include/c++/7/streambuf" 3\n      virtual int_type\n      overflow(int_type __c = traits_type::eof())\n      { return traits_typ'
[#] parse_declaration, is_constructor=False, meet line: 'int_type\n      overflow(int_type __c = traits_type::eof())\n      { return traits_type::eof(); }\n\n\n\n    public:\n# 782 "/usr/include/c++/7/streambuf" 3\n      void\n      stossc()\n      {\n if (this->gptr('
[#] parse_declaration, is_constructor=False, meet line: 'void\n      stossc()\n      {\n if (this->gptr() < this->egptr())\n   this->gbump(1);\n else\n   this->uflow();\n      }\n\n\n\n      void\n      __safe_gbump(streamsize __n) { _M_in_cur += __n; }\n\n      void\n   '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      __safe_gbump(streamsize __n) { _M_in_cur += __n; }\n\n      void\n      __safe_pbump(streamsize __n) { _M_out_cur += __n; }\n\n\n\n\n    protected:\n\n      basic_streambuf(const basic_streambuf&);\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      __safe_pbump(streamsize __n) { _M_out_cur += __n; }\n\n\n\n\n    protected:\n\n      basic_streambuf(const basic_streambuf&);\n\n      basic_streambuf&\n      operator=(const basic_streambuf&);\n\n\n   '
[#] parse_declaration, is_constructor=True, meet line: 'basic_streambuf(const basic_streambuf&);\n\n      basic_streambuf&\n      operator=(const basic_streambuf&);\n\n\n      void\n      swap(basic_streambuf& __sb)\n      {\n std::swap(_M_in_beg, __sb._M_in_beg);\n'
[#] parse_declaration, is_constructor=True, meet line: 'basic_streambuf&\n      operator=(const basic_streambuf&);\n\n\n      void\n      swap(basic_streambuf& __sb)\n      {\n std::swap(_M_in_beg, __sb._M_in_beg);\n std::swap(_M_in_cur, __sb._M_in_cur);\n std::swa'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      swap(basic_streambuf& __sb)\n      {\n std::swap(_M_in_beg, __sb._M_in_beg);\n std::swap(_M_in_cur, __sb._M_in_cur);\n std::swap(_M_in_end, __sb._M_in_end);\n std::swap(_M_out_beg, __sb._M_out_b'
[#] parse_declaration, is_constructor=False, meet line: 'std::basic_streambuf<_CharT, _Traits>::\n    basic_streambuf(const basic_streambuf&) = default;\n\n  template<typename _CharT, typename _Traits>\n    std::basic_streambuf<_CharT, _Traits>&\n    std::basic_'
[#] parse_declaration, is_constructor=False, meet line: 'std::basic_streambuf<_CharT, _Traits>&\n    std::basic_streambuf<_CharT, _Traits>::\n    operator=(const basic_streambuf&) = default;\n\n\n\n  template<>\n    streamsize\n    __copy_streambufs_eof(basic_strea'
[#] parse_declaration, is_constructor=False, meet line: 'streamsize\n    __copy_streambufs_eof(basic_streambuf<char>* __sbin,\n     basic_streambuf<char>* __sbout, bool& __ineof);\n\n  template<>\n    streamsize\n    __copy_streambufs_eof(basic_streambuf<wchar_t>'
[#] parse_declaration, is_constructor=False, meet line: 'streamsize\n    __copy_streambufs_eof(basic_streambuf<wchar_t>* __sbin,\n     basic_streambuf<wchar_t>* __sbout, bool& __ineof);\n\n\n\n}\n\n# 1 "/usr/include/c++/7/bits/streambuf.tcc" 1 3\n# 37 "/usr/include/'
[#] parse_declaration, is_constructor=False, meet line: 'streamsize\n    basic_streambuf<_CharT, _Traits>::\n    xsgetn(char_type* __s, streamsize __n)\n    {\n      streamsize __ret = 0;\n      while (__ret < __n)\n {\n   const streamsize __buf_len = this->egptr('
[#] parse_declaration, is_constructor=False, meet line: 'streamsize\n    basic_streambuf<_CharT, _Traits>::\n    xsputn(const char_type* __s, streamsize __n)\n    {\n      streamsize __ret = 0;\n      while (__ret < __n)\n {\n   const streamsize __buf_len = this->'
[#] parse_declaration, is_constructor=False, meet line: 'streamsize\n    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>* __sbin,\n     basic_streambuf<_CharT, _Traits>* __sbout,\n     bool& __ineof)\n    {\n      streamsize __ret = 0;\n      __ineof = tru'
[#] parse_declaration, is_constructor=False, meet line: 'streamsize\n    __copy_streambufs(basic_streambuf<_CharT, _Traits>* __sbin,\n        basic_streambuf<_CharT, _Traits>* __sbout)\n    {\n      bool __ineof;\n      return __copy_streambufs_eof(__sbin, __sbo'
[#] parse_declaration, is_constructor=False, meet line: 'template class basic_streambuf<char>;\n  extern template\n    streamsize\n    __copy_streambufs(basic_streambuf<char>*,\n        basic_streambuf<char>*);\n  extern template\n    streamsize\n    __copy_stream'
[#] parse_declaration, is_constructor=False, meet line: 'template\n    streamsize\n    __copy_streambufs(basic_streambuf<char>*,\n        basic_streambuf<char>*);\n  extern template\n    streamsize\n    __copy_streambufs_eof(basic_streambuf<char>*,\n     basic_str'
[#] parse_declaration, is_constructor=False, meet line: 'template\n    streamsize\n    __copy_streambufs_eof(basic_streambuf<char>*,\n     basic_streambuf<char>*, bool&);\n\n\n  extern template class basic_streambuf<wchar_t>;\n  extern template\n    streamsize\n    '
[#] parse_declaration, is_constructor=False, meet line: 'template class basic_streambuf<wchar_t>;\n  extern template\n    streamsize\n    __copy_streambufs(basic_streambuf<wchar_t>*,\n        basic_streambuf<wchar_t>*);\n  extern template\n    streamsize\n    __co'
[#] parse_declaration, is_constructor=False, meet line: 'template\n    streamsize\n    __copy_streambufs(basic_streambuf<wchar_t>*,\n        basic_streambuf<wchar_t>*);\n  extern template\n    streamsize\n    __copy_streambufs_eof(basic_streambuf<wchar_t>*,\n     '
[#] parse_declaration, is_constructor=False, meet line: 'template\n    streamsize\n    __copy_streambufs_eof(basic_streambuf<wchar_t>*,\n     basic_streambuf<wchar_t>*, bool&);\n\n\n\n\n}\n# 851 "/usr/include/c++/7/streambuf" 2 3\n# 44 "/usr/include/c++/7/ios" 2 3\n# '
[#] parse_declaration, is_constructor=False, meet line: 'int iswalnum (wint_t __wc) throw ();\n\n\n\n\n\nextern int iswalpha (wint_t __wc) throw ();\n\n\nextern int iswcntrl (wint_t __wc) throw ();\n\n\n\nextern int iswdigit (wint_t __wc) throw ();\n\n\n\nextern int iswgrap'
[#] parse_declaration, is_constructor=False, meet line: 'int iswalpha (wint_t __wc) throw ();\n\n\nextern int iswcntrl (wint_t __wc) throw ();\n\n\n\nextern int iswdigit (wint_t __wc) throw ();\n\n\n\nextern int iswgraph (wint_t __wc) throw ();\n\n\n\n\nextern int iswlower'
[#] parse_declaration, is_constructor=False, meet line: 'int iswcntrl (wint_t __wc) throw ();\n\n\n\nextern int iswdigit (wint_t __wc) throw ();\n\n\n\nextern int iswgraph (wint_t __wc) throw ();\n\n\n\n\nextern int iswlower (wint_t __wc) throw ();\n\n\nextern int iswprint'
[#] parse_declaration, is_constructor=False, meet line: 'int iswdigit (wint_t __wc) throw ();\n\n\n\nextern int iswgraph (wint_t __wc) throw ();\n\n\n\n\nextern int iswlower (wint_t __wc) throw ();\n\n\nextern int iswprint (wint_t __wc) throw ();\n\n\n\n\nextern int iswpunc'
[#] parse_declaration, is_constructor=False, meet line: 'int iswgraph (wint_t __wc) throw ();\n\n\n\n\nextern int iswlower (wint_t __wc) throw ();\n\n\nextern int iswprint (wint_t __wc) throw ();\n\n\n\n\nextern int iswpunct (wint_t __wc) throw ();\n\n\n\n\nextern int iswspa'
[#] parse_declaration, is_constructor=False, meet line: 'int iswlower (wint_t __wc) throw ();\n\n\nextern int iswprint (wint_t __wc) throw ();\n\n\n\n\nextern int iswpunct (wint_t __wc) throw ();\n\n\n\n\nextern int iswspace (wint_t __wc) throw ();\n\n\n\n\nextern int iswupp'
[#] parse_declaration, is_constructor=False, meet line: 'int iswprint (wint_t __wc) throw ();\n\n\n\n\nextern int iswpunct (wint_t __wc) throw ();\n\n\n\n\nextern int iswspace (wint_t __wc) throw ();\n\n\n\n\nextern int iswupper (wint_t __wc) throw ();\n\n\n\n\nextern int iswx'
[#] parse_declaration, is_constructor=False, meet line: 'int iswpunct (wint_t __wc) throw ();\n\n\n\n\nextern int iswspace (wint_t __wc) throw ();\n\n\n\n\nextern int iswupper (wint_t __wc) throw ();\n\n\n\n\nextern int iswxdigit (wint_t __wc) throw ();\n\n\n\n\n\nextern int is'
[#] parse_declaration, is_constructor=False, meet line: 'int iswspace (wint_t __wc) throw ();\n\n\n\n\nextern int iswupper (wint_t __wc) throw ();\n\n\n\n\nextern int iswxdigit (wint_t __wc) throw ();\n\n\n\n\n\nextern int iswblank (wint_t __wc) throw ();\n# 155 "/usr/inclu'
[#] parse_declaration, is_constructor=False, meet line: 'int iswupper (wint_t __wc) throw ();\n\n\n\n\nextern int iswxdigit (wint_t __wc) throw ();\n\n\n\n\n\nextern int iswblank (wint_t __wc) throw ();\n# 155 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h" 3 4\next'
[#] parse_declaration, is_constructor=False, meet line: 'int iswxdigit (wint_t __wc) throw ();\n\n\n\n\n\nextern int iswblank (wint_t __wc) throw ();\n# 155 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h" 3 4\nextern wctype_t wctype (const char *__property) thr'
[#] parse_declaration, is_constructor=False, meet line: 'int iswblank (wint_t __wc) throw ();\n# 155 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h" 3 4\nextern wctype_t wctype (const char *__property) throw ();\n\n\n\nextern int iswctype (wint_t __wc, wctype'
[#] parse_declaration, is_constructor=False, meet line: 'wctype_t wctype (const char *__property) throw ();\n\n\n\nextern int iswctype (wint_t __wc, wctype_t __desc) throw ();\n\n\n\n\n\n\nextern wint_t towlower (wint_t __wc) throw ();\n\n\nextern wint_t towupper (wint_t'
[#] parse_declaration, is_constructor=False, meet line: 'int iswctype (wint_t __wc, wctype_t __desc) throw ();\n\n\n\n\n\n\nextern wint_t towlower (wint_t __wc) throw ();\n\n\nextern wint_t towupper (wint_t __wc) throw ();\n\n}\n# 39 "/usr/include/wctype.h" 2 3 4\n\n\n\n\n\ne'
[#] parse_declaration, is_constructor=False, meet line: 'wint_t towlower (wint_t __wc) throw ();\n\n\nextern wint_t towupper (wint_t __wc) throw ();\n\n}\n# 39 "/usr/include/wctype.h" 2 3 4\n\n\n\n\n\nextern "C" {\n\n\n\ntypedef const __int32_t *wctrans_t;\n\n\n\nextern wctran'
[#] parse_declaration, is_constructor=False, meet line: 'wint_t towupper (wint_t __wc) throw ();\n\n}\n# 39 "/usr/include/wctype.h" 2 3 4\n\n\n\n\n\nextern "C" {\n\n\n\ntypedef const __int32_t *wctrans_t;\n\n\n\nextern wctrans_t wctrans (const char *__property) throw ();\n\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'wctrans_t wctrans (const char *__property) throw ();\n\n\nextern wint_t towctrans (wint_t __wc, wctrans_t __desc) throw ();\n\n\n\n\n\n\n\nextern int iswalnum_l (wint_t __wc, locale_t __locale) throw ();\n\n\n\n\n\nex'
[#] parse_declaration, is_constructor=False, meet line: 'wint_t towctrans (wint_t __wc, wctrans_t __desc) throw ();\n\n\n\n\n\n\n\nextern int iswalnum_l (wint_t __wc, locale_t __locale) throw ();\n\n\n\n\n\nextern int iswalpha_l (wint_t __wc, locale_t __locale) throw ();'
[#] parse_declaration, is_constructor=False, meet line: 'int iswalnum_l (wint_t __wc, locale_t __locale) throw ();\n\n\n\n\n\nextern int iswalpha_l (wint_t __wc, locale_t __locale) throw ();\n\n\nextern int iswcntrl_l (wint_t __wc, locale_t __locale) throw ();\n\n\n\nex'
[#] parse_declaration, is_constructor=False, meet line: 'int iswalpha_l (wint_t __wc, locale_t __locale) throw ();\n\n\nextern int iswcntrl_l (wint_t __wc, locale_t __locale) throw ();\n\n\n\nextern int iswdigit_l (wint_t __wc, locale_t __locale) throw ();\n\n\n\nexte'
[#] parse_declaration, is_constructor=False, meet line: 'int iswcntrl_l (wint_t __wc, locale_t __locale) throw ();\n\n\n\nextern int iswdigit_l (wint_t __wc, locale_t __locale) throw ();\n\n\n\nextern int iswgraph_l (wint_t __wc, locale_t __locale) throw ();\n\n\n\n\nex'
[#] parse_declaration, is_constructor=False, meet line: 'int iswdigit_l (wint_t __wc, locale_t __locale) throw ();\n\n\n\nextern int iswgraph_l (wint_t __wc, locale_t __locale) throw ();\n\n\n\n\nextern int iswlower_l (wint_t __wc, locale_t __locale) throw ();\n\n\next'
[#] parse_declaration, is_constructor=False, meet line: 'int iswgraph_l (wint_t __wc, locale_t __locale) throw ();\n\n\n\n\nextern int iswlower_l (wint_t __wc, locale_t __locale) throw ();\n\n\nextern int iswprint_l (wint_t __wc, locale_t __locale) throw ();\n\n\n\n\nex'
[#] parse_declaration, is_constructor=False, meet line: 'int iswlower_l (wint_t __wc, locale_t __locale) throw ();\n\n\nextern int iswprint_l (wint_t __wc, locale_t __locale) throw ();\n\n\n\n\nextern int iswpunct_l (wint_t __wc, locale_t __locale) throw ();\n\n\n\n\nex'
[#] parse_declaration, is_constructor=False, meet line: 'int iswprint_l (wint_t __wc, locale_t __locale) throw ();\n\n\n\n\nextern int iswpunct_l (wint_t __wc, locale_t __locale) throw ();\n\n\n\n\nextern int iswspace_l (wint_t __wc, locale_t __locale) throw ();\n\n\n\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'int iswpunct_l (wint_t __wc, locale_t __locale) throw ();\n\n\n\n\nextern int iswspace_l (wint_t __wc, locale_t __locale) throw ();\n\n\n\n\nextern int iswupper_l (wint_t __wc, locale_t __locale) throw ();\n\n\n\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'int iswspace_l (wint_t __wc, locale_t __locale) throw ();\n\n\n\n\nextern int iswupper_l (wint_t __wc, locale_t __locale) throw ();\n\n\n\n\nextern int iswxdigit_l (wint_t __wc, locale_t __locale) throw ();\n\n\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'int iswupper_l (wint_t __wc, locale_t __locale) throw ();\n\n\n\n\nextern int iswxdigit_l (wint_t __wc, locale_t __locale) throw ();\n\n\n\n\nextern int iswblank_l (wint_t __wc, locale_t __locale) throw ();\n\n\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'int iswxdigit_l (wint_t __wc, locale_t __locale) throw ();\n\n\n\n\nextern int iswblank_l (wint_t __wc, locale_t __locale) throw ();\n\n\n\nextern wctype_t wctype_l (const char *__property, locale_t __locale)\n'
[#] parse_declaration, is_constructor=False, meet line: 'int iswblank_l (wint_t __wc, locale_t __locale) throw ();\n\n\n\nextern wctype_t wctype_l (const char *__property, locale_t __locale)\n     throw ();\n\n\n\nextern int iswctype_l (wint_t __wc, wctype_t __desc,'
[#] parse_declaration, is_constructor=False, meet line: 'wctype_t wctype_l (const char *__property, locale_t __locale)\n     throw ();\n\n\n\nextern int iswctype_l (wint_t __wc, wctype_t __desc, locale_t __locale)\n     throw ();\n\n\n\n\n\n\nextern wint_t towlower_l (w'
[#] parse_declaration, is_constructor=False, meet line: 'int iswctype_l (wint_t __wc, wctype_t __desc, locale_t __locale)\n     throw ();\n\n\n\n\n\n\nextern wint_t towlower_l (wint_t __wc, locale_t __locale) throw ();\n\n\nextern wint_t towupper_l (wint_t __wc, local'
[#] parse_declaration, is_constructor=False, meet line: 'wint_t towlower_l (wint_t __wc, locale_t __locale) throw ();\n\n\nextern wint_t towupper_l (wint_t __wc, locale_t __locale) throw ();\n\n\n\nextern wctrans_t wctrans_l (const char *__property, locale_t __loc'
[#] parse_declaration, is_constructor=False, meet line: 'wint_t towupper_l (wint_t __wc, locale_t __locale) throw ();\n\n\n\nextern wctrans_t wctrans_l (const char *__property, locale_t __locale)\n     throw ();\n\n\nextern wint_t towctrans_l (wint_t __wc, wctrans_'
[#] parse_declaration, is_constructor=False, meet line: 'wctrans_t wctrans_l (const char *__property, locale_t __locale)\n     throw ();\n\n\nextern wint_t towctrans_l (wint_t __wc, wctrans_t __desc,\n      locale_t __locale) throw ();\n\n\n\n}\n# 51 "/usr/include/c+'
[#] parse_declaration, is_constructor=False, meet line: 'wint_t towctrans_l (wint_t __wc, wctrans_t __desc,\n      locale_t __locale) throw ();\n\n\n\n}\n# 51 "/usr/include/c++/7/cwctype" 2 3\n# 80 "/usr/include/c++/7/cwctype" 3\nnamespace std\n{\n  using ::wctrans_t'
[#] parse_declaration, is_constructor=False, meet line: 'mask upper = _ISupper;\n    static const mask lower = _ISlower;\n    static const mask alpha = _ISalpha;\n    static const mask digit = _ISdigit;\n    static const mask xdigit = _ISxdigit;\n    static cons'
[#] parse_declaration, is_constructor=False, meet line: 'mask lower = _ISlower;\n    static const mask alpha = _ISalpha;\n    static const mask digit = _ISdigit;\n    static const mask xdigit = _ISxdigit;\n    static const mask space = _ISspace;\n    static cons'
[#] parse_declaration, is_constructor=False, meet line: 'mask alpha = _ISalpha;\n    static const mask digit = _ISdigit;\n    static const mask xdigit = _ISxdigit;\n    static const mask space = _ISspace;\n    static const mask print = _ISprint;\n    static cons'
[#] parse_declaration, is_constructor=False, meet line: 'mask digit = _ISdigit;\n    static const mask xdigit = _ISxdigit;\n    static const mask space = _ISspace;\n    static const mask print = _ISprint;\n    static const mask graph = _ISalpha | _ISdigit | _IS'
[#] parse_declaration, is_constructor=False, meet line: 'mask xdigit = _ISxdigit;\n    static const mask space = _ISspace;\n    static const mask print = _ISprint;\n    static const mask graph = _ISalpha | _ISdigit | _ISpunct;\n    static const mask cntrl = _IS'
[#] parse_declaration, is_constructor=False, meet line: 'mask space = _ISspace;\n    static const mask print = _ISprint;\n    static const mask graph = _ISalpha | _ISdigit | _ISpunct;\n    static const mask cntrl = _IScntrl;\n    static const mask punct = _ISpu'
[#] parse_declaration, is_constructor=False, meet line: 'mask print = _ISprint;\n    static const mask graph = _ISalpha | _ISdigit | _ISpunct;\n    static const mask cntrl = _IScntrl;\n    static const mask punct = _ISpunct;\n    static const mask alnum = _ISal'
[#] parse_declaration, is_constructor=False, meet line: 'mask graph = _ISalpha | _ISdigit | _ISpunct;\n    static const mask cntrl = _IScntrl;\n    static const mask punct = _ISpunct;\n    static const mask alnum = _ISalpha | _ISdigit;\n\n    static const mask b'
[#] parse_declaration, is_constructor=False, meet line: 'mask cntrl = _IScntrl;\n    static const mask punct = _ISpunct;\n    static const mask alnum = _ISalpha | _ISdigit;\n\n    static const mask blank = _ISblank;\n\n  };\n\n\n}\n# 42 "/usr/include/c++/7/bits/local'
[#] parse_declaration, is_constructor=False, meet line: 'mask punct = _ISpunct;\n    static const mask alnum = _ISalpha | _ISdigit;\n\n    static const mask blank = _ISblank;\n\n  };\n\n\n}\n# 42 "/usr/include/c++/7/bits/locale_facets.h" 2 3\n\n\n\n\n\n\n# 1 "/usr/include/'
[#] parse_declaration, is_constructor=False, meet line: 'mask alnum = _ISalpha | _ISdigit;\n\n    static const mask blank = _ISblank;\n\n  };\n\n\n}\n# 42 "/usr/include/c++/7/bits/locale_facets.h" 2 3\n\n\n\n\n\n\n# 1 "/usr/include/c++/7/bits/streambuf_iterator.h" 1 3\n# 3'
[#] parse_declaration, is_constructor=False, meet line: 'mask blank = _ISblank;\n\n  };\n\n\n}\n# 42 "/usr/include/c++/7/bits/locale_facets.h" 2 3\n\n\n\n\n\n\n# 1 "/usr/include/c++/7/bits/streambuf_iterator.h" 1 3\n# 33 "/usr/include/c++/7/bits/streambuf_iterator.h" 3\n '
[#] parse_declaration, is_constructor=False, meet line: '__gnu_cxx::__enable_if<__is_char<_CharT2>::__value,\n                      ostreambuf_iterator<_CharT2> >::__type\n copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,\n      ostreambuf_iter'
[#] parse_declaration, is_constructor=False, meet line: '__gnu_cxx::__enable_if<__is_char<_CharT2>::__value,\n            _CharT2*>::__type\n __copy_move_a2(istreambuf_iterator<_CharT2>,\n         istreambuf_iterator<_CharT2>, _CharT2*);\n\n      template<typena'
[#] parse_declaration, is_constructor=False, meet line: '__gnu_cxx::__enable_if<__is_char<_CharT2>::__value,\n               istreambuf_iterator<_CharT2> >::__type\n find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,\n      const _CharT2&);\n\n    '
[#] parse_declaration, is_constructor=False, meet line: 'streambuf_type* _M_sbuf;\n      mutable int_type _M_c;\n\n    public:\n\n      constexpr istreambuf_iterator() noexcept\n      : _M_sbuf(0), _M_c(traits_type::eof()) { }\n\n\n      istreambuf_iterator(const is'
[#] parse_declaration, is_constructor=False, meet line: 'int_type _M_c;\n\n    public:\n\n      constexpr istreambuf_iterator() noexcept\n      : _M_sbuf(0), _M_c(traits_type::eof()) { }\n\n\n      istreambuf_iterator(const istreambuf_iterator&) noexcept = default;'
[#] parse_declaration, is_constructor=True, meet line: 'istreambuf_iterator() noexcept\n      : _M_sbuf(0), _M_c(traits_type::eof()) { }\n\n\n      istreambuf_iterator(const istreambuf_iterator&) noexcept = default;\n\n      ~istreambuf_iterator() = default;\n\n\n\n'
[#] parse_declaration, is_constructor=True, meet line: 'istreambuf_iterator(const istreambuf_iterator&) noexcept = default;\n\n      ~istreambuf_iterator() = default;\n\n\n\n      istreambuf_iterator(istream_type& __s) noexcept\n      : _M_sbuf(__s.rdbuf()), _M_c'
[#] parse_declaration, is_constructor=True, meet line: 'istreambuf_iterator() = default;\n\n\n\n      istreambuf_iterator(istream_type& __s) noexcept\n      : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof()) { }\n\n\n      istreambuf_iterator(streambuf_type* __s) no'
[#] parse_declaration, is_constructor=True, meet line: 'istreambuf_iterator(istream_type& __s) noexcept\n      : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof()) { }\n\n\n      istreambuf_iterator(streambuf_type* __s) noexcept\n      : _M_sbuf(__s), _M_c(traits_t'
[#] parse_declaration, is_constructor=True, meet line: 'istreambuf_iterator(streambuf_type* __s) noexcept\n      : _M_sbuf(__s), _M_c(traits_type::eof()) { }\n\n\n\n\n      char_type\n      operator*() const\n      {\n\n\n\n\n\n\n\n return traits_type::to_char_type(_M_get'
[#] parse_declaration, is_constructor=False, meet line: 'char_type\n      operator*() const\n      {\n\n\n\n\n\n\n\n return traits_type::to_char_type(_M_get());\n      }\n\n\n      istreambuf_iterator&\n      operator++()\n      {\n\n\n                        ;\n if (_M_sbuf)\n'
[#] parse_declaration, is_constructor=True, meet line: 'istreambuf_iterator&\n      operator++()\n      {\n\n\n                        ;\n if (_M_sbuf)\n   {\n     _M_sbuf->sbumpc();\n     _M_c = traits_type::eof();\n   }\n return *this;\n      }\n\n\n      istreambuf_it'
[#] parse_declaration, is_constructor=True, meet line: 'istreambuf_iterator\n      operator++(int)\n      {\n\n\n                        ;\n\n istreambuf_iterator __old = *this;\n if (_M_sbuf)\n   {\n     __old._M_c = _M_sbuf->sbumpc();\n     _M_c = traits_type::eof('
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      equal(const istreambuf_iterator& __b) const\n      { return _M_at_eof() == __b._M_at_eof(); }\n\n    private:\n      int_type\n      _M_get() const\n      {\n const int_type __eof = traits_type::e'
[#] parse_declaration, is_constructor=False, meet line: 'int_type\n      _M_get() const\n      {\n const int_type __eof = traits_type::eof();\n int_type __ret = __eof;\n if (_M_sbuf)\n   {\n     if (!traits_type::eq_int_type(_M_c, __eof))\n       __ret = _M_c;\n    '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      _M_at_eof() const\n      {\n const int_type __eof = traits_type::eof();\n return traits_type::eq_int_type(_M_get(), __eof);\n      }\n    };\n\n  template<typename _CharT, typename _Traits>\n    in'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator==(const istreambuf_iterator<_CharT, _Traits>& __a,\n        const istreambuf_iterator<_CharT, _Traits>& __b)\n    { return __a.equal(__b); }\n\n  template<typename _CharT, typename _Trai'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,\n        const istreambuf_iterator<_CharT, _Traits>& __b)\n    { return !__a.equal(__b); }\n\n\n  template<typename _CharT, typename _Tr'
[#] parse_declaration, is_constructor=False, meet line: '__gnu_cxx::__enable_if<__is_char<_CharT2>::__value,\n                      ostreambuf_iterator<_CharT2> >::__type\n copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,\n      ostreambuf_iter'
[#] parse_declaration, is_constructor=False, meet line: 'streambuf_type* _M_sbuf;\n      bool _M_failed;\n\n    public:\n\n      ostreambuf_iterator(ostream_type& __s) noexcept\n      : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) { }\n\n\n      ostreambuf_iterator(str'
[#] parse_declaration, is_constructor=False, meet line: 'bool _M_failed;\n\n    public:\n\n      ostreambuf_iterator(ostream_type& __s) noexcept\n      : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) { }\n\n\n      ostreambuf_iterator(streambuf_type* __s) noexcept\n    '
[#] parse_declaration, is_constructor=True, meet line: 'ostreambuf_iterator(ostream_type& __s) noexcept\n      : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) { }\n\n\n      ostreambuf_iterator(streambuf_type* __s) noexcept\n      : _M_sbuf(__s), _M_failed(!_M_sbuf'
[#] parse_declaration, is_constructor=True, meet line: 'ostreambuf_iterator(streambuf_type* __s) noexcept\n      : _M_sbuf(__s), _M_failed(!_M_sbuf) { }\n\n\n      ostreambuf_iterator&\n      operator=(_CharT __c)\n      {\n if (!_M_failed &&\n     _Traits::eq_int'
[#] parse_declaration, is_constructor=True, meet line: 'ostreambuf_iterator&\n      operator=(_CharT __c)\n      {\n if (!_M_failed &&\n     _Traits::eq_int_type(_M_sbuf->sputc(__c), _Traits::eof()))\n   _M_failed = true;\n return *this;\n      }\n\n\n      ostreamb'
[#] parse_declaration, is_constructor=True, meet line: 'ostreambuf_iterator&\n      operator*()\n      { return *this; }\n\n\n      ostreambuf_iterator&\n      operator++(int)\n      { return *this; }\n\n\n      ostreambuf_iterator&\n      operator++()\n      { return'
[#] parse_declaration, is_constructor=True, meet line: 'ostreambuf_iterator&\n      operator++(int)\n      { return *this; }\n\n\n      ostreambuf_iterator&\n      operator++()\n      { return *this; }\n\n\n      bool\n      failed() const noexcept\n      { return _M_'
[#] parse_declaration, is_constructor=True, meet line: 'ostreambuf_iterator&\n      operator++()\n      { return *this; }\n\n\n      bool\n      failed() const noexcept\n      { return _M_failed; }\n\n      ostreambuf_iterator&\n      _M_put(const _CharT* __ws, stre'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      failed() const noexcept\n      { return _M_failed; }\n\n      ostreambuf_iterator&\n      _M_put(const _CharT* __ws, streamsize __len)\n      {\n if (__builtin_expect(!_M_failed, true)\n     && __'
[#] parse_declaration, is_constructor=True, meet line: 'ostreambuf_iterator&\n      _M_put(const _CharT* __ws, streamsize __len)\n      {\n if (__builtin_expect(!_M_failed, true)\n     && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len,\n    false))'
[#] parse_declaration, is_constructor=False, meet line: '__gnu_cxx::__enable_if<__is_char<_CharT>::__value,\n                           ostreambuf_iterator<_CharT> >::__type\n    copy(istreambuf_iterator<_CharT> __first,\n  istreambuf_iterator<_CharT> __last,\n'
[#] parse_declaration, is_constructor=False, meet line: '__gnu_cxx::__enable_if<__is_char<_CharT>::__value,\n            ostreambuf_iterator<_CharT> >::__type\n    __copy_move_a2(_CharT* __first, _CharT* __last,\n     ostreambuf_iterator<_CharT> __result)\n    '
[#] parse_declaration, is_constructor=False, meet line: '__gnu_cxx::__enable_if<__is_char<_CharT>::__value,\n        ostreambuf_iterator<_CharT> >::__type\n    __copy_move_a2(const _CharT* __first, const _CharT* __last,\n     ostreambuf_iterator<_CharT> __resu'
[#] parse_declaration, is_constructor=False, meet line: '__gnu_cxx::__enable_if<__is_char<_CharT>::__value,\n            _CharT*>::__type\n    __copy_move_a2(istreambuf_iterator<_CharT> __first,\n     istreambuf_iterator<_CharT> __last, _CharT* __result)\n    {'
[#] parse_declaration, is_constructor=False, meet line: '__gnu_cxx::__enable_if<__is_char<_CharT>::__value,\n          istreambuf_iterator<_CharT> >::__type\n    find(istreambuf_iterator<_CharT> __first,\n  istreambuf_iterator<_CharT> __last, const _CharT& __v'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    __convert_to_v(const char*, _Tp&, ios_base::iostate&,\n     const __c_locale&) throw();\n\n\n  template<>\n    void\n    __convert_to_v(const char*, float&, ios_base::iostate&,\n     const __c_local'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    __convert_to_v(const char*, float&, ios_base::iostate&,\n     const __c_locale&) throw();\n\n  template<>\n    void\n    __convert_to_v(const char*, double&, ios_base::iostate&,\n     const __c_loc'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    __convert_to_v(const char*, double&, ios_base::iostate&,\n     const __c_locale&) throw();\n\n  template<>\n    void\n    __convert_to_v(const char*, long double&, ios_base::iostate&,\n     const _'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    __convert_to_v(const char*, long double&, ios_base::iostate&,\n     const __c_locale&) throw();\n\n\n\n  template<typename _CharT, typename _Traits>\n    struct __pad\n    {\n      static void\n      '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _S_pad(ios_base& __io, _CharT __fill, _CharT* __news,\n      const _CharT* __olds, streamsize __newlen, streamsize __oldlen);\n    };\n\n\n\n\n\n\n  template<typename _CharT>\n    _CharT*\n    __add_g'
[#] parse_declaration, is_constructor=False, meet line: '_CharT*\n    __add_grouping(_CharT* __s, _CharT __sep,\n     const char* __gbeg, size_t __gsize,\n     const _CharT* __first, const _CharT* __last);\n\n\n\n\n  template<typename _CharT>\n    inline\n    ostream'
[#] parse_declaration, is_constructor=False, meet line: 'ostreambuf_iterator<_CharT>\n    __write(ostreambuf_iterator<_CharT> __s, const _CharT* __ws, int __len)\n    {\n      __s._M_put(__ws, __len);\n      return __s;\n    }\n\n\n  template<typename _CharT, typen'
[#] parse_declaration, is_constructor=False, meet line: '_OutIter\n    __write(_OutIter __s, const _CharT* __ws, int __len)\n    {\n      for (int __j = 0; __j < __len; __j++, ++__s)\n *__s = __ws[__j];\n      return __s;\n    }\n# 149 "/usr/include/c++/7/bits/loc'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      is(mask __m, char_type __c) const\n      { return this->do_is(__m, __c); }\n# 185 "/usr/include/c++/7/bits/locale_facets.h" 3\n      const char_type*\n      is(const char_type *__lo, const char'
[#] parse_declaration, is_constructor=False, meet line: 'char_type*\n      is(const char_type *__lo, const char_type *__hi, mask *__vec) const\n      { return this->do_is(__lo, __hi, __vec); }\n# 201 "/usr/include/c++/7/bits/locale_facets.h" 3\n      const char'
[#] parse_declaration, is_constructor=False, meet line: 'char_type*\n      scan_is(mask __m, const char_type* __lo, const char_type* __hi) const\n      { return this->do_scan_is(__m, __lo, __hi); }\n# 217 "/usr/include/c++/7/bits/locale_facets.h" 3\n      const'
[#] parse_declaration, is_constructor=False, meet line: 'char_type*\n      scan_not(mask __m, const char_type* __lo, const char_type* __hi) const\n      { return this->do_scan_not(__m, __lo, __hi); }\n# 231 "/usr/include/c++/7/bits/locale_facets.h" 3\n      cha'
[#] parse_declaration, is_constructor=False, meet line: 'char_type\n      toupper(char_type __c) const\n      { return this->do_toupper(__c); }\n# 246 "/usr/include/c++/7/bits/locale_facets.h" 3\n      const char_type*\n      toupper(char_type *__lo, const char_'
[#] parse_declaration, is_constructor=False, meet line: 'char_type*\n      toupper(char_type *__lo, const char_type* __hi) const\n      { return this->do_toupper(__lo, __hi); }\n# 260 "/usr/include/c++/7/bits/locale_facets.h" 3\n      char_type\n      tolower(ch'
[#] parse_declaration, is_constructor=False, meet line: 'char_type\n      tolower(char_type __c) const\n      { return this->do_tolower(__c); }\n# 275 "/usr/include/c++/7/bits/locale_facets.h" 3\n      const char_type*\n      tolower(char_type* __lo, const char_'
[#] parse_declaration, is_constructor=False, meet line: 'char_type*\n      tolower(char_type* __lo, const char_type* __hi) const\n      { return this->do_tolower(__lo, __hi); }\n# 292 "/usr/include/c++/7/bits/locale_facets.h" 3\n      char_type\n      widen(char'
[#] parse_declaration, is_constructor=False, meet line: 'char_type\n      widen(char __c) const\n      { return this->do_widen(__c); }\n# 311 "/usr/include/c++/7/bits/locale_facets.h" 3\n      const char*\n      widen(const char* __lo, const char* __hi, char_typ'
[#] parse_declaration, is_constructor=False, meet line: 'char*\n      widen(const char* __lo, const char* __hi, char_type* __to) const\n      { return this->do_widen(__lo, __hi, __to); }\n# 330 "/usr/include/c++/7/bits/locale_facets.h" 3\n      char\n      narro'
[#] parse_declaration, is_constructor=False, meet line: 'char\n      narrow(char_type __c, char __dfault) const\n      { return this->do_narrow(__c, __dfault); }\n# 352 "/usr/include/c++/7/bits/locale_facets.h" 3\n      const char_type*\n      narrow(const char_'
[#] parse_declaration, is_constructor=False, meet line: 'char_type*\n      narrow(const char_type* __lo, const char_type* __hi,\n       char __dfault, char* __to) const\n      { return this->do_narrow(__lo, __hi, __dfault, __to); }\n\n    protected:\n      explic'
[#] parse_declaration, is_constructor=True, meet line: '__ctype_abstract_base(size_t __refs = 0): facet(__refs) { }\n\n      virtual\n      ~__ctype_abstract_base() { }\n# 377 "/usr/include/c++/7/bits/locale_facets.h" 3\n      virtual bool\n      do_is(mask __m,'
[#] parse_declaration, is_constructor=True, meet line: '__ctype_abstract_base() { }\n# 377 "/usr/include/c++/7/bits/locale_facets.h" 3\n      virtual bool\n      do_is(mask __m, char_type __c) const = 0;\n# 396 "/usr/include/c++/7/bits/locale_facets.h" 3\n     '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      do_is(mask __m, char_type __c) const = 0;\n# 396 "/usr/include/c++/7/bits/locale_facets.h" 3\n      virtual const char_type*\n      do_is(const char_type* __lo, const char_type* __hi,\n     mas'
[#] parse_declaration, is_constructor=False, meet line: 'char_type*\n      do_is(const char_type* __lo, const char_type* __hi,\n     mask* __vec) const = 0;\n# 415 "/usr/include/c++/7/bits/locale_facets.h" 3\n      virtual const char_type*\n      do_scan_is(mask'
[#] parse_declaration, is_constructor=False, meet line: 'char_type*\n      do_scan_is(mask __m, const char_type* __lo,\n   const char_type* __hi) const = 0;\n# 434 "/usr/include/c++/7/bits/locale_facets.h" 3\n      virtual const char_type*\n      do_scan_not(mas'
[#] parse_declaration, is_constructor=False, meet line: 'char_type*\n      do_scan_not(mask __m, const char_type* __lo,\n    const char_type* __hi) const = 0;\n# 452 "/usr/include/c++/7/bits/locale_facets.h" 3\n      virtual char_type\n      do_toupper(char_type'
[#] parse_declaration, is_constructor=False, meet line: 'char_type\n      do_toupper(char_type __c) const = 0;\n# 469 "/usr/include/c++/7/bits/locale_facets.h" 3\n      virtual const char_type*\n      do_toupper(char_type* __lo, const char_type* __hi) const = 0'
[#] parse_declaration, is_constructor=False, meet line: 'char_type*\n      do_toupper(char_type* __lo, const char_type* __hi) const = 0;\n# 485 "/usr/include/c++/7/bits/locale_facets.h" 3\n      virtual char_type\n      do_tolower(char_type __c) const = 0;\n# 50'
[#] parse_declaration, is_constructor=False, meet line: 'char_type\n      do_tolower(char_type __c) const = 0;\n# 502 "/usr/include/c++/7/bits/locale_facets.h" 3\n      virtual const char_type*\n      do_tolower(char_type* __lo, const char_type* __hi) const = 0'
[#] parse_declaration, is_constructor=False, meet line: 'char_type*\n      do_tolower(char_type* __lo, const char_type* __hi) const = 0;\n# 521 "/usr/include/c++/7/bits/locale_facets.h" 3\n      virtual char_type\n      do_widen(char __c) const = 0;\n# 542 "/usr'
[#] parse_declaration, is_constructor=False, meet line: 'char_type\n      do_widen(char __c) const = 0;\n# 542 "/usr/include/c++/7/bits/locale_facets.h" 3\n      virtual const char*\n      do_widen(const char* __lo, const char* __hi, char_type* __to) const = 0;'
[#] parse_declaration, is_constructor=False, meet line: 'char*\n      do_widen(const char* __lo, const char* __hi, char_type* __to) const = 0;\n# 563 "/usr/include/c++/7/bits/locale_facets.h" 3\n      virtual char\n      do_narrow(char_type __c, char __dfault) '
[#] parse_declaration, is_constructor=False, meet line: 'char\n      do_narrow(char_type __c, char __dfault) const = 0;\n# 588 "/usr/include/c++/7/bits/locale_facets.h" 3\n      virtual const char_type*\n      do_narrow(const char_type* __lo, const char_type* _'
[#] parse_declaration, is_constructor=False, meet line: 'char_type*\n      do_narrow(const char_type* __lo, const char_type* __hi,\n  char __dfault, char* __to) const = 0;\n    };\n# 611 "/usr/include/c++/7/bits/locale_facets.h" 3\n  template<typename _CharT>\n  '
[#] parse_declaration, is_constructor=False, meet line: 'locale::id id;\n\n      explicit\n      ctype(size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs) { }\n\n   protected:\n      virtual\n      ~ctype();\n\n      virtual bool\n      do_is(mask __m, char_ty'
[#] parse_declaration, is_constructor=True, meet line: 'ctype(size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs) { }\n\n   protected:\n      virtual\n      ~ctype();\n\n      virtual bool\n      do_is(mask __m, char_type __c) const;\n\n      virtual const c'
[#] parse_declaration, is_constructor=True, meet line: 'ctype();\n\n      virtual bool\n      do_is(mask __m, char_type __c) const;\n\n      virtual const char_type*\n      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;\n\n      virtual co'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      do_is(mask __m, char_type __c) const;\n\n      virtual const char_type*\n      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;\n\n      virtual const char_type*\n      do_'
[#] parse_declaration, is_constructor=False, meet line: 'char_type*\n      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;\n\n      virtual const char_type*\n      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;'
[#] parse_declaration, is_constructor=False, meet line: 'char_type*\n      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;\n\n      virtual const char_type*\n      do_scan_not(mask __m, const char_type* __lo,\n    const char_type* __hi)'
[#] parse_declaration, is_constructor=False, meet line: 'char_type*\n      do_scan_not(mask __m, const char_type* __lo,\n    const char_type* __hi) const;\n\n      virtual char_type\n      do_toupper(char_type __c) const;\n\n      virtual const char_type*\n      do'
[#] parse_declaration, is_constructor=False, meet line: 'char_type\n      do_toupper(char_type __c) const;\n\n      virtual const char_type*\n      do_toupper(char_type* __lo, const char_type* __hi) const;\n\n      virtual char_type\n      do_tolower(char_type __c'
[#] parse_declaration, is_constructor=False, meet line: 'char_type*\n      do_toupper(char_type* __lo, const char_type* __hi) const;\n\n      virtual char_type\n      do_tolower(char_type __c) const;\n\n      virtual const char_type*\n      do_tolower(char_type* _'
[#] parse_declaration, is_constructor=False, meet line: 'char_type\n      do_tolower(char_type __c) const;\n\n      virtual const char_type*\n      do_tolower(char_type* __lo, const char_type* __hi) const;\n\n      virtual char_type\n      do_widen(char __c) const'
[#] parse_declaration, is_constructor=False, meet line: 'char_type*\n      do_tolower(char_type* __lo, const char_type* __hi) const;\n\n      virtual char_type\n      do_widen(char __c) const;\n\n      virtual const char*\n      do_widen(const char* __lo, const ch'
[#] parse_declaration, is_constructor=False, meet line: 'char_type\n      do_widen(char __c) const;\n\n      virtual const char*\n      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;\n\n      virtual char\n      do_narrow(char_type, char __'
[#] parse_declaration, is_constructor=False, meet line: 'char*\n      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;\n\n      virtual char\n      do_narrow(char_type, char __dfault) const;\n\n      virtual const char_type*\n      do_narrow('
[#] parse_declaration, is_constructor=False, meet line: 'char\n      do_narrow(char_type, char __dfault) const;\n\n      virtual const char_type*\n      do_narrow(const char_type* __lo, const char_type* __hi,\n  char __dfault, char* __to) const;\n    };\n\n  templa'
[#] parse_declaration, is_constructor=False, meet line: 'char_type*\n      do_narrow(const char_type* __lo, const char_type* __hi,\n  char __dfault, char* __to) const;\n    };\n\n  template<typename _CharT>\n    locale::id ctype<_CharT>::id;\n# 680 "/usr/include/c'
[#] parse_declaration, is_constructor=False, meet line: 'locale::id ctype<_CharT>::id;\n# 680 "/usr/include/c++/7/bits/locale_facets.h" 3\n  template<>\n    class ctype<char> : public locale::facet, public ctype_base\n    {\n    public:\n\n\n      typedef char char'
[#] parse_declaration, is_constructor=False, meet line: '__c_locale _M_c_locale_ctype;\n      bool _M_del;\n      __to_type _M_toupper;\n      __to_type _M_tolower;\n      const mask* _M_table;\n      mutable char _M_widen_ok;\n      mutable char _M_widen[1 + sta'
[#] parse_declaration, is_constructor=False, meet line: 'bool _M_del;\n      __to_type _M_toupper;\n      __to_type _M_tolower;\n      const mask* _M_table;\n      mutable char _M_widen_ok;\n      mutable char _M_widen[1 + static_cast<unsigned char>(-1)];\n      '
[#] parse_declaration, is_constructor=False, meet line: '__to_type _M_toupper;\n      __to_type _M_tolower;\n      const mask* _M_table;\n      mutable char _M_widen_ok;\n      mutable char _M_widen[1 + static_cast<unsigned char>(-1)];\n      mutable char _M_nar'
[#] parse_declaration, is_constructor=False, meet line: '__to_type _M_tolower;\n      const mask* _M_table;\n      mutable char _M_widen_ok;\n      mutable char _M_widen[1 + static_cast<unsigned char>(-1)];\n      mutable char _M_narrow[1 + static_cast<unsigned'
[#] parse_declaration, is_constructor=False, meet line: 'mask* _M_table;\n      mutable char _M_widen_ok;\n      mutable char _M_widen[1 + static_cast<unsigned char>(-1)];\n      mutable char _M_narrow[1 + static_cast<unsigned char>(-1)];\n      mutable char _M'
[#] parse_declaration, is_constructor=False, meet line: 'char _M_widen_ok;\n      mutable char _M_widen[1 + static_cast<unsigned char>(-1)];\n      mutable char _M_narrow[1 + static_cast<unsigned char>(-1)];\n      mutable char _M_narrow_ok;\n\n\n    public:\n\n   '
[#] parse_declaration, is_constructor=False, meet line: 'char _M_widen[1 + static_cast<unsigned char>(-1)];\n      mutable char _M_narrow[1 + static_cast<unsigned char>(-1)];\n      mutable char _M_narrow_ok;\n\n\n    public:\n\n      static locale::id id;\n\n      '
[#] parse_declaration, is_constructor=False, meet line: 'char _M_narrow[1 + static_cast<unsigned char>(-1)];\n      mutable char _M_narrow_ok;\n\n\n    public:\n\n      static locale::id id;\n\n      static const size_t table_size = 1 + static_cast<unsigned char>(-'
[#] parse_declaration, is_constructor=False, meet line: 'char _M_narrow_ok;\n\n\n    public:\n\n      static locale::id id;\n\n      static const size_t table_size = 1 + static_cast<unsigned char>(-1);\n# 717 "/usr/include/c++/7/bits/locale_facets.h" 3\n      explic'
[#] parse_declaration, is_constructor=False, meet line: 'locale::id id;\n\n      static const size_t table_size = 1 + static_cast<unsigned char>(-1);\n# 717 "/usr/include/c++/7/bits/locale_facets.h" 3\n      explicit\n      ctype(const mask* __table = 0, bool __'
[#] parse_declaration, is_constructor=False, meet line: 'size_t table_size = 1 + static_cast<unsigned char>(-1);\n# 717 "/usr/include/c++/7/bits/locale_facets.h" 3\n      explicit\n      ctype(const mask* __table = 0, bool __del = false, size_t __refs = 0);\n# '
[#] parse_declaration, is_constructor=True, meet line: 'ctype(const mask* __table = 0, bool __del = false, size_t __refs = 0);\n# 730 "/usr/include/c++/7/bits/locale_facets.h" 3\n      explicit\n      ctype(__c_locale __cloc, const mask* __table = 0, bool __d'
[#] parse_declaration, is_constructor=True, meet line: 'ctype(__c_locale __cloc, const mask* __table = 0, bool __del = false,\n     size_t __refs = 0);\n# 743 "/usr/include/c++/7/bits/locale_facets.h" 3\n      inline bool\n      is(mask __m, char __c) const;\n#'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      is(mask __m, char __c) const;\n# 758 "/usr/include/c++/7/bits/locale_facets.h" 3\n      inline const char*\n      is(const char* __lo, const char* __hi, mask* __vec) const;\n# 772 "/usr/include'
[#] parse_declaration, is_constructor=False, meet line: 'char*\n      is(const char* __lo, const char* __hi, mask* __vec) const;\n# 772 "/usr/include/c++/7/bits/locale_facets.h" 3\n      inline const char*\n      scan_is(mask __m, const char* __lo, const char* '
[#] parse_declaration, is_constructor=False, meet line: 'char*\n      scan_is(mask __m, const char* __lo, const char* __hi) const;\n# 786 "/usr/include/c++/7/bits/locale_facets.h" 3\n      inline const char*\n      scan_not(mask __m, const char* __lo, const cha'
[#] parse_declaration, is_constructor=False, meet line: 'char*\n      scan_not(mask __m, const char* __lo, const char* __hi) const;\n# 801 "/usr/include/c++/7/bits/locale_facets.h" 3\n      char_type\n      toupper(char_type __c) const\n      { return this->do_t'
[#] parse_declaration, is_constructor=False, meet line: 'char_type\n      toupper(char_type __c) const\n      { return this->do_toupper(__c); }\n# 818 "/usr/include/c++/7/bits/locale_facets.h" 3\n      const char_type*\n      toupper(char_type *__lo, const char_'
[#] parse_declaration, is_constructor=False, meet line: 'char_type*\n      toupper(char_type *__lo, const char_type* __hi) const\n      { return this->do_toupper(__lo, __hi); }\n# 834 "/usr/include/c++/7/bits/locale_facets.h" 3\n      char_type\n      tolower(ch'
[#] parse_declaration, is_constructor=False, meet line: 'char_type\n      tolower(char_type __c) const\n      { return this->do_tolower(__c); }\n# 851 "/usr/include/c++/7/bits/locale_facets.h" 3\n      const char_type*\n      tolower(char_type* __lo, const char_'
[#] parse_declaration, is_constructor=False, meet line: 'char_type*\n      tolower(char_type* __lo, const char_type* __hi) const\n      { return this->do_tolower(__lo, __hi); }\n# 871 "/usr/include/c++/7/bits/locale_facets.h" 3\n      char_type\n      widen(char'
[#] parse_declaration, is_constructor=False, meet line: 'char_type\n      widen(char __c) const\n      {\n if (_M_widen_ok)\n   return _M_widen[static_cast<unsigned char>(__c)];\n this->_M_widen_init();\n return this->do_widen(__c);\n      }\n# 898 "/usr/include/c+'
[#] parse_declaration, is_constructor=False, meet line: 'char*\n      widen(const char* __lo, const char* __hi, char_type* __to) const\n      {\n if (_M_widen_ok == 1)\n   {\n     __builtin_memcpy(__to, __lo, __hi - __lo);\n     return __hi;\n   }\n if (!_M_widen_o'
[#] parse_declaration, is_constructor=False, meet line: 'char\n      narrow(char_type __c, char __dfault) const\n      {\n if (_M_narrow[static_cast<unsigned char>(__c)])\n   return _M_narrow[static_cast<unsigned char>(__c)];\n const char __t = do_narrow(__c, __'
[#] parse_declaration, is_constructor=False, meet line: 'char_type*\n      narrow(const char_type* __lo, const char_type* __hi,\n      char __dfault, char* __to) const\n      {\n if (__builtin_expect(_M_narrow_ok == 1, true))\n   {\n     __builtin_memcpy(__to, __'
[#] parse_declaration, is_constructor=False, meet line: 'mask*\n      table() const throw()\n      { return _M_table; }\n\n\n      static const mask*\n      classic_table() throw();\n    protected:\n\n\n\n\n\n\n\n      virtual\n      ~ctype();\n# 1011 "/usr/include/c++/7/bi'
[#] parse_declaration, is_constructor=False, meet line: 'mask*\n      classic_table() throw();\n    protected:\n\n\n\n\n\n\n\n      virtual\n      ~ctype();\n# 1011 "/usr/include/c++/7/bits/locale_facets.h" 3\n      virtual char_type\n      do_toupper(char_type __c) cons'
[#] parse_declaration, is_constructor=True, meet line: 'ctype();\n# 1011 "/usr/include/c++/7/bits/locale_facets.h" 3\n      virtual char_type\n      do_toupper(char_type __c) const;\n# 1028 "/usr/include/c++/7/bits/locale_facets.h" 3\n      virtual const char_t'
[#] parse_declaration, is_constructor=False, meet line: 'char_type\n      do_toupper(char_type __c) const;\n# 1028 "/usr/include/c++/7/bits/locale_facets.h" 3\n      virtual const char_type*\n      do_toupper(char_type* __lo, const char_type* __hi) const;\n# 104'
[#] parse_declaration, is_constructor=False, meet line: 'char_type*\n      do_toupper(char_type* __lo, const char_type* __hi) const;\n# 1044 "/usr/include/c++/7/bits/locale_facets.h" 3\n      virtual char_type\n      do_tolower(char_type __c) const;\n# 1061 "/us'
[#] parse_declaration, is_constructor=False, meet line: 'char_type\n      do_tolower(char_type __c) const;\n# 1061 "/usr/include/c++/7/bits/locale_facets.h" 3\n      virtual const char_type*\n      do_tolower(char_type* __lo, const char_type* __hi) const;\n# 108'
[#] parse_declaration, is_constructor=False, meet line: 'char_type*\n      do_tolower(char_type* __lo, const char_type* __hi) const;\n# 1081 "/usr/include/c++/7/bits/locale_facets.h" 3\n      virtual char_type\n      do_widen(char __c) const\n      { return __c;'
[#] parse_declaration, is_constructor=False, meet line: 'char_type\n      do_widen(char __c) const\n      { return __c; }\n# 1104 "/usr/include/c++/7/bits/locale_facets.h" 3\n      virtual const char*\n      do_widen(const char* __lo, const char* __hi, char_type'
[#] parse_declaration, is_constructor=False, meet line: 'char*\n      do_widen(const char* __lo, const char* __hi, char_type* __to) const\n      {\n __builtin_memcpy(__to, __lo, __hi - __lo);\n return __hi;\n      }\n# 1130 "/usr/include/c++/7/bits/locale_facets.'
[#] parse_declaration, is_constructor=False, meet line: 'char\n      do_narrow(char_type __c, char __dfault __attribute__((__unused__))) const\n      { return __c; }\n# 1156 "/usr/include/c++/7/bits/locale_facets.h" 3\n      virtual const char_type*\n      do_na'
[#] parse_declaration, is_constructor=False, meet line: 'char_type*\n      do_narrow(const char_type* __lo, const char_type* __hi,\n  char __dfault __attribute__((__unused__)), char* __to) const\n      {\n __builtin_memcpy(__to, __lo, __hi - __lo);\n return __hi'
[#] parse_declaration, is_constructor=False, meet line: 'void _M_narrow_init() const;\n      void _M_widen_init() const;\n    };\n# 1181 "/usr/include/c++/7/bits/locale_facets.h" 3\n  template<>\n    class ctype<wchar_t> : public __ctype_abstract_base<wchar_t>\n '
[#] parse_declaration, is_constructor=False, meet line: 'void _M_widen_init() const;\n    };\n# 1181 "/usr/include/c++/7/bits/locale_facets.h" 3\n  template<>\n    class ctype<wchar_t> : public __ctype_abstract_base<wchar_t>\n    {\n    public:\n\n\n      typedef wc'
[#] parse_declaration, is_constructor=False, meet line: '__c_locale _M_c_locale_ctype;\n\n\n      bool _M_narrow_ok;\n      char _M_narrow[128];\n      wint_t _M_widen[1 + static_cast<unsigned char>(-1)];\n\n\n      mask _M_bit[16];\n      __wmask_type _M_wmask[16];'
[#] parse_declaration, is_constructor=False, meet line: 'bool _M_narrow_ok;\n      char _M_narrow[128];\n      wint_t _M_widen[1 + static_cast<unsigned char>(-1)];\n\n\n      mask _M_bit[16];\n      __wmask_type _M_wmask[16];\n\n    public:\n\n\n      static locale::i'
[#] parse_declaration, is_constructor=False, meet line: 'char _M_narrow[128];\n      wint_t _M_widen[1 + static_cast<unsigned char>(-1)];\n\n\n      mask _M_bit[16];\n      __wmask_type _M_wmask[16];\n\n    public:\n\n\n      static locale::id id;\n# 1214 "/usr/includ'
[#] parse_declaration, is_constructor=False, meet line: 'wint_t _M_widen[1 + static_cast<unsigned char>(-1)];\n\n\n      mask _M_bit[16];\n      __wmask_type _M_wmask[16];\n\n    public:\n\n\n      static locale::id id;\n# 1214 "/usr/include/c++/7/bits/locale_facets.'
[#] parse_declaration, is_constructor=False, meet line: 'mask _M_bit[16];\n      __wmask_type _M_wmask[16];\n\n    public:\n\n\n      static locale::id id;\n# 1214 "/usr/include/c++/7/bits/locale_facets.h" 3\n      explicit\n      ctype(size_t __refs = 0);\n# 1225 "/'
[#] parse_declaration, is_constructor=False, meet line: '__wmask_type _M_wmask[16];\n\n    public:\n\n\n      static locale::id id;\n# 1214 "/usr/include/c++/7/bits/locale_facets.h" 3\n      explicit\n      ctype(size_t __refs = 0);\n# 1225 "/usr/include/c++/7/bits/'
[#] parse_declaration, is_constructor=False, meet line: 'locale::id id;\n# 1214 "/usr/include/c++/7/bits/locale_facets.h" 3\n      explicit\n      ctype(size_t __refs = 0);\n# 1225 "/usr/include/c++/7/bits/locale_facets.h" 3\n      explicit\n      ctype(__c_local'
[#] parse_declaration, is_constructor=True, meet line: 'ctype(size_t __refs = 0);\n# 1225 "/usr/include/c++/7/bits/locale_facets.h" 3\n      explicit\n      ctype(__c_locale __cloc, size_t __refs = 0);\n\n    protected:\n      __wmask_type\n      _M_convert_to_wm'
[#] parse_declaration, is_constructor=True, meet line: 'ctype(__c_locale __cloc, size_t __refs = 0);\n\n    protected:\n      __wmask_type\n      _M_convert_to_wmask(const mask __m) const throw();\n\n\n      virtual\n      ~ctype();\n# 1249 "/usr/include/c++/7/bits'
[#] parse_declaration, is_constructor=False, meet line: '__wmask_type\n      _M_convert_to_wmask(const mask __m) const throw();\n\n\n      virtual\n      ~ctype();\n# 1249 "/usr/include/c++/7/bits/locale_facets.h" 3\n      virtual bool\n      do_is(mask __m, char_t'
[#] parse_declaration, is_constructor=True, meet line: 'ctype();\n# 1249 "/usr/include/c++/7/bits/locale_facets.h" 3\n      virtual bool\n      do_is(mask __m, char_type __c) const;\n# 1268 "/usr/include/c++/7/bits/locale_facets.h" 3\n      virtual const char_t'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      do_is(mask __m, char_type __c) const;\n# 1268 "/usr/include/c++/7/bits/locale_facets.h" 3\n      virtual const char_type*\n      do_is(const char_type* __lo, const char_type* __hi, mask* __vec'
[#] parse_declaration, is_constructor=False, meet line: 'char_type*\n      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;\n# 1286 "/usr/include/c++/7/bits/locale_facets.h" 3\n      virtual const char_type*\n      do_scan_is(mask __m, co'
[#] parse_declaration, is_constructor=False, meet line: 'char_type*\n      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;\n# 1304 "/usr/include/c++/7/bits/locale_facets.h" 3\n      virtual const char_type*\n      do_scan_not(mask __m,'
[#] parse_declaration, is_constructor=False, meet line: 'char_type*\n      do_scan_not(mask __m, const char_type* __lo,\n    const char_type* __hi) const;\n# 1321 "/usr/include/c++/7/bits/locale_facets.h" 3\n      virtual char_type\n      do_toupper(char_type __'
[#] parse_declaration, is_constructor=False, meet line: 'char_type\n      do_toupper(char_type __c) const;\n# 1338 "/usr/include/c++/7/bits/locale_facets.h" 3\n      virtual const char_type*\n      do_toupper(char_type* __lo, const char_type* __hi) const;\n# 135'
[#] parse_declaration, is_constructor=False, meet line: 'char_type*\n      do_toupper(char_type* __lo, const char_type* __hi) const;\n# 1354 "/usr/include/c++/7/bits/locale_facets.h" 3\n      virtual char_type\n      do_tolower(char_type __c) const;\n# 1371 "/us'
[#] parse_declaration, is_constructor=False, meet line: 'char_type\n      do_tolower(char_type __c) const;\n# 1371 "/usr/include/c++/7/bits/locale_facets.h" 3\n      virtual const char_type*\n      do_tolower(char_type* __lo, const char_type* __hi) const;\n# 139'
[#] parse_declaration, is_constructor=False, meet line: 'char_type*\n      do_tolower(char_type* __lo, const char_type* __hi) const;\n# 1391 "/usr/include/c++/7/bits/locale_facets.h" 3\n      virtual char_type\n      do_widen(char __c) const;\n# 1413 "/usr/inclu'
[#] parse_declaration, is_constructor=False, meet line: 'char_type\n      do_widen(char __c) const;\n# 1413 "/usr/include/c++/7/bits/locale_facets.h" 3\n      virtual const char*\n      do_widen(const char* __lo, const char* __hi, char_type* __to) const;\n# 1436'
[#] parse_declaration, is_constructor=False, meet line: 'char*\n      do_widen(const char* __lo, const char* __hi, char_type* __to) const;\n# 1436 "/usr/include/c++/7/bits/locale_facets.h" 3\n      virtual char\n      do_narrow(char_type __c, char __dfault) con'
[#] parse_declaration, is_constructor=False, meet line: 'char\n      do_narrow(char_type __c, char __dfault) const;\n# 1462 "/usr/include/c++/7/bits/locale_facets.h" 3\n      virtual const char_type*\n      do_narrow(const char_type* __lo, const char_type* __hi'
[#] parse_declaration, is_constructor=False, meet line: 'char_type*\n      do_narrow(const char_type* __lo, const char_type* __hi,\n  char __dfault, char* __to) const;\n\n\n      void\n      _M_initialize_ctype() throw();\n    };\n\n\n\n  template<typename _CharT>\n   '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_initialize_ctype() throw();\n    };\n\n\n\n  template<typename _CharT>\n    class ctype_byname : public ctype<_CharT>\n    {\n    public:\n      typedef typename ctype<_CharT>::mask mask;\n\n      '
[#] parse_declaration, is_constructor=True, meet line: 'ctype_byname(const char* __s, size_t __refs = 0);\n\n\n      explicit\n      ctype_byname(const string& __s, size_t __refs = 0)\n      : ctype_byname(__s.c_str(), __refs) { }\n\n\n    protected:\n      virtual'
[#] parse_declaration, is_constructor=True, meet line: 'ctype_byname(const string& __s, size_t __refs = 0)\n      : ctype_byname(__s.c_str(), __refs) { }\n\n\n    protected:\n      virtual\n      ~ctype_byname() { };\n    };\n\n\n  template<>\n    class ctype_byname<'
[#] parse_declaration, is_constructor=True, meet line: 'ctype_byname() { };\n    };\n\n\n  template<>\n    class ctype_byname<char> : public ctype<char>\n    {\n    public:\n      explicit\n      ctype_byname(const char* __s, size_t __refs = 0);\n\n\n      explicit\n  '
[#] parse_declaration, is_constructor=True, meet line: 'ctype_byname(const char* __s, size_t __refs = 0);\n\n\n      explicit\n      ctype_byname(const string& __s, size_t __refs = 0);\n\n\n    protected:\n      virtual\n      ~ctype_byname();\n    };\n\n\n  template<>'
[#] parse_declaration, is_constructor=True, meet line: 'ctype_byname(const string& __s, size_t __refs = 0);\n\n\n    protected:\n      virtual\n      ~ctype_byname();\n    };\n\n\n  template<>\n    class ctype_byname<wchar_t> : public ctype<wchar_t>\n    {\n    public'
[#] parse_declaration, is_constructor=True, meet line: 'ctype_byname();\n    };\n\n\n  template<>\n    class ctype_byname<wchar_t> : public ctype<wchar_t>\n    {\n    public:\n      explicit\n      ctype_byname(const char* __s, size_t __refs = 0);\n\n\n      explicit\n'
[#] parse_declaration, is_constructor=True, meet line: 'ctype_byname(const char* __s, size_t __refs = 0);\n\n\n      explicit\n      ctype_byname(const string& __s, size_t __refs = 0);\n\n\n    protected:\n      virtual\n      ~ctype_byname();\n    };\n\n\n\n}\n\n\n# 1 "/u'
[#] parse_declaration, is_constructor=True, meet line: 'ctype_byname(const string& __s, size_t __refs = 0);\n\n\n    protected:\n      virtual\n      ~ctype_byname();\n    };\n\n\n\n}\n\n\n# 1 "/usr/include/x86_64-linux-gnu/c++/7/bits/ctype_inline.h" 1 3\n# 37 "/usr/inc'
[#] parse_declaration, is_constructor=True, meet line: 'ctype_byname();\n    };\n\n\n\n}\n\n\n# 1 "/usr/include/x86_64-linux-gnu/c++/7/bits/ctype_inline.h" 1 3\n# 37 "/usr/include/x86_64-linux-gnu/c++/7/bits/ctype_inline.h" 3\nnamespace std __attribute__ ((__visibil'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n  ctype<char>::\n  is(mask __m, char __c) const\n  { return _M_table[static_cast<unsigned char>(__c)] & __m; }\n\n  const char*\n  ctype<char>::\n  is(const char* __low, const char* __high, mask* __vec'
[#] parse_declaration, is_constructor=False, meet line: 'char*\n  ctype<char>::\n  is(const char* __low, const char* __high, mask* __vec) const\n  {\n    while (__low < __high)\n      *__vec++ = _M_table[static_cast<unsigned char>(*__low++)];\n    return __high;\n'
[#] parse_declaration, is_constructor=False, meet line: 'char*\n  ctype<char>::\n  scan_is(mask __m, const char* __low, const char* __high) const\n  {\n    while (__low < __high\n    && !(_M_table[static_cast<unsigned char>(*__low)] & __m))\n      ++__low;\n    re'
[#] parse_declaration, is_constructor=False, meet line: 'char*\n  ctype<char>::\n  scan_not(mask __m, const char* __low, const char* __high) const\n  {\n    while (__low < __high\n    && (_M_table[static_cast<unsigned char>(*__low)] & __m) != 0)\n      ++__low;\n '
[#] parse_declaration, is_constructor=False, meet line: 'char* _S_atoms_out;\n\n\n\n    static const char* _S_atoms_in;\n\n    enum\n    {\n      _S_iminus,\n      _S_iplus,\n      _S_ix,\n      _S_iX,\n      _S_izero,\n      _S_ie = _S_izero + 14,\n      _S_iE = _S_izer'
[#] parse_declaration, is_constructor=False, meet line: 'char* _S_atoms_in;\n\n    enum\n    {\n      _S_iminus,\n      _S_iplus,\n      _S_ix,\n      _S_iX,\n      _S_izero,\n      _S_ie = _S_izero + 14,\n      _S_iE = _S_izero + 20,\n      _S_iend = 26\n    };\n\n\n\n   '
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _S_format_float(const ios_base& __io, char* __fptr, char __mod) throw();\n  };\n\n  template<typename _CharT>\n    struct __numpunct_cache : public locale::facet\n    {\n      const char* _M_groupi'
[#] parse_declaration, is_constructor=False, meet line: 'char* _M_grouping;\n      size_t _M_grouping_size;\n      bool _M_use_grouping;\n      const _CharT* _M_truename;\n      size_t _M_truename_size;\n      const _CharT* _M_falsename;\n      size_t _M_falsenam'
[#] parse_declaration, is_constructor=False, meet line: 'size_t _M_grouping_size;\n      bool _M_use_grouping;\n      const _CharT* _M_truename;\n      size_t _M_truename_size;\n      const _CharT* _M_falsename;\n      size_t _M_falsename_size;\n      _CharT _M_d'
[#] parse_declaration, is_constructor=False, meet line: 'bool _M_use_grouping;\n      const _CharT* _M_truename;\n      size_t _M_truename_size;\n      const _CharT* _M_falsename;\n      size_t _M_falsename_size;\n      _CharT _M_decimal_point;\n      _CharT _M_t'
[#] parse_declaration, is_constructor=False, meet line: '_CharT* _M_truename;\n      size_t _M_truename_size;\n      const _CharT* _M_falsename;\n      size_t _M_falsename_size;\n      _CharT _M_decimal_point;\n      _CharT _M_thousands_sep;\n\n\n\n\n\n      _CharT _M'
[#] parse_declaration, is_constructor=False, meet line: 'size_t _M_truename_size;\n      const _CharT* _M_falsename;\n      size_t _M_falsename_size;\n      _CharT _M_decimal_point;\n      _CharT _M_thousands_sep;\n\n\n\n\n\n      _CharT _M_atoms_out[__num_base::_S_o'
[#] parse_declaration, is_constructor=False, meet line: '_CharT* _M_falsename;\n      size_t _M_falsename_size;\n      _CharT _M_decimal_point;\n      _CharT _M_thousands_sep;\n\n\n\n\n\n      _CharT _M_atoms_out[__num_base::_S_oend];\n\n\n\n\n\n      _CharT _M_atoms_in[_'
[#] parse_declaration, is_constructor=False, meet line: 'size_t _M_falsename_size;\n      _CharT _M_decimal_point;\n      _CharT _M_thousands_sep;\n\n\n\n\n\n      _CharT _M_atoms_out[__num_base::_S_oend];\n\n\n\n\n\n      _CharT _M_atoms_in[__num_base::_S_iend];\n\n      '
[#] parse_declaration, is_constructor=False, meet line: '_CharT _M_decimal_point;\n      _CharT _M_thousands_sep;\n\n\n\n\n\n      _CharT _M_atoms_out[__num_base::_S_oend];\n\n\n\n\n\n      _CharT _M_atoms_in[__num_base::_S_iend];\n\n      bool _M_allocated;\n\n      __nump'
[#] parse_declaration, is_constructor=False, meet line: '_CharT _M_thousands_sep;\n\n\n\n\n\n      _CharT _M_atoms_out[__num_base::_S_oend];\n\n\n\n\n\n      _CharT _M_atoms_in[__num_base::_S_iend];\n\n      bool _M_allocated;\n\n      __numpunct_cache(size_t __refs = 0)\n '
[#] parse_declaration, is_constructor=False, meet line: '_CharT _M_atoms_out[__num_base::_S_oend];\n\n\n\n\n\n      _CharT _M_atoms_in[__num_base::_S_iend];\n\n      bool _M_allocated;\n\n      __numpunct_cache(size_t __refs = 0)\n      : facet(__refs), _M_grouping(0)'
[#] parse_declaration, is_constructor=False, meet line: '_CharT _M_atoms_in[__num_base::_S_iend];\n\n      bool _M_allocated;\n\n      __numpunct_cache(size_t __refs = 0)\n      : facet(__refs), _M_grouping(0), _M_grouping_size(0),\n _M_use_grouping(false),\n _M_t'
[#] parse_declaration, is_constructor=False, meet line: 'bool _M_allocated;\n\n      __numpunct_cache(size_t __refs = 0)\n      : facet(__refs), _M_grouping(0), _M_grouping_size(0),\n _M_use_grouping(false),\n _M_truename(0), _M_truename_size(0), _M_falsename(0)'
[#] parse_declaration, is_constructor=True, meet line: '__numpunct_cache(size_t __refs = 0)\n      : facet(__refs), _M_grouping(0), _M_grouping_size(0),\n _M_use_grouping(false),\n _M_truename(0), _M_truename_size(0), _M_falsename(0),\n _M_falsename_size(0), _'
[#] parse_declaration, is_constructor=True, meet line: '__numpunct_cache();\n\n      void\n      _M_cache(const locale& __loc);\n\n    private:\n      __numpunct_cache&\n      operator=(const __numpunct_cache&);\n\n      explicit\n      __numpunct_cache(const __nump'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_cache(const locale& __loc);\n\n    private:\n      __numpunct_cache&\n      operator=(const __numpunct_cache&);\n\n      explicit\n      __numpunct_cache(const __numpunct_cache&);\n    };\n\n  tem'
[#] parse_declaration, is_constructor=True, meet line: '__numpunct_cache&\n      operator=(const __numpunct_cache&);\n\n      explicit\n      __numpunct_cache(const __numpunct_cache&);\n    };\n\n  template<typename _CharT>\n    __numpunct_cache<_CharT>::~__numpun'
[#] parse_declaration, is_constructor=True, meet line: '__numpunct_cache(const __numpunct_cache&);\n    };\n\n  template<typename _CharT>\n    __numpunct_cache<_CharT>::~__numpunct_cache()\n    {\n      if (_M_allocated)\n {\n   delete [] _M_grouping;\n   delete []'
[#] parse_declaration, is_constructor=False, meet line: '__numpunct_cache<_CharT>::~__numpunct_cache()\n    {\n      if (_M_allocated)\n {\n   delete [] _M_grouping;\n   delete [] _M_truename;\n   delete [] _M_falsename;\n }\n    }\n\nnamespace __cxx11 {\n# 1665 "/usr'
[#] parse_declaration, is_constructor=False, meet line: '__cache_type* _M_data;\n\n    public:\n\n      static locale::id id;\n\n\n\n\n\n\n      explicit\n      numpunct(size_t __refs = 0)\n      : facet(__refs), _M_data(0)\n      { _M_initialize_numpunct(); }\n# 1703 "/u'
[#] parse_declaration, is_constructor=False, meet line: 'locale::id id;\n\n\n\n\n\n\n      explicit\n      numpunct(size_t __refs = 0)\n      : facet(__refs), _M_data(0)\n      { _M_initialize_numpunct(); }\n# 1703 "/usr/include/c++/7/bits/locale_facets.h" 3\n      exp'
[#] parse_declaration, is_constructor=True, meet line: 'numpunct(size_t __refs = 0)\n      : facet(__refs), _M_data(0)\n      { _M_initialize_numpunct(); }\n# 1703 "/usr/include/c++/7/bits/locale_facets.h" 3\n      explicit\n      numpunct(__cache_type* __cache'
[#] parse_declaration, is_constructor=True, meet line: 'numpunct(__cache_type* __cache, size_t __refs = 0)\n      : facet(__refs), _M_data(__cache)\n      { _M_initialize_numpunct(); }\n# 1717 "/usr/include/c++/7/bits/locale_facets.h" 3\n      explicit\n      n'
[#] parse_declaration, is_constructor=True, meet line: 'numpunct(__c_locale __cloc, size_t __refs = 0)\n      : facet(__refs), _M_data(0)\n      { _M_initialize_numpunct(__cloc); }\n# 1731 "/usr/include/c++/7/bits/locale_facets.h" 3\n      char_type\n      deci'
[#] parse_declaration, is_constructor=False, meet line: 'char_type\n      decimal_point() const\n      { return this->do_decimal_point(); }\n# 1744 "/usr/include/c++/7/bits/locale_facets.h" 3\n      char_type\n      thousands_sep() const\n      { return this->do_'
[#] parse_declaration, is_constructor=False, meet line: 'char_type\n      thousands_sep() const\n      { return this->do_thousands_sep(); }\n# 1775 "/usr/include/c++/7/bits/locale_facets.h" 3\n      string\n      grouping() const\n      { return this->do_grouping'
[#] parse_declaration, is_constructor=False, meet line: 'string\n      grouping() const\n      { return this->do_grouping(); }\n# 1788 "/usr/include/c++/7/bits/locale_facets.h" 3\n      string_type\n      truename() const\n      { return this->do_truename(); }\n# '
[#] parse_declaration, is_constructor=False, meet line: 'string_type\n      truename() const\n      { return this->do_truename(); }\n# 1801 "/usr/include/c++/7/bits/locale_facets.h" 3\n      string_type\n      falsename() const\n      { return this->do_falsename('
[#] parse_declaration, is_constructor=False, meet line: 'string_type\n      falsename() const\n      { return this->do_falsename(); }\n\n    protected:\n\n      virtual\n      ~numpunct();\n# 1818 "/usr/include/c++/7/bits/locale_facets.h" 3\n      virtual char_type\n'
[#] parse_declaration, is_constructor=True, meet line: 'numpunct();\n# 1818 "/usr/include/c++/7/bits/locale_facets.h" 3\n      virtual char_type\n      do_decimal_point() const\n      { return _M_data->_M_decimal_point; }\n# 1830 "/usr/include/c++/7/bits/locale'
[#] parse_declaration, is_constructor=False, meet line: 'char_type\n      do_decimal_point() const\n      { return _M_data->_M_decimal_point; }\n# 1830 "/usr/include/c++/7/bits/locale_facets.h" 3\n      virtual char_type\n      do_thousands_sep() const\n      { r'
[#] parse_declaration, is_constructor=False, meet line: 'char_type\n      do_thousands_sep() const\n      { return _M_data->_M_thousands_sep; }\n# 1843 "/usr/include/c++/7/bits/locale_facets.h" 3\n      virtual string\n      do_grouping() const\n      { return _M'
[#] parse_declaration, is_constructor=False, meet line: 'string\n      do_grouping() const\n      { return _M_data->_M_grouping; }\n# 1856 "/usr/include/c++/7/bits/locale_facets.h" 3\n      virtual string_type\n      do_truename() const\n      { return _M_data->_'
[#] parse_declaration, is_constructor=False, meet line: 'string_type\n      do_truename() const\n      { return _M_data->_M_truename; }\n# 1869 "/usr/include/c++/7/bits/locale_facets.h" 3\n      virtual string_type\n      do_falsename() const\n      { return _M_d'
[#] parse_declaration, is_constructor=False, meet line: 'string_type\n      do_falsename() const\n      { return _M_data->_M_falsename; }\n\n\n      void\n      _M_initialize_numpunct(__c_locale __cloc = 0);\n    };\n\n  template<typename _CharT>\n    locale::id nump'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_initialize_numpunct(__c_locale __cloc = 0);\n    };\n\n  template<typename _CharT>\n    locale::id numpunct<_CharT>::id;\n\n  template<>\n    numpunct<char>::~numpunct();\n\n  template<>\n    void'
[#] parse_declaration, is_constructor=False, meet line: 'locale::id numpunct<_CharT>::id;\n\n  template<>\n    numpunct<char>::~numpunct();\n\n  template<>\n    void\n    numpunct<char>::_M_initialize_numpunct(__c_locale __cloc);\n\n\n  template<>\n    numpunct<wchar_'
[#] parse_declaration, is_constructor=False, meet line: 'numpunct<char>::~numpunct();\n\n  template<>\n    void\n    numpunct<char>::_M_initialize_numpunct(__c_locale __cloc);\n\n\n  template<>\n    numpunct<wchar_t>::~numpunct();\n\n  template<>\n    void\n    numpunc'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    numpunct<char>::_M_initialize_numpunct(__c_locale __cloc);\n\n\n  template<>\n    numpunct<wchar_t>::~numpunct();\n\n  template<>\n    void\n    numpunct<wchar_t>::_M_initialize_numpunct(__c_locale _'
[#] parse_declaration, is_constructor=False, meet line: 'numpunct<wchar_t>::~numpunct();\n\n  template<>\n    void\n    numpunct<wchar_t>::_M_initialize_numpunct(__c_locale __cloc);\n\n\n\n  template<typename _CharT>\n    class numpunct_byname : public numpunct<_Cha'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    numpunct<wchar_t>::_M_initialize_numpunct(__c_locale __cloc);\n\n\n\n  template<typename _CharT>\n    class numpunct_byname : public numpunct<_CharT>\n    {\n    public:\n      typedef _CharT char_ty'
[#] parse_declaration, is_constructor=True, meet line: 'numpunct_byname(const char* __s, size_t __refs = 0)\n      : numpunct<_CharT>(__refs)\n      {\n if (__builtin_strcmp(__s, "C") != 0\n     && __builtin_strcmp(__s, "POSIX") != 0)\n   {\n     __c_locale __tm'
[#] parse_declaration, is_constructor=True, meet line: 'numpunct_byname(const string& __s, size_t __refs = 0)\n      : numpunct_byname(__s.c_str(), __refs) { }\n\n\n    protected:\n      virtual\n      ~numpunct_byname() { }\n    };\n\n}\n\n\n# 1947 "/usr/include/c++/'
[#] parse_declaration, is_constructor=True, meet line: 'numpunct_byname() { }\n    };\n\n}\n\n\n# 1947 "/usr/include/c++/7/bits/locale_facets.h" 3\n  template<typename _CharT, typename _InIter>\n    class num_get : public locale::facet\n    {\n    public:\n\n\n\n      t'
[#] parse_declaration, is_constructor=False, meet line: 'locale::id id;\n# 1968 "/usr/include/c++/7/bits/locale_facets.h" 3\n      explicit\n      num_get(size_t __refs = 0) : facet(__refs) { }\n# 1994 "/usr/include/c++/7/bits/locale_facets.h" 3\n      iter_type'
[#] parse_declaration, is_constructor=True, meet line: 'num_get(size_t __refs = 0) : facet(__refs) { }\n# 1994 "/usr/include/c++/7/bits/locale_facets.h" 3\n      iter_type\n      get(iter_type __in, iter_type __end, ios_base& __io,\n   ios_base::iostate& __err'
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      get(iter_type __in, iter_type __end, ios_base& __io,\n   ios_base::iostate& __err, bool& __v) const\n      { return this->do_get(__in, __end, __io, __err, __v); }\n# 2031 "/usr/include/c+'
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      get(iter_type __in, iter_type __end, ios_base& __io,\n   ios_base::iostate& __err, long& __v) const\n      { return this->do_get(__in, __end, __io, __err, __v); }\n\n      iter_type\n      '
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      get(iter_type __in, iter_type __end, ios_base& __io,\n   ios_base::iostate& __err, unsigned short& __v) const\n      { return this->do_get(__in, __end, __io, __err, __v); }\n\n      iter_t'
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      get(iter_type __in, iter_type __end, ios_base& __io,\n   ios_base::iostate& __err, unsigned int& __v) const\n      { return this->do_get(__in, __end, __io, __err, __v); }\n\n      iter_typ'
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      get(iter_type __in, iter_type __end, ios_base& __io,\n   ios_base::iostate& __err, unsigned long& __v) const\n      { return this->do_get(__in, __end, __io, __err, __v); }\n\n\n      iter_t'
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      get(iter_type __in, iter_type __end, ios_base& __io,\n   ios_base::iostate& __err, long long& __v) const\n      { return this->do_get(__in, __end, __io, __err, __v); }\n\n      iter_type\n '
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      get(iter_type __in, iter_type __end, ios_base& __io,\n   ios_base::iostate& __err, unsigned long long& __v) const\n      { return this->do_get(__in, __end, __io, __err, __v); }\n# 2091 "/'
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      get(iter_type __in, iter_type __end, ios_base& __io,\n   ios_base::iostate& __err, float& __v) const\n      { return this->do_get(__in, __end, __io, __err, __v); }\n\n      iter_type\n     '
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      get(iter_type __in, iter_type __end, ios_base& __io,\n   ios_base::iostate& __err, double& __v) const\n      { return this->do_get(__in, __end, __io, __err, __v); }\n\n      iter_type\n    '
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      get(iter_type __in, iter_type __end, ios_base& __io,\n   ios_base::iostate& __err, long double& __v) const\n      { return this->do_get(__in, __end, __io, __err, __v); }\n# 2134 "/usr/inc'
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      get(iter_type __in, iter_type __end, ios_base& __io,\n   ios_base::iostate& __err, void*& __v) const\n      { return this->do_get(__in, __end, __io, __err, __v); }\n\n    protected:\n\n     '
[#] parse_declaration, is_constructor=True, meet line: 'num_get() { }\n\n      __attribute ((__abi_tag__ ("cxx11")))\n      iter_type\n      _M_extract_float(iter_type, iter_type, ios_base&, ios_base::iostate&,\n         string&) const;\n\n      template<typename'
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      _M_extract_float(iter_type, iter_type, ios_base&, ios_base::iostate&,\n         string&) const;\n\n      template<typename _ValueT>\n __attribute ((__abi_tag__ ("cxx11")))\n iter_type\n _M_e'
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n _M_extract_int(iter_type, iter_type, ios_base&, ios_base::iostate&,\n         _ValueT&) const;\n\n      template<typename _CharT2>\n      typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__v'
[#] parse_declaration, is_constructor=False, meet line: "__gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type\n _M_find(const _CharT2*, size_t __len, _CharT2 __c) const\n {\n   int __ret = -1;\n   if (__len <= 10)\n     {\n       if (__c >= _CharT2('0"
[#] parse_declaration, is_constructor=False, meet line: '__gnu_cxx::__enable_if<!__is_char<_CharT2>::__value,\n          int>::__type\n _M_find(const _CharT2* __zero, size_t __len, _CharT2 __c) const\n {\n   int __ret = -1;\n   const char_type* __q = char_traits'
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const;\n\n      virtual iter_type\n      do_get(iter_type __beg, iter_type __end, ios_base& __io,\n      ios_base::iostat'
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      do_get(iter_type __beg, iter_type __end, ios_base& __io,\n      ios_base::iostate& __err, long& __v) const\n      { return _M_extract_int(__beg, __end, __io, __err, __v); }\n\n      virtua'
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      do_get(iter_type __beg, iter_type __end, ios_base& __io,\n      ios_base::iostate& __err, unsigned short& __v) const\n      { return _M_extract_int(__beg, __end, __io, __err, __v); }\n\n  '
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      do_get(iter_type __beg, iter_type __end, ios_base& __io,\n      ios_base::iostate& __err, unsigned int& __v) const\n      { return _M_extract_int(__beg, __end, __io, __err, __v); }\n\n    '
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      do_get(iter_type __beg, iter_type __end, ios_base& __io,\n      ios_base::iostate& __err, unsigned long& __v) const\n      { return _M_extract_int(__beg, __end, __io, __err, __v); }\n\n\n  '
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      do_get(iter_type __beg, iter_type __end, ios_base& __io,\n      ios_base::iostate& __err, long long& __v) const\n      { return _M_extract_int(__beg, __end, __io, __err, __v); }\n\n      v'
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      do_get(iter_type __beg, iter_type __end, ios_base& __io,\n      ios_base::iostate& __err, unsigned long long& __v) const\n      { return _M_extract_int(__beg, __end, __io, __err, __v); }'
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, float&) const;\n\n      virtual iter_type\n      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,\n      double&) con'
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,\n      double&) const;\n\n\n\n\n\n\n\n      virtual iter_type\n      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,\n     '
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,\n      long double&) const;\n\n\n      virtual iter_type\n      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, void*'
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, void*&) const;\n# 2270 "/usr/include/c++/7/bits/locale_facets.h" 3\n    };\n\n  template<typename _CharT, typename _InIter>\n    '
[#] parse_declaration, is_constructor=False, meet line: 'locale::id num_get<_CharT, _InIter>::id;\n# 2288 "/usr/include/c++/7/bits/locale_facets.h" 3\n  template<typename _CharT, typename _OutIter>\n    class num_put : public locale::facet\n    {\n    public:\n\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'locale::id id;\n# 2309 "/usr/include/c++/7/bits/locale_facets.h" 3\n      explicit\n      num_put(size_t __refs = 0) : facet(__refs) { }\n# 2327 "/usr/include/c++/7/bits/locale_facets.h" 3\n      iter_type'
[#] parse_declaration, is_constructor=True, meet line: 'num_put(size_t __refs = 0) : facet(__refs) { }\n# 2327 "/usr/include/c++/7/bits/locale_facets.h" 3\n      iter_type\n      put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const\n      { ret'
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const\n      { return this->do_put(__s, __io, __fill, __v); }\n# 2369 "/usr/include/c++/7/bits/locale_facets.h" 3\n      ite'
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      put(iter_type __s, ios_base& __io, char_type __fill, long __v) const\n      { return this->do_put(__s, __io, __fill, __v); }\n\n      iter_type\n      put(iter_type __s, ios_base& __io, ch'
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      put(iter_type __s, ios_base& __io, char_type __fill,\n   unsigned long __v) const\n      { return this->do_put(__s, __io, __fill, __v); }\n\n\n      iter_type\n      put(iter_type __s, ios_b'
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      put(iter_type __s, ios_base& __io, char_type __fill, long long __v) const\n      { return this->do_put(__s, __io, __fill, __v); }\n\n      iter_type\n      put(iter_type __s, ios_base& __i'
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      put(iter_type __s, ios_base& __io, char_type __fill,\n   unsigned long long __v) const\n      { return this->do_put(__s, __io, __fill, __v); }\n# 2432 "/usr/include/c++/7/bits/locale_face'
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      put(iter_type __s, ios_base& __io, char_type __fill, double __v) const\n      { return this->do_put(__s, __io, __fill, __v); }\n\n      iter_type\n      put(iter_type __s, ios_base& __io, '
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      put(iter_type __s, ios_base& __io, char_type __fill,\n   long double __v) const\n      { return this->do_put(__s, __io, __fill, __v); }\n# 2457 "/usr/include/c++/7/bits/locale_facets.h" 3'
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      put(iter_type __s, ios_base& __io, char_type __fill,\n   const void* __v) const\n      { return this->do_put(__s, __io, __fill, __v); }\n\n    protected:\n      template<typename _ValueT>\n '
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n _M_insert_float(iter_type, ios_base& __io, char_type __fill,\n   char __mod, _ValueT __v) const;\n\n      void\n      _M_group_float(const char* __grouping, size_t __grouping_size,\n       char_'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_group_float(const char* __grouping, size_t __grouping_size,\n       char_type __sep, const char_type* __p, char_type* __new,\n       char_type* __cs, int& __len) const;\n\n      template<typ'
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n _M_insert_int(iter_type, ios_base& __io, char_type __fill,\n        _ValueT __v) const;\n\n      void\n      _M_group_int(const char* __grouping, size_t __grouping_size,\n     char_type __sep, i'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_group_int(const char* __grouping, size_t __grouping_size,\n     char_type __sep, ios_base& __io, char_type* __new,\n     char_type* __cs, int& __len) const;\n\n      void\n      _M_pad(char_t'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_pad(char_type __fill, streamsize __w, ios_base& __io,\n      char_type* __new, const char_type* __cs, int& __len) const;\n\n\n      virtual\n      ~num_put() { };\n# 2505 "/usr/include/c++/7/b'
[#] parse_declaration, is_constructor=True, meet line: 'num_put() { };\n# 2505 "/usr/include/c++/7/bits/locale_facets.h" 3\n      virtual iter_type\n      do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const;\n\n      virtual iter_type\n      '
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const;\n\n      virtual iter_type\n      do_put(iter_type __s, ios_base& __io, char_type __fill, long __v) const\n      { '
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      do_put(iter_type __s, ios_base& __io, char_type __fill, long __v) const\n      { return _M_insert_int(__s, __io, __fill, __v); }\n\n      virtual iter_type\n      do_put(iter_type __s, ios'
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      do_put(iter_type __s, ios_base& __io, char_type __fill,\n      unsigned long __v) const\n      { return _M_insert_int(__s, __io, __fill, __v); }\n\n\n      virtual iter_type\n      do_put(it'
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      do_put(iter_type __s, ios_base& __io, char_type __fill,\n      long long __v) const\n      { return _M_insert_int(__s, __io, __fill, __v); }\n\n      virtual iter_type\n      do_put(iter_ty'
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      do_put(iter_type __s, ios_base& __io, char_type __fill,\n      unsigned long long __v) const\n      { return _M_insert_int(__s, __io, __fill, __v); }\n\n\n      virtual iter_type\n      do_p'
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      do_put(iter_type, ios_base&, char_type, double) const;\n\n\n\n\n\n\n      virtual iter_type\n      do_put(iter_type, ios_base&, char_type, long double) const;\n\n\n      virtual iter_type\n      d'
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      do_put(iter_type, ios_base&, char_type, long double) const;\n\n\n      virtual iter_type\n      do_put(iter_type, ios_base&, char_type, const void*) const;\n\n\n\n\n\n\n\n    };\n\n  template <typen'
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      do_put(iter_type, ios_base&, char_type, const void*) const;\n\n\n\n\n\n\n\n    };\n\n  template <typename _CharT, typename _OutIter>\n    locale::id num_put<_CharT, _OutIter>::id;\n\n\n\n\n\n\n\n\n\n  temp'
[#] parse_declaration, is_constructor=False, meet line: 'locale::id num_put<_CharT, _OutIter>::id;\n\n\n\n\n\n\n\n\n\n  template<typename _CharT>\n    inline bool\n    isspace(_CharT __c, const locale& __loc)\n    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base:'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    isspace(_CharT __c, const locale& __loc)\n    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c); }\n\n\n  template<typename _CharT>\n    inline bool\n    isprint(_CharT __c, cons'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    isprint(_CharT __c, const locale& __loc)\n    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c); }\n\n\n  template<typename _CharT>\n    inline bool\n    iscntrl(_CharT __c, cons'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    iscntrl(_CharT __c, const locale& __loc)\n    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c); }\n\n\n  template<typename _CharT>\n    inline bool\n    isupper(_CharT __c, cons'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    isupper(_CharT __c, const locale& __loc)\n    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c); }\n\n\n  template<typename _CharT>\n    inline bool\n    islower(_CharT __c, cons'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    islower(_CharT __c, const locale& __loc)\n    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c); }\n\n\n  template<typename _CharT>\n    inline bool\n    isalpha(_CharT __c, cons'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    isalpha(_CharT __c, const locale& __loc)\n    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c); }\n\n\n  template<typename _CharT>\n    inline bool\n    isdigit(_CharT __c, cons'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    isdigit(_CharT __c, const locale& __loc)\n    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c); }\n\n\n  template<typename _CharT>\n    inline bool\n    ispunct(_CharT __c, cons'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    ispunct(_CharT __c, const locale& __loc)\n    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c); }\n\n\n  template<typename _CharT>\n    inline bool\n    isxdigit(_CharT __c, con'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    isxdigit(_CharT __c, const locale& __loc)\n    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c); }\n\n\n  template<typename _CharT>\n    inline bool\n    isalnum(_CharT __c, co'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    isalnum(_CharT __c, const locale& __loc)\n    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c); }\n\n\n  template<typename _CharT>\n    inline bool\n    isgraph(_CharT __c, cons'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    isgraph(_CharT __c, const locale& __loc)\n    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c); }\n\n\n\n  template<typename _CharT>\n    inline bool\n    isblank(_CharT __c, con'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    isblank(_CharT __c, const locale& __loc)\n    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::blank, __c); }\n\n\n\n  template<typename _CharT>\n    inline _CharT\n    toupper(_CharT __c, c'
[#] parse_declaration, is_constructor=False, meet line: '_CharT\n    toupper(_CharT __c, const locale& __loc)\n    { return use_facet<ctype<_CharT> >(__loc).toupper(__c); }\n\n\n  template<typename _CharT>\n    inline _CharT\n    tolower(_CharT __c, const locale& '
[#] parse_declaration, is_constructor=False, meet line: '_CharT\n    tolower(_CharT __c, const locale& __loc)\n    { return use_facet<ctype<_CharT> >(__loc).tolower(__c); }\n\n\n}\n\n# 1 "/usr/include/c++/7/bits/locale_facets.tcc" 1 3\n# 33 "/usr/include/c++/7/bits'
[#] parse_declaration, is_constructor=False, meet line: '_Facet*\n      operator() (const locale& __loc) const;\n    };\n\n\n  template<typename _CharT>\n    struct __use_cache<__numpunct_cache<_CharT> >\n    {\n      const __numpunct_cache<_CharT>*\n      operator('
[#] parse_declaration, is_constructor=False, meet line: '__numpunct_cache<_CharT>*\n      operator() (const locale& __loc) const\n      {\n const size_t __i = numpunct<_CharT>::id._M_id();\n const locale::facet** __caches = __loc._M_impl->_M_caches;\n if (!__cac'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    __numpunct_cache<_CharT>::_M_cache(const locale& __loc)\n    {\n      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);\n\n      char* __grouping = 0;\n      _CharT* __truename ='
[#] parse_declaration, is_constructor=False, meet line: '__attribute__ ((__pure__)) bool\n  __verify_grouping(const char* __grouping, size_t __grouping_size,\n      const string& __grouping_tmp) throw ();\n\n\n\n  template<typename _CharT, typename _InIter>\n    _'
[#] parse_declaration, is_constructor=False, meet line: '_InIter\n    num_get<_CharT, _InIter>::\n    _M_extract_float(_InIter __beg, _InIter __end, ios_base& __io,\n       ios_base::iostate& __err, string& __xtrc) const\n    {\n      typedef char_traits<_CharT>'
[#] parse_declaration, is_constructor=False, meet line: '_InIter\n      num_get<_CharT, _InIter>::\n      _M_extract_int(_InIter __beg, _InIter __end, ios_base& __io,\n       ios_base::iostate& __err, _ValueT& __v) const\n      {\n        typedef char_traits<_Ch'
[#] parse_declaration, is_constructor=False, meet line: '_InIter\n    num_get<_CharT, _InIter>::\n    do_get(iter_type __beg, iter_type __end, ios_base& __io,\n           ios_base::iostate& __err, bool& __v) const\n    {\n      if (!(__io.flags() & ios_base::boo'
[#] parse_declaration, is_constructor=False, meet line: '_InIter\n    num_get<_CharT, _InIter>::\n    do_get(iter_type __beg, iter_type __end, ios_base& __io,\n    ios_base::iostate& __err, float& __v) const\n    {\n      string __xtrc;\n      __xtrc.reserve(32);'
[#] parse_declaration, is_constructor=False, meet line: '_InIter\n    num_get<_CharT, _InIter>::\n    do_get(iter_type __beg, iter_type __end, ios_base& __io,\n           ios_base::iostate& __err, double& __v) const\n    {\n      string __xtrc;\n      __xtrc.rese'
[#] parse_declaration, is_constructor=False, meet line: '_InIter\n    num_get<_CharT, _InIter>::\n    do_get(iter_type __beg, iter_type __end, ios_base& __io,\n           ios_base::iostate& __err, long double& __v) const\n    {\n      string __xtrc;\n      __xtrc'
[#] parse_declaration, is_constructor=False, meet line: '_InIter\n    num_get<_CharT, _InIter>::\n    do_get(iter_type __beg, iter_type __end, ios_base& __io,\n           ios_base::iostate& __err, void*& __v) const\n    {\n\n      typedef ios_base::fmtflags fmtfl'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    num_put<_CharT, _OutIter>::\n    _M_pad(_CharT __fill, streamsize __w, ios_base& __io,\n    _CharT* __new, const _CharT* __cs, int& __len) const\n    {\n\n\n      __pad<_CharT, char_traits<_CharT> '
[#] parse_declaration, is_constructor=False, meet line: 'int\n    __int_to_char(_CharT* __bufend, _ValueT __v, const _CharT* __lit,\n    ios_base::fmtflags __flags, bool __dec)\n    {\n      _CharT* __buf = __bufend;\n      if (__builtin_expect(__dec, true))\n {\n'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    num_put<_CharT, _OutIter>::\n    _M_group_int(const char* __grouping, size_t __grouping_size, _CharT __sep,\n   ios_base&, _CharT* __new, _CharT* __cs, int& __len) const\n    {\n      _CharT* __p'
[#] parse_declaration, is_constructor=False, meet line: '_OutIter\n      num_put<_CharT, _OutIter>::\n      _M_insert_int(_OutIter __s, ios_base& __io, _CharT __fill,\n      _ValueT __v) const\n      {\n using __gnu_cxx::__add_unsigned;\n typedef typename __add_u'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    num_put<_CharT, _OutIter>::\n    _M_group_float(const char* __grouping, size_t __grouping_size,\n     _CharT __sep, const _CharT* __p, _CharT* __new,\n     _CharT* __cs, int& __len) const\n    {\n'
[#] parse_declaration, is_constructor=False, meet line: '_OutIter\n      num_put<_CharT, _OutIter>::\n      _M_insert_float(_OutIter __s, ios_base& __io, _CharT __fill, char __mod,\n         _ValueT __v) const\n      {\n typedef __numpunct_cache<_CharT> __cache_'
[#] parse_declaration, is_constructor=False, meet line: '_OutIter\n    num_put<_CharT, _OutIter>::\n    do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const\n    {\n      const ios_base::fmtflags __flags = __io.flags();\n      if ((__flags & i'
[#] parse_declaration, is_constructor=False, meet line: '_OutIter\n    num_put<_CharT, _OutIter>::\n    do_put(iter_type __s, ios_base& __io, char_type __fill, double __v) const\n    { return _M_insert_float(__s, __io, __fill, char(), __v); }\n# 1169 "/usr/incl'
[#] parse_declaration, is_constructor=False, meet line: "_OutIter\n    num_put<_CharT, _OutIter>::\n    do_put(iter_type __s, ios_base& __io, char_type __fill,\n    long double __v) const\n    { return _M_insert_float(__s, __io, __fill, 'L', __v); }\n\n  template"
[#] parse_declaration, is_constructor=False, meet line: '_OutIter\n    num_put<_CharT, _OutIter>::\n    do_put(iter_type __s, ios_base& __io, char_type __fill,\n           const void* __v) const\n    {\n      const ios_base::fmtflags __flags = __io.flags();\n    '
[#] parse_declaration, is_constructor=False, meet line: 'void\n    __pad<_CharT, _Traits>::_S_pad(ios_base& __io, _CharT __fill,\n       _CharT* __news, const _CharT* __olds,\n       streamsize __newlen, streamsize __oldlen)\n    {\n      const size_t __plen = s'
[#] parse_declaration, is_constructor=False, meet line: '_CharT*\n    __add_grouping(_CharT* __s, _CharT __sep,\n     const char* __gbeg, size_t __gsize,\n     const _CharT* __first, const _CharT* __last)\n    {\n      size_t __idx = 0;\n      size_t __ctr = 0;\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'template class __cxx11:: numpunct<char>;\n  extern template class __cxx11:: numpunct_byname<char>;\n  extern template class num_get<char>;\n  extern template class num_put<char>;\n  extern template class '
[#] parse_declaration, is_constructor=False, meet line: 'template class __cxx11:: numpunct_byname<char>;\n  extern template class num_get<char>;\n  extern template class num_put<char>;\n  extern template class ctype_byname<char>;\n\n  extern template\n    const c'
[#] parse_declaration, is_constructor=False, meet line: 'template class num_get<char>;\n  extern template class num_put<char>;\n  extern template class ctype_byname<char>;\n\n  extern template\n    const ctype<char>&\n    use_facet<ctype<char> >(const locale&);\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'template class num_put<char>;\n  extern template class ctype_byname<char>;\n\n  extern template\n    const ctype<char>&\n    use_facet<ctype<char> >(const locale&);\n\n  extern template\n    const numpunct<ch'
[#] parse_declaration, is_constructor=False, meet line: 'template class ctype_byname<char>;\n\n  extern template\n    const ctype<char>&\n    use_facet<ctype<char> >(const locale&);\n\n  extern template\n    const numpunct<char>&\n    use_facet<numpunct<char> >(con'
[#] parse_declaration, is_constructor=False, meet line: 'template\n    const ctype<char>&\n    use_facet<ctype<char> >(const locale&);\n\n  extern template\n    const numpunct<char>&\n    use_facet<numpunct<char> >(const locale&);\n\n  extern template\n    const num'
[#] parse_declaration, is_constructor=False, meet line: 'template\n    const numpunct<char>&\n    use_facet<numpunct<char> >(const locale&);\n\n  extern template\n    const num_put<char>&\n    use_facet<num_put<char> >(const locale&);\n\n  extern template\n    const'
[#] parse_declaration, is_constructor=False, meet line: 'template\n    const num_put<char>&\n    use_facet<num_put<char> >(const locale&);\n\n  extern template\n    const num_get<char>&\n    use_facet<num_get<char> >(const locale&);\n\n  extern template\n    bool\n  '
[#] parse_declaration, is_constructor=False, meet line: 'template\n    const num_get<char>&\n    use_facet<num_get<char> >(const locale&);\n\n  extern template\n    bool\n    has_facet<ctype<char> >(const locale&);\n\n  extern template\n    bool\n    has_facet<numpun'
[#] parse_declaration, is_constructor=False, meet line: 'template\n    bool\n    has_facet<ctype<char> >(const locale&);\n\n  extern template\n    bool\n    has_facet<numpunct<char> >(const locale&);\n\n  extern template\n    bool\n    has_facet<num_put<char> >(const'
[#] parse_declaration, is_constructor=False, meet line: 'template\n    bool\n    has_facet<numpunct<char> >(const locale&);\n\n  extern template\n    bool\n    has_facet<num_put<char> >(const locale&);\n\n  extern template\n    bool\n    has_facet<num_get<char> >(con'
[#] parse_declaration, is_constructor=False, meet line: 'template\n    bool\n    has_facet<num_put<char> >(const locale&);\n\n  extern template\n    bool\n    has_facet<num_get<char> >(const locale&);\n\n\n  extern template class __cxx11:: numpunct<wchar_t>;\n  exter'
[#] parse_declaration, is_constructor=False, meet line: 'template\n    bool\n    has_facet<num_get<char> >(const locale&);\n\n\n  extern template class __cxx11:: numpunct<wchar_t>;\n  extern template class __cxx11:: numpunct_byname<wchar_t>;\n  extern template cla'
[#] parse_declaration, is_constructor=False, meet line: 'template class __cxx11:: numpunct<wchar_t>;\n  extern template class __cxx11:: numpunct_byname<wchar_t>;\n  extern template class num_get<wchar_t>;\n  extern template class num_put<wchar_t>;\n  extern tem'
[#] parse_declaration, is_constructor=False, meet line: 'template class __cxx11:: numpunct_byname<wchar_t>;\n  extern template class num_get<wchar_t>;\n  extern template class num_put<wchar_t>;\n  extern template class ctype_byname<wchar_t>;\n\n  extern template'
[#] parse_declaration, is_constructor=False, meet line: 'template class num_get<wchar_t>;\n  extern template class num_put<wchar_t>;\n  extern template class ctype_byname<wchar_t>;\n\n  extern template\n    const ctype<wchar_t>&\n    use_facet<ctype<wchar_t> >(co'
[#] parse_declaration, is_constructor=False, meet line: 'template class num_put<wchar_t>;\n  extern template class ctype_byname<wchar_t>;\n\n  extern template\n    const ctype<wchar_t>&\n    use_facet<ctype<wchar_t> >(const locale&);\n\n  extern template\n    const'
[#] parse_declaration, is_constructor=False, meet line: 'template class ctype_byname<wchar_t>;\n\n  extern template\n    const ctype<wchar_t>&\n    use_facet<ctype<wchar_t> >(const locale&);\n\n  extern template\n    const numpunct<wchar_t>&\n    use_facet<numpunct'
[#] parse_declaration, is_constructor=False, meet line: 'template\n    const ctype<wchar_t>&\n    use_facet<ctype<wchar_t> >(const locale&);\n\n  extern template\n    const numpunct<wchar_t>&\n    use_facet<numpunct<wchar_t> >(const locale&);\n\n  extern template\n '
[#] parse_declaration, is_constructor=False, meet line: 'template\n    const numpunct<wchar_t>&\n    use_facet<numpunct<wchar_t> >(const locale&);\n\n  extern template\n    const num_put<wchar_t>&\n    use_facet<num_put<wchar_t> >(const locale&);\n\n  extern templa'
[#] parse_declaration, is_constructor=False, meet line: 'template\n    const num_put<wchar_t>&\n    use_facet<num_put<wchar_t> >(const locale&);\n\n  extern template\n    const num_get<wchar_t>&\n    use_facet<num_get<wchar_t> >(const locale&);\n\n extern template\n'
[#] parse_declaration, is_constructor=False, meet line: 'template\n    const num_get<wchar_t>&\n    use_facet<num_get<wchar_t> >(const locale&);\n\n extern template\n    bool\n    has_facet<ctype<wchar_t> >(const locale&);\n\n  extern template\n    bool\n    has_face'
[#] parse_declaration, is_constructor=False, meet line: 'template\n    bool\n    has_facet<ctype<wchar_t> >(const locale&);\n\n  extern template\n    bool\n    has_facet<numpunct<wchar_t> >(const locale&);\n\n  extern template\n    bool\n    has_facet<num_put<wchar_t'
[#] parse_declaration, is_constructor=False, meet line: 'template\n    bool\n    has_facet<numpunct<wchar_t> >(const locale&);\n\n  extern template\n    bool\n    has_facet<num_put<wchar_t> >(const locale&);\n\n  extern template\n    bool\n    has_facet<num_get<wchar'
[#] parse_declaration, is_constructor=False, meet line: 'template\n    bool\n    has_facet<num_put<wchar_t> >(const locale&);\n\n  extern template\n    bool\n    has_facet<num_get<wchar_t> >(const locale&);\n\n\n\n\n}\n# 2652 "/usr/include/c++/7/bits/locale_facets.h" 2'
[#] parse_declaration, is_constructor=False, meet line: 'template\n    bool\n    has_facet<num_get<wchar_t> >(const locale&);\n\n\n\n\n}\n# 2652 "/usr/include/c++/7/bits/locale_facets.h" 2 3\n# 38 "/usr/include/c++/7/bits/basic_ios.h" 2 3\n\n\n\nnamespace std __attribut'
[#] parse_declaration, is_constructor=False, meet line: '_Facet&\n    __check_facet(const _Facet* __f)\n    {\n      if (!__f)\n __throw_bad_cast();\n      return *__f;\n    }\n# 66 "/usr/include/c++/7/bits/basic_ios.h" 3\n  template<typename _CharT, typename _Trai'
[#] parse_declaration, is_constructor=False, meet line: 'basic_ostream<_CharT, _Traits>* _M_tie;\n      mutable char_type _M_fill;\n      mutable bool _M_fill_init;\n      basic_streambuf<_CharT, _Traits>* _M_streambuf;\n\n\n      const __ctype_type* _M_ctype;\n\n '
[#] parse_declaration, is_constructor=False, meet line: 'char_type _M_fill;\n      mutable bool _M_fill_init;\n      basic_streambuf<_CharT, _Traits>* _M_streambuf;\n\n\n      const __ctype_type* _M_ctype;\n\n      const __num_put_type* _M_num_put;\n\n      const __'
[#] parse_declaration, is_constructor=False, meet line: 'bool _M_fill_init;\n      basic_streambuf<_CharT, _Traits>* _M_streambuf;\n\n\n      const __ctype_type* _M_ctype;\n\n      const __num_put_type* _M_num_put;\n\n      const __num_get_type* _M_num_get;\n\n    pu'
[#] parse_declaration, is_constructor=False, meet line: 'basic_streambuf<_CharT, _Traits>* _M_streambuf;\n\n\n      const __ctype_type* _M_ctype;\n\n      const __num_put_type* _M_num_put;\n\n      const __num_get_type* _M_num_get;\n\n    public:\n# 117 "/usr/include'
[#] parse_declaration, is_constructor=False, meet line: '__ctype_type* _M_ctype;\n\n      const __num_put_type* _M_num_put;\n\n      const __num_get_type* _M_num_get;\n\n    public:\n# 117 "/usr/include/c++/7/bits/basic_ios.h" 3\n      explicit operator bool() cons'
[#] parse_declaration, is_constructor=False, meet line: '__num_put_type* _M_num_put;\n\n      const __num_get_type* _M_num_get;\n\n    public:\n# 117 "/usr/include/c++/7/bits/basic_ios.h" 3\n      explicit operator bool() const\n      { return !this->fail(); }\n\n\n\n'
[#] parse_declaration, is_constructor=False, meet line: '__num_get_type* _M_num_get;\n\n    public:\n# 117 "/usr/include/c++/7/bits/basic_ios.h" 3\n      explicit operator bool() const\n      { return !this->fail(); }\n\n\n\n\n\n      bool\n      operator!() const\n    '
[#] parse_declaration, is_constructor=False, meet line: 'operator bool() const\n      { return !this->fail(); }\n\n\n\n\n\n      bool\n      operator!() const\n      { return this->fail(); }\n# 136 "/usr/include/c++/7/bits/basic_ios.h" 3\n      iostate\n      rdstate()'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      operator!() const\n      { return this->fail(); }\n# 136 "/usr/include/c++/7/bits/basic_ios.h" 3\n      iostate\n      rdstate() const\n      { return _M_streambuf_state; }\n# 147 "/usr/include/c'
[#] parse_declaration, is_constructor=False, meet line: 'iostate\n      rdstate() const\n      { return _M_streambuf_state; }\n# 147 "/usr/include/c++/7/bits/basic_ios.h" 3\n      void\n      clear(iostate __state = goodbit);\n\n\n\n\n\n\n\n      void\n      setstate(ios'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      clear(iostate __state = goodbit);\n\n\n\n\n\n\n\n      void\n      setstate(iostate __state)\n      { this->clear(this->rdstate() | __state); }\n\n\n\n\n      void\n      _M_setstate(iostate __state)\n     '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      setstate(iostate __state)\n      { this->clear(this->rdstate() | __state); }\n\n\n\n\n      void\n      _M_setstate(iostate __state)\n      {\n\n\n _M_streambuf_state |= __state;\n if (this->exceptions'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_setstate(iostate __state)\n      {\n\n\n _M_streambuf_state |= __state;\n if (this->exceptions() & __state)\n   throw;\n      }\n\n\n\n\n\n\n\n      bool\n      good() const\n      { return this->rdstate'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      good() const\n      { return this->rdstate() == 0; }\n\n\n\n\n\n\n\n      bool\n      eof() const\n      { return (this->rdstate() & eofbit) != 0; }\n# 200 "/usr/include/c++/7/bits/basic_ios.h" 3\n     '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      eof() const\n      { return (this->rdstate() & eofbit) != 0; }\n# 200 "/usr/include/c++/7/bits/basic_ios.h" 3\n      bool\n      fail() const\n      { return (this->rdstate() & (badbit | failbit'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      fail() const\n      { return (this->rdstate() & (badbit | failbit)) != 0; }\n\n\n\n\n\n\n\n      bool\n      bad() const\n      { return (this->rdstate() & badbit) != 0; }\n# 221 "/usr/include/c++/7/bi'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      bad() const\n      { return (this->rdstate() & badbit) != 0; }\n# 221 "/usr/include/c++/7/bits/basic_ios.h" 3\n      iostate\n      exceptions() const\n      { return _M_exception; }\n# 256 "/usr'
[#] parse_declaration, is_constructor=False, meet line: 'iostate\n      exceptions() const\n      { return _M_exception; }\n# 256 "/usr/include/c++/7/bits/basic_ios.h" 3\n      void\n      exceptions(iostate __except)\n      {\n        _M_exception = __except;\n   '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      exceptions(iostate __except)\n      {\n        _M_exception = __except;\n        this->clear(_M_streambuf_state);\n      }\n\n\n\n\n\n\n\n      explicit\n      basic_ios(basic_streambuf<_CharT, _Traits>'
[#] parse_declaration, is_constructor=True, meet line: 'basic_ios(basic_streambuf<_CharT, _Traits>* __sb)\n      : ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0),\n _M_ctype(0), _M_num_put(0), _M_num_get(0)\n      { this->init(__sb); }'
[#] parse_declaration, is_constructor=True, meet line: 'basic_ios() { }\n# 294 "/usr/include/c++/7/bits/basic_ios.h" 3\n      basic_ostream<_CharT, _Traits>*\n      tie() const\n      { return _M_tie; }\n# 306 "/usr/include/c++/7/bits/basic_ios.h" 3\n      basic'
[#] parse_declaration, is_constructor=False, meet line: 'basic_ostream<_CharT, _Traits>*\n      tie() const\n      { return _M_tie; }\n# 306 "/usr/include/c++/7/bits/basic_ios.h" 3\n      basic_ostream<_CharT, _Traits>*\n      tie(basic_ostream<_CharT, _Traits>*'
[#] parse_declaration, is_constructor=False, meet line: 'basic_ostream<_CharT, _Traits>*\n      tie(basic_ostream<_CharT, _Traits>* __tiestr)\n      {\n        basic_ostream<_CharT, _Traits>* __old = _M_tie;\n        _M_tie = __tiestr;\n        return __old;\n   '
[#] parse_declaration, is_constructor=False, meet line: 'basic_streambuf<_CharT, _Traits>*\n      rdbuf() const\n      { return _M_streambuf; }\n# 346 "/usr/include/c++/7/bits/basic_ios.h" 3\n      basic_streambuf<_CharT, _Traits>*\n      rdbuf(basic_streambuf<_'
[#] parse_declaration, is_constructor=False, meet line: 'basic_streambuf<_CharT, _Traits>*\n      rdbuf(basic_streambuf<_CharT, _Traits>* __sb);\n# 360 "/usr/include/c++/7/bits/basic_ios.h" 3\n      basic_ios&\n      copyfmt(const basic_ios& __rhs);\n\n\n\n\n\n\n\n    '
[#] parse_declaration, is_constructor=True, meet line: "basic_ios&\n      copyfmt(const basic_ios& __rhs);\n\n\n\n\n\n\n\n      char_type\n      fill() const\n      {\n if (!_M_fill_init)\n   {\n     _M_fill = this->widen(' ');\n     _M_fill_init = true;\n   }\n return _M_"
[#] parse_declaration, is_constructor=False, meet line: 'char_type\n      fill() const\n      {\n if (!_M_fill_init)\n   {\n     _M_fill = this->widen(\' \');\n     _M_fill_init = true;\n   }\n return _M_fill;\n      }\n# 389 "/usr/include/c++/7/bits/basic_ios.h" 3\n   '
[#] parse_declaration, is_constructor=False, meet line: 'char_type\n      fill(char_type __ch)\n      {\n char_type __old = this->fill();\n _M_fill = __ch;\n return __old;\n      }\n# 409 "/usr/include/c++/7/bits/basic_ios.h" 3\n      locale\n      imbue(const local'
[#] parse_declaration, is_constructor=False, meet line: 'locale\n      imbue(const locale& __loc);\n# 429 "/usr/include/c++/7/bits/basic_ios.h" 3\n      char\n      narrow(char_type __c, char __dfault) const\n      { return __check_facet(_M_ctype).narrow(__c, __'
[#] parse_declaration, is_constructor=False, meet line: 'char\n      narrow(char_type __c, char __dfault) const\n      { return __check_facet(_M_ctype).narrow(__c, __dfault); }\n# 448 "/usr/include/c++/7/bits/basic_ios.h" 3\n      char_type\n      widen(char __c'
[#] parse_declaration, is_constructor=False, meet line: 'char_type\n      widen(char __c) const\n      { return __check_facet(_M_ctype).widen(__c); }\n\n    protected:\n\n\n\n\n\n\n\n      basic_ios()\n      : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(fa'
[#] parse_declaration, is_constructor=True, meet line: 'basic_ios()\n      : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false),\n _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)\n      { }\n\n\n\n\n\n\n\n      void\n      init(basic_streambuf'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      init(basic_streambuf<_CharT, _Traits>* __sb);\n\n\n      basic_ios(const basic_ios&) = delete;\n      basic_ios& operator=(const basic_ios&) = delete;\n\n      void\n      move(basic_ios& __rhs)\n '
[#] parse_declaration, is_constructor=True, meet line: 'basic_ios(const basic_ios&) = delete;\n      basic_ios& operator=(const basic_ios&) = delete;\n\n      void\n      move(basic_ios& __rhs)\n      {\n ios_base::_M_move(__rhs);\n _M_cache_locale(_M_ios_locale)'
[#] parse_declaration, is_constructor=True, meet line: 'basic_ios& operator=(const basic_ios&) = delete;\n\n      void\n      move(basic_ios& __rhs)\n      {\n ios_base::_M_move(__rhs);\n _M_cache_locale(_M_ios_locale);\n this->tie(__rhs.tie(nullptr));\n _M_fill ='
[#] parse_declaration, is_constructor=False, meet line: 'void\n      move(basic_ios& __rhs)\n      {\n ios_base::_M_move(__rhs);\n _M_cache_locale(_M_ios_locale);\n this->tie(__rhs.tie(nullptr));\n _M_fill = __rhs._M_fill;\n _M_fill_init = __rhs._M_fill_init;\n _M_'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      move(basic_ios&& __rhs)\n      { this->move(__rhs); }\n\n      void\n      swap(basic_ios& __rhs) noexcept\n      {\n ios_base::_M_swap(__rhs);\n _M_cache_locale(_M_ios_locale);\n __rhs._M_cache_lo'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      swap(basic_ios& __rhs) noexcept\n      {\n ios_base::_M_swap(__rhs);\n _M_cache_locale(_M_ios_locale);\n __rhs._M_cache_locale(__rhs._M_ios_locale);\n std::swap(_M_tie, __rhs._M_tie);\n std::swap'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      set_rdbuf(basic_streambuf<_CharT, _Traits>* __sb)\n      { _M_streambuf = __sb; }\n\n\n      void\n      _M_cache_locale(const locale& __loc);\n    };\n\n\n}\n\n# 1 "/usr/include/c++/7/bits/basic_ios.'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_cache_locale(const locale& __loc);\n    };\n\n\n}\n\n# 1 "/usr/include/c++/7/bits/basic_ios.tcc" 1 3\n# 33 "/usr/include/c++/7/bits/basic_ios.tcc" 3\n       \n# 34 "/usr/include/c++/7/bits/basic_'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    basic_ios<_CharT, _Traits>::clear(iostate __state)\n    {\n      if (this->rdbuf())\n _M_streambuf_state = __state;\n      else\n   _M_streambuf_state = __state | badbit;\n      if (this->exception'
[#] parse_declaration, is_constructor=False, meet line: 'basic_streambuf<_CharT, _Traits>*\n    basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits>* __sb)\n    {\n      basic_streambuf<_CharT, _Traits>* __old = _M_streambuf;\n      _M_streambuf ='
[#] parse_declaration, is_constructor=False, meet line: 'basic_ios<_CharT, _Traits>&\n    basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)\n    {\n\n\n      if (this != &__rhs)\n {\n\n\n\n\n   _Words* __words = (__rhs._M_word_size <= _S_local_word_size) ?\n '
[#] parse_declaration, is_constructor=False, meet line: 'locale\n    basic_ios<_CharT, _Traits>::imbue(const locale& __loc)\n    {\n      locale __old(this->getloc());\n      ios_base::imbue(__loc);\n      _M_cache_locale(__loc);\n      if (this->rdbuf() != 0)\n t'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits>* __sb)\n    {\n\n      ios_base::_M_init();\n\n\n      _M_cache_locale(_M_ios_locale);\n# 146 "/usr/include/c++/7/bits/basic_ios.tcc'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    basic_ios<_CharT, _Traits>::_M_cache_locale(const locale& __loc)\n    {\n      if (__builtin_expect(has_facet<__ctype_type>(__loc), true))\n _M_ctype = std::__addressof(use_facet<__ctype_type>(_'
[#] parse_declaration, is_constructor=False, meet line: 'template class basic_ios<char>;\n\n\n  extern template class basic_ios<wchar_t>;\n\n\n\n\n}\n# 517 "/usr/include/c++/7/bits/basic_ios.h" 2 3\n# 45 "/usr/include/c++/7/ios" 2 3\n# 39 "/usr/include/c++/7/ostream" '
[#] parse_declaration, is_constructor=False, meet line: 'template class basic_ios<wchar_t>;\n\n\n\n\n}\n# 517 "/usr/include/c++/7/bits/basic_ios.h" 2 3\n# 45 "/usr/include/c++/7/ios" 2 3\n# 39 "/usr/include/c++/7/ostream" 2 3\n\n\nnamespace std __attribute__ ((__visib'
[#] parse_declaration, is_constructor=True, meet line: 'basic_ostream(__streambuf_type* __sb)\n      { this->init(__sb); }\n\n\n\n\n\n\n      virtual\n      ~basic_ostream() { }\n\n\n      class sentry;\n      friend class sentry;\n# 107 "/usr/include/c++/7/ostream" 3\n '
[#] parse_declaration, is_constructor=True, meet line: 'basic_ostream() { }\n\n\n      class sentry;\n      friend class sentry;\n# 107 "/usr/include/c++/7/ostream" 3\n      __ostream_type&\n      operator<<(__ostream_type& (*__pf)(__ostream_type&))\n      {\n\n\n\n r'
[#] parse_declaration, is_constructor=False, meet line: '__ostream_type&\n      operator<<(__ostream_type& (*__pf)(__ostream_type&))\n      {\n\n\n\n return __pf(*this);\n      }\n\n      __ostream_type&\n      operator<<(__ios_type& (*__pf)(__ios_type&))\n      {\n\n\n\n'
[#] parse_declaration, is_constructor=False, meet line: '__ostream_type&\n      operator<<(__ios_type& (*__pf)(__ios_type&))\n      {\n\n\n\n __pf(*this);\n return *this;\n      }\n\n      __ostream_type&\n      operator<<(ios_base& (*__pf) (ios_base&))\n      {\n\n\n\n __'
[#] parse_declaration, is_constructor=False, meet line: '__ostream_type&\n      operator<<(ios_base& (*__pf) (ios_base&))\n      {\n\n\n\n __pf(*this);\n return *this;\n      }\n# 165 "/usr/include/c++/7/ostream" 3\n      __ostream_type&\n      operator<<(long __n)\n  '
[#] parse_declaration, is_constructor=False, meet line: '__ostream_type&\n      operator<<(long __n)\n      { return _M_insert(__n); }\n\n      __ostream_type&\n      operator<<(unsigned long __n)\n      { return _M_insert(__n); }\n\n      __ostream_type&\n      ope'
[#] parse_declaration, is_constructor=False, meet line: '__ostream_type&\n      operator<<(unsigned long __n)\n      { return _M_insert(__n); }\n\n      __ostream_type&\n      operator<<(bool __n)\n      { return _M_insert(__n); }\n\n      __ostream_type&\n      ope'
[#] parse_declaration, is_constructor=False, meet line: '__ostream_type&\n      operator<<(bool __n)\n      { return _M_insert(__n); }\n\n      __ostream_type&\n      operator<<(short __n);\n\n      __ostream_type&\n      operator<<(unsigned short __n)\n      {\n\n\n r'
[#] parse_declaration, is_constructor=False, meet line: '__ostream_type&\n      operator<<(short __n);\n\n      __ostream_type&\n      operator<<(unsigned short __n)\n      {\n\n\n return _M_insert(static_cast<unsigned long>(__n));\n      }\n\n      __ostream_type&\n  '
[#] parse_declaration, is_constructor=False, meet line: '__ostream_type&\n      operator<<(unsigned short __n)\n      {\n\n\n return _M_insert(static_cast<unsigned long>(__n));\n      }\n\n      __ostream_type&\n      operator<<(int __n);\n\n      __ostream_type&\n    '
[#] parse_declaration, is_constructor=False, meet line: '__ostream_type&\n      operator<<(int __n);\n\n      __ostream_type&\n      operator<<(unsigned int __n)\n      {\n\n\n return _M_insert(static_cast<unsigned long>(__n));\n      }\n\n\n      __ostream_type&\n     '
[#] parse_declaration, is_constructor=False, meet line: '__ostream_type&\n      operator<<(unsigned int __n)\n      {\n\n\n return _M_insert(static_cast<unsigned long>(__n));\n      }\n\n\n      __ostream_type&\n      operator<<(long long __n)\n      { return _M_inser'
[#] parse_declaration, is_constructor=False, meet line: '__ostream_type&\n      operator<<(long long __n)\n      { return _M_insert(__n); }\n\n      __ostream_type&\n      operator<<(unsigned long long __n)\n      { return _M_insert(__n); }\n# 219 "/usr/include/c+'
[#] parse_declaration, is_constructor=False, meet line: '__ostream_type&\n      operator<<(unsigned long long __n)\n      { return _M_insert(__n); }\n# 219 "/usr/include/c++/7/ostream" 3\n      __ostream_type&\n      operator<<(double __f)\n      { return _M_inse'
[#] parse_declaration, is_constructor=False, meet line: '__ostream_type&\n      operator<<(double __f)\n      { return _M_insert(__f); }\n\n      __ostream_type&\n      operator<<(float __f)\n      {\n\n\n return _M_insert(static_cast<double>(__f));\n      }\n\n      _'
[#] parse_declaration, is_constructor=False, meet line: '__ostream_type&\n      operator<<(float __f)\n      {\n\n\n return _M_insert(static_cast<double>(__f));\n      }\n\n      __ostream_type&\n      operator<<(long double __f)\n      { return _M_insert(__f); }\n# 2'
[#] parse_declaration, is_constructor=False, meet line: '__ostream_type&\n      operator<<(long double __f)\n      { return _M_insert(__f); }\n# 244 "/usr/include/c++/7/ostream" 3\n      __ostream_type&\n      operator<<(const void* __p)\n      { return _M_insert'
[#] parse_declaration, is_constructor=False, meet line: '__ostream_type&\n      operator<<(const void* __p)\n      { return _M_insert(__p); }\n# 269 "/usr/include/c++/7/ostream" 3\n      __ostream_type&\n      operator<<(__streambuf_type* __sb);\n# 302 "/usr/incl'
[#] parse_declaration, is_constructor=False, meet line: '__ostream_type&\n      operator<<(__streambuf_type* __sb);\n# 302 "/usr/include/c++/7/ostream" 3\n      __ostream_type&\n      put(char_type __c);\n\n\n\n\n\n\n      void\n      _M_write(const char_type* __s, str'
[#] parse_declaration, is_constructor=False, meet line: '__ostream_type&\n      put(char_type __c);\n\n\n\n\n\n\n      void\n      _M_write(const char_type* __s, streamsize __n)\n      {\n const streamsize __put = this->rdbuf()->sputn(__s, __n);\n if (__put != __n)\n   '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_write(const char_type* __s, streamsize __n)\n      {\n const streamsize __put = this->rdbuf()->sputn(__s, __n);\n if (__put != __n)\n   this->setstate(ios_base::badbit);\n      }\n# 334 "/usr/'
[#] parse_declaration, is_constructor=False, meet line: '__ostream_type&\n      write(const char_type* __s, streamsize __n);\n# 347 "/usr/include/c++/7/ostream" 3\n      __ostream_type&\n      flush();\n# 357 "/usr/include/c++/7/ostream" 3\n      pos_type\n      t'
[#] parse_declaration, is_constructor=False, meet line: '__ostream_type&\n      flush();\n# 357 "/usr/include/c++/7/ostream" 3\n      pos_type\n      tellp();\n# 368 "/usr/include/c++/7/ostream" 3\n      __ostream_type&\n      seekp(pos_type);\n# 380 "/usr/include/'
[#] parse_declaration, is_constructor=False, meet line: 'pos_type\n      tellp();\n# 368 "/usr/include/c++/7/ostream" 3\n      __ostream_type&\n      seekp(pos_type);\n# 380 "/usr/include/c++/7/ostream" 3\n       __ostream_type&\n      seekp(off_type, ios_base::se'
[#] parse_declaration, is_constructor=False, meet line: '__ostream_type&\n      seekp(pos_type);\n# 380 "/usr/include/c++/7/ostream" 3\n       __ostream_type&\n      seekp(off_type, ios_base::seekdir);\n\n    protected:\n      basic_ostream()\n      { this->init(0)'
[#] parse_declaration, is_constructor=False, meet line: '__ostream_type&\n      seekp(off_type, ios_base::seekdir);\n\n    protected:\n      basic_ostream()\n      { this->init(0); }\n\n\n\n      basic_ostream(basic_iostream<_CharT, _Traits>&) { }\n\n      basic_ostre'
[#] parse_declaration, is_constructor=True, meet line: 'basic_ostream()\n      { this->init(0); }\n\n\n\n      basic_ostream(basic_iostream<_CharT, _Traits>&) { }\n\n      basic_ostream(const basic_ostream&) = delete;\n\n      basic_ostream(basic_ostream&& __rhs)\n '
[#] parse_declaration, is_constructor=True, meet line: 'basic_ostream(basic_iostream<_CharT, _Traits>&) { }\n\n      basic_ostream(const basic_ostream&) = delete;\n\n      basic_ostream(basic_ostream&& __rhs)\n      : __ios_type()\n      { __ios_type::move(__rhs'
[#] parse_declaration, is_constructor=True, meet line: 'basic_ostream(const basic_ostream&) = delete;\n\n      basic_ostream(basic_ostream&& __rhs)\n      : __ios_type()\n      { __ios_type::move(__rhs); }\n\n\n\n      basic_ostream& operator=(const basic_ostream&'
[#] parse_declaration, is_constructor=True, meet line: 'basic_ostream(basic_ostream&& __rhs)\n      : __ios_type()\n      { __ios_type::move(__rhs); }\n\n\n\n      basic_ostream& operator=(const basic_ostream&) = delete;\n\n      basic_ostream&\n      operator=(bas'
[#] parse_declaration, is_constructor=True, meet line: 'basic_ostream& operator=(const basic_ostream&) = delete;\n\n      basic_ostream&\n      operator=(basic_ostream&& __rhs)\n      {\n swap(__rhs);\n return *this;\n      }\n\n      void\n      swap(basic_ostream&'
[#] parse_declaration, is_constructor=True, meet line: 'basic_ostream&\n      operator=(basic_ostream&& __rhs)\n      {\n swap(__rhs);\n return *this;\n      }\n\n      void\n      swap(basic_ostream& __rhs)\n      { __ios_type::swap(__rhs); }\n\n\n      template<type'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      swap(basic_ostream& __rhs)\n      { __ios_type::swap(__rhs); }\n\n\n      template<typename _ValueT>\n __ostream_type&\n _M_insert(_ValueT __v);\n    };\n# 425 "/usr/include/c++/7/ostream" 3\n  temp'
[#] parse_declaration, is_constructor=False, meet line: '__ostream_type&\n _M_insert(_ValueT __v);\n    };\n# 425 "/usr/include/c++/7/ostream" 3\n  template <typename _CharT, typename _Traits>\n    class basic_ostream<_CharT, _Traits>::sentry\n    {\n\n      bool _'
[#] parse_declaration, is_constructor=False, meet line: 'bool _M_ok;\n      basic_ostream<_CharT, _Traits>& _M_os;\n\n    public:\n# 444 "/usr/include/c++/7/ostream" 3\n      explicit\n      sentry(basic_ostream<_CharT, _Traits>& __os);\n# 454 "/usr/include/c++/7/'
[#] parse_declaration, is_constructor=True, meet line: 'basic_ostream<_CharT, _Traits>& _M_os;\n\n    public:\n# 444 "/usr/include/c++/7/ostream" 3\n      explicit\n      sentry(basic_ostream<_CharT, _Traits>& __os);\n# 454 "/usr/include/c++/7/ostream" 3\n      ~'
[#] parse_declaration, is_constructor=False, meet line: 'sentry(basic_ostream<_CharT, _Traits>& __os);\n# 454 "/usr/include/c++/7/ostream" 3\n      ~sentry()\n      {\n\n if (bool(_M_os.flags() & ios_base::unitbuf) && !uncaught_exception())\n   {\n\n     if (_M_os.'
[#] parse_declaration, is_constructor=False, meet line: 'sentry()\n      {\n\n if (bool(_M_os.flags() & ios_base::unitbuf) && !uncaught_exception())\n   {\n\n     if (_M_os.rdbuf() && _M_os.rdbuf()->pubsync() == -1)\n       _M_os.setstate(ios_base::badbit);\n   }\n '
[#] parse_declaration, is_constructor=False, meet line: 'operator bool() const\n      { return _M_ok; }\n    };\n# 495 "/usr/include/c++/7/ostream" 3\n  template<typename _CharT, typename _Traits>\n    inline basic_ostream<_CharT, _Traits>&\n    operator<<(basic_'
[#] parse_declaration, is_constructor=False, meet line: 'basic_ostream<_CharT, _Traits>&\n    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c)\n    { return __ostream_insert(__out, &__c, 1); }\n\n  template<typename _CharT, typename _Traits>\n    in'
[#] parse_declaration, is_constructor=False, meet line: 'basic_ostream<_CharT, _Traits>&\n    operator<<(basic_ostream<_CharT, _Traits>& __out, char __c)\n    { return (__out << __out.widen(__c)); }\n\n\n  template <class _Traits>\n    inline basic_ostream<char, '
[#] parse_declaration, is_constructor=False, meet line: 'basic_ostream<char, _Traits>&\n    operator<<(basic_ostream<char, _Traits>& __out, char __c)\n    { return __ostream_insert(__out, &__c, 1); }\n\n\n  template<class _Traits>\n    inline basic_ostream<char, '
[#] parse_declaration, is_constructor=False, meet line: 'basic_ostream<char, _Traits>&\n    operator<<(basic_ostream<char, _Traits>& __out, signed char __c)\n    { return (__out << static_cast<char>(__c)); }\n\n  template<class _Traits>\n    inline basic_ostream'
[#] parse_declaration, is_constructor=False, meet line: 'basic_ostream<char, _Traits>&\n    operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)\n    { return (__out << static_cast<char>(__c)); }\n# 537 "/usr/include/c++/7/ostream" 3\n  template<t'
[#] parse_declaration, is_constructor=False, meet line: 'basic_ostream<_CharT, _Traits>&\n    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s)\n    {\n      if (!__s)\n __out.setstate(ios_base::badbit);\n      else\n __ostream_insert(__out, __'
[#] parse_declaration, is_constructor=False, meet line: 'basic_ostream<_CharT, _Traits> &\n    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s);\n\n\n  template<class _Traits>\n    inline basic_ostream<char, _Traits>&\n    operator<<(basic_ostre'
[#] parse_declaration, is_constructor=False, meet line: 'basic_ostream<char, _Traits>&\n    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)\n    {\n      if (!__s)\n __out.setstate(ios_base::badbit);\n      else\n __ostream_insert(__out, __s,\n   '
[#] parse_declaration, is_constructor=False, meet line: 'basic_ostream<char, _Traits>&\n    operator<<(basic_ostream<char, _Traits>& __out, const signed char* __s)\n    { return (__out << reinterpret_cast<const char*>(__s)); }\n\n  template<class _Traits>\n    i'
[#] parse_declaration, is_constructor=False, meet line: 'basic_ostream<char, _Traits> &\n    operator<<(basic_ostream<char, _Traits>& __out, const unsigned char* __s)\n    { return (__out << reinterpret_cast<const char*>(__s)); }\n# 588 "/usr/include/c++/7/ost'
[#] parse_declaration, is_constructor=False, meet line: 'basic_ostream<_CharT, _Traits>&\n    endl(basic_ostream<_CharT, _Traits>& __os)\n    { return flush(__os.put(__os.widen(\'\\n\'))); }\n# 600 "/usr/include/c++/7/ostream" 3\n  template<typename _CharT, typena'
[#] parse_declaration, is_constructor=False, meet line: 'basic_ostream<_CharT, _Traits>&\n    ends(basic_ostream<_CharT, _Traits>& __os)\n    { return __os.put(_CharT()); }\n\n\n\n\n\n\n  template<typename _CharT, typename _Traits>\n    inline basic_ostream<_CharT, _'
[#] parse_declaration, is_constructor=False, meet line: 'basic_ostream<_CharT, _Traits>&\n    flush(basic_ostream<_CharT, _Traits>& __os)\n    { return __os.flush(); }\n\n\n  template<typename _Ch, typename _Up>\n    basic_ostream<_Ch, _Up>&\n    __is_convertible_'
[#] parse_declaration, is_constructor=False, meet line: 'basic_ostream<_Ch, _Up>&\n    __is_convertible_to_basic_ostream_test(basic_ostream<_Ch, _Up>*);\n\n  template<typename _Tp, typename = void>\n    struct __is_convertible_to_basic_ostream_impl\n    {\n      '
[#] parse_declaration, is_constructor=False, meet line: 'bool value = type::value;\n    };\n\n  template<typename _Ostream, typename _Tp, typename = void>\n    struct __is_insertable : false_type {};\n\n  template<typename _Ostream, typename _Tp>\n    struct __is_'
[#] parse_declaration, is_constructor=False, meet line: 'enable_if<__and_<__not_<is_lvalue_reference<_Ostream>>,\n         __is_convertible_to_basic_ostream<_Ostream>,\n         __is_insertable<\n    __rvalue_ostream_type<_Ostream>,\n    const _Tp&>>::value,\n  '
[#] parse_declaration, is_constructor=False, meet line: 'basic_ostream<_CharT, _Traits>::sentry::\n    sentry(basic_ostream<_CharT, _Traits>& __os)\n    : _M_ok(false), _M_os(__os)\n    {\n\n      if (__os.tie() && __os.good())\n __os.tie()->flush();\n\n      if (_'
[#] parse_declaration, is_constructor=False, meet line: 'basic_ostream<_CharT, _Traits>&\n      basic_ostream<_CharT, _Traits>::\n      _M_insert(_ValueT __v)\n      {\n sentry __cerb(*this);\n if (__cerb)\n   {\n     ios_base::iostate __err = ios_base::goodbit;\n '
[#] parse_declaration, is_constructor=False, meet line: 'basic_ostream<_CharT, _Traits>&\n    basic_ostream<_CharT, _Traits>::\n    operator<<(short __n)\n    {\n\n\n      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;\n      if (__fmt == io'
[#] parse_declaration, is_constructor=False, meet line: 'basic_ostream<_CharT, _Traits>&\n    basic_ostream<_CharT, _Traits>::\n    operator<<(int __n)\n    {\n\n\n      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;\n      if (__fmt == ios_'
[#] parse_declaration, is_constructor=False, meet line: 'basic_ostream<_CharT, _Traits>&\n    basic_ostream<_CharT, _Traits>::\n    operator<<(__streambuf_type* __sbin)\n    {\n      ios_base::iostate __err = ios_base::goodbit;\n      sentry __cerb(*this);\n     '
[#] parse_declaration, is_constructor=False, meet line: 'basic_ostream<_CharT, _Traits>&\n    basic_ostream<_CharT, _Traits>::\n    put(char_type __c)\n    {\n\n\n\n\n\n\n      sentry __cerb(*this);\n      if (__cerb)\n {\n   ios_base::iostate __err = ios_base::goodbit;'
[#] parse_declaration, is_constructor=False, meet line: 'basic_ostream<_CharT, _Traits>&\n    basic_ostream<_CharT, _Traits>::\n    write(const _CharT* __s, streamsize __n)\n    {\n\n\n\n\n\n\n\n      sentry __cerb(*this);\n      if (__cerb)\n {\n   try\n     { _M_write(_'
[#] parse_declaration, is_constructor=False, meet line: 'basic_ostream<_CharT, _Traits>&\n    basic_ostream<_CharT, _Traits>::\n    flush()\n    {\n\n\n\n      ios_base::iostate __err = ios_base::goodbit;\n      try\n {\n   if (this->rdbuf() && this->rdbuf()->pubsync'
[#] parse_declaration, is_constructor=False, meet line: 'basic_ostream<_CharT, _Traits>::pos_type\n    basic_ostream<_CharT, _Traits>::\n    tellp()\n    {\n      pos_type __ret = pos_type(-1);\n      try\n {\n   if (!this->fail())\n     __ret = this->rdbuf()->pubs'
[#] parse_declaration, is_constructor=False, meet line: 'basic_ostream<_CharT, _Traits>&\n    basic_ostream<_CharT, _Traits>::\n    seekp(pos_type __pos)\n    {\n      ios_base::iostate __err = ios_base::goodbit;\n      try\n {\n   if (!this->fail())\n     {\n\n\n    '
[#] parse_declaration, is_constructor=False, meet line: 'basic_ostream<_CharT, _Traits>&\n    basic_ostream<_CharT, _Traits>::\n    seekp(off_type __off, ios_base::seekdir __dir)\n    {\n      ios_base::iostate __err = ios_base::goodbit;\n      try\n {\n   if (!th'
[#] parse_declaration, is_constructor=False, meet line: 'basic_ostream<_CharT, _Traits>&\n    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s)\n    {\n      if (!__s)\n __out.setstate(ios_base::badbit);\n      else\n {\n\n\n   const size_t __clen ='
[#] parse_declaration, is_constructor=False, meet line: 'template class basic_ostream<char>;\n  extern template ostream& endl(ostream&);\n  extern template ostream& ends(ostream&);\n  extern template ostream& flush(ostream&);\n  extern template ostream& operato'
[#] parse_declaration, is_constructor=False, meet line: 'template ostream& endl(ostream&);\n  extern template ostream& ends(ostream&);\n  extern template ostream& flush(ostream&);\n  extern template ostream& operator<<(ostream&, char);\n  extern template ostrea'
[#] parse_declaration, is_constructor=False, meet line: 'template ostream& ends(ostream&);\n  extern template ostream& flush(ostream&);\n  extern template ostream& operator<<(ostream&, char);\n  extern template ostream& operator<<(ostream&, unsigned char);\n  e'
[#] parse_declaration, is_constructor=False, meet line: 'template ostream& flush(ostream&);\n  extern template ostream& operator<<(ostream&, char);\n  extern template ostream& operator<<(ostream&, unsigned char);\n  extern template ostream& operator<<(ostream&'
[#] parse_declaration, is_constructor=False, meet line: 'template ostream& operator<<(ostream&, char);\n  extern template ostream& operator<<(ostream&, unsigned char);\n  extern template ostream& operator<<(ostream&, signed char);\n  extern template ostream& o'
[#] parse_declaration, is_constructor=False, meet line: 'template ostream& operator<<(ostream&, unsigned char);\n  extern template ostream& operator<<(ostream&, signed char);\n  extern template ostream& operator<<(ostream&, const char*);\n  extern template ost'
[#] parse_declaration, is_constructor=False, meet line: 'template ostream& operator<<(ostream&, signed char);\n  extern template ostream& operator<<(ostream&, const char*);\n  extern template ostream& operator<<(ostream&, const unsigned char*);\n  extern templ'
[#] parse_declaration, is_constructor=False, meet line: 'template ostream& operator<<(ostream&, const char*);\n  extern template ostream& operator<<(ostream&, const unsigned char*);\n  extern template ostream& operator<<(ostream&, const signed char*);\n\n  exte'
[#] parse_declaration, is_constructor=False, meet line: 'template ostream& operator<<(ostream&, const unsigned char*);\n  extern template ostream& operator<<(ostream&, const signed char*);\n\n  extern template ostream& ostream::_M_insert(long);\n  extern templa'
[#] parse_declaration, is_constructor=False, meet line: 'template ostream& operator<<(ostream&, const signed char*);\n\n  extern template ostream& ostream::_M_insert(long);\n  extern template ostream& ostream::_M_insert(unsigned long);\n  extern template ostrea'
[#] parse_declaration, is_constructor=False, meet line: 'template ostream& ostream::_M_insert(long);\n  extern template ostream& ostream::_M_insert(unsigned long);\n  extern template ostream& ostream::_M_insert(bool);\n\n  extern template ostream& ostream::_M_i'
[#] parse_declaration, is_constructor=False, meet line: 'template ostream& ostream::_M_insert(unsigned long);\n  extern template ostream& ostream::_M_insert(bool);\n\n  extern template ostream& ostream::_M_insert(long long);\n  extern template ostream& ostream:'
[#] parse_declaration, is_constructor=False, meet line: 'template ostream& ostream::_M_insert(bool);\n\n  extern template ostream& ostream::_M_insert(long long);\n  extern template ostream& ostream::_M_insert(unsigned long long);\n\n  extern template ostream& os'
[#] parse_declaration, is_constructor=False, meet line: 'template ostream& ostream::_M_insert(long long);\n  extern template ostream& ostream::_M_insert(unsigned long long);\n\n  extern template ostream& ostream::_M_insert(double);\n  extern template ostream& o'
[#] parse_declaration, is_constructor=False, meet line: 'template ostream& ostream::_M_insert(unsigned long long);\n\n  extern template ostream& ostream::_M_insert(double);\n  extern template ostream& ostream::_M_insert(long double);\n  extern template ostream&'
[#] parse_declaration, is_constructor=False, meet line: 'template ostream& ostream::_M_insert(double);\n  extern template ostream& ostream::_M_insert(long double);\n  extern template ostream& ostream::_M_insert(const void*);\n\n\n  extern template class basic_os'
[#] parse_declaration, is_constructor=False, meet line: 'template ostream& ostream::_M_insert(long double);\n  extern template ostream& ostream::_M_insert(const void*);\n\n\n  extern template class basic_ostream<wchar_t>;\n  extern template wostream& endl(wostre'
[#] parse_declaration, is_constructor=False, meet line: 'template ostream& ostream::_M_insert(const void*);\n\n\n  extern template class basic_ostream<wchar_t>;\n  extern template wostream& endl(wostream&);\n  extern template wostream& ends(wostream&);\n  extern '
[#] parse_declaration, is_constructor=False, meet line: 'template class basic_ostream<wchar_t>;\n  extern template wostream& endl(wostream&);\n  extern template wostream& ends(wostream&);\n  extern template wostream& flush(wostream&);\n  extern template wostrea'
[#] parse_declaration, is_constructor=False, meet line: 'template wostream& endl(wostream&);\n  extern template wostream& ends(wostream&);\n  extern template wostream& flush(wostream&);\n  extern template wostream& operator<<(wostream&, wchar_t);\n  extern temp'
[#] parse_declaration, is_constructor=False, meet line: 'template wostream& ends(wostream&);\n  extern template wostream& flush(wostream&);\n  extern template wostream& operator<<(wostream&, wchar_t);\n  extern template wostream& operator<<(wostream&, char);\n '
[#] parse_declaration, is_constructor=False, meet line: 'template wostream& flush(wostream&);\n  extern template wostream& operator<<(wostream&, wchar_t);\n  extern template wostream& operator<<(wostream&, char);\n  extern template wostream& operator<<(wostrea'
[#] parse_declaration, is_constructor=False, meet line: 'template wostream& operator<<(wostream&, wchar_t);\n  extern template wostream& operator<<(wostream&, char);\n  extern template wostream& operator<<(wostream&, const wchar_t*);\n  extern template wostrea'
[#] parse_declaration, is_constructor=False, meet line: 'template wostream& operator<<(wostream&, char);\n  extern template wostream& operator<<(wostream&, const wchar_t*);\n  extern template wostream& operator<<(wostream&, const char*);\n\n  extern template wo'
[#] parse_declaration, is_constructor=False, meet line: 'template wostream& operator<<(wostream&, const wchar_t*);\n  extern template wostream& operator<<(wostream&, const char*);\n\n  extern template wostream& wostream::_M_insert(long);\n  extern template wost'
[#] parse_declaration, is_constructor=False, meet line: 'template wostream& operator<<(wostream&, const char*);\n\n  extern template wostream& wostream::_M_insert(long);\n  extern template wostream& wostream::_M_insert(unsigned long);\n  extern template wostrea'
[#] parse_declaration, is_constructor=False, meet line: 'template wostream& wostream::_M_insert(long);\n  extern template wostream& wostream::_M_insert(unsigned long);\n  extern template wostream& wostream::_M_insert(bool);\n\n  extern template wostream& wostre'
[#] parse_declaration, is_constructor=False, meet line: 'template wostream& wostream::_M_insert(unsigned long);\n  extern template wostream& wostream::_M_insert(bool);\n\n  extern template wostream& wostream::_M_insert(long long);\n  extern template wostream& w'
[#] parse_declaration, is_constructor=False, meet line: 'template wostream& wostream::_M_insert(bool);\n\n  extern template wostream& wostream::_M_insert(long long);\n  extern template wostream& wostream::_M_insert(unsigned long long);\n\n  extern template wostr'
[#] parse_declaration, is_constructor=False, meet line: 'template wostream& wostream::_M_insert(long long);\n  extern template wostream& wostream::_M_insert(unsigned long long);\n\n  extern template wostream& wostream::_M_insert(double);\n  extern template wost'
[#] parse_declaration, is_constructor=False, meet line: 'template wostream& wostream::_M_insert(unsigned long long);\n\n  extern template wostream& wostream::_M_insert(double);\n  extern template wostream& wostream::_M_insert(long double);\n  extern template wo'
[#] parse_declaration, is_constructor=False, meet line: 'template wostream& wostream::_M_insert(double);\n  extern template wostream& wostream::_M_insert(long double);\n  extern template wostream& wostream::_M_insert(const void*);\n\n\n\n\n}\n# 694 "/usr/include/c+'
[#] parse_declaration, is_constructor=False, meet line: 'template wostream& wostream::_M_insert(long double);\n  extern template wostream& wostream::_M_insert(const void*);\n\n\n\n\n}\n# 694 "/usr/include/c++/7/ostream" 2 3\n# 65 "/usr/include/c++/7/iterator" 2 3\n#'
[#] parse_declaration, is_constructor=False, meet line: 'template wostream& wostream::_M_insert(const void*);\n\n\n\n\n}\n# 694 "/usr/include/c++/7/ostream" 2 3\n# 65 "/usr/include/c++/7/iterator" 2 3\n# 1 "/usr/include/c++/7/istream" 1 3\n# 36 "/usr/include/c++/7/i'
[#] parse_declaration, is_constructor=False, meet line: 'streamsize _M_gcount;\n\n    public:\n\n\n\n\n\n\n\n      explicit\n      basic_istream(__streambuf_type* __sb)\n      : _M_gcount(streamsize(0))\n      { this->init(__sb); }\n\n\n\n\n\n\n      virtual\n      ~basic_istre'
[#] parse_declaration, is_constructor=True, meet line: 'basic_istream(__streambuf_type* __sb)\n      : _M_gcount(streamsize(0))\n      { this->init(__sb); }\n\n\n\n\n\n\n      virtual\n      ~basic_istream()\n      { _M_gcount = streamsize(0); }\n\n\n      class sentry;'
[#] parse_declaration, is_constructor=True, meet line: 'basic_istream()\n      { _M_gcount = streamsize(0); }\n\n\n      class sentry;\n      friend class sentry;\n# 119 "/usr/include/c++/7/istream" 3\n      __istream_type&\n      operator>>(__istream_type& (*__pf'
[#] parse_declaration, is_constructor=False, meet line: '__istream_type&\n      operator>>(__istream_type& (*__pf)(__istream_type&))\n      { return __pf(*this); }\n\n      __istream_type&\n      operator>>(__ios_type& (*__pf)(__ios_type&))\n      {\n __pf(*this);'
[#] parse_declaration, is_constructor=False, meet line: '__istream_type&\n      operator>>(__ios_type& (*__pf)(__ios_type&))\n      {\n __pf(*this);\n return *this;\n      }\n\n      __istream_type&\n      operator>>(ios_base& (*__pf)(ios_base&))\n      {\n __pf(*thi'
[#] parse_declaration, is_constructor=False, meet line: '__istream_type&\n      operator>>(ios_base& (*__pf)(ios_base&))\n      {\n __pf(*this);\n return *this;\n      }\n# 167 "/usr/include/c++/7/istream" 3\n      __istream_type&\n      operator>>(bool& __n)\n     '
[#] parse_declaration, is_constructor=False, meet line: '__istream_type&\n      operator>>(bool& __n)\n      { return _M_extract(__n); }\n\n      __istream_type&\n      operator>>(short& __n);\n\n      __istream_type&\n      operator>>(unsigned short& __n)\n      { '
[#] parse_declaration, is_constructor=False, meet line: '__istream_type&\n      operator>>(short& __n);\n\n      __istream_type&\n      operator>>(unsigned short& __n)\n      { return _M_extract(__n); }\n\n      __istream_type&\n      operator>>(int& __n);\n\n      _'
[#] parse_declaration, is_constructor=False, meet line: '__istream_type&\n      operator>>(unsigned short& __n)\n      { return _M_extract(__n); }\n\n      __istream_type&\n      operator>>(int& __n);\n\n      __istream_type&\n      operator>>(unsigned int& __n)\n  '
[#] parse_declaration, is_constructor=False, meet line: '__istream_type&\n      operator>>(int& __n);\n\n      __istream_type&\n      operator>>(unsigned int& __n)\n      { return _M_extract(__n); }\n\n      __istream_type&\n      operator>>(long& __n)\n      { retu'
[#] parse_declaration, is_constructor=False, meet line: '__istream_type&\n      operator>>(unsigned int& __n)\n      { return _M_extract(__n); }\n\n      __istream_type&\n      operator>>(long& __n)\n      { return _M_extract(__n); }\n\n      __istream_type&\n      '
[#] parse_declaration, is_constructor=False, meet line: '__istream_type&\n      operator>>(long& __n)\n      { return _M_extract(__n); }\n\n      __istream_type&\n      operator>>(unsigned long& __n)\n      { return _M_extract(__n); }\n\n\n      __istream_type&\n    '
[#] parse_declaration, is_constructor=False, meet line: '__istream_type&\n      operator>>(unsigned long& __n)\n      { return _M_extract(__n); }\n\n\n      __istream_type&\n      operator>>(long long& __n)\n      { return _M_extract(__n); }\n\n      __istream_type&'
[#] parse_declaration, is_constructor=False, meet line: '__istream_type&\n      operator>>(long long& __n)\n      { return _M_extract(__n); }\n\n      __istream_type&\n      operator>>(unsigned long long& __n)\n      { return _M_extract(__n); }\n# 213 "/usr/includ'
[#] parse_declaration, is_constructor=False, meet line: '__istream_type&\n      operator>>(unsigned long long& __n)\n      { return _M_extract(__n); }\n# 213 "/usr/include/c++/7/istream" 3\n      __istream_type&\n      operator>>(float& __f)\n      { return _M_ex'
[#] parse_declaration, is_constructor=False, meet line: '__istream_type&\n      operator>>(float& __f)\n      { return _M_extract(__f); }\n\n      __istream_type&\n      operator>>(double& __f)\n      { return _M_extract(__f); }\n\n      __istream_type&\n      opera'
[#] parse_declaration, is_constructor=False, meet line: '__istream_type&\n      operator>>(double& __f)\n      { return _M_extract(__f); }\n\n      __istream_type&\n      operator>>(long double& __f)\n      { return _M_extract(__f); }\n# 234 "/usr/include/c++/7/is'
[#] parse_declaration, is_constructor=False, meet line: '__istream_type&\n      operator>>(long double& __f)\n      { return _M_extract(__f); }\n# 234 "/usr/include/c++/7/istream" 3\n      __istream_type&\n      operator>>(void*& __p)\n      { return _M_extract(_'
[#] parse_declaration, is_constructor=False, meet line: '__istream_type&\n      operator>>(void*& __p)\n      { return _M_extract(__p); }\n# 258 "/usr/include/c++/7/istream" 3\n      __istream_type&\n      operator>>(__streambuf_type* __sb);\n# 268 "/usr/include/'
[#] parse_declaration, is_constructor=False, meet line: '__istream_type&\n      operator>>(__streambuf_type* __sb);\n# 268 "/usr/include/c++/7/istream" 3\n      streamsize\n      gcount() const\n      { return _M_gcount; }\n# 301 "/usr/include/c++/7/istream" 3\n  '
[#] parse_declaration, is_constructor=False, meet line: 'streamsize\n      gcount() const\n      { return _M_gcount; }\n# 301 "/usr/include/c++/7/istream" 3\n      int_type\n      get();\n# 315 "/usr/include/c++/7/istream" 3\n      __istream_type&\n      get(char_t'
[#] parse_declaration, is_constructor=False, meet line: 'int_type\n      get();\n# 315 "/usr/include/c++/7/istream" 3\n      __istream_type&\n      get(char_type& __c);\n# 342 "/usr/include/c++/7/istream" 3\n      __istream_type&\n      get(char_type* __s, streams'
[#] parse_declaration, is_constructor=False, meet line: '__istream_type&\n      get(char_type& __c);\n# 342 "/usr/include/c++/7/istream" 3\n      __istream_type&\n      get(char_type* __s, streamsize __n, char_type __delim);\n# 353 "/usr/include/c++/7/istream" 3'
[#] parse_declaration, is_constructor=False, meet line: '__istream_type&\n      get(char_type* __s, streamsize __n, char_type __delim);\n# 353 "/usr/include/c++/7/istream" 3\n      __istream_type&\n      get(char_type* __s, streamsize __n)\n      { return this->'
[#] parse_declaration, is_constructor=False, meet line: '__istream_type&\n      get(char_type* __s, streamsize __n)\n      { return this->get(__s, __n, this->widen(\'\\n\')); }\n# 376 "/usr/include/c++/7/istream" 3\n      __istream_type&\n      get(__streambuf_type'
[#] parse_declaration, is_constructor=False, meet line: '__istream_type&\n      get(__streambuf_type& __sb, char_type __delim);\n# 386 "/usr/include/c++/7/istream" 3\n      __istream_type&\n      get(__streambuf_type& __sb)\n      { return this->get(__sb, this->'
[#] parse_declaration, is_constructor=False, meet line: '__istream_type&\n      get(__streambuf_type& __sb)\n      { return this->get(__sb, this->widen(\'\\n\')); }\n# 415 "/usr/include/c++/7/istream" 3\n      __istream_type&\n      getline(char_type* __s, streamsi'
[#] parse_declaration, is_constructor=False, meet line: '__istream_type&\n      getline(char_type* __s, streamsize __n, char_type __delim);\n# 426 "/usr/include/c++/7/istream" 3\n      __istream_type&\n      getline(char_type* __s, streamsize __n)\n      { retur'
[#] parse_declaration, is_constructor=False, meet line: '__istream_type&\n      getline(char_type* __s, streamsize __n)\n      { return this->getline(__s, __n, this->widen(\'\\n\')); }\n# 450 "/usr/include/c++/7/istream" 3\n      __istream_type&\n      ignore(strea'
[#] parse_declaration, is_constructor=False, meet line: '__istream_type&\n      ignore(streamsize __n, int_type __delim);\n\n      __istream_type&\n      ignore(streamsize __n);\n\n      __istream_type&\n      ignore();\n# 467 "/usr/include/c++/7/istream" 3\n      i'
[#] parse_declaration, is_constructor=False, meet line: '__istream_type&\n      ignore(streamsize __n);\n\n      __istream_type&\n      ignore();\n# 467 "/usr/include/c++/7/istream" 3\n      int_type\n      peek();\n# 485 "/usr/include/c++/7/istream" 3\n      __istr'
[#] parse_declaration, is_constructor=False, meet line: '__istream_type&\n      ignore();\n# 467 "/usr/include/c++/7/istream" 3\n      int_type\n      peek();\n# 485 "/usr/include/c++/7/istream" 3\n      __istream_type&\n      read(char_type* __s, streamsize __n);'
[#] parse_declaration, is_constructor=False, meet line: 'int_type\n      peek();\n# 485 "/usr/include/c++/7/istream" 3\n      __istream_type&\n      read(char_type* __s, streamsize __n);\n# 504 "/usr/include/c++/7/istream" 3\n      streamsize\n      readsome(char_'
[#] parse_declaration, is_constructor=False, meet line: '__istream_type&\n      read(char_type* __s, streamsize __n);\n# 504 "/usr/include/c++/7/istream" 3\n      streamsize\n      readsome(char_type* __s, streamsize __n);\n# 521 "/usr/include/c++/7/istream" 3\n '
[#] parse_declaration, is_constructor=False, meet line: 'streamsize\n      readsome(char_type* __s, streamsize __n);\n# 521 "/usr/include/c++/7/istream" 3\n      __istream_type&\n      putback(char_type __c);\n# 537 "/usr/include/c++/7/istream" 3\n      __istream'
[#] parse_declaration, is_constructor=False, meet line: '__istream_type&\n      putback(char_type __c);\n# 537 "/usr/include/c++/7/istream" 3\n      __istream_type&\n      unget();\n# 555 "/usr/include/c++/7/istream" 3\n      int\n      sync();\n# 570 "/usr/include'
[#] parse_declaration, is_constructor=False, meet line: '__istream_type&\n      unget();\n# 555 "/usr/include/c++/7/istream" 3\n      int\n      sync();\n# 570 "/usr/include/c++/7/istream" 3\n      pos_type\n      tellg();\n# 585 "/usr/include/c++/7/istream" 3\n    '
[#] parse_declaration, is_constructor=False, meet line: 'int\n      sync();\n# 570 "/usr/include/c++/7/istream" 3\n      pos_type\n      tellg();\n# 585 "/usr/include/c++/7/istream" 3\n      __istream_type&\n      seekg(pos_type);\n# 601 "/usr/include/c++/7/istream'
[#] parse_declaration, is_constructor=False, meet line: 'pos_type\n      tellg();\n# 585 "/usr/include/c++/7/istream" 3\n      __istream_type&\n      seekg(pos_type);\n# 601 "/usr/include/c++/7/istream" 3\n      __istream_type&\n      seekg(off_type, ios_base::see'
[#] parse_declaration, is_constructor=False, meet line: '__istream_type&\n      seekg(pos_type);\n# 601 "/usr/include/c++/7/istream" 3\n      __istream_type&\n      seekg(off_type, ios_base::seekdir);\n\n\n    protected:\n      basic_istream()\n      : _M_gcount(str'
[#] parse_declaration, is_constructor=False, meet line: '__istream_type&\n      seekg(off_type, ios_base::seekdir);\n\n\n    protected:\n      basic_istream()\n      : _M_gcount(streamsize(0))\n      { this->init(0); }\n\n\n      basic_istream(const basic_istream&) ='
[#] parse_declaration, is_constructor=True, meet line: 'basic_istream()\n      : _M_gcount(streamsize(0))\n      { this->init(0); }\n\n\n      basic_istream(const basic_istream&) = delete;\n\n      basic_istream(basic_istream&& __rhs)\n      : __ios_type(), _M_gco'
[#] parse_declaration, is_constructor=True, meet line: 'basic_istream(const basic_istream&) = delete;\n\n      basic_istream(basic_istream&& __rhs)\n      : __ios_type(), _M_gcount(__rhs._M_gcount)\n      {\n __ios_type::move(__rhs);\n __rhs._M_gcount = 0;\n     '
[#] parse_declaration, is_constructor=True, meet line: 'basic_istream(basic_istream&& __rhs)\n      : __ios_type(), _M_gcount(__rhs._M_gcount)\n      {\n __ios_type::move(__rhs);\n __rhs._M_gcount = 0;\n      }\n\n\n\n      basic_istream& operator=(const basic_istr'
[#] parse_declaration, is_constructor=True, meet line: 'basic_istream& operator=(const basic_istream&) = delete;\n\n      basic_istream&\n      operator=(basic_istream&& __rhs)\n      {\n swap(__rhs);\n return *this;\n      }\n\n      void\n      swap(basic_istream&'
[#] parse_declaration, is_constructor=True, meet line: 'basic_istream&\n      operator=(basic_istream&& __rhs)\n      {\n swap(__rhs);\n return *this;\n      }\n\n      void\n      swap(basic_istream& __rhs)\n      {\n __ios_type::swap(__rhs);\n std::swap(_M_gcount, '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      swap(basic_istream& __rhs)\n      {\n __ios_type::swap(__rhs);\n std::swap(_M_gcount, __rhs._M_gcount);\n      }\n\n\n      template<typename _ValueT>\n __istream_type&\n _M_extract(_ValueT& __v);\n '
[#] parse_declaration, is_constructor=False, meet line: '__istream_type&\n _M_extract(_ValueT& __v);\n    };\n\n\n  template<>\n    basic_istream<char>&\n    basic_istream<char>::\n    getline(char_type* __s, streamsize __n, char_type __delim);\n\n  template<>\n    ba'
[#] parse_declaration, is_constructor=False, meet line: 'basic_istream<char>&\n    basic_istream<char>::\n    getline(char_type* __s, streamsize __n, char_type __delim);\n\n  template<>\n    basic_istream<char>&\n    basic_istream<char>::\n    ignore(streamsize __'
[#] parse_declaration, is_constructor=False, meet line: 'basic_istream<char>&\n    basic_istream<char>::\n    ignore(streamsize __n);\n\n  template<>\n    basic_istream<char>&\n    basic_istream<char>::\n    ignore(streamsize __n, int_type __delim);\n\n\n  template<>'
[#] parse_declaration, is_constructor=False, meet line: 'basic_istream<char>&\n    basic_istream<char>::\n    ignore(streamsize __n, int_type __delim);\n\n\n  template<>\n    basic_istream<wchar_t>&\n    basic_istream<wchar_t>::\n    getline(char_type* __s, streams'
[#] parse_declaration, is_constructor=False, meet line: 'basic_istream<wchar_t>&\n    basic_istream<wchar_t>::\n    getline(char_type* __s, streamsize __n, char_type __delim);\n\n  template<>\n    basic_istream<wchar_t>&\n    basic_istream<wchar_t>::\n    ignore(s'
[#] parse_declaration, is_constructor=False, meet line: 'basic_istream<wchar_t>&\n    basic_istream<wchar_t>::\n    ignore(streamsize __n);\n\n  template<>\n    basic_istream<wchar_t>&\n    basic_istream<wchar_t>::\n    ignore(streamsize __n, int_type __delim);\n# '
[#] parse_declaration, is_constructor=False, meet line: 'basic_istream<wchar_t>&\n    basic_istream<wchar_t>::\n    ignore(streamsize __n, int_type __delim);\n# 685 "/usr/include/c++/7/istream" 3\n  template<typename _CharT, typename _Traits>\n    class basic_is'
[#] parse_declaration, is_constructor=False, meet line: 'bool _M_ok;\n\n    public:\n\n      typedef _Traits traits_type;\n      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;\n      typedef basic_istream<_CharT, _Traits> __istream_type;\n      typedef'
[#] parse_declaration, is_constructor=False, meet line: 'sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);\n# 732 "/usr/include/c++/7/istream" 3\n      explicit\n\n      operator bool() const\n      { return _M_ok; }\n    };\n# 750 "/usr/inclu'
[#] parse_declaration, is_constructor=False, meet line: 'operator bool() const\n      { return _M_ok; }\n    };\n# 750 "/usr/include/c++/7/istream" 3\n  template<typename _CharT, typename _Traits>\n    basic_istream<_CharT, _Traits>&\n    operator>>(basic_istream'
[#] parse_declaration, is_constructor=False, meet line: 'basic_istream<_CharT, _Traits>&\n    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c);\n\n  template<class _Traits>\n    inline basic_istream<char, _Traits>&\n    operator>>(basic_istream<char'
[#] parse_declaration, is_constructor=False, meet line: 'basic_istream<char, _Traits>&\n    operator>>(basic_istream<char, _Traits>& __in, unsigned char& __c)\n    { return (__in >> reinterpret_cast<char&>(__c)); }\n\n  template<class _Traits>\n    inline basic_'
[#] parse_declaration, is_constructor=False, meet line: 'basic_istream<char, _Traits>&\n    operator>>(basic_istream<char, _Traits>& __in, signed char& __c)\n    { return (__in >> reinterpret_cast<char&>(__c)); }\n# 792 "/usr/include/c++/7/istream" 3\n  templat'
[#] parse_declaration, is_constructor=False, meet line: 'basic_istream<_CharT, _Traits>&\n    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s);\n\n\n  template<>\n    basic_istream<char>&\n    operator>>(basic_istream<char>& __in, char* __s);\n\n  temp'
[#] parse_declaration, is_constructor=False, meet line: 'basic_istream<char>&\n    operator>>(basic_istream<char>& __in, char* __s);\n\n  template<class _Traits>\n    inline basic_istream<char, _Traits>&\n    operator>>(basic_istream<char, _Traits>& __in, unsign'
[#] parse_declaration, is_constructor=False, meet line: 'basic_istream<char, _Traits>&\n    operator>>(basic_istream<char, _Traits>& __in, unsigned char* __s)\n    { return (__in >> reinterpret_cast<char*>(__s)); }\n\n  template<class _Traits>\n    inline basic_'
[#] parse_declaration, is_constructor=False, meet line: 'basic_istream<char, _Traits>&\n    operator>>(basic_istream<char, _Traits>& __in, signed char* __s)\n    { return (__in >> reinterpret_cast<char*>(__s)); }\n# 823 "/usr/include/c++/7/istream" 3\n  templat'
[#] parse_declaration, is_constructor=True, meet line: 'basic_iostream(basic_streambuf<_CharT, _Traits>* __sb)\n      : __istream_type(__sb), __ostream_type(__sb) { }\n\n\n\n\n      virtual\n      ~basic_iostream() { }\n\n    protected:\n      basic_iostream()\n     '
[#] parse_declaration, is_constructor=True, meet line: 'basic_iostream() { }\n\n    protected:\n      basic_iostream()\n      : __istream_type(), __ostream_type() { }\n\n\n      basic_iostream(const basic_iostream&) = delete;\n\n      basic_iostream(basic_iostream&'
[#] parse_declaration, is_constructor=True, meet line: 'basic_iostream()\n      : __istream_type(), __ostream_type() { }\n\n\n      basic_iostream(const basic_iostream&) = delete;\n\n      basic_iostream(basic_iostream&& __rhs)\n      : __istream_type(std::move(_'
[#] parse_declaration, is_constructor=True, meet line: 'basic_iostream(const basic_iostream&) = delete;\n\n      basic_iostream(basic_iostream&& __rhs)\n      : __istream_type(std::move(__rhs)), __ostream_type(*this)\n      { }\n\n\n\n      basic_iostream& operato'
[#] parse_declaration, is_constructor=True, meet line: 'basic_iostream(basic_iostream&& __rhs)\n      : __istream_type(std::move(__rhs)), __ostream_type(*this)\n      { }\n\n\n\n      basic_iostream& operator=(const basic_iostream&) = delete;\n\n      basic_iostre'
[#] parse_declaration, is_constructor=True, meet line: 'basic_iostream& operator=(const basic_iostream&) = delete;\n\n      basic_iostream&\n      operator=(basic_iostream&& __rhs)\n      {\n swap(__rhs);\n return *this;\n      }\n\n      void\n      swap(basic_iost'
[#] parse_declaration, is_constructor=True, meet line: 'basic_iostream&\n      operator=(basic_iostream&& __rhs)\n      {\n swap(__rhs);\n return *this;\n      }\n\n      void\n      swap(basic_iostream& __rhs)\n      { __istream_type::swap(__rhs); }\n\n    };\n# 906 '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      swap(basic_iostream& __rhs)\n      { __istream_type::swap(__rhs); }\n\n    };\n# 906 "/usr/include/c++/7/istream" 3\n  template<typename _CharT, typename _Traits>\n    basic_istream<_CharT, _Trai'
[#] parse_declaration, is_constructor=False, meet line: 'basic_istream<_CharT, _Traits>&\n    ws(basic_istream<_CharT, _Traits>& __is);\n\n\n  template<typename _Ch, typename _Up>\n    basic_istream<_Ch, _Up>&\n    __is_convertible_to_basic_istream_test(basic_ist'
[#] parse_declaration, is_constructor=False, meet line: 'basic_istream<_Ch, _Up>&\n    __is_convertible_to_basic_istream_test(basic_istream<_Ch, _Up>*);\n\n  template<typename _Tp, typename = void>\n    struct __is_convertible_to_basic_istream_impl\n    {\n      '
[#] parse_declaration, is_constructor=False, meet line: 'bool value = type::value;\n    };\n\n  template<typename _Istream, typename _Tp, typename = void>\n    struct __is_extractable : false_type {};\n\n  template<typename _Istream, typename _Tp>\n    struct __is'
[#] parse_declaration, is_constructor=False, meet line: 'enable_if<__and_<__not_<is_lvalue_reference<_Istream>>,\n         __is_convertible_to_basic_istream<_Istream>,\n         __is_extractable<\n    __rvalue_istream_type<_Istream>,\n    _Tp&&>>::value,\n      '
[#] parse_declaration, is_constructor=False, meet line: 'basic_istream<_CharT, _Traits>::sentry::\n    sentry(basic_istream<_CharT, _Traits>& __in, bool __noskip) : _M_ok(false)\n    {\n      ios_base::iostate __err = ios_base::goodbit;\n      if (__in.good())\n'
[#] parse_declaration, is_constructor=False, meet line: 'basic_istream<_CharT, _Traits>&\n      basic_istream<_CharT, _Traits>::\n      _M_extract(_ValueT& __v)\n      {\n sentry __cerb(*this, false);\n if (__cerb)\n   {\n     ios_base::iostate __err = ios_base::g'
[#] parse_declaration, is_constructor=False, meet line: 'basic_istream<_CharT, _Traits>&\n    basic_istream<_CharT, _Traits>::\n    operator>>(short& __n)\n    {\n\n\n      sentry __cerb(*this, false);\n      if (__cerb)\n {\n   ios_base::iostate __err = ios_base::g'
[#] parse_declaration, is_constructor=False, meet line: 'basic_istream<_CharT, _Traits>&\n    basic_istream<_CharT, _Traits>::\n    operator>>(int& __n)\n    {\n\n\n      sentry __cerb(*this, false);\n      if (__cerb)\n {\n   ios_base::iostate __err = ios_base::goo'
[#] parse_declaration, is_constructor=False, meet line: 'basic_istream<_CharT, _Traits>&\n    basic_istream<_CharT, _Traits>::\n    operator>>(__streambuf_type* __sbout)\n    {\n      ios_base::iostate __err = ios_base::goodbit;\n      sentry __cerb(*this, false'
[#] parse_declaration, is_constructor=False, meet line: 'basic_istream<_CharT, _Traits>::int_type\n    basic_istream<_CharT, _Traits>::\n    get(void)\n    {\n      const int_type __eof = traits_type::eof();\n      int_type __c = __eof;\n      _M_gcount = 0;\n    '
[#] parse_declaration, is_constructor=False, meet line: 'basic_istream<_CharT, _Traits>&\n    basic_istream<_CharT, _Traits>::\n    get(char_type& __c)\n    {\n      _M_gcount = 0;\n      ios_base::iostate __err = ios_base::goodbit;\n      sentry __cerb(*this, tr'
[#] parse_declaration, is_constructor=False, meet line: 'basic_istream<_CharT, _Traits>&\n    basic_istream<_CharT, _Traits>::\n    get(char_type* __s, streamsize __n, char_type __delim)\n    {\n      _M_gcount = 0;\n      ios_base::iostate __err = ios_base::goo'
[#] parse_declaration, is_constructor=False, meet line: 'basic_istream<_CharT, _Traits>&\n    basic_istream<_CharT, _Traits>::\n    get(__streambuf_type& __sb, char_type __delim)\n    {\n      _M_gcount = 0;\n      ios_base::iostate __err = ios_base::goodbit;\n  '
[#] parse_declaration, is_constructor=False, meet line: 'basic_istream<_CharT, _Traits>&\n    basic_istream<_CharT, _Traits>::\n    getline(char_type* __s, streamsize __n, char_type __delim)\n    {\n      _M_gcount = 0;\n      ios_base::iostate __err = ios_base:'
[#] parse_declaration, is_constructor=False, meet line: 'basic_istream<_CharT, _Traits>&\n    basic_istream<_CharT, _Traits>::\n    ignore(void)\n    {\n      _M_gcount = 0;\n      sentry __cerb(*this, true);\n      if (__cerb)\n {\n   ios_base::iostate __err = ios'
[#] parse_declaration, is_constructor=False, meet line: 'basic_istream<_CharT, _Traits>&\n    basic_istream<_CharT, _Traits>::\n    ignore(streamsize __n)\n    {\n      _M_gcount = 0;\n      sentry __cerb(*this, true);\n      if (__cerb && __n > 0)\n        {\n    '
[#] parse_declaration, is_constructor=False, meet line: 'basic_istream<_CharT, _Traits>&\n    basic_istream<_CharT, _Traits>::\n    ignore(streamsize __n, int_type __delim)\n    {\n      _M_gcount = 0;\n      sentry __cerb(*this, true);\n      if (__cerb && __n >'
[#] parse_declaration, is_constructor=False, meet line: 'basic_istream<_CharT, _Traits>::int_type\n    basic_istream<_CharT, _Traits>::\n    peek(void)\n    {\n      int_type __c = traits_type::eof();\n      _M_gcount = 0;\n      sentry __cerb(*this, true);\n     '
[#] parse_declaration, is_constructor=False, meet line: 'basic_istream<_CharT, _Traits>&\n    basic_istream<_CharT, _Traits>::\n    read(char_type* __s, streamsize __n)\n    {\n      _M_gcount = 0;\n      sentry __cerb(*this, true);\n      if (__cerb)\n {\n   ios_b'
[#] parse_declaration, is_constructor=False, meet line: 'streamsize\n    basic_istream<_CharT, _Traits>::\n    readsome(char_type* __s, streamsize __n)\n    {\n      _M_gcount = 0;\n      sentry __cerb(*this, true);\n      if (__cerb)\n {\n   ios_base::iostate __er'
[#] parse_declaration, is_constructor=False, meet line: 'basic_istream<_CharT, _Traits>&\n    basic_istream<_CharT, _Traits>::\n    putback(char_type __c)\n    {\n\n\n      _M_gcount = 0;\n\n      this->clear(this->rdstate() & ~ios_base::eofbit);\n      sentry __cer'
[#] parse_declaration, is_constructor=False, meet line: 'basic_istream<_CharT, _Traits>&\n    basic_istream<_CharT, _Traits>::\n    unget(void)\n    {\n\n\n      _M_gcount = 0;\n\n      this->clear(this->rdstate() & ~ios_base::eofbit);\n      sentry __cerb(*this, tr'
[#] parse_declaration, is_constructor=False, meet line: 'int\n    basic_istream<_CharT, _Traits>::\n    sync(void)\n    {\n\n\n      int __ret = -1;\n      sentry __cerb(*this, true);\n      if (__cerb)\n {\n   ios_base::iostate __err = ios_base::goodbit;\n   try\n    '
[#] parse_declaration, is_constructor=False, meet line: 'basic_istream<_CharT, _Traits>::pos_type\n    basic_istream<_CharT, _Traits>::\n    tellg(void)\n    {\n\n\n      pos_type __ret = pos_type(-1);\n      sentry __cerb(*this, true);\n      if (__cerb)\n {\n   try'
[#] parse_declaration, is_constructor=False, meet line: 'basic_istream<_CharT, _Traits>&\n    basic_istream<_CharT, _Traits>::\n    seekg(pos_type __pos)\n    {\n\n\n\n      this->clear(this->rdstate() & ~ios_base::eofbit);\n      sentry __cerb(*this, true);\n      '
[#] parse_declaration, is_constructor=False, meet line: 'basic_istream<_CharT, _Traits>&\n    basic_istream<_CharT, _Traits>::\n    seekg(off_type __off, ios_base::seekdir __dir)\n    {\n\n\n\n      this->clear(this->rdstate() & ~ios_base::eofbit);\n      sentry __'
[#] parse_declaration, is_constructor=False, meet line: 'basic_istream<_CharT, _Traits>&\n    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c)\n    {\n      typedef basic_istream<_CharT, _Traits> __istream_type;\n      typedef typename __istream_ty'
[#] parse_declaration, is_constructor=False, meet line: 'basic_istream<_CharT, _Traits>&\n    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s)\n    {\n      typedef basic_istream<_CharT, _Traits> __istream_type;\n      typedef basic_streambuf<_Char'
[#] parse_declaration, is_constructor=False, meet line: 'basic_istream<_CharT, _Traits>&\n    ws(basic_istream<_CharT, _Traits>& __in)\n    {\n      typedef basic_istream<_CharT, _Traits> __istream_type;\n      typedef basic_streambuf<_CharT, _Traits> __streamb'
[#] parse_declaration, is_constructor=False, meet line: 'template class basic_istream<char>;\n  extern template istream& ws(istream&);\n  extern template istream& operator>>(istream&, char&);\n  extern template istream& operator>>(istream&, char*);\n  extern te'
[#] parse_declaration, is_constructor=False, meet line: 'template istream& ws(istream&);\n  extern template istream& operator>>(istream&, char&);\n  extern template istream& operator>>(istream&, char*);\n  extern template istream& operator>>(istream&, unsigned'
[#] parse_declaration, is_constructor=False, meet line: 'template istream& operator>>(istream&, char&);\n  extern template istream& operator>>(istream&, char*);\n  extern template istream& operator>>(istream&, unsigned char&);\n  extern template istream& opera'
[#] parse_declaration, is_constructor=False, meet line: 'template istream& operator>>(istream&, char*);\n  extern template istream& operator>>(istream&, unsigned char&);\n  extern template istream& operator>>(istream&, signed char&);\n  extern template istream'
[#] parse_declaration, is_constructor=False, meet line: 'template istream& operator>>(istream&, unsigned char&);\n  extern template istream& operator>>(istream&, signed char&);\n  extern template istream& operator>>(istream&, unsigned char*);\n  extern templat'
[#] parse_declaration, is_constructor=False, meet line: 'template istream& operator>>(istream&, signed char&);\n  extern template istream& operator>>(istream&, unsigned char*);\n  extern template istream& operator>>(istream&, signed char*);\n\n  extern template'
[#] parse_declaration, is_constructor=False, meet line: 'template istream& operator>>(istream&, unsigned char*);\n  extern template istream& operator>>(istream&, signed char*);\n\n  extern template istream& istream::_M_extract(unsigned short&);\n  extern templa'
[#] parse_declaration, is_constructor=False, meet line: 'template istream& operator>>(istream&, signed char*);\n\n  extern template istream& istream::_M_extract(unsigned short&);\n  extern template istream& istream::_M_extract(unsigned int&);\n  extern template'
[#] parse_declaration, is_constructor=False, meet line: 'template istream& istream::_M_extract(unsigned short&);\n  extern template istream& istream::_M_extract(unsigned int&);\n  extern template istream& istream::_M_extract(long&);\n  extern template istream&'
[#] parse_declaration, is_constructor=False, meet line: 'template istream& istream::_M_extract(unsigned int&);\n  extern template istream& istream::_M_extract(long&);\n  extern template istream& istream::_M_extract(unsigned long&);\n  extern template istream& '
[#] parse_declaration, is_constructor=False, meet line: 'template istream& istream::_M_extract(long&);\n  extern template istream& istream::_M_extract(unsigned long&);\n  extern template istream& istream::_M_extract(bool&);\n\n  extern template istream& istream'
[#] parse_declaration, is_constructor=False, meet line: 'template istream& istream::_M_extract(unsigned long&);\n  extern template istream& istream::_M_extract(bool&);\n\n  extern template istream& istream::_M_extract(long long&);\n  extern template istream& is'
[#] parse_declaration, is_constructor=False, meet line: 'template istream& istream::_M_extract(bool&);\n\n  extern template istream& istream::_M_extract(long long&);\n  extern template istream& istream::_M_extract(unsigned long long&);\n\n  extern template istre'
[#] parse_declaration, is_constructor=False, meet line: 'template istream& istream::_M_extract(long long&);\n  extern template istream& istream::_M_extract(unsigned long long&);\n\n  extern template istream& istream::_M_extract(float&);\n  extern template istre'
[#] parse_declaration, is_constructor=False, meet line: 'template istream& istream::_M_extract(unsigned long long&);\n\n  extern template istream& istream::_M_extract(float&);\n  extern template istream& istream::_M_extract(double&);\n  extern template istream&'
[#] parse_declaration, is_constructor=False, meet line: 'template istream& istream::_M_extract(float&);\n  extern template istream& istream::_M_extract(double&);\n  extern template istream& istream::_M_extract(long double&);\n  extern template istream& istream'
[#] parse_declaration, is_constructor=False, meet line: 'template istream& istream::_M_extract(double&);\n  extern template istream& istream::_M_extract(long double&);\n  extern template istream& istream::_M_extract(void*&);\n\n  extern template class basic_ios'
[#] parse_declaration, is_constructor=False, meet line: 'template istream& istream::_M_extract(long double&);\n  extern template istream& istream::_M_extract(void*&);\n\n  extern template class basic_iostream<char>;\n\n\n  extern template class basic_istream<wcha'
[#] parse_declaration, is_constructor=False, meet line: 'template istream& istream::_M_extract(void*&);\n\n  extern template class basic_iostream<char>;\n\n\n  extern template class basic_istream<wchar_t>;\n  extern template wistream& ws(wistream&);\n  extern temp'
[#] parse_declaration, is_constructor=False, meet line: 'template class basic_iostream<char>;\n\n\n  extern template class basic_istream<wchar_t>;\n  extern template wistream& ws(wistream&);\n  extern template wistream& operator>>(wistream&, wchar_t&);\n  extern '
[#] parse_declaration, is_constructor=False, meet line: 'template class basic_istream<wchar_t>;\n  extern template wistream& ws(wistream&);\n  extern template wistream& operator>>(wistream&, wchar_t&);\n  extern template wistream& operator>>(wistream&, wchar_t'
[#] parse_declaration, is_constructor=False, meet line: 'template wistream& ws(wistream&);\n  extern template wistream& operator>>(wistream&, wchar_t&);\n  extern template wistream& operator>>(wistream&, wchar_t*);\n\n  extern template wistream& wistream::_M_ex'
[#] parse_declaration, is_constructor=False, meet line: 'template wistream& operator>>(wistream&, wchar_t&);\n  extern template wistream& operator>>(wistream&, wchar_t*);\n\n  extern template wistream& wistream::_M_extract(unsigned short&);\n  extern template w'
[#] parse_declaration, is_constructor=False, meet line: 'template wistream& operator>>(wistream&, wchar_t*);\n\n  extern template wistream& wistream::_M_extract(unsigned short&);\n  extern template wistream& wistream::_M_extract(unsigned int&);\n  extern templa'
[#] parse_declaration, is_constructor=False, meet line: 'template wistream& wistream::_M_extract(unsigned short&);\n  extern template wistream& wistream::_M_extract(unsigned int&);\n  extern template wistream& wistream::_M_extract(long&);\n  extern template wi'
[#] parse_declaration, is_constructor=False, meet line: 'template wistream& wistream::_M_extract(unsigned int&);\n  extern template wistream& wistream::_M_extract(long&);\n  extern template wistream& wistream::_M_extract(unsigned long&);\n  extern template wis'
[#] parse_declaration, is_constructor=False, meet line: 'template wistream& wistream::_M_extract(long&);\n  extern template wistream& wistream::_M_extract(unsigned long&);\n  extern template wistream& wistream::_M_extract(bool&);\n\n  extern template wistream& '
[#] parse_declaration, is_constructor=False, meet line: 'template wistream& wistream::_M_extract(unsigned long&);\n  extern template wistream& wistream::_M_extract(bool&);\n\n  extern template wistream& wistream::_M_extract(long long&);\n  extern template wistr'
[#] parse_declaration, is_constructor=False, meet line: 'template wistream& wistream::_M_extract(bool&);\n\n  extern template wistream& wistream::_M_extract(long long&);\n  extern template wistream& wistream::_M_extract(unsigned long long&);\n\n  extern template'
[#] parse_declaration, is_constructor=False, meet line: 'template wistream& wistream::_M_extract(long long&);\n  extern template wistream& wistream::_M_extract(unsigned long long&);\n\n  extern template wistream& wistream::_M_extract(float&);\n  extern template'
[#] parse_declaration, is_constructor=False, meet line: 'template wistream& wistream::_M_extract(unsigned long long&);\n\n  extern template wistream& wistream::_M_extract(float&);\n  extern template wistream& wistream::_M_extract(double&);\n  extern template wi'
[#] parse_declaration, is_constructor=False, meet line: 'template wistream& wistream::_M_extract(float&);\n  extern template wistream& wistream::_M_extract(double&);\n  extern template wistream& wistream::_M_extract(long double&);\n  extern template wistream& '
[#] parse_declaration, is_constructor=False, meet line: 'template wistream& wistream::_M_extract(double&);\n  extern template wistream& wistream::_M_extract(long double&);\n  extern template wistream& wistream::_M_extract(void*&);\n\n  extern template class bas'
[#] parse_declaration, is_constructor=False, meet line: 'template wistream& wistream::_M_extract(long double&);\n  extern template wistream& wistream::_M_extract(void*&);\n\n  extern template class basic_iostream<wchar_t>;\n\n\n\n\n}\n# 992 "/usr/include/c++/7/istre'
[#] parse_declaration, is_constructor=False, meet line: 'template wistream& wistream::_M_extract(void*&);\n\n  extern template class basic_iostream<wchar_t>;\n\n\n\n\n}\n# 992 "/usr/include/c++/7/istream" 2 3\n# 66 "/usr/include/c++/7/iterator" 2 3\n# 1 "/usr/include'
[#] parse_declaration, is_constructor=False, meet line: 'template class basic_iostream<wchar_t>;\n\n\n\n\n}\n# 992 "/usr/include/c++/7/istream" 2 3\n# 66 "/usr/include/c++/7/iterator" 2 3\n# 1 "/usr/include/c++/7/bits/stream_iterator.h" 1 3\n# 33 "/usr/include/c++/7'
[#] parse_declaration, is_constructor=False, meet line: 'istream_type* _M_stream;\n      _Tp _M_value;\n      bool _M_ok;\n\n    public:\n\n      constexpr istream_iterator()\n      : _M_stream(0), _M_value(), _M_ok(false) {}\n\n\n      istream_iterator(istream_type&'
[#] parse_declaration, is_constructor=False, meet line: '_Tp _M_value;\n      bool _M_ok;\n\n    public:\n\n      constexpr istream_iterator()\n      : _M_stream(0), _M_value(), _M_ok(false) {}\n\n\n      istream_iterator(istream_type& __s)\n      : _M_stream(std::__'
[#] parse_declaration, is_constructor=False, meet line: 'bool _M_ok;\n\n    public:\n\n      constexpr istream_iterator()\n      : _M_stream(0), _M_value(), _M_ok(false) {}\n\n\n      istream_iterator(istream_type& __s)\n      : _M_stream(std::__addressof(__s))\n    '
[#] parse_declaration, is_constructor=True, meet line: 'istream_iterator()\n      : _M_stream(0), _M_value(), _M_ok(false) {}\n\n\n      istream_iterator(istream_type& __s)\n      : _M_stream(std::__addressof(__s))\n      { _M_read(); }\n\n      istream_iterator(c'
[#] parse_declaration, is_constructor=True, meet line: 'istream_iterator(istream_type& __s)\n      : _M_stream(std::__addressof(__s))\n      { _M_read(); }\n\n      istream_iterator(const istream_iterator& __obj)\n      : _M_stream(__obj._M_stream), _M_value(__'
[#] parse_declaration, is_constructor=True, meet line: 'istream_iterator(const istream_iterator& __obj)\n      : _M_stream(__obj._M_stream), _M_value(__obj._M_value),\n        _M_ok(__obj._M_ok)\n      { }\n\n      const _Tp&\n      operator*() const\n      {\n\n\n '
[#] parse_declaration, is_constructor=False, meet line: '_Tp&\n      operator*() const\n      {\n\n\n                        ;\n return _M_value;\n      }\n\n      const _Tp*\n      operator->() const { return std::__addressof((operator*())); }\n\n      istream_iterato'
[#] parse_declaration, is_constructor=False, meet line: '_Tp*\n      operator->() const { return std::__addressof((operator*())); }\n\n      istream_iterator&\n      operator++()\n      {\n\n\n                        ;\n _M_read();\n return *this;\n      }\n\n      istr'
[#] parse_declaration, is_constructor=True, meet line: 'istream_iterator&\n      operator++()\n      {\n\n\n                        ;\n _M_read();\n return *this;\n      }\n\n      istream_iterator\n      operator++(int)\n      {\n\n\n                        ;\n istream_i'
[#] parse_declaration, is_constructor=True, meet line: 'istream_iterator\n      operator++(int)\n      {\n\n\n                        ;\n istream_iterator __tmp = *this;\n _M_read();\n return __tmp;\n      }\n\n      bool\n      _M_equal(const istream_iterator& __x) c'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      _M_equal(const istream_iterator& __x) const\n      { return (_M_ok == __x._M_ok) && (!_M_ok || _M_stream == __x._M_stream); }\n\n    private:\n      void\n      _M_read()\n      {\n _M_ok = (_M_st'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_read()\n      {\n _M_ok = (_M_stream && *_M_stream) ? true : false;\n if (_M_ok)\n   {\n     *_M_stream >> _M_value;\n     _M_ok = *_M_stream ? true : false;\n   }\n      }\n    };\n\n\n  template<t'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator==(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,\n        const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __y)\n    { return __x._M_equal(__y); }\n\n\n  template <class _T'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator!=(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,\n        const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __y)\n    { return !__x._M_equal(__y); }\n# 152 "/usr/include/c'
[#] parse_declaration, is_constructor=False, meet line: 'ostream_type* _M_stream;\n      const _CharT* _M_string;\n\n    public:\n\n      ostream_iterator(ostream_type& __s)\n      : _M_stream(std::__addressof(__s)), _M_string(0) {}\n# 184 "/usr/include/c++/7/bits'
[#] parse_declaration, is_constructor=False, meet line: '_CharT* _M_string;\n\n    public:\n\n      ostream_iterator(ostream_type& __s)\n      : _M_stream(std::__addressof(__s)), _M_string(0) {}\n# 184 "/usr/include/c++/7/bits/stream_iterator.h" 3\n      ostream_i'
[#] parse_declaration, is_constructor=True, meet line: 'ostream_iterator(ostream_type& __s)\n      : _M_stream(std::__addressof(__s)), _M_string(0) {}\n# 184 "/usr/include/c++/7/bits/stream_iterator.h" 3\n      ostream_iterator(ostream_type& __s, const _CharT'
[#] parse_declaration, is_constructor=True, meet line: 'ostream_iterator(ostream_type& __s, const _CharT* __c)\n      : _M_stream(&__s), _M_string(__c) { }\n\n\n      ostream_iterator(const ostream_iterator& __obj)\n      : _M_stream(__obj._M_stream), _M_string'
[#] parse_declaration, is_constructor=True, meet line: 'ostream_iterator(const ostream_iterator& __obj)\n      : _M_stream(__obj._M_stream), _M_string(__obj._M_string) { }\n\n\n\n      ostream_iterator&\n      operator=(const _Tp& __value)\n      {\n\n\n            '
[#] parse_declaration, is_constructor=True, meet line: 'ostream_iterator&\n      operator=(const _Tp& __value)\n      {\n\n\n                        ;\n *_M_stream << __value;\n if (_M_string) *_M_stream << _M_string;\n return *this;\n      }\n\n      ostream_iterato'
[#] parse_declaration, is_constructor=True, meet line: 'ostream_iterator&\n      operator*()\n      { return *this; }\n\n      ostream_iterator&\n      operator++()\n      { return *this; }\n\n      ostream_iterator&\n      operator++(int)\n      { return *this; }\n '
[#] parse_declaration, is_constructor=True, meet line: 'ostream_iterator&\n      operator++()\n      { return *this; }\n\n      ostream_iterator&\n      operator++(int)\n      { return *this; }\n    };\n\n\n\n\n}\n# 67 "/usr/include/c++/7/iterator" 2 3\n# 44 "/usr/inclu'
[#] parse_declaration, is_constructor=True, meet line: 'ostream_iterator&\n      operator++(int)\n      { return *this; }\n    };\n\n\n\n\n}\n# 67 "/usr/include/c++/7/iterator" 2 3\n# 44 "/usr/include/c++/7/regex" 2 3\n# 1 "/usr/include/c++/7/locale" 1 3\n# 36 "/usr/i'
[#] parse_declaration, is_constructor=False, meet line: '_CharT* _S_timezones[14];\n\n      const _CharT* _M_date_format;\n      const _CharT* _M_date_era_format;\n      const _CharT* _M_time_format;\n      const _CharT* _M_time_era_format;\n      const _CharT* _'
[#] parse_declaration, is_constructor=False, meet line: '_CharT* _M_date_format;\n      const _CharT* _M_date_era_format;\n      const _CharT* _M_time_format;\n      const _CharT* _M_time_era_format;\n      const _CharT* _M_date_time_format;\n      const _CharT*'
[#] parse_declaration, is_constructor=False, meet line: '_CharT* _M_date_era_format;\n      const _CharT* _M_time_format;\n      const _CharT* _M_time_era_format;\n      const _CharT* _M_date_time_format;\n      const _CharT* _M_date_time_era_format;\n      cons'
[#] parse_declaration, is_constructor=False, meet line: '_CharT* _M_time_format;\n      const _CharT* _M_time_era_format;\n      const _CharT* _M_date_time_format;\n      const _CharT* _M_date_time_era_format;\n      const _CharT* _M_am;\n      const _CharT* _M_'
[#] parse_declaration, is_constructor=False, meet line: '_CharT* _M_time_era_format;\n      const _CharT* _M_date_time_format;\n      const _CharT* _M_date_time_era_format;\n      const _CharT* _M_am;\n      const _CharT* _M_pm;\n      const _CharT* _M_am_pm_for'
[#] parse_declaration, is_constructor=False, meet line: '_CharT* _M_date_time_format;\n      const _CharT* _M_date_time_era_format;\n      const _CharT* _M_am;\n      const _CharT* _M_pm;\n      const _CharT* _M_am_pm_format;\n\n\n      const _CharT* _M_day1;\n    '
[#] parse_declaration, is_constructor=False, meet line: '_CharT* _M_date_time_era_format;\n      const _CharT* _M_am;\n      const _CharT* _M_pm;\n      const _CharT* _M_am_pm_format;\n\n\n      const _CharT* _M_day1;\n      const _CharT* _M_day2;\n      const _Cha'
[#] parse_declaration, is_constructor=False, meet line: '_CharT* _M_am;\n      const _CharT* _M_pm;\n      const _CharT* _M_am_pm_format;\n\n\n      const _CharT* _M_day1;\n      const _CharT* _M_day2;\n      const _CharT* _M_day3;\n      const _CharT* _M_day4;\n   '
[#] parse_declaration, is_constructor=False, meet line: '_CharT* _M_pm;\n      const _CharT* _M_am_pm_format;\n\n\n      const _CharT* _M_day1;\n      const _CharT* _M_day2;\n      const _CharT* _M_day3;\n      const _CharT* _M_day4;\n      const _CharT* _M_day5;\n '
[#] parse_declaration, is_constructor=False, meet line: '_CharT* _M_am_pm_format;\n\n\n      const _CharT* _M_day1;\n      const _CharT* _M_day2;\n      const _CharT* _M_day3;\n      const _CharT* _M_day4;\n      const _CharT* _M_day5;\n      const _CharT* _M_day6;'
[#] parse_declaration, is_constructor=False, meet line: '_CharT* _M_day1;\n      const _CharT* _M_day2;\n      const _CharT* _M_day3;\n      const _CharT* _M_day4;\n      const _CharT* _M_day5;\n      const _CharT* _M_day6;\n      const _CharT* _M_day7;\n\n\n      c'
[#] parse_declaration, is_constructor=False, meet line: '_CharT* _M_day2;\n      const _CharT* _M_day3;\n      const _CharT* _M_day4;\n      const _CharT* _M_day5;\n      const _CharT* _M_day6;\n      const _CharT* _M_day7;\n\n\n      const _CharT* _M_aday1;\n      '
[#] parse_declaration, is_constructor=False, meet line: '_CharT* _M_day3;\n      const _CharT* _M_day4;\n      const _CharT* _M_day5;\n      const _CharT* _M_day6;\n      const _CharT* _M_day7;\n\n\n      const _CharT* _M_aday1;\n      const _CharT* _M_aday2;\n     '
[#] parse_declaration, is_constructor=False, meet line: '_CharT* _M_day4;\n      const _CharT* _M_day5;\n      const _CharT* _M_day6;\n      const _CharT* _M_day7;\n\n\n      const _CharT* _M_aday1;\n      const _CharT* _M_aday2;\n      const _CharT* _M_aday3;\n    '
[#] parse_declaration, is_constructor=False, meet line: '_CharT* _M_day5;\n      const _CharT* _M_day6;\n      const _CharT* _M_day7;\n\n\n      const _CharT* _M_aday1;\n      const _CharT* _M_aday2;\n      const _CharT* _M_aday3;\n      const _CharT* _M_aday4;\n   '
[#] parse_declaration, is_constructor=False, meet line: '_CharT* _M_day6;\n      const _CharT* _M_day7;\n\n\n      const _CharT* _M_aday1;\n      const _CharT* _M_aday2;\n      const _CharT* _M_aday3;\n      const _CharT* _M_aday4;\n      const _CharT* _M_aday5;\n  '
[#] parse_declaration, is_constructor=False, meet line: '_CharT* _M_day7;\n\n\n      const _CharT* _M_aday1;\n      const _CharT* _M_aday2;\n      const _CharT* _M_aday3;\n      const _CharT* _M_aday4;\n      const _CharT* _M_aday5;\n      const _CharT* _M_aday6;\n '
[#] parse_declaration, is_constructor=False, meet line: '_CharT* _M_aday1;\n      const _CharT* _M_aday2;\n      const _CharT* _M_aday3;\n      const _CharT* _M_aday4;\n      const _CharT* _M_aday5;\n      const _CharT* _M_aday6;\n      const _CharT* _M_aday7;\n\n\n'
[#] parse_declaration, is_constructor=False, meet line: '_CharT* _M_aday2;\n      const _CharT* _M_aday3;\n      const _CharT* _M_aday4;\n      const _CharT* _M_aday5;\n      const _CharT* _M_aday6;\n      const _CharT* _M_aday7;\n\n\n      const _CharT* _M_month01'
[#] parse_declaration, is_constructor=False, meet line: '_CharT* _M_aday3;\n      const _CharT* _M_aday4;\n      const _CharT* _M_aday5;\n      const _CharT* _M_aday6;\n      const _CharT* _M_aday7;\n\n\n      const _CharT* _M_month01;\n      const _CharT* _M_month'
[#] parse_declaration, is_constructor=False, meet line: '_CharT* _M_aday4;\n      const _CharT* _M_aday5;\n      const _CharT* _M_aday6;\n      const _CharT* _M_aday7;\n\n\n      const _CharT* _M_month01;\n      const _CharT* _M_month02;\n      const _CharT* _M_mon'
[#] parse_declaration, is_constructor=False, meet line: '_CharT* _M_aday5;\n      const _CharT* _M_aday6;\n      const _CharT* _M_aday7;\n\n\n      const _CharT* _M_month01;\n      const _CharT* _M_month02;\n      const _CharT* _M_month03;\n      const _CharT* _M_m'
[#] parse_declaration, is_constructor=False, meet line: '_CharT* _M_aday6;\n      const _CharT* _M_aday7;\n\n\n      const _CharT* _M_month01;\n      const _CharT* _M_month02;\n      const _CharT* _M_month03;\n      const _CharT* _M_month04;\n      const _CharT* _M'
[#] parse_declaration, is_constructor=False, meet line: '_CharT* _M_aday7;\n\n\n      const _CharT* _M_month01;\n      const _CharT* _M_month02;\n      const _CharT* _M_month03;\n      const _CharT* _M_month04;\n      const _CharT* _M_month05;\n      const _CharT* '
[#] parse_declaration, is_constructor=False, meet line: '_CharT* _M_month01;\n      const _CharT* _M_month02;\n      const _CharT* _M_month03;\n      const _CharT* _M_month04;\n      const _CharT* _M_month05;\n      const _CharT* _M_month06;\n      const _CharT* '
[#] parse_declaration, is_constructor=False, meet line: '_CharT* _M_month02;\n      const _CharT* _M_month03;\n      const _CharT* _M_month04;\n      const _CharT* _M_month05;\n      const _CharT* _M_month06;\n      const _CharT* _M_month07;\n      const _CharT* '
[#] parse_declaration, is_constructor=False, meet line: '_CharT* _M_month03;\n      const _CharT* _M_month04;\n      const _CharT* _M_month05;\n      const _CharT* _M_month06;\n      const _CharT* _M_month07;\n      const _CharT* _M_month08;\n      const _CharT* '
[#] parse_declaration, is_constructor=False, meet line: '_CharT* _M_month04;\n      const _CharT* _M_month05;\n      const _CharT* _M_month06;\n      const _CharT* _M_month07;\n      const _CharT* _M_month08;\n      const _CharT* _M_month09;\n      const _CharT* '
[#] parse_declaration, is_constructor=False, meet line: '_CharT* _M_month05;\n      const _CharT* _M_month06;\n      const _CharT* _M_month07;\n      const _CharT* _M_month08;\n      const _CharT* _M_month09;\n      const _CharT* _M_month10;\n      const _CharT* '
[#] parse_declaration, is_constructor=False, meet line: '_CharT* _M_month06;\n      const _CharT* _M_month07;\n      const _CharT* _M_month08;\n      const _CharT* _M_month09;\n      const _CharT* _M_month10;\n      const _CharT* _M_month11;\n      const _CharT* '
[#] parse_declaration, is_constructor=False, meet line: '_CharT* _M_month07;\n      const _CharT* _M_month08;\n      const _CharT* _M_month09;\n      const _CharT* _M_month10;\n      const _CharT* _M_month11;\n      const _CharT* _M_month12;\n\n\n      const _CharT'
[#] parse_declaration, is_constructor=False, meet line: '_CharT* _M_month08;\n      const _CharT* _M_month09;\n      const _CharT* _M_month10;\n      const _CharT* _M_month11;\n      const _CharT* _M_month12;\n\n\n      const _CharT* _M_amonth01;\n      const _Char'
[#] parse_declaration, is_constructor=False, meet line: '_CharT* _M_month09;\n      const _CharT* _M_month10;\n      const _CharT* _M_month11;\n      const _CharT* _M_month12;\n\n\n      const _CharT* _M_amonth01;\n      const _CharT* _M_amonth02;\n      const _Cha'
[#] parse_declaration, is_constructor=False, meet line: '_CharT* _M_month10;\n      const _CharT* _M_month11;\n      const _CharT* _M_month12;\n\n\n      const _CharT* _M_amonth01;\n      const _CharT* _M_amonth02;\n      const _CharT* _M_amonth03;\n      const _Ch'
[#] parse_declaration, is_constructor=False, meet line: '_CharT* _M_month11;\n      const _CharT* _M_month12;\n\n\n      const _CharT* _M_amonth01;\n      const _CharT* _M_amonth02;\n      const _CharT* _M_amonth03;\n      const _CharT* _M_amonth04;\n      const _C'
[#] parse_declaration, is_constructor=False, meet line: '_CharT* _M_month12;\n\n\n      const _CharT* _M_amonth01;\n      const _CharT* _M_amonth02;\n      const _CharT* _M_amonth03;\n      const _CharT* _M_amonth04;\n      const _CharT* _M_amonth05;\n      const _'
[#] parse_declaration, is_constructor=False, meet line: '_CharT* _M_amonth01;\n      const _CharT* _M_amonth02;\n      const _CharT* _M_amonth03;\n      const _CharT* _M_amonth04;\n      const _CharT* _M_amonth05;\n      const _CharT* _M_amonth06;\n      const _C'
[#] parse_declaration, is_constructor=False, meet line: '_CharT* _M_amonth02;\n      const _CharT* _M_amonth03;\n      const _CharT* _M_amonth04;\n      const _CharT* _M_amonth05;\n      const _CharT* _M_amonth06;\n      const _CharT* _M_amonth07;\n      const _C'
[#] parse_declaration, is_constructor=False, meet line: '_CharT* _M_amonth03;\n      const _CharT* _M_amonth04;\n      const _CharT* _M_amonth05;\n      const _CharT* _M_amonth06;\n      const _CharT* _M_amonth07;\n      const _CharT* _M_amonth08;\n      const _C'
[#] parse_declaration, is_constructor=False, meet line: '_CharT* _M_amonth04;\n      const _CharT* _M_amonth05;\n      const _CharT* _M_amonth06;\n      const _CharT* _M_amonth07;\n      const _CharT* _M_amonth08;\n      const _CharT* _M_amonth09;\n      const _C'
[#] parse_declaration, is_constructor=False, meet line: '_CharT* _M_amonth05;\n      const _CharT* _M_amonth06;\n      const _CharT* _M_amonth07;\n      const _CharT* _M_amonth08;\n      const _CharT* _M_amonth09;\n      const _CharT* _M_amonth10;\n      const _C'
[#] parse_declaration, is_constructor=False, meet line: '_CharT* _M_amonth06;\n      const _CharT* _M_amonth07;\n      const _CharT* _M_amonth08;\n      const _CharT* _M_amonth09;\n      const _CharT* _M_amonth10;\n      const _CharT* _M_amonth11;\n      const _C'
[#] parse_declaration, is_constructor=False, meet line: '_CharT* _M_amonth07;\n      const _CharT* _M_amonth08;\n      const _CharT* _M_amonth09;\n      const _CharT* _M_amonth10;\n      const _CharT* _M_amonth11;\n      const _CharT* _M_amonth12;\n\n      bool _M'
[#] parse_declaration, is_constructor=False, meet line: '_CharT* _M_amonth08;\n      const _CharT* _M_amonth09;\n      const _CharT* _M_amonth10;\n      const _CharT* _M_amonth11;\n      const _CharT* _M_amonth12;\n\n      bool _M_allocated;\n\n      __timepunct_ca'
[#] parse_declaration, is_constructor=False, meet line: '_CharT* _M_amonth09;\n      const _CharT* _M_amonth10;\n      const _CharT* _M_amonth11;\n      const _CharT* _M_amonth12;\n\n      bool _M_allocated;\n\n      __timepunct_cache(size_t __refs = 0) : facet(__'
[#] parse_declaration, is_constructor=False, meet line: '_CharT* _M_amonth10;\n      const _CharT* _M_amonth11;\n      const _CharT* _M_amonth12;\n\n      bool _M_allocated;\n\n      __timepunct_cache(size_t __refs = 0) : facet(__refs),\n      _M_date_format(0), _'
[#] parse_declaration, is_constructor=False, meet line: '_CharT* _M_amonth11;\n      const _CharT* _M_amonth12;\n\n      bool _M_allocated;\n\n      __timepunct_cache(size_t __refs = 0) : facet(__refs),\n      _M_date_format(0), _M_date_era_format(0), _M_time_for'
[#] parse_declaration, is_constructor=False, meet line: '_CharT* _M_amonth12;\n\n      bool _M_allocated;\n\n      __timepunct_cache(size_t __refs = 0) : facet(__refs),\n      _M_date_format(0), _M_date_era_format(0), _M_time_format(0),\n      _M_time_era_format('
[#] parse_declaration, is_constructor=False, meet line: 'bool _M_allocated;\n\n      __timepunct_cache(size_t __refs = 0) : facet(__refs),\n      _M_date_format(0), _M_date_era_format(0), _M_time_format(0),\n      _M_time_era_format(0), _M_date_time_format(0),\n'
[#] parse_declaration, is_constructor=True, meet line: '__timepunct_cache(size_t __refs = 0) : facet(__refs),\n      _M_date_format(0), _M_date_era_format(0), _M_time_format(0),\n      _M_time_era_format(0), _M_date_time_format(0),\n      _M_date_time_era_for'
[#] parse_declaration, is_constructor=True, meet line: '__timepunct_cache();\n\n    private:\n      __timepunct_cache&\n      operator=(const __timepunct_cache&);\n\n      explicit\n      __timepunct_cache(const __timepunct_cache&);\n    };\n\n  template<typename _C'
[#] parse_declaration, is_constructor=True, meet line: '__timepunct_cache&\n      operator=(const __timepunct_cache&);\n\n      explicit\n      __timepunct_cache(const __timepunct_cache&);\n    };\n\n  template<typename _CharT>\n    __timepunct_cache<_CharT>::~__t'
[#] parse_declaration, is_constructor=True, meet line: '__timepunct_cache(const __timepunct_cache&);\n    };\n\n  template<typename _CharT>\n    __timepunct_cache<_CharT>::~__timepunct_cache()\n    {\n      if (_M_allocated)\n {\n\n }\n    }\n\n\n  template<>\n    const'
[#] parse_declaration, is_constructor=False, meet line: '__timepunct_cache<_CharT>::~__timepunct_cache()\n    {\n      if (_M_allocated)\n {\n\n }\n    }\n\n\n  template<>\n    const char*\n    __timepunct_cache<char>::_S_timezones[14];\n\n\n  template<>\n    const wchar_'
[#] parse_declaration, is_constructor=False, meet line: 'char*\n    __timepunct_cache<char>::_S_timezones[14];\n\n\n  template<>\n    const wchar_t*\n    __timepunct_cache<wchar_t>::_S_timezones[14];\n\n\n\n  template<typename _CharT>\n    const _CharT* __timepunct_ca'
[#] parse_declaration, is_constructor=False, meet line: 'wchar_t*\n    __timepunct_cache<wchar_t>::_S_timezones[14];\n\n\n\n  template<typename _CharT>\n    const _CharT* __timepunct_cache<_CharT>::_S_timezones[14];\n\n  template<typename _CharT>\n    class __timepu'
[#] parse_declaration, is_constructor=False, meet line: '_CharT* __timepunct_cache<_CharT>::_S_timezones[14];\n\n  template<typename _CharT>\n    class __timepunct : public locale::facet\n    {\n    public:\n\n      typedef _CharT __char_type;\n      typedef __time'
[#] parse_declaration, is_constructor=False, meet line: '__cache_type* _M_data;\n      __c_locale _M_c_locale_timepunct;\n      const char* _M_name_timepunct;\n\n    public:\n\n      static locale::id id;\n\n      explicit\n      __timepunct(size_t __refs = 0);\n\n   '
[#] parse_declaration, is_constructor=False, meet line: '__c_locale _M_c_locale_timepunct;\n      const char* _M_name_timepunct;\n\n    public:\n\n      static locale::id id;\n\n      explicit\n      __timepunct(size_t __refs = 0);\n\n      explicit\n      __timepunct'
[#] parse_declaration, is_constructor=False, meet line: 'char* _M_name_timepunct;\n\n    public:\n\n      static locale::id id;\n\n      explicit\n      __timepunct(size_t __refs = 0);\n\n      explicit\n      __timepunct(__cache_type* __cache, size_t __refs = 0);\n# '
[#] parse_declaration, is_constructor=False, meet line: 'locale::id id;\n\n      explicit\n      __timepunct(size_t __refs = 0);\n\n      explicit\n      __timepunct(__cache_type* __cache, size_t __refs = 0);\n# 206 "/usr/include/c++/7/bits/locale_facets_nonio.h" '
[#] parse_declaration, is_constructor=True, meet line: '__timepunct(size_t __refs = 0);\n\n      explicit\n      __timepunct(__cache_type* __cache, size_t __refs = 0);\n# 206 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n      explicit\n      __timepunct(__'
[#] parse_declaration, is_constructor=True, meet line: '__timepunct(__cache_type* __cache, size_t __refs = 0);\n# 206 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n      explicit\n      __timepunct(__c_locale __cloc, const char* __s, size_t __refs = 0);\n'
[#] parse_declaration, is_constructor=True, meet line: '__timepunct(__c_locale __cloc, const char* __s, size_t __refs = 0);\n\n\n\n      void\n      _M_put(_CharT* __s, size_t __maxlen, const _CharT* __format,\n      const tm* __tm) const throw ();\n\n      void\n '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_put(_CharT* __s, size_t __maxlen, const _CharT* __format,\n      const tm* __tm) const throw ();\n\n      void\n      _M_date_formats(const _CharT** __date) const\n      {\n\n __date[0] = _M_da'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_date_formats(const _CharT** __date) const\n      {\n\n __date[0] = _M_data->_M_date_format;\n __date[1] = _M_data->_M_date_era_format;\n      }\n\n      void\n      _M_time_formats(const _CharT*'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_time_formats(const _CharT** __time) const\n      {\n\n __time[0] = _M_data->_M_time_format;\n __time[1] = _M_data->_M_time_era_format;\n      }\n\n      void\n      _M_date_time_formats(const _C'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_date_time_formats(const _CharT** __dt) const\n      {\n\n __dt[0] = _M_data->_M_date_time_format;\n __dt[1] = _M_data->_M_date_time_era_format;\n      }\n\n      void\n      _M_am_pm_format(cons'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_am_pm_format(const _CharT* __ampm) const\n      { __ampm = _M_data->_M_am_pm_format; }\n\n      void\n      _M_am_pm(const _CharT** __ampm) const\n      {\n __ampm[0] = _M_data->_M_am;\n __ampm'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_am_pm(const _CharT** __ampm) const\n      {\n __ampm[0] = _M_data->_M_am;\n __ampm[1] = _M_data->_M_pm;\n      }\n\n      void\n      _M_days(const _CharT** __days) const\n      {\n __days[0] = _'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_days(const _CharT** __days) const\n      {\n __days[0] = _M_data->_M_day1;\n __days[1] = _M_data->_M_day2;\n __days[2] = _M_data->_M_day3;\n __days[3] = _M_data->_M_day4;\n __days[4] = _M_data'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_days_abbreviated(const _CharT** __days) const\n      {\n __days[0] = _M_data->_M_aday1;\n __days[1] = _M_data->_M_aday2;\n __days[2] = _M_data->_M_aday3;\n __days[3] = _M_data->_M_aday4;\n __d'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_months(const _CharT** __months) const\n      {\n __months[0] = _M_data->_M_month01;\n __months[1] = _M_data->_M_month02;\n __months[2] = _M_data->_M_month03;\n __months[3] = _M_data->_M_month'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_months_abbreviated(const _CharT** __months) const\n      {\n __months[0] = _M_data->_M_amonth01;\n __months[1] = _M_data->_M_amonth02;\n __months[2] = _M_data->_M_amonth03;\n __months[3] = _M'
[#] parse_declaration, is_constructor=True, meet line: '__timepunct();\n\n\n      void\n      _M_initialize_timepunct(__c_locale __cloc = 0);\n    };\n\n  template<typename _CharT>\n    locale::id __timepunct<_CharT>::id;\n\n\n  template<>\n    void\n    __timepunct<ch'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_initialize_timepunct(__c_locale __cloc = 0);\n    };\n\n  template<typename _CharT>\n    locale::id __timepunct<_CharT>::id;\n\n\n  template<>\n    void\n    __timepunct<char>::_M_initialize_time'
[#] parse_declaration, is_constructor=False, meet line: 'locale::id __timepunct<_CharT>::id;\n\n\n  template<>\n    void\n    __timepunct<char>::_M_initialize_timepunct(__c_locale __cloc);\n\n  template<>\n    void\n    __timepunct<char>::_M_put(char*, size_t, const'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    __timepunct<char>::_M_initialize_timepunct(__c_locale __cloc);\n\n  template<>\n    void\n    __timepunct<char>::_M_put(char*, size_t, const char*, const tm*) const throw ();\n\n\n  template<>\n    v'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    __timepunct<char>::_M_put(char*, size_t, const char*, const tm*) const throw ();\n\n\n  template<>\n    void\n    __timepunct<wchar_t>::_M_initialize_timepunct(__c_locale __cloc);\n\n  template<>\n  '
[#] parse_declaration, is_constructor=False, meet line: 'void\n    __timepunct<wchar_t>::_M_initialize_timepunct(__c_locale __cloc);\n\n  template<>\n    void\n    __timepunct<wchar_t>::_M_put(wchar_t*, size_t, const wchar_t*,\n     const tm*) const throw ();\n\n\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    __timepunct<wchar_t>::_M_put(wchar_t*, size_t, const wchar_t*,\n     const tm*) const throw ();\n\n\n\n}\n\n\n# 1 "/usr/include/x86_64-linux-gnu/c++/7/bits/time_members.h" 1 3\n# 37 "/usr/include/x86_'
[#] parse_declaration, is_constructor=False, meet line: '__timepunct<_CharT>::__timepunct(size_t __refs)\n    : facet(__refs), _M_data(0), _M_c_locale_timepunct(0),\n      _M_name_timepunct(_S_get_c_name())\n    { _M_initialize_timepunct(); }\n\n  template<typen'
[#] parse_declaration, is_constructor=False, meet line: '__timepunct<_CharT>::__timepunct(__cache_type* __cache, size_t __refs)\n    : facet(__refs), _M_data(__cache), _M_c_locale_timepunct(0),\n      _M_name_timepunct(_S_get_c_name())\n    { _M_initialize_tim'
[#] parse_declaration, is_constructor=False, meet line: '__timepunct<_CharT>::__timepunct(__c_locale __cloc, const char* __s,\n         size_t __refs)\n    : facet(__refs), _M_data(0), _M_c_locale_timepunct(0),\n      _M_name_timepunct(0)\n    {\n      if (__bui'
[#] parse_declaration, is_constructor=False, meet line: '__timepunct<_CharT>::~__timepunct()\n    {\n      if (_M_name_timepunct != _S_get_c_name())\n delete [] _M_name_timepunct;\n      delete _M_data;\n      _S_destroy_c_locale(_M_c_locale_timepunct);\n    }\n\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'locale::id id;\n# 386 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n      explicit\n      time_get(size_t __refs = 0)\n      : facet (__refs) { }\n# 403 "/usr/include/c++/7/bits/locale_facets_nonio.h"'
[#] parse_declaration, is_constructor=True, meet line: 'time_get(size_t __refs = 0)\n      : facet (__refs) { }\n# 403 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n      dateorder\n      date_order() const\n      { return this->do_date_order(); }\n# 427 "/'
[#] parse_declaration, is_constructor=False, meet line: 'dateorder\n      date_order() const\n      { return this->do_date_order(); }\n# 427 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n      iter_type\n      get_time(iter_type __beg, iter_type __end, ios_'
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      get_time(iter_type __beg, iter_type __end, ios_base& __io,\n        ios_base::iostate& __err, tm* __tm) const\n      { return this->do_get_time(__beg, __end, __io, __err, __tm); }\n# 452 '
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      get_date(iter_type __beg, iter_type __end, ios_base& __io,\n        ios_base::iostate& __err, tm* __tm) const\n      { return this->do_get_date(__beg, __end, __io, __err, __tm); }\n# 480 '
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      get_weekday(iter_type __beg, iter_type __end, ios_base& __io,\n    ios_base::iostate& __err, tm* __tm) const\n      { return this->do_get_weekday(__beg, __end, __io, __err, __tm); }\n# 50'
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      get_monthname(iter_type __beg, iter_type __end, ios_base& __io,\n      ios_base::iostate& __err, tm* __tm) const\n      { return this->do_get_monthname(__beg, __end, __io, __err, __tm); '
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      get_year(iter_type __beg, iter_type __end, ios_base& __io,\n        ios_base::iostate& __err, tm* __tm) const\n      { return this->do_get_year(__beg, __end, __io, __err, __tm); }\n# 556 '
[#] parse_declaration, is_constructor=False, meet line: 'iter_type get(iter_type __s, iter_type __end, ios_base& __io,\n                    ios_base::iostate& __err, tm* __tm, char __format,\n                    char __modifier = 0) const\n      {\n        retu'
[#] parse_declaration, is_constructor=False, meet line: 'iter_type get(iter_type __s, iter_type __end, ios_base& __io,\n                    ios_base::iostate& __err, tm* __tm, const char_type* __fmt,\n                    const char_type* __fmtend) const;\n\n\n  '
[#] parse_declaration, is_constructor=True, meet line: 'time_get() { }\n# 603 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n      virtual dateorder\n      do_date_order() const;\n# 621 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n      virtual iter_t'
[#] parse_declaration, is_constructor=False, meet line: 'dateorder\n      do_date_order() const;\n# 621 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n      virtual iter_type\n      do_get_time(iter_type __beg, iter_type __end, ios_base& __io,\n    ios_base:'
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      do_get_time(iter_type __beg, iter_type __end, ios_base& __io,\n    ios_base::iostate& __err, tm* __tm) const;\n# 640 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n      virtual iter_'
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      do_get_date(iter_type __beg, iter_type __end, ios_base& __io,\n    ios_base::iostate& __err, tm* __tm) const;\n# 659 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n      virtual iter_'
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      do_get_weekday(iter_type __beg, iter_type __end, ios_base&,\n       ios_base::iostate& __err, tm* __tm) const;\n# 678 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n      virtual iter'
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      do_get_monthname(iter_type __beg, iter_type __end, ios_base&,\n         ios_base::iostate& __err, tm* __tm) const;\n# 697 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n      virtual '
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      do_get_year(iter_type __beg, iter_type __end, ios_base& __io,\n    ios_base::iostate& __err, tm* __tm) const;\n# 720 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n      virtual\n\n    '
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      do_get(iter_type __s, iter_type __end, ios_base& __f,\n             ios_base::iostate& __err, tm* __tm,\n             char __format, char __modifier) const;\n\n\n\n      iter_type\n      _M_e'
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      _M_extract_num(iter_type __beg, iter_type __end, int& __member,\n       int __min, int __max, size_t __len,\n       ios_base& __io, ios_base::iostate& __err) const;\n\n\n      iter_type\n   '
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      _M_extract_name(iter_type __beg, iter_type __end, int& __member,\n        const _CharT** __names, size_t __indexlen,\n        ios_base& __io, ios_base::iostate& __err) const;\n\n\n      ite'
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      _M_extract_wday_or_month(iter_type __beg, iter_type __end, int& __member,\n          const _CharT** __names, size_t __indexlen,\n          ios_base& __io, ios_base::iostate& __err) const'
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      _M_extract_via_format(iter_type __beg, iter_type __end, ios_base& __io,\n       ios_base::iostate& __err, tm* __tm,\n       const _CharT* __format) const;\n    };\n\n  template<typename _Ch'
[#] parse_declaration, is_constructor=False, meet line: 'locale::id time_get<_CharT, _InIter>::id;\n\n\n  template<typename _CharT, typename _InIter>\n    class time_get_byname : public time_get<_CharT, _InIter>\n    {\n    public:\n\n      typedef _CharT char_type'
[#] parse_declaration, is_constructor=True, meet line: 'time_get_byname(const char*, size_t __refs = 0)\n      : time_get<_CharT, _InIter>(__refs) { }\n\n\n      explicit\n      time_get_byname(const string& __s, size_t __refs = 0)\n      : time_get_byname(__s.c'
[#] parse_declaration, is_constructor=True, meet line: 'time_get_byname(const string& __s, size_t __refs = 0)\n      : time_get_byname(__s.c_str(), __refs) { }\n\n\n    protected:\n      virtual\n      ~time_get_byname() { }\n    };\n\n}\n# 794 "/usr/include/c++/7/b'
[#] parse_declaration, is_constructor=True, meet line: 'time_get_byname() { }\n    };\n\n}\n# 794 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n  template<typename _CharT, typename _OutIter>\n    class time_put : public locale::facet\n    {\n    public:\n\n\n\n  '
[#] parse_declaration, is_constructor=False, meet line: 'locale::id id;\n# 815 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n      explicit\n      time_put(size_t __refs = 0)\n      : facet(__refs) { }\n# 834 "/usr/include/c++/7/bits/locale_facets_nonio.h" '
[#] parse_declaration, is_constructor=True, meet line: 'time_put(size_t __refs = 0)\n      : facet(__refs) { }\n# 834 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n      iter_type\n      put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,'
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,\n   const _CharT* __beg, const _CharT* __end) const;\n# 854 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n      i'
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      put(iter_type __s, ios_base& __io, char_type __fill,\n   const tm* __tm, char __format, char __mod = 0) const\n      { return this->do_put(__s, __io, __fill, __tm, __format, __mod); }\n\n '
[#] parse_declaration, is_constructor=True, meet line: 'time_put()\n      { }\n# 881 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n      virtual iter_type\n      do_put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,\n      char __format, '
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      do_put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,\n      char __format, char __mod) const;\n    };\n\n  template<typename _CharT, typename _OutIter>\n    locale::id ti'
[#] parse_declaration, is_constructor=False, meet line: 'locale::id time_put<_CharT, _OutIter>::id;\n\n\n  template<typename _CharT, typename _OutIter>\n    class time_put_byname : public time_put<_CharT, _OutIter>\n    {\n    public:\n\n      typedef _CharT char_t'
[#] parse_declaration, is_constructor=True, meet line: 'time_put_byname(const char*, size_t __refs = 0)\n      : time_put<_CharT, _OutIter>(__refs)\n      { };\n\n\n      explicit\n      time_put_byname(const string& __s, size_t __refs = 0)\n      : time_put_byna'
[#] parse_declaration, is_constructor=True, meet line: 'time_put_byname(const string& __s, size_t __refs = 0)\n      : time_put_byname(__s.c_str(), __refs) { }\n\n\n    protected:\n      virtual\n      ~time_put_byname() { }\n    };\n# 926 "/usr/include/c++/7/bits'
[#] parse_declaration, is_constructor=True, meet line: 'time_put_byname() { }\n    };\n# 926 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n  class money_base\n  {\n  public:\n    enum part { none, space, symbol, sign, value };\n    struct pattern { char fiel'
[#] parse_declaration, is_constructor=False, meet line: 'char field[4]; };\n\n    static const pattern _S_default_pattern;\n\n    enum\n    {\n      _S_minus,\n      _S_zero,\n      _S_end = 11\n    };\n\n\n\n    static const char* _S_atoms;\n\n\n\n    __attribute__ ((__con'
[#] parse_declaration, is_constructor=False, meet line: 'pattern _S_default_pattern;\n\n    enum\n    {\n      _S_minus,\n      _S_zero,\n      _S_end = 11\n    };\n\n\n\n    static const char* _S_atoms;\n\n\n\n    __attribute__ ((__const__)) static pattern\n    _S_constru'
[#] parse_declaration, is_constructor=False, meet line: 'char* _S_atoms;\n\n\n\n    __attribute__ ((__const__)) static pattern\n    _S_construct_pattern(char __precedes, char __space, char __posn) throw ();\n  };\n\n  template<typename _CharT, bool _Intl>\n    struc'
[#] parse_declaration, is_constructor=False, meet line: '__attribute__ ((__const__)) static pattern\n    _S_construct_pattern(char __precedes, char __space, char __posn) throw ();\n  };\n\n  template<typename _CharT, bool _Intl>\n    struct __moneypunct_cache : '
[#] parse_declaration, is_constructor=False, meet line: 'char* _M_grouping;\n      size_t _M_grouping_size;\n      bool _M_use_grouping;\n      _CharT _M_decimal_point;\n      _CharT _M_thousands_sep;\n      const _CharT* _M_curr_symbol;\n      size_t _M_curr_sym'
[#] parse_declaration, is_constructor=False, meet line: 'size_t _M_grouping_size;\n      bool _M_use_grouping;\n      _CharT _M_decimal_point;\n      _CharT _M_thousands_sep;\n      const _CharT* _M_curr_symbol;\n      size_t _M_curr_symbol_size;\n      const _Ch'
[#] parse_declaration, is_constructor=False, meet line: 'bool _M_use_grouping;\n      _CharT _M_decimal_point;\n      _CharT _M_thousands_sep;\n      const _CharT* _M_curr_symbol;\n      size_t _M_curr_symbol_size;\n      const _CharT* _M_positive_sign;\n      si'
[#] parse_declaration, is_constructor=False, meet line: '_CharT _M_decimal_point;\n      _CharT _M_thousands_sep;\n      const _CharT* _M_curr_symbol;\n      size_t _M_curr_symbol_size;\n      const _CharT* _M_positive_sign;\n      size_t _M_positive_sign_size;\n'
[#] parse_declaration, is_constructor=False, meet line: '_CharT _M_thousands_sep;\n      const _CharT* _M_curr_symbol;\n      size_t _M_curr_symbol_size;\n      const _CharT* _M_positive_sign;\n      size_t _M_positive_sign_size;\n      const _CharT* _M_negative'
[#] parse_declaration, is_constructor=False, meet line: '_CharT* _M_curr_symbol;\n      size_t _M_curr_symbol_size;\n      const _CharT* _M_positive_sign;\n      size_t _M_positive_sign_size;\n      const _CharT* _M_negative_sign;\n      size_t _M_negative_sign_'
[#] parse_declaration, is_constructor=False, meet line: 'size_t _M_curr_symbol_size;\n      const _CharT* _M_positive_sign;\n      size_t _M_positive_sign_size;\n      const _CharT* _M_negative_sign;\n      size_t _M_negative_sign_size;\n      int _M_frac_digits'
[#] parse_declaration, is_constructor=False, meet line: '_CharT* _M_positive_sign;\n      size_t _M_positive_sign_size;\n      const _CharT* _M_negative_sign;\n      size_t _M_negative_sign_size;\n      int _M_frac_digits;\n      money_base::pattern _M_pos_forma'
[#] parse_declaration, is_constructor=False, meet line: 'size_t _M_positive_sign_size;\n      const _CharT* _M_negative_sign;\n      size_t _M_negative_sign_size;\n      int _M_frac_digits;\n      money_base::pattern _M_pos_format;\n      money_base::pattern _M_'
[#] parse_declaration, is_constructor=False, meet line: '_CharT* _M_negative_sign;\n      size_t _M_negative_sign_size;\n      int _M_frac_digits;\n      money_base::pattern _M_pos_format;\n      money_base::pattern _M_neg_format;\n\n\n\n\n      _CharT _M_atoms[mone'
[#] parse_declaration, is_constructor=False, meet line: 'size_t _M_negative_sign_size;\n      int _M_frac_digits;\n      money_base::pattern _M_pos_format;\n      money_base::pattern _M_neg_format;\n\n\n\n\n      _CharT _M_atoms[money_base::_S_end];\n\n      bool _M_'
[#] parse_declaration, is_constructor=False, meet line: 'int _M_frac_digits;\n      money_base::pattern _M_pos_format;\n      money_base::pattern _M_neg_format;\n\n\n\n\n      _CharT _M_atoms[money_base::_S_end];\n\n      bool _M_allocated;\n\n      __moneypunct_cache'
[#] parse_declaration, is_constructor=False, meet line: 'money_base::pattern _M_pos_format;\n      money_base::pattern _M_neg_format;\n\n\n\n\n      _CharT _M_atoms[money_base::_S_end];\n\n      bool _M_allocated;\n\n      __moneypunct_cache(size_t __refs = 0) : face'
[#] parse_declaration, is_constructor=False, meet line: 'money_base::pattern _M_neg_format;\n\n\n\n\n      _CharT _M_atoms[money_base::_S_end];\n\n      bool _M_allocated;\n\n      __moneypunct_cache(size_t __refs = 0) : facet(__refs),\n      _M_grouping(0), _M_group'
[#] parse_declaration, is_constructor=False, meet line: '_CharT _M_atoms[money_base::_S_end];\n\n      bool _M_allocated;\n\n      __moneypunct_cache(size_t __refs = 0) : facet(__refs),\n      _M_grouping(0), _M_grouping_size(0), _M_use_grouping(false),\n      _M'
[#] parse_declaration, is_constructor=False, meet line: 'bool _M_allocated;\n\n      __moneypunct_cache(size_t __refs = 0) : facet(__refs),\n      _M_grouping(0), _M_grouping_size(0), _M_use_grouping(false),\n      _M_decimal_point(_CharT()), _M_thousands_sep(_'
[#] parse_declaration, is_constructor=True, meet line: '__moneypunct_cache(size_t __refs = 0) : facet(__refs),\n      _M_grouping(0), _M_grouping_size(0), _M_use_grouping(false),\n      _M_decimal_point(_CharT()), _M_thousands_sep(_CharT()),\n      _M_curr_sy'
[#] parse_declaration, is_constructor=True, meet line: '__moneypunct_cache();\n\n      void\n      _M_cache(const locale& __loc);\n\n    private:\n      __moneypunct_cache&\n      operator=(const __moneypunct_cache&);\n\n      explicit\n      __moneypunct_cache(cons'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_cache(const locale& __loc);\n\n    private:\n      __moneypunct_cache&\n      operator=(const __moneypunct_cache&);\n\n      explicit\n      __moneypunct_cache(const __moneypunct_cache&);\n    }'
[#] parse_declaration, is_constructor=True, meet line: '__moneypunct_cache&\n      operator=(const __moneypunct_cache&);\n\n      explicit\n      __moneypunct_cache(const __moneypunct_cache&);\n    };\n\n  template<typename _CharT, bool _Intl>\n    __moneypunct_ca'
[#] parse_declaration, is_constructor=True, meet line: '__moneypunct_cache(const __moneypunct_cache&);\n    };\n\n  template<typename _CharT, bool _Intl>\n    __moneypunct_cache<_CharT, _Intl>::~__moneypunct_cache()\n    {\n      if (_M_allocated)\n {\n   delete ['
[#] parse_declaration, is_constructor=False, meet line: '__moneypunct_cache<_CharT, _Intl>::~__moneypunct_cache()\n    {\n      if (_M_allocated)\n {\n   delete [] _M_grouping;\n   delete [] _M_curr_symbol;\n   delete [] _M_positive_sign;\n   delete [] _M_negative'
[#] parse_declaration, is_constructor=False, meet line: '__cache_type* _M_data;\n\n    public:\n\n\n      static const bool intl = _Intl;\n\n      static locale::id id;\n# 1050 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n      explicit\n      moneypunct(size_t'
[#] parse_declaration, is_constructor=False, meet line: 'bool intl = _Intl;\n\n      static locale::id id;\n# 1050 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n      explicit\n      moneypunct(size_t __refs = 0)\n      : facet(__refs), _M_data(0)\n      { _M'
[#] parse_declaration, is_constructor=False, meet line: 'locale::id id;\n# 1050 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n      explicit\n      moneypunct(size_t __refs = 0)\n      : facet(__refs), _M_data(0)\n      { _M_initialize_moneypunct(); }\n# 106'
[#] parse_declaration, is_constructor=True, meet line: 'moneypunct(size_t __refs = 0)\n      : facet(__refs), _M_data(0)\n      { _M_initialize_moneypunct(); }\n# 1063 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n      explicit\n      moneypunct(__cache_t'
[#] parse_declaration, is_constructor=True, meet line: 'moneypunct(__cache_type* __cache, size_t __refs = 0)\n      : facet(__refs), _M_data(__cache)\n      { _M_initialize_moneypunct(); }\n# 1078 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n      explic'
[#] parse_declaration, is_constructor=True, meet line: 'moneypunct(__c_locale __cloc, const char* __s, size_t __refs = 0)\n      : facet(__refs), _M_data(0)\n      { _M_initialize_moneypunct(__cloc, __s); }\n# 1092 "/usr/include/c++/7/bits/locale_facets_nonio'
[#] parse_declaration, is_constructor=False, meet line: 'char_type\n      decimal_point() const\n      { return this->do_decimal_point(); }\n# 1105 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n      char_type\n      thousands_sep() const\n      { return thi'
[#] parse_declaration, is_constructor=False, meet line: 'char_type\n      thousands_sep() const\n      { return this->do_thousands_sep(); }\n# 1135 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n      string\n      grouping() const\n      { return this->do_gr'
[#] parse_declaration, is_constructor=False, meet line: 'string\n      grouping() const\n      { return this->do_grouping(); }\n# 1148 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n      string_type\n      curr_symbol() const\n      { return this->do_curr_sy'
[#] parse_declaration, is_constructor=False, meet line: 'string_type\n      curr_symbol() const\n      { return this->do_curr_symbol(); }\n# 1165 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n      string_type\n      positive_sign() const\n      { return thi'
[#] parse_declaration, is_constructor=False, meet line: 'string_type\n      positive_sign() const\n      { return this->do_positive_sign(); }\n# 1182 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n      string_type\n      negative_sign() const\n      { return'
[#] parse_declaration, is_constructor=False, meet line: 'string_type\n      negative_sign() const\n      { return this->do_negative_sign(); }\n# 1198 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n      int\n      frac_digits() const\n      { return this->do_'
[#] parse_declaration, is_constructor=False, meet line: 'int\n      frac_digits() const\n      { return this->do_frac_digits(); }\n# 1234 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n      pattern\n      pos_format() const\n      { return this->do_pos_forma'
[#] parse_declaration, is_constructor=False, meet line: 'pattern\n      pos_format() const\n      { return this->do_pos_format(); }\n\n      pattern\n      neg_format() const\n      { return this->do_neg_format(); }\n\n\n    protected:\n\n      virtual\n      ~moneypun'
[#] parse_declaration, is_constructor=False, meet line: 'pattern\n      neg_format() const\n      { return this->do_neg_format(); }\n\n\n    protected:\n\n      virtual\n      ~moneypunct();\n# 1256 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n      virtual cha'
[#] parse_declaration, is_constructor=True, meet line: 'moneypunct();\n# 1256 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n      virtual char_type\n      do_decimal_point() const\n      { return _M_data->_M_decimal_point; }\n# 1268 "/usr/include/c++/7/bit'
[#] parse_declaration, is_constructor=False, meet line: 'char_type\n      do_decimal_point() const\n      { return _M_data->_M_decimal_point; }\n# 1268 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n      virtual char_type\n      do_thousands_sep() const\n   '
[#] parse_declaration, is_constructor=False, meet line: 'char_type\n      do_thousands_sep() const\n      { return _M_data->_M_thousands_sep; }\n# 1281 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n      virtual string\n      do_grouping() const\n      { ret'
[#] parse_declaration, is_constructor=False, meet line: 'string\n      do_grouping() const\n      { return _M_data->_M_grouping; }\n# 1294 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n      virtual string_type\n      do_curr_symbol() const\n      { return _'
[#] parse_declaration, is_constructor=False, meet line: 'string_type\n      do_curr_symbol() const\n      { return _M_data->_M_curr_symbol; }\n# 1307 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n      virtual string_type\n      do_positive_sign() const\n   '
[#] parse_declaration, is_constructor=False, meet line: 'string_type\n      do_positive_sign() const\n      { return _M_data->_M_positive_sign; }\n# 1320 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n      virtual string_type\n      do_negative_sign() const'
[#] parse_declaration, is_constructor=False, meet line: 'string_type\n      do_negative_sign() const\n      { return _M_data->_M_negative_sign; }\n# 1334 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n      virtual int\n      do_frac_digits() const\n      { r'
[#] parse_declaration, is_constructor=False, meet line: 'int\n      do_frac_digits() const\n      { return _M_data->_M_frac_digits; }\n# 1348 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n      virtual pattern\n      do_pos_format() const\n      { return _M_'
[#] parse_declaration, is_constructor=False, meet line: 'pattern\n      do_pos_format() const\n      { return _M_data->_M_pos_format; }\n# 1362 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n      virtual pattern\n      do_neg_format() const\n      { return _'
[#] parse_declaration, is_constructor=False, meet line: 'pattern\n      do_neg_format() const\n      { return _M_data->_M_neg_format; }\n\n\n       void\n       _M_initialize_moneypunct(__c_locale __cloc = 0,\n    const char* __name = 0);\n    };\n\n  template<typena'
[#] parse_declaration, is_constructor=False, meet line: 'void\n       _M_initialize_moneypunct(__c_locale __cloc = 0,\n    const char* __name = 0);\n    };\n\n  template<typename _CharT, bool _Intl>\n    locale::id moneypunct<_CharT, _Intl>::id;\n\n  template<typen'
[#] parse_declaration, is_constructor=False, meet line: 'locale::id moneypunct<_CharT, _Intl>::id;\n\n  template<typename _CharT, bool _Intl>\n    const bool moneypunct<_CharT, _Intl>::intl;\n\n  template<>\n    moneypunct<char, true>::~moneypunct();\n\n  template<'
[#] parse_declaration, is_constructor=False, meet line: 'bool moneypunct<_CharT, _Intl>::intl;\n\n  template<>\n    moneypunct<char, true>::~moneypunct();\n\n  template<>\n    moneypunct<char, false>::~moneypunct();\n\n  template<>\n    void\n    moneypunct<char, tru'
[#] parse_declaration, is_constructor=False, meet line: 'moneypunct<char, true>::~moneypunct();\n\n  template<>\n    moneypunct<char, false>::~moneypunct();\n\n  template<>\n    void\n    moneypunct<char, true>::_M_initialize_moneypunct(__c_locale, const char*);\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'moneypunct<char, false>::~moneypunct();\n\n  template<>\n    void\n    moneypunct<char, true>::_M_initialize_moneypunct(__c_locale, const char*);\n\n  template<>\n    void\n    moneypunct<char, false>::_M_ini'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    moneypunct<char, true>::_M_initialize_moneypunct(__c_locale, const char*);\n\n  template<>\n    void\n    moneypunct<char, false>::_M_initialize_moneypunct(__c_locale, const char*);\n\n\n  template<'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    moneypunct<char, false>::_M_initialize_moneypunct(__c_locale, const char*);\n\n\n  template<>\n    moneypunct<wchar_t, true>::~moneypunct();\n\n  template<>\n    moneypunct<wchar_t, false>::~moneypu'
[#] parse_declaration, is_constructor=False, meet line: 'moneypunct<wchar_t, true>::~moneypunct();\n\n  template<>\n    moneypunct<wchar_t, false>::~moneypunct();\n\n  template<>\n    void\n    moneypunct<wchar_t, true>::_M_initialize_moneypunct(__c_locale,\n      '
[#] parse_declaration, is_constructor=False, meet line: 'moneypunct<wchar_t, false>::~moneypunct();\n\n  template<>\n    void\n    moneypunct<wchar_t, true>::_M_initialize_moneypunct(__c_locale,\n       const char*);\n\n  template<>\n    void\n    moneypunct<wchar_t'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    moneypunct<wchar_t, true>::_M_initialize_moneypunct(__c_locale,\n       const char*);\n\n  template<>\n    void\n    moneypunct<wchar_t, false>::_M_initialize_moneypunct(__c_locale,\n        const '
[#] parse_declaration, is_constructor=False, meet line: 'void\n    moneypunct<wchar_t, false>::_M_initialize_moneypunct(__c_locale,\n        const char*);\n\n\n\n  template<typename _CharT, bool _Intl>\n    class moneypunct_byname : public moneypunct<_CharT, _Intl'
[#] parse_declaration, is_constructor=False, meet line: 'bool intl = _Intl;\n\n      explicit\n      moneypunct_byname(const char* __s, size_t __refs = 0)\n      : moneypunct<_CharT, _Intl>(__refs)\n      {\n if (__builtin_strcmp(__s, "C") != 0\n     && __builtin_'
[#] parse_declaration, is_constructor=True, meet line: 'moneypunct_byname(const char* __s, size_t __refs = 0)\n      : moneypunct<_CharT, _Intl>(__refs)\n      {\n if (__builtin_strcmp(__s, "C") != 0\n     && __builtin_strcmp(__s, "POSIX") != 0)\n   {\n     __c_'
[#] parse_declaration, is_constructor=True, meet line: 'moneypunct_byname(const string& __s, size_t __refs = 0)\n      : moneypunct_byname(__s.c_str(), __refs) { }\n\n\n    protected:\n      virtual\n      ~moneypunct_byname() { }\n    };\n\n  template<typename _Ch'
[#] parse_declaration, is_constructor=True, meet line: 'moneypunct_byname() { }\n    };\n\n  template<typename _CharT, bool _Intl>\n    const bool moneypunct_byname<_CharT, _Intl>::intl;\n\n}\n\nnamespace __cxx11 {\n# 1465 "/usr/include/c++/7/bits/locale_facets_non'
[#] parse_declaration, is_constructor=False, meet line: 'bool moneypunct_byname<_CharT, _Intl>::intl;\n\n}\n\nnamespace __cxx11 {\n# 1465 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n  template<typename _CharT, typename _InIter>\n    class money_get : public'
[#] parse_declaration, is_constructor=False, meet line: 'locale::id id;\n# 1487 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n      explicit\n      money_get(size_t __refs = 0) : facet(__refs) { }\n# 1517 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n '
[#] parse_declaration, is_constructor=True, meet line: 'money_get(size_t __refs = 0) : facet(__refs) { }\n# 1517 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n      iter_type\n      get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,\n   ios_'
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,\n   ios_base::iostate& __err, long double& __units) const\n      { return this->do_get(__s, __end, __intl, __io, __err, _'
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,\n   ios_base::iostate& __err, string_type& __digits) const\n      { return this->do_get(__s, __end, __intl, __io, __err, '
[#] parse_declaration, is_constructor=True, meet line: 'money_get() { }\n# 1572 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n      virtual iter_type\n      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,\n      ios_base::iostate& __er'
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,\n      ios_base::iostate& __err, long double& __units) const;\n# 1584 "/usr/include/c++/7/bits/locale_facets_nonio.h" '
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,\n      ios_base::iostate& __err, string_type& __digits) const;\n# 1596 "/usr/include/c++/7/bits/locale_facets_nonio.h"'
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n        _M_extract(iter_type __s, iter_type __end, ios_base& __io,\n     ios_base::iostate& __err, string& __digits) const;\n    };\n\n  template<typename _CharT, typename _InIter>\n    locale::i'
[#] parse_declaration, is_constructor=False, meet line: 'locale::id money_get<_CharT, _InIter>::id;\n# 1618 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n  template<typename _CharT, typename _OutIter>\n    class money_put : public locale::facet\n    {\n    '
[#] parse_declaration, is_constructor=False, meet line: 'locale::id id;\n# 1639 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n      explicit\n      money_put(size_t __refs = 0) : facet(__refs) { }\n# 1659 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n '
[#] parse_declaration, is_constructor=True, meet line: 'money_put(size_t __refs = 0) : facet(__refs) { }\n# 1659 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n      iter_type\n      put(iter_type __s, bool __intl, ios_base& __io,\n   char_type __fill, lon'
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      put(iter_type __s, bool __intl, ios_base& __io,\n   char_type __fill, long double __units) const\n      { return this->do_put(__s, __intl, __io, __fill, __units); }\n# 1682 "/usr/include/'
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      put(iter_type __s, bool __intl, ios_base& __io,\n   char_type __fill, const string_type& __digits) const\n      { return this->do_put(__s, __intl, __io, __fill, __digits); }\n\n    protect'
[#] parse_declaration, is_constructor=True, meet line: 'money_put() { }\n# 1717 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n      virtual iter_type\n      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,\n      long double __units) c'
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,\n      long double __units) const;\n# 1741 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n      virtual iter_type\n'
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,\n      const string_type& __digits) const;\n# 1753 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n      template<b'
[#] parse_declaration, is_constructor=False, meet line: 'iter_type\n        _M_insert(iter_type __s, ios_base& __io, char_type __fill,\n    const string_type& __digits) const;\n    };\n\n  template<typename _CharT, typename _OutIter>\n    locale::id money_put<_Ch'
[#] parse_declaration, is_constructor=False, meet line: 'locale::id money_put<_CharT, _OutIter>::id;\n\n}\n\n\n\n\n\n  struct messages_base\n  {\n    typedef int catalog;\n  };\n\nnamespace __cxx11 {\n# 1796 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n  template<ty'
[#] parse_declaration, is_constructor=False, meet line: '__c_locale _M_c_locale_messages;\n      const char* _M_name_messages;\n\n    public:\n\n      static locale::id id;\n# 1824 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n      explicit\n      messages(si'
[#] parse_declaration, is_constructor=False, meet line: 'char* _M_name_messages;\n\n    public:\n\n      static locale::id id;\n# 1824 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n      explicit\n      messages(size_t __refs = 0);\n# 1838 "/usr/include/c++/7/'
[#] parse_declaration, is_constructor=False, meet line: 'locale::id id;\n# 1824 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n      explicit\n      messages(size_t __refs = 0);\n# 1838 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n      explicit\n      '
[#] parse_declaration, is_constructor=True, meet line: 'messages(size_t __refs = 0);\n# 1838 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n      explicit\n      messages(__c_locale __cloc, const char* __s, size_t __refs = 0);\n# 1851 "/usr/include/c++/7/b'
[#] parse_declaration, is_constructor=True, meet line: 'messages(__c_locale __cloc, const char* __s, size_t __refs = 0);\n# 1851 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n      catalog\n      open(const basic_string<char>& __s, const locale& __loc) c'
[#] parse_declaration, is_constructor=False, meet line: 'catalog\n      open(const basic_string<char>& __s, const locale& __loc) const\n      { return this->do_open(__s, __loc); }\n# 1869 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n      catalog\n      op'
[#] parse_declaration, is_constructor=False, meet line: 'catalog\n      open(const basic_string<char>&, const locale&, const char*) const;\n# 1887 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n      string_type\n      get(catalog __c, int __set, int __msgi'
[#] parse_declaration, is_constructor=False, meet line: 'string_type\n      get(catalog __c, int __set, int __msgid, const string_type& __s) const\n      { return this->do_get(__c, __set, __msgid, __s); }\n# 1898 "/usr/include/c++/7/bits/locale_facets_nonio.h"'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      close(catalog __c) const\n      { return this->do_close(__c); }\n\n    protected:\n\n      virtual\n      ~messages();\n# 1918 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n      virtual catal'
[#] parse_declaration, is_constructor=True, meet line: 'messages();\n# 1918 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n      virtual catalog\n      do_open(const basic_string<char>&, const locale&) const;\n# 1937 "/usr/include/c++/7/bits/locale_facets_'
[#] parse_declaration, is_constructor=False, meet line: 'catalog\n      do_open(const basic_string<char>&, const locale&) const;\n# 1937 "/usr/include/c++/7/bits/locale_facets_nonio.h" 3\n      virtual string_type\n      do_get(catalog, int, int, const string_t'
[#] parse_declaration, is_constructor=False, meet line: 'string_type\n      do_get(catalog, int, int, const string_type& __dfault) const;\n\n\n\n\n\n\n      virtual void\n      do_close(catalog) const;\n\n\n      char*\n      _M_convert_to_char(const string_type& __msg)'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      do_close(catalog) const;\n\n\n      char*\n      _M_convert_to_char(const string_type& __msg) const\n      {\n\n return reinterpret_cast<char*>(const_cast<_CharT*>(__msg.c_str()));\n      }\n\n\n     '
[#] parse_declaration, is_constructor=False, meet line: 'char*\n      _M_convert_to_char(const string_type& __msg) const\n      {\n\n return reinterpret_cast<char*>(const_cast<_CharT*>(__msg.c_str()));\n      }\n\n\n      string_type\n      _M_convert_from_char(char'
[#] parse_declaration, is_constructor=False, meet line: 'string_type\n      _M_convert_from_char(char*) const\n      {\n\n return string_type();\n      }\n     };\n\n  template<typename _CharT>\n    locale::id messages<_CharT>::id;\n\n\n  template<>\n    string\n    mess'
[#] parse_declaration, is_constructor=False, meet line: 'locale::id messages<_CharT>::id;\n\n\n  template<>\n    string\n    messages<char>::do_get(catalog, int, int, const string&) const;\n\n\n  template<>\n    wstring\n    messages<wchar_t>::do_get(catalog, int, in'
[#] parse_declaration, is_constructor=False, meet line: 'string\n    messages<char>::do_get(catalog, int, int, const string&) const;\n\n\n  template<>\n    wstring\n    messages<wchar_t>::do_get(catalog, int, int, const wstring&) const;\n\n\n\n   template<typename _C'
[#] parse_declaration, is_constructor=False, meet line: 'wstring\n    messages<wchar_t>::do_get(catalog, int, int, const wstring&) const;\n\n\n\n   template<typename _CharT>\n    class messages_byname : public messages<_CharT>\n    {\n    public:\n      typedef _Cha'
[#] parse_declaration, is_constructor=True, meet line: 'messages_byname(const char* __s, size_t __refs = 0);\n\n\n      explicit\n      messages_byname(const string& __s, size_t __refs = 0)\n      : messages_byname(__s.c_str(), __refs) { }\n\n\n    protected:\n    '
[#] parse_declaration, is_constructor=True, meet line: 'messages_byname(const string& __s, size_t __refs = 0)\n      : messages_byname(__s.c_str(), __refs) { }\n\n\n    protected:\n      virtual\n      ~messages_byname()\n      { }\n    };\n\n}\n\n\n}\n\n\n# 1 "/usr/inclu'
[#] parse_declaration, is_constructor=True, meet line: 'messages_byname()\n      { }\n    };\n\n}\n\n\n}\n\n\n# 1 "/usr/include/x86_64-linux-gnu/c++/7/bits/messages_members.h" 1 3\n# 36 "/usr/include/x86_64-linux-gnu/c++/7/bits/messages_members.h" 3\n# 1 "/usr/include'
[#] parse_declaration, is_constructor=False, meet line: 'char *gettext (const char *__msgid)\n     throw () __attribute__ ((__format_arg__ (1)));\n\n\n\nextern char *dgettext (const char *__domainname, const char *__msgid)\n     throw () __attribute__ ((__format_'
[#] parse_declaration, is_constructor=False, meet line: 'char *dgettext (const char *__domainname, const char *__msgid)\n     throw () __attribute__ ((__format_arg__ (2)));\nextern char *__dgettext (const char *__domainname, const char *__msgid)\n     throw ()'
[#] parse_declaration, is_constructor=False, meet line: 'char *__dgettext (const char *__domainname, const char *__msgid)\n     throw () __attribute__ ((__format_arg__ (2)));\n\n\n\nextern char *dcgettext (const char *__domainname,\n   const char *__msgid, int __'
[#] parse_declaration, is_constructor=False, meet line: 'char *dcgettext (const char *__domainname,\n   const char *__msgid, int __category)\n     throw () __attribute__ ((__format_arg__ (2)));\nextern char *__dcgettext (const char *__domainname,\n     const ch'
[#] parse_declaration, is_constructor=False, meet line: 'char *__dcgettext (const char *__domainname,\n     const char *__msgid, int __category)\n     throw () __attribute__ ((__format_arg__ (2)));\n\n\n\n\nextern char *ngettext (const char *__msgid1, const char *'
[#] parse_declaration, is_constructor=False, meet line: 'char *ngettext (const char *__msgid1, const char *__msgid2,\n         unsigned long int __n)\n     throw () __attribute__ ((__format_arg__ (1))) __attribute__ ((__format_arg__ (2)));\n\n\n\nextern char *dng'
[#] parse_declaration, is_constructor=False, meet line: 'char *dngettext (const char *__domainname, const char *__msgid1,\n   const char *__msgid2, unsigned long int __n)\n     throw () __attribute__ ((__format_arg__ (2))) __attribute__ ((__format_arg__ (3)))'
[#] parse_declaration, is_constructor=False, meet line: 'char *dcngettext (const char *__domainname, const char *__msgid1,\n    const char *__msgid2, unsigned long int __n,\n    int __category)\n     throw () __attribute__ ((__format_arg__ (2))) __attribute__ '
[#] parse_declaration, is_constructor=False, meet line: 'char *textdomain (const char *__domainname) throw ();\n\n\n\nextern char *bindtextdomain (const char *__domainname,\n        const char *__dirname) throw ();\n\n\n\nextern char *bind_textdomain_codeset (const '
[#] parse_declaration, is_constructor=False, meet line: 'char *bindtextdomain (const char *__domainname,\n        const char *__dirname) throw ();\n\n\n\nextern char *bind_textdomain_codeset (const char *__domainname,\n          const char *__codeset) throw ();\n#'
[#] parse_declaration, is_constructor=False, meet line: 'char *bind_textdomain_codeset (const char *__domainname,\n          const char *__codeset) throw ();\n# 121 "/usr/include/libintl.h" 3 4\n}\n# 37 "/usr/include/x86_64-linux-gnu/c++/7/bits/messages_members'
[#] parse_declaration, is_constructor=False, meet line: 'messages<_CharT>::messages(size_t __refs)\n    : facet(__refs), _M_c_locale_messages(_S_get_c_locale()),\n      _M_name_messages(_S_get_c_name())\n    { }\n\n  template<typename _CharT>\n    messages<_CharT'
[#] parse_declaration, is_constructor=False, meet line: 'messages<_CharT>::messages(__c_locale __cloc, const char* __s,\n          size_t __refs)\n    : facet(__refs), _M_c_locale_messages(0), _M_name_messages(0)\n    {\n      if (__builtin_strcmp(__s, _S_get_c'
[#] parse_declaration, is_constructor=False, meet line: 'messages<_CharT>::catalog\n    messages<_CharT>::open(const basic_string<char>& __s, const locale& __loc,\n      const char* __dir) const\n    {\n      bindtextdomain(__s.c_str(), __dir);\n      return thi'
[#] parse_declaration, is_constructor=False, meet line: 'messages<_CharT>::~messages()\n    {\n      if (_M_name_messages != _S_get_c_name())\n delete [] _M_name_messages;\n      _S_destroy_c_locale(_M_c_locale_messages);\n    }\n\n  template<typename _CharT>\n    '
[#] parse_declaration, is_constructor=False, meet line: 'messages<_CharT>::catalog\n    messages<_CharT>::do_open(const basic_string<char>& __s,\n         const locale&) const\n    {\n\n\n      textdomain(__s.c_str());\n      return 0;\n    }\n\n  template<typename _'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    messages<_CharT>::do_close(catalog) const\n    { }\n\n\n  template<typename _CharT>\n    messages_byname<_CharT>::messages_byname(const char* __s, size_t __refs)\n    : messages<_CharT>(__refs)\n   '
[#] parse_declaration, is_constructor=False, meet line: 'messages_byname<_CharT>::messages_byname(const char* __s, size_t __refs)\n    : messages<_CharT>(__refs)\n    {\n      if (this->_M_name_messages != locale::facet::_S_get_c_name())\n {\n   delete [] this->'
[#] parse_declaration, is_constructor=False, meet line: 'messages<char>::catalog\n    messages<char>::do_open(const basic_string<char>&,\n       const locale&) const;\n\n  template<>\n    void\n    messages<char>::do_close(catalog) const;\n\n\n  template<>\n    typen'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    messages<char>::do_close(catalog) const;\n\n\n  template<>\n    typename messages<wchar_t>::catalog\n    messages<wchar_t>::do_open(const basic_string<char>&,\n          const locale&) const;\n\n  te'
[#] parse_declaration, is_constructor=False, meet line: 'messages<wchar_t>::catalog\n    messages<wchar_t>::do_open(const basic_string<char>&,\n          const locale&) const;\n\n  template<>\n    void\n    messages<wchar_t>::do_close(catalog) const;\n\n\n\n}\n# 2009 '
[#] parse_declaration, is_constructor=False, meet line: 'void\n    messages<wchar_t>::do_close(catalog) const;\n\n\n\n}\n# 2009 "/usr/include/c++/7/bits/locale_facets_nonio.h" 2 3\n\n\n# 1 "/usr/include/c++/7/bits/codecvt.h" 1 3\n# 39 "/usr/include/c++/7/bits/codecvt'
[#] parse_declaration, is_constructor=False, meet line: 'result\n      out(state_type& __state, const intern_type* __from,\n   const intern_type* __from_end, const intern_type*& __from_next,\n   extern_type* __to, extern_type* __to_end,\n   extern_type*& __to_n'
[#] parse_declaration, is_constructor=False, meet line: 'result\n      unshift(state_type& __state, extern_type* __to, extern_type* __to_end,\n       extern_type*& __to_next) const\n      { return this->do_unshift(__state, __to,__to_end,__to_next); }\n# 195 "/u'
[#] parse_declaration, is_constructor=False, meet line: 'result\n      in(state_type& __state, const extern_type* __from,\n  const extern_type* __from_end, const extern_type*& __from_next,\n  intern_type* __to, intern_type* __to_end,\n  intern_type*& __to_next)'
[#] parse_declaration, is_constructor=False, meet line: 'int\n      encoding() const throw()\n      { return this->do_encoding(); }\n\n      bool\n      always_noconv() const throw()\n      { return this->do_always_noconv(); }\n\n      int\n      length(state_type& '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      always_noconv() const throw()\n      { return this->do_always_noconv(); }\n\n      int\n      length(state_type& __state, const extern_type* __from,\n      const extern_type* __end, size_t __max'
[#] parse_declaration, is_constructor=False, meet line: 'int\n      length(state_type& __state, const extern_type* __from,\n      const extern_type* __end, size_t __max) const\n      { return this->do_length(__state, __from, __end, __max); }\n\n      int\n      m'
[#] parse_declaration, is_constructor=False, meet line: 'int\n      max_length() const throw()\n      { return this->do_max_length(); }\n\n    protected:\n      explicit\n      __codecvt_abstract_base(size_t __refs = 0) : locale::facet(__refs) { }\n\n      virtual\n'
[#] parse_declaration, is_constructor=True, meet line: '__codecvt_abstract_base(size_t __refs = 0) : locale::facet(__refs) { }\n\n      virtual\n      ~__codecvt_abstract_base() { }\n# 236 "/usr/include/c++/7/bits/codecvt.h" 3\n      virtual result\n      do_out'
[#] parse_declaration, is_constructor=True, meet line: '__codecvt_abstract_base() { }\n# 236 "/usr/include/c++/7/bits/codecvt.h" 3\n      virtual result\n      do_out(state_type& __state, const intern_type* __from,\n      const intern_type* __from_end, const i'
[#] parse_declaration, is_constructor=False, meet line: 'result\n      do_out(state_type& __state, const intern_type* __from,\n      const intern_type* __from_end, const intern_type*& __from_next,\n      extern_type* __to, extern_type* __to_end,\n      extern_t'
[#] parse_declaration, is_constructor=False, meet line: 'result\n      do_unshift(state_type& __state, extern_type* __to,\n   extern_type* __to_end, extern_type*& __to_next) const = 0;\n\n      virtual result\n      do_in(state_type& __state, const extern_type* '
[#] parse_declaration, is_constructor=False, meet line: 'result\n      do_in(state_type& __state, const extern_type* __from,\n     const extern_type* __from_end, const extern_type*& __from_next,\n     intern_type* __to, intern_type* __to_end,\n     intern_type*'
[#] parse_declaration, is_constructor=False, meet line: 'int\n      do_encoding() const throw() = 0;\n\n      virtual bool\n      do_always_noconv() const throw() = 0;\n\n      virtual int\n      do_length(state_type&, const extern_type* __from,\n  const extern_typ'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      do_always_noconv() const throw() = 0;\n\n      virtual int\n      do_length(state_type&, const extern_type* __from,\n  const extern_type* __end, size_t __max) const = 0;\n\n      virtual int\n    '
[#] parse_declaration, is_constructor=False, meet line: 'int\n      do_length(state_type&, const extern_type* __from,\n  const extern_type* __end, size_t __max) const = 0;\n\n      virtual int\n      do_max_length() const throw() = 0;\n    };\n# 273 "/usr/include/'
[#] parse_declaration, is_constructor=False, meet line: 'int\n      do_max_length() const throw() = 0;\n    };\n# 273 "/usr/include/c++/7/bits/codecvt.h" 3\n   template<typename _InternT, typename _ExternT, typename _StateT>\n    class codecvt\n    : public __cod'
[#] parse_declaration, is_constructor=False, meet line: '__c_locale _M_c_locale_codecvt;\n\n    public:\n      static locale::id id;\n\n      explicit\n      codecvt(size_t __refs = 0)\n      : __codecvt_abstract_base<_InternT, _ExternT, _StateT> (__refs),\n _M_c_l'
[#] parse_declaration, is_constructor=False, meet line: 'locale::id id;\n\n      explicit\n      codecvt(size_t __refs = 0)\n      : __codecvt_abstract_base<_InternT, _ExternT, _StateT> (__refs),\n _M_c_locale_codecvt(0)\n      { }\n\n      explicit\n      codecvt(_'
[#] parse_declaration, is_constructor=True, meet line: 'codecvt(size_t __refs = 0)\n      : __codecvt_abstract_base<_InternT, _ExternT, _StateT> (__refs),\n _M_c_locale_codecvt(0)\n      { }\n\n      explicit\n      codecvt(__c_locale __cloc, size_t __refs = 0);'
[#] parse_declaration, is_constructor=True, meet line: 'codecvt(__c_locale __cloc, size_t __refs = 0);\n\n    protected:\n      virtual\n      ~codecvt() { }\n\n      virtual result\n      do_out(state_type& __state, const intern_type* __from,\n      const intern_'
[#] parse_declaration, is_constructor=True, meet line: 'codecvt() { }\n\n      virtual result\n      do_out(state_type& __state, const intern_type* __from,\n      const intern_type* __from_end, const intern_type*& __from_next,\n      extern_type* __to, extern_t'
[#] parse_declaration, is_constructor=False, meet line: 'result\n      do_out(state_type& __state, const intern_type* __from,\n      const intern_type* __from_end, const intern_type*& __from_next,\n      extern_type* __to, extern_type* __to_end,\n      extern_t'
[#] parse_declaration, is_constructor=False, meet line: 'result\n      do_unshift(state_type& __state, extern_type* __to,\n   extern_type* __to_end, extern_type*& __to_next) const;\n\n      virtual result\n      do_in(state_type& __state, const extern_type* __fr'
[#] parse_declaration, is_constructor=False, meet line: 'result\n      do_in(state_type& __state, const extern_type* __from,\n     const extern_type* __from_end, const extern_type*& __from_next,\n     intern_type* __to, intern_type* __to_end,\n     intern_type*'
[#] parse_declaration, is_constructor=False, meet line: 'int\n      do_encoding() const throw();\n\n      virtual bool\n      do_always_noconv() const throw();\n\n      virtual int\n      do_length(state_type&, const extern_type* __from,\n  const extern_type* __end'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      do_always_noconv() const throw();\n\n      virtual int\n      do_length(state_type&, const extern_type* __from,\n  const extern_type* __end, size_t __max) const;\n\n      virtual int\n      do_max'
[#] parse_declaration, is_constructor=False, meet line: 'int\n      do_length(state_type&, const extern_type* __from,\n  const extern_type* __end, size_t __max) const;\n\n      virtual int\n      do_max_length() const throw();\n    };\n\n  template<typename _Intern'
[#] parse_declaration, is_constructor=False, meet line: 'int\n      do_max_length() const throw();\n    };\n\n  template<typename _InternT, typename _ExternT, typename _StateT>\n    locale::id codecvt<_InternT, _ExternT, _StateT>::id;\n\n\n  template<>\n    class co'
[#] parse_declaration, is_constructor=False, meet line: 'locale::id codecvt<_InternT, _ExternT, _StateT>::id;\n\n\n  template<>\n    class codecvt<char, char, mbstate_t>\n    : public __codecvt_abstract_base<char, char, mbstate_t>\n    {\n      friend class messag'
[#] parse_declaration, is_constructor=False, meet line: '__c_locale _M_c_locale_codecvt;\n\n    public:\n      static locale::id id;\n\n      explicit\n      codecvt(size_t __refs = 0);\n\n      explicit\n      codecvt(__c_locale __cloc, size_t __refs = 0);\n\n    pro'
[#] parse_declaration, is_constructor=False, meet line: 'locale::id id;\n\n      explicit\n      codecvt(size_t __refs = 0);\n\n      explicit\n      codecvt(__c_locale __cloc, size_t __refs = 0);\n\n    protected:\n      virtual\n      ~codecvt();\n\n      virtual res'
[#] parse_declaration, is_constructor=True, meet line: 'codecvt(size_t __refs = 0);\n\n      explicit\n      codecvt(__c_locale __cloc, size_t __refs = 0);\n\n    protected:\n      virtual\n      ~codecvt();\n\n      virtual result\n      do_out(state_type& __state,'
[#] parse_declaration, is_constructor=True, meet line: 'codecvt(__c_locale __cloc, size_t __refs = 0);\n\n    protected:\n      virtual\n      ~codecvt();\n\n      virtual result\n      do_out(state_type& __state, const intern_type* __from,\n      const intern_typ'
[#] parse_declaration, is_constructor=True, meet line: 'codecvt();\n\n      virtual result\n      do_out(state_type& __state, const intern_type* __from,\n      const intern_type* __from_end, const intern_type*& __from_next,\n      extern_type* __to, extern_type'
[#] parse_declaration, is_constructor=False, meet line: 'result\n      do_out(state_type& __state, const intern_type* __from,\n      const intern_type* __from_end, const intern_type*& __from_next,\n      extern_type* __to, extern_type* __to_end,\n      extern_t'
[#] parse_declaration, is_constructor=False, meet line: 'result\n      do_unshift(state_type& __state, extern_type* __to,\n   extern_type* __to_end, extern_type*& __to_next) const;\n\n      virtual result\n      do_in(state_type& __state, const extern_type* __fr'
[#] parse_declaration, is_constructor=False, meet line: 'result\n      do_in(state_type& __state, const extern_type* __from,\n     const extern_type* __from_end, const extern_type*& __from_next,\n     intern_type* __to, intern_type* __to_end,\n     intern_type*'
[#] parse_declaration, is_constructor=False, meet line: 'int\n      do_encoding() const throw();\n\n      virtual bool\n      do_always_noconv() const throw();\n\n      virtual int\n      do_length(state_type&, const extern_type* __from,\n  const extern_type* __end'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      do_always_noconv() const throw();\n\n      virtual int\n      do_length(state_type&, const extern_type* __from,\n  const extern_type* __end, size_t __max) const;\n\n      virtual int\n      do_max'
[#] parse_declaration, is_constructor=False, meet line: 'int\n      do_length(state_type&, const extern_type* __from,\n  const extern_type* __end, size_t __max) const;\n\n      virtual int\n      do_max_length() const throw();\n  };\n\n\n\n\n\n\n  template<>\n    class c'
[#] parse_declaration, is_constructor=False, meet line: 'int\n      do_max_length() const throw();\n  };\n\n\n\n\n\n\n  template<>\n    class codecvt<wchar_t, char, mbstate_t>\n    : public __codecvt_abstract_base<wchar_t, char, mbstate_t>\n    {\n      friend class mes'
[#] parse_declaration, is_constructor=False, meet line: '__c_locale _M_c_locale_codecvt;\n\n    public:\n      static locale::id id;\n\n      explicit\n      codecvt(size_t __refs = 0);\n\n      explicit\n      codecvt(__c_locale __cloc, size_t __refs = 0);\n\n    pro'
[#] parse_declaration, is_constructor=False, meet line: 'locale::id id;\n\n      explicit\n      codecvt(size_t __refs = 0);\n\n      explicit\n      codecvt(__c_locale __cloc, size_t __refs = 0);\n\n    protected:\n      virtual\n      ~codecvt();\n\n      virtual res'
[#] parse_declaration, is_constructor=True, meet line: 'codecvt(size_t __refs = 0);\n\n      explicit\n      codecvt(__c_locale __cloc, size_t __refs = 0);\n\n    protected:\n      virtual\n      ~codecvt();\n\n      virtual result\n      do_out(state_type& __state,'
[#] parse_declaration, is_constructor=True, meet line: 'codecvt(__c_locale __cloc, size_t __refs = 0);\n\n    protected:\n      virtual\n      ~codecvt();\n\n      virtual result\n      do_out(state_type& __state, const intern_type* __from,\n      const intern_typ'
[#] parse_declaration, is_constructor=True, meet line: 'codecvt();\n\n      virtual result\n      do_out(state_type& __state, const intern_type* __from,\n      const intern_type* __from_end, const intern_type*& __from_next,\n      extern_type* __to, extern_type'
[#] parse_declaration, is_constructor=False, meet line: 'result\n      do_out(state_type& __state, const intern_type* __from,\n      const intern_type* __from_end, const intern_type*& __from_next,\n      extern_type* __to, extern_type* __to_end,\n      extern_t'
[#] parse_declaration, is_constructor=False, meet line: 'result\n      do_unshift(state_type& __state,\n   extern_type* __to, extern_type* __to_end,\n   extern_type*& __to_next) const;\n\n      virtual result\n      do_in(state_type& __state,\n      const extern_t'
[#] parse_declaration, is_constructor=False, meet line: 'result\n      do_in(state_type& __state,\n      const extern_type* __from, const extern_type* __from_end,\n      const extern_type*& __from_next,\n      intern_type* __to, intern_type* __to_end,\n      int'
[#] parse_declaration, is_constructor=False, meet line: 'int do_encoding() const throw();\n\n      virtual\n      bool do_always_noconv() const throw();\n\n      virtual\n      int do_length(state_type&, const extern_type* __from,\n      const extern_type* __end, '
[#] parse_declaration, is_constructor=False, meet line: 'bool do_always_noconv() const throw();\n\n      virtual\n      int do_length(state_type&, const extern_type* __from,\n      const extern_type* __end, size_t __max) const;\n\n      virtual int\n      do_max_l'
[#] parse_declaration, is_constructor=False, meet line: 'int do_length(state_type&, const extern_type* __from,\n      const extern_type* __end, size_t __max) const;\n\n      virtual int\n      do_max_length() const throw();\n    };\n# 467 "/usr/include/c++/7/bits'
[#] parse_declaration, is_constructor=False, meet line: 'int\n      do_max_length() const throw();\n    };\n# 467 "/usr/include/c++/7/bits/codecvt.h" 3\n  template<>\n    class codecvt<char16_t, char, mbstate_t>\n    : public __codecvt_abstract_base<char16_t, cha'
[#] parse_declaration, is_constructor=False, meet line: 'locale::id id;\n\n      explicit\n      codecvt(size_t __refs = 0)\n      : __codecvt_abstract_base<char16_t, char, mbstate_t>(__refs) { }\n\n    protected:\n      virtual\n      ~codecvt();\n\n      virtual re'
[#] parse_declaration, is_constructor=True, meet line: 'codecvt(size_t __refs = 0)\n      : __codecvt_abstract_base<char16_t, char, mbstate_t>(__refs) { }\n\n    protected:\n      virtual\n      ~codecvt();\n\n      virtual result\n      do_out(state_type& __state'
[#] parse_declaration, is_constructor=True, meet line: 'codecvt();\n\n      virtual result\n      do_out(state_type& __state, const intern_type* __from,\n      const intern_type* __from_end, const intern_type*& __from_next,\n      extern_type* __to, extern_type'
[#] parse_declaration, is_constructor=False, meet line: 'result\n      do_out(state_type& __state, const intern_type* __from,\n      const intern_type* __from_end, const intern_type*& __from_next,\n      extern_type* __to, extern_type* __to_end,\n      extern_t'
[#] parse_declaration, is_constructor=False, meet line: 'result\n      do_unshift(state_type& __state,\n   extern_type* __to, extern_type* __to_end,\n   extern_type*& __to_next) const;\n\n      virtual result\n      do_in(state_type& __state,\n      const extern_t'
[#] parse_declaration, is_constructor=False, meet line: 'result\n      do_in(state_type& __state,\n      const extern_type* __from, const extern_type* __from_end,\n      const extern_type*& __from_next,\n      intern_type* __to, intern_type* __to_end,\n      int'
[#] parse_declaration, is_constructor=False, meet line: 'int do_encoding() const throw();\n\n      virtual\n      bool do_always_noconv() const throw();\n\n      virtual\n      int do_length(state_type&, const extern_type* __from,\n      const extern_type* __end, '
[#] parse_declaration, is_constructor=False, meet line: 'bool do_always_noconv() const throw();\n\n      virtual\n      int do_length(state_type&, const extern_type* __from,\n      const extern_type* __end, size_t __max) const;\n\n      virtual int\n      do_max_l'
[#] parse_declaration, is_constructor=False, meet line: 'int do_length(state_type&, const extern_type* __from,\n      const extern_type* __end, size_t __max) const;\n\n      virtual int\n      do_max_length() const throw();\n    };\n\n\n\n\n\n  template<>\n    class co'
[#] parse_declaration, is_constructor=False, meet line: 'int\n      do_max_length() const throw();\n    };\n\n\n\n\n\n  template<>\n    class codecvt<char32_t, char, mbstate_t>\n    : public __codecvt_abstract_base<char32_t, char, mbstate_t>\n    {\n    public:\n\n      '
[#] parse_declaration, is_constructor=False, meet line: 'locale::id id;\n\n      explicit\n      codecvt(size_t __refs = 0)\n      : __codecvt_abstract_base<char32_t, char, mbstate_t>(__refs) { }\n\n    protected:\n      virtual\n      ~codecvt();\n\n      virtual re'
[#] parse_declaration, is_constructor=True, meet line: 'codecvt(size_t __refs = 0)\n      : __codecvt_abstract_base<char32_t, char, mbstate_t>(__refs) { }\n\n    protected:\n      virtual\n      ~codecvt();\n\n      virtual result\n      do_out(state_type& __state'
[#] parse_declaration, is_constructor=True, meet line: 'codecvt();\n\n      virtual result\n      do_out(state_type& __state, const intern_type* __from,\n      const intern_type* __from_end, const intern_type*& __from_next,\n      extern_type* __to, extern_type'
[#] parse_declaration, is_constructor=False, meet line: 'result\n      do_out(state_type& __state, const intern_type* __from,\n      const intern_type* __from_end, const intern_type*& __from_next,\n      extern_type* __to, extern_type* __to_end,\n      extern_t'
[#] parse_declaration, is_constructor=False, meet line: 'result\n      do_unshift(state_type& __state,\n   extern_type* __to, extern_type* __to_end,\n   extern_type*& __to_next) const;\n\n      virtual result\n      do_in(state_type& __state,\n      const extern_t'
[#] parse_declaration, is_constructor=False, meet line: 'result\n      do_in(state_type& __state,\n      const extern_type* __from, const extern_type* __from_end,\n      const extern_type*& __from_next,\n      intern_type* __to, intern_type* __to_end,\n      int'
[#] parse_declaration, is_constructor=False, meet line: 'int do_encoding() const throw();\n\n      virtual\n      bool do_always_noconv() const throw();\n\n      virtual\n      int do_length(state_type&, const extern_type* __from,\n      const extern_type* __end, '
[#] parse_declaration, is_constructor=False, meet line: 'bool do_always_noconv() const throw();\n\n      virtual\n      int do_length(state_type&, const extern_type* __from,\n      const extern_type* __end, size_t __max) const;\n\n      virtual int\n      do_max_l'
[#] parse_declaration, is_constructor=False, meet line: 'int do_length(state_type&, const extern_type* __from,\n      const extern_type* __end, size_t __max) const;\n\n      virtual int\n      do_max_length() const throw();\n    };\n\n\n\n\n\n  template<typename _Inte'
[#] parse_declaration, is_constructor=False, meet line: 'int\n      do_max_length() const throw();\n    };\n\n\n\n\n\n  template<typename _InternT, typename _ExternT, typename _StateT>\n    class codecvt_byname : public codecvt<_InternT, _ExternT, _StateT>\n    {\n   '
[#] parse_declaration, is_constructor=True, meet line: 'codecvt_byname(const char* __s, size_t __refs = 0)\n      : codecvt<_InternT, _ExternT, _StateT>(__refs)\n      {\n if (__builtin_strcmp(__s, "C") != 0\n     && __builtin_strcmp(__s, "POSIX") != 0)\n   {\n '
[#] parse_declaration, is_constructor=True, meet line: 'codecvt_byname(const string& __s, size_t __refs = 0)\n      : codecvt_byname(__s.c_str(), __refs) { }\n\n\n    protected:\n      virtual\n      ~codecvt_byname() { }\n    };\n\n\n  template<>\n    class codecvt_'
[#] parse_declaration, is_constructor=True, meet line: 'codecvt_byname() { }\n    };\n\n\n  template<>\n    class codecvt_byname<char16_t, char, mbstate_t>\n    : public codecvt<char16_t, char, mbstate_t>\n    {\n    public:\n      explicit\n      codecvt_byname(con'
[#] parse_declaration, is_constructor=True, meet line: 'codecvt_byname(const char* __s, size_t __refs = 0)\n      : codecvt<char16_t, char, mbstate_t>(__refs) { }\n\n      explicit\n      codecvt_byname(const string& __s, size_t __refs = 0)\n      : codecvt_byn'
[#] parse_declaration, is_constructor=True, meet line: 'codecvt_byname(const string& __s, size_t __refs = 0)\n      : codecvt_byname(__s.c_str(), __refs) { }\n\n    protected:\n      virtual\n      ~codecvt_byname() { }\n    };\n\n  template<>\n    class codecvt_by'
[#] parse_declaration, is_constructor=True, meet line: 'codecvt_byname() { }\n    };\n\n  template<>\n    class codecvt_byname<char32_t, char, mbstate_t>\n    : public codecvt<char32_t, char, mbstate_t>\n    {\n    public:\n      explicit\n      codecvt_byname(cons'
[#] parse_declaration, is_constructor=True, meet line: 'codecvt_byname(const char* __s, size_t __refs = 0)\n      : codecvt<char32_t, char, mbstate_t>(__refs) { }\n\n      explicit\n      codecvt_byname(const string& __s, size_t __refs = 0)\n      : codecvt_byn'
[#] parse_declaration, is_constructor=True, meet line: 'codecvt_byname(const string& __s, size_t __refs = 0)\n      : codecvt_byname(__s.c_str(), __refs) { }\n\n    protected:\n      virtual\n      ~codecvt_byname() { }\n    };\n\n\n\n\n\n  extern template class codec'
[#] parse_declaration, is_constructor=True, meet line: 'codecvt_byname() { }\n    };\n\n\n\n\n\n  extern template class codecvt_byname<char, char, mbstate_t>;\n\n  extern template\n    const codecvt<char, char, mbstate_t>&\n    use_facet<codecvt<char, char, mbstate_t'
[#] parse_declaration, is_constructor=False, meet line: 'template class codecvt_byname<char, char, mbstate_t>;\n\n  extern template\n    const codecvt<char, char, mbstate_t>&\n    use_facet<codecvt<char, char, mbstate_t> >(const locale&);\n\n  extern template\n   '
[#] parse_declaration, is_constructor=False, meet line: 'template\n    const codecvt<char, char, mbstate_t>&\n    use_facet<codecvt<char, char, mbstate_t> >(const locale&);\n\n  extern template\n    bool\n    has_facet<codecvt<char, char, mbstate_t> >(const local'
[#] parse_declaration, is_constructor=False, meet line: 'template\n    bool\n    has_facet<codecvt<char, char, mbstate_t> >(const locale&);\n\n\n  extern template class codecvt_byname<wchar_t, char, mbstate_t>;\n\n  extern template\n    const codecvt<wchar_t, char,'
[#] parse_declaration, is_constructor=False, meet line: 'template class codecvt_byname<wchar_t, char, mbstate_t>;\n\n  extern template\n    const codecvt<wchar_t, char, mbstate_t>&\n    use_facet<codecvt<wchar_t, char, mbstate_t> >(const locale&);\n\n  extern tem'
[#] parse_declaration, is_constructor=False, meet line: 'template\n    const codecvt<wchar_t, char, mbstate_t>&\n    use_facet<codecvt<wchar_t, char, mbstate_t> >(const locale&);\n\n  extern template\n    bool\n    has_facet<codecvt<wchar_t, char, mbstate_t> >(co'
[#] parse_declaration, is_constructor=False, meet line: 'template\n    bool\n    has_facet<codecvt<wchar_t, char, mbstate_t> >(const locale&);\n\n\n\n  extern template class codecvt_byname<char16_t, char, mbstate_t>;\n  extern template class codecvt_byname<char32_'
[#] parse_declaration, is_constructor=False, meet line: 'template class codecvt_byname<char16_t, char, mbstate_t>;\n  extern template class codecvt_byname<char32_t, char, mbstate_t>;\n\n\n\n\n\n}\n# 2012 "/usr/include/c++/7/bits/locale_facets_nonio.h" 2 3\n\n# 1 "/us'
[#] parse_declaration, is_constructor=False, meet line: 'template class codecvt_byname<char32_t, char, mbstate_t>;\n\n\n\n\n\n}\n# 2012 "/usr/include/c++/7/bits/locale_facets_nonio.h" 2 3\n\n# 1 "/usr/include/c++/7/bits/locale_facets_nonio.tcc" 1 3\n# 33 "/usr/includ'
[#] parse_declaration, is_constructor=False, meet line: '__moneypunct_cache<_CharT, _Intl>*\n      operator() (const locale& __loc) const\n      {\n const size_t __i = moneypunct<_CharT, _Intl>::id._M_id();\n const locale::facet** __caches = __loc._M_impl->_M_c'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    __moneypunct_cache<_CharT, _Intl>::_M_cache(const locale& __loc)\n    {\n      const moneypunct<_CharT, _Intl>& __mp =\n use_facet<moneypunct<_CharT, _Intl> >(__loc);\n\n      _M_decimal_point = _'
[#] parse_declaration, is_constructor=False, meet line: '_InIter\n      money_get<_CharT, _InIter>::\n      _M_extract(iter_type __beg, iter_type __end, ios_base& __io,\n   ios_base::iostate& __err, string& __units) const\n      {\n typedef char_traits<_CharT> _'
[#] parse_declaration, is_constructor=False, meet line: '_InIter\n    money_get<_CharT, _InIter>::\n    do_get(iter_type __beg, iter_type __end, bool __intl, ios_base& __io,\n    ios_base::iostate& __err, long double& __units) const\n    {\n      string __str;\n '
[#] parse_declaration, is_constructor=False, meet line: '_InIter\n    money_get<_CharT, _InIter>::\n    do_get(iter_type __beg, iter_type __end, bool __intl, ios_base& __io,\n    ios_base::iostate& __err, string_type& __digits) const\n    {\n      typedef typena'
[#] parse_declaration, is_constructor=False, meet line: '_OutIter\n      money_put<_CharT, _OutIter>::\n      _M_insert(iter_type __s, ios_base& __io, char_type __fill,\n  const string_type& __digits) const\n      {\n typedef typename string_type::size_type size'
[#] parse_declaration, is_constructor=False, meet line: '_OutIter\n    money_put<_CharT, _OutIter>::\n    do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,\n    long double __units) const\n    {\n      const locale __loc = __io.getloc();\n     '
[#] parse_declaration, is_constructor=False, meet line: '_OutIter\n    money_put<_CharT, _OutIter>::\n    do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,\n    const string_type& __digits) const\n    { return __intl ? _M_insert<true>(__s, __'
[#] parse_declaration, is_constructor=False, meet line: 'time_base::dateorder\n    time_get<_CharT, _InIter>::do_date_order() const\n    { return time_base::no_order; }\n\n\n\n  template<typename _CharT, typename _InIter>\n    _InIter\n    time_get<_CharT, _InIter>'
[#] parse_declaration, is_constructor=False, meet line: '_InIter\n    time_get<_CharT, _InIter>::\n    _M_extract_via_format(iter_type __beg, iter_type __end, ios_base& __io,\n     ios_base::iostate& __err, tm* __tm,\n     const _CharT* __format) const\n    {\n  '
[#] parse_declaration, is_constructor=False, meet line: '_InIter\n    time_get<_CharT, _InIter>::\n    _M_extract_num(iter_type __beg, iter_type __end, int& __member,\n     int __min, int __max, size_t __len,\n     ios_base& __io, ios_base::iostate& __err) cons'
[#] parse_declaration, is_constructor=False, meet line: '_InIter\n    time_get<_CharT, _InIter>::\n    _M_extract_name(iter_type __beg, iter_type __end, int& __member,\n      const _CharT** __names, size_t __indexlen,\n      ios_base& __io, ios_base::iostate& _'
[#] parse_declaration, is_constructor=False, meet line: '_InIter\n    time_get<_CharT, _InIter>::\n    _M_extract_wday_or_month(iter_type __beg, iter_type __end, int& __member,\n        const _CharT** __names, size_t __indexlen,\n        ios_base& __io, ios_bas'
[#] parse_declaration, is_constructor=False, meet line: '_InIter\n    time_get<_CharT, _InIter>::\n    do_get_time(iter_type __beg, iter_type __end, ios_base& __io,\n  ios_base::iostate& __err, tm* __tm) const\n    {\n      const locale& __loc = __io._M_getloc()'
[#] parse_declaration, is_constructor=False, meet line: '_InIter\n    time_get<_CharT, _InIter>::\n    do_get_date(iter_type __beg, iter_type __end, ios_base& __io,\n  ios_base::iostate& __err, tm* __tm) const\n    {\n      const locale& __loc = __io._M_getloc()'
[#] parse_declaration, is_constructor=False, meet line: '_InIter\n    time_get<_CharT, _InIter>::\n    do_get_weekday(iter_type __beg, iter_type __end, ios_base& __io,\n     ios_base::iostate& __err, tm* __tm) const\n    {\n      const locale& __loc = __io._M_ge'
[#] parse_declaration, is_constructor=False, meet line: '_InIter\n    time_get<_CharT, _InIter>::\n    do_get_monthname(iter_type __beg, iter_type __end,\n                     ios_base& __io, ios_base::iostate& __err, tm* __tm) const\n    {\n      const locale& '
[#] parse_declaration, is_constructor=False, meet line: '_InIter\n    time_get<_CharT, _InIter>::\n    do_get_year(iter_type __beg, iter_type __end, ios_base& __io,\n  ios_base::iostate& __err, tm* __tm) const\n    {\n      const locale& __loc = __io._M_getloc()'
[#] parse_declaration, is_constructor=False, meet line: '_InIter\n    time_get<_CharT, _InIter>::\n    get(iter_type __s, iter_type __end, ios_base& __io,\n        ios_base::iostate& __err, tm* __tm, const char_type* __fmt,\n        const char_type* __fmtend) c'
[#] parse_declaration, is_constructor=False, meet line: '_InIter\n    time_get<_CharT, _InIter>::\n    do_get(iter_type __beg, iter_type __end, ios_base& __io,\n           ios_base::iostate& __err, tm* __tm,\n           char __format, char __mod) const\n    {\n  '
[#] parse_declaration, is_constructor=False, meet line: '_OutIter\n    time_put<_CharT, _OutIter>::\n    put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,\n const _CharT* __beg, const _CharT* __end) const\n    {\n      const locale& __loc = __'
[#] parse_declaration, is_constructor=False, meet line: '_OutIter\n    time_put<_CharT, _OutIter>::\n    do_put(iter_type __s, ios_base& __io, char_type, const tm* __tm,\n    char __format, char __mod) const\n    {\n      const locale& __loc = __io._M_getloc();\n'
[#] parse_declaration, is_constructor=False, meet line: 'template class moneypunct<char, false>;\n  extern template class moneypunct<char, true>;\n  extern template class moneypunct_byname<char, false>;\n  extern template class moneypunct_byname<char, true>;\n '
[#] parse_declaration, is_constructor=False, meet line: 'template class moneypunct<char, true>;\n  extern template class moneypunct_byname<char, false>;\n  extern template class moneypunct_byname<char, true>;\n  extern template class __cxx11:: money_get<char>;'
[#] parse_declaration, is_constructor=False, meet line: 'template class moneypunct_byname<char, false>;\n  extern template class moneypunct_byname<char, true>;\n  extern template class __cxx11:: money_get<char>;\n  extern template class __cxx11:: money_put<cha'
[#] parse_declaration, is_constructor=False, meet line: 'template class moneypunct_byname<char, true>;\n  extern template class __cxx11:: money_get<char>;\n  extern template class __cxx11:: money_put<char>;\n  extern template class __timepunct<char>;\n  extern '
[#] parse_declaration, is_constructor=False, meet line: 'template class __cxx11:: money_get<char>;\n  extern template class __cxx11:: money_put<char>;\n  extern template class __timepunct<char>;\n  extern template class time_put<char>;\n  extern template class '
[#] parse_declaration, is_constructor=False, meet line: 'template class __cxx11:: money_put<char>;\n  extern template class __timepunct<char>;\n  extern template class time_put<char>;\n  extern template class time_put_byname<char>;\n  extern template class time'
[#] parse_declaration, is_constructor=False, meet line: 'template class __timepunct<char>;\n  extern template class time_put<char>;\n  extern template class time_put_byname<char>;\n  extern template class time_get<char>;\n  extern template class time_get_byname'
[#] parse_declaration, is_constructor=False, meet line: 'template class time_put<char>;\n  extern template class time_put_byname<char>;\n  extern template class time_get<char>;\n  extern template class time_get_byname<char>;\n  extern template class messages<ch'
[#] parse_declaration, is_constructor=False, meet line: 'template class time_put_byname<char>;\n  extern template class time_get<char>;\n  extern template class time_get_byname<char>;\n  extern template class messages<char>;\n  extern template class messages_by'
[#] parse_declaration, is_constructor=False, meet line: 'template class time_get<char>;\n  extern template class time_get_byname<char>;\n  extern template class messages<char>;\n  extern template class messages_byname<char>;\n\n  extern template\n    const moneyp'
[#] parse_declaration, is_constructor=False, meet line: 'template class time_get_byname<char>;\n  extern template class messages<char>;\n  extern template class messages_byname<char>;\n\n  extern template\n    const moneypunct<char, true>&\n    use_facet<moneypun'
[#] parse_declaration, is_constructor=False, meet line: 'template class messages<char>;\n  extern template class messages_byname<char>;\n\n  extern template\n    const moneypunct<char, true>&\n    use_facet<moneypunct<char, true> >(const locale&);\n\n  extern temp'
[#] parse_declaration, is_constructor=False, meet line: 'template class messages_byname<char>;\n\n  extern template\n    const moneypunct<char, true>&\n    use_facet<moneypunct<char, true> >(const locale&);\n\n  extern template\n    const moneypunct<char, false>&\n'
[#] parse_declaration, is_constructor=False, meet line: 'template\n    const moneypunct<char, true>&\n    use_facet<moneypunct<char, true> >(const locale&);\n\n  extern template\n    const moneypunct<char, false>&\n    use_facet<moneypunct<char, false> >(const lo'
[#] parse_declaration, is_constructor=False, meet line: 'template\n    const moneypunct<char, false>&\n    use_facet<moneypunct<char, false> >(const locale&);\n\n  extern template\n    const money_put<char>&\n    use_facet<money_put<char> >(const locale&);\n\n  ext'
[#] parse_declaration, is_constructor=False, meet line: 'template\n    const money_put<char>&\n    use_facet<money_put<char> >(const locale&);\n\n  extern template\n    const money_get<char>&\n    use_facet<money_get<char> >(const locale&);\n\n  extern template\n   '
[#] parse_declaration, is_constructor=False, meet line: 'template\n    const money_get<char>&\n    use_facet<money_get<char> >(const locale&);\n\n  extern template\n    const __timepunct<char>&\n    use_facet<__timepunct<char> >(const locale&);\n\n  extern template'
[#] parse_declaration, is_constructor=False, meet line: 'template\n    const __timepunct<char>&\n    use_facet<__timepunct<char> >(const locale&);\n\n  extern template\n    const time_put<char>&\n    use_facet<time_put<char> >(const locale&);\n\n  extern template\n '
[#] parse_declaration, is_constructor=False, meet line: 'template\n    const time_put<char>&\n    use_facet<time_put<char> >(const locale&);\n\n  extern template\n    const time_get<char>&\n    use_facet<time_get<char> >(const locale&);\n\n  extern template\n    con'
[#] parse_declaration, is_constructor=False, meet line: 'template\n    const time_get<char>&\n    use_facet<time_get<char> >(const locale&);\n\n  extern template\n    const messages<char>&\n    use_facet<messages<char> >(const locale&);\n\n  extern template\n    boo'
[#] parse_declaration, is_constructor=False, meet line: 'template\n    const messages<char>&\n    use_facet<messages<char> >(const locale&);\n\n  extern template\n    bool\n    has_facet<moneypunct<char> >(const locale&);\n\n  extern template\n    bool\n    has_facet'
[#] parse_declaration, is_constructor=False, meet line: 'template\n    bool\n    has_facet<moneypunct<char> >(const locale&);\n\n  extern template\n    bool\n    has_facet<money_put<char> >(const locale&);\n\n  extern template\n    bool\n    has_facet<money_get<char>'
[#] parse_declaration, is_constructor=False, meet line: 'template\n    bool\n    has_facet<money_put<char> >(const locale&);\n\n  extern template\n    bool\n    has_facet<money_get<char> >(const locale&);\n\n  extern template\n    bool\n    has_facet<__timepunct<char'
[#] parse_declaration, is_constructor=False, meet line: 'template\n    bool\n    has_facet<money_get<char> >(const locale&);\n\n  extern template\n    bool\n    has_facet<__timepunct<char> >(const locale&);\n\n  extern template\n    bool\n    has_facet<time_put<char>'
[#] parse_declaration, is_constructor=False, meet line: 'template\n    bool\n    has_facet<__timepunct<char> >(const locale&);\n\n  extern template\n    bool\n    has_facet<time_put<char> >(const locale&);\n\n  extern template\n    bool\n    has_facet<time_get<char> '
[#] parse_declaration, is_constructor=False, meet line: 'template\n    bool\n    has_facet<time_put<char> >(const locale&);\n\n  extern template\n    bool\n    has_facet<time_get<char> >(const locale&);\n\n  extern template\n    bool\n    has_facet<messages<char> >(c'
[#] parse_declaration, is_constructor=False, meet line: 'template\n    bool\n    has_facet<time_get<char> >(const locale&);\n\n  extern template\n    bool\n    has_facet<messages<char> >(const locale&);\n\n\n  extern template class moneypunct<wchar_t, false>;\n  exte'
[#] parse_declaration, is_constructor=False, meet line: 'template\n    bool\n    has_facet<messages<char> >(const locale&);\n\n\n  extern template class moneypunct<wchar_t, false>;\n  extern template class moneypunct<wchar_t, true>;\n  extern template class moneyp'
[#] parse_declaration, is_constructor=False, meet line: 'template class moneypunct<wchar_t, false>;\n  extern template class moneypunct<wchar_t, true>;\n  extern template class moneypunct_byname<wchar_t, false>;\n  extern template class moneypunct_byname<wchar'
[#] parse_declaration, is_constructor=False, meet line: 'template class moneypunct<wchar_t, true>;\n  extern template class moneypunct_byname<wchar_t, false>;\n  extern template class moneypunct_byname<wchar_t, true>;\n  extern template class __cxx11:: money_g'
[#] parse_declaration, is_constructor=False, meet line: 'template class moneypunct_byname<wchar_t, false>;\n  extern template class moneypunct_byname<wchar_t, true>;\n  extern template class __cxx11:: money_get<wchar_t>;\n  extern template class __cxx11:: mone'
[#] parse_declaration, is_constructor=False, meet line: 'template class moneypunct_byname<wchar_t, true>;\n  extern template class __cxx11:: money_get<wchar_t>;\n  extern template class __cxx11:: money_put<wchar_t>;\n  extern template class __timepunct<wchar_t'
[#] parse_declaration, is_constructor=False, meet line: 'template class __cxx11:: money_get<wchar_t>;\n  extern template class __cxx11:: money_put<wchar_t>;\n  extern template class __timepunct<wchar_t>;\n  extern template class time_put<wchar_t>;\n  extern tem'
[#] parse_declaration, is_constructor=False, meet line: 'template class __cxx11:: money_put<wchar_t>;\n  extern template class __timepunct<wchar_t>;\n  extern template class time_put<wchar_t>;\n  extern template class time_put_byname<wchar_t>;\n  extern templat'
[#] parse_declaration, is_constructor=False, meet line: 'template class __timepunct<wchar_t>;\n  extern template class time_put<wchar_t>;\n  extern template class time_put_byname<wchar_t>;\n  extern template class time_get<wchar_t>;\n  extern template class tim'
[#] parse_declaration, is_constructor=False, meet line: 'template class time_put<wchar_t>;\n  extern template class time_put_byname<wchar_t>;\n  extern template class time_get<wchar_t>;\n  extern template class time_get_byname<wchar_t>;\n  extern template class'
[#] parse_declaration, is_constructor=False, meet line: 'template class time_put_byname<wchar_t>;\n  extern template class time_get<wchar_t>;\n  extern template class time_get_byname<wchar_t>;\n  extern template class messages<wchar_t>;\n  extern template class'
[#] parse_declaration, is_constructor=False, meet line: 'template class time_get<wchar_t>;\n  extern template class time_get_byname<wchar_t>;\n  extern template class messages<wchar_t>;\n  extern template class messages_byname<wchar_t>;\n\n  extern template\n    '
[#] parse_declaration, is_constructor=False, meet line: 'template class time_get_byname<wchar_t>;\n  extern template class messages<wchar_t>;\n  extern template class messages_byname<wchar_t>;\n\n  extern template\n    const moneypunct<wchar_t, true>&\n    use_fa'
[#] parse_declaration, is_constructor=False, meet line: 'template class messages<wchar_t>;\n  extern template class messages_byname<wchar_t>;\n\n  extern template\n    const moneypunct<wchar_t, true>&\n    use_facet<moneypunct<wchar_t, true> >(const locale&);\n\n '
[#] parse_declaration, is_constructor=False, meet line: 'template class messages_byname<wchar_t>;\n\n  extern template\n    const moneypunct<wchar_t, true>&\n    use_facet<moneypunct<wchar_t, true> >(const locale&);\n\n  extern template\n    const moneypunct<wchar'
[#] parse_declaration, is_constructor=False, meet line: 'template\n    const moneypunct<wchar_t, true>&\n    use_facet<moneypunct<wchar_t, true> >(const locale&);\n\n  extern template\n    const moneypunct<wchar_t, false>&\n    use_facet<moneypunct<wchar_t, false'
[#] parse_declaration, is_constructor=False, meet line: 'template\n    const moneypunct<wchar_t, false>&\n    use_facet<moneypunct<wchar_t, false> >(const locale&);\n\n  extern template\n    const money_put<wchar_t>&\n    use_facet<money_put<wchar_t> >(const loca'
[#] parse_declaration, is_constructor=False, meet line: 'template\n    const money_put<wchar_t>&\n    use_facet<money_put<wchar_t> >(const locale&);\n\n  extern template\n    const money_get<wchar_t>&\n    use_facet<money_get<wchar_t> >(const locale&);\n\n  extern '
[#] parse_declaration, is_constructor=False, meet line: 'template\n    const money_get<wchar_t>&\n    use_facet<money_get<wchar_t> >(const locale&);\n\n  extern template\n    const __timepunct<wchar_t>&\n    use_facet<__timepunct<wchar_t> >(const locale&);\n\n  ext'
[#] parse_declaration, is_constructor=False, meet line: 'template\n    const __timepunct<wchar_t>&\n    use_facet<__timepunct<wchar_t> >(const locale&);\n\n  extern template\n    const time_put<wchar_t>&\n    use_facet<time_put<wchar_t> >(const locale&);\n\n  exter'
[#] parse_declaration, is_constructor=False, meet line: 'template\n    const time_put<wchar_t>&\n    use_facet<time_put<wchar_t> >(const locale&);\n\n  extern template\n    const time_get<wchar_t>&\n    use_facet<time_get<wchar_t> >(const locale&);\n\n  extern temp'
[#] parse_declaration, is_constructor=False, meet line: 'template\n    const time_get<wchar_t>&\n    use_facet<time_get<wchar_t> >(const locale&);\n\n  extern template\n    const messages<wchar_t>&\n    use_facet<messages<wchar_t> >(const locale&);\n\n  extern temp'
[#] parse_declaration, is_constructor=False, meet line: 'template\n    const messages<wchar_t>&\n    use_facet<messages<wchar_t> >(const locale&);\n\n  extern template\n    bool\n    has_facet<moneypunct<wchar_t> >(const locale&);\n\n  extern template\n    bool\n    '
[#] parse_declaration, is_constructor=False, meet line: 'template\n    bool\n    has_facet<moneypunct<wchar_t> >(const locale&);\n\n  extern template\n    bool\n    has_facet<money_put<wchar_t> >(const locale&);\n\n  extern template\n    bool\n    has_facet<money_get'
[#] parse_declaration, is_constructor=False, meet line: 'template\n    bool\n    has_facet<money_put<wchar_t> >(const locale&);\n\n  extern template\n    bool\n    has_facet<money_get<wchar_t> >(const locale&);\n\n  extern template\n    bool\n    has_facet<__timepunc'
[#] parse_declaration, is_constructor=False, meet line: 'template\n    bool\n    has_facet<money_get<wchar_t> >(const locale&);\n\n  extern template\n    bool\n    has_facet<__timepunct<wchar_t> >(const locale&);\n\n  extern template\n    bool\n    has_facet<time_put'
[#] parse_declaration, is_constructor=False, meet line: 'template\n    bool\n    has_facet<__timepunct<wchar_t> >(const locale&);\n\n  extern template\n    bool\n    has_facet<time_put<wchar_t> >(const locale&);\n\n  extern template\n    bool\n    has_facet<time_get<'
[#] parse_declaration, is_constructor=False, meet line: 'template\n    bool\n    has_facet<time_put<wchar_t> >(const locale&);\n\n  extern template\n    bool\n    has_facet<time_get<wchar_t> >(const locale&);\n\n  extern template\n    bool\n    has_facet<messages<wch'
[#] parse_declaration, is_constructor=False, meet line: 'template\n    bool\n    has_facet<time_get<wchar_t> >(const locale&);\n\n  extern template\n    bool\n    has_facet<messages<wchar_t> >(const locale&);\n\n\n\n\n}\n# 2014 "/usr/include/c++/7/bits/locale_facets_no'
[#] parse_declaration, is_constructor=False, meet line: 'template\n    bool\n    has_facet<messages<wchar_t> >(const locale&);\n\n\n\n\n}\n# 2014 "/usr/include/c++/7/bits/locale_facets_nonio.h" 2 3\n# 42 "/usr/include/c++/7/locale" 2 3\n\n# 1 "/usr/include/c++/7/bits/'
[#] parse_declaration, is_constructor=False, meet line: '_Tp&\n      _S_ref(const _Type& __t, std::size_t __n) noexcept\n      { return const_cast<_Tp&>(__t[__n]); }\n\n      static constexpr _Tp*\n      _S_ptr(const _Type& __t) noexcept\n      { return const_cas'
[#] parse_declaration, is_constructor=False, meet line: '_Tp*\n      _S_ptr(const _Type& __t) noexcept\n      { return const_cast<_Tp*>(__t); }\n    };\n\n template<typename _Tp>\n   struct __array_traits<_Tp, 0>\n   {\n     struct _Type { };\n     typedef true_type'
[#] parse_declaration, is_constructor=False, meet line: '_Tp&\n     _S_ref(const _Type&, std::size_t) noexcept\n     { return *static_cast<_Tp*>(nullptr); }\n\n     static constexpr _Tp*\n     _S_ptr(const _Type&) noexcept\n     { return nullptr; }\n   };\n# 93 "/u'
[#] parse_declaration, is_constructor=False, meet line: '_Tp*\n     _S_ptr(const _Type&) noexcept\n     { return nullptr; }\n   };\n# 93 "/usr/include/c++/7/array" 3\n  template<typename _Tp, std::size_t _Nm>\n    struct array\n    {\n      typedef _Tp value_type;\n'
[#] parse_declaration, is_constructor=False, meet line: '_AT_Type::_Type _M_elems;\n\n\n\n\n      void\n      fill(const value_type& __u)\n      { std::fill_n(begin(), size(), __u); }\n\n      void\n      swap(array& __other)\n      noexcept(_AT_Type::_Is_nothrow_swap'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      fill(const value_type& __u)\n      { std::fill_n(begin(), size(), __u); }\n\n      void\n      swap(array& __other)\n      noexcept(_AT_Type::_Is_nothrow_swappable::value)\n      { std::swap_rang'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      swap(array& __other)\n      noexcept(_AT_Type::_Is_nothrow_swappable::value)\n      { std::swap_ranges(begin(), end(), __other.begin()); }\n\n\n      iterator\n      begin() noexcept\n      { retu'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      begin() noexcept\n      { return iterator(data()); }\n\n      const_iterator\n      begin() const noexcept\n      { return const_iterator(data()); }\n\n      iterator\n      end() noexcept\n    '
[#] parse_declaration, is_constructor=False, meet line: 'const_iterator\n      begin() const noexcept\n      { return const_iterator(data()); }\n\n      iterator\n      end() noexcept\n      { return iterator(data() + _Nm); }\n\n      const_iterator\n      end() con'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      end() noexcept\n      { return iterator(data() + _Nm); }\n\n      const_iterator\n      end() const noexcept\n      { return const_iterator(data() + _Nm); }\n\n      reverse_iterator\n      rbe'
[#] parse_declaration, is_constructor=False, meet line: 'const_iterator\n      end() const noexcept\n      { return const_iterator(data() + _Nm); }\n\n      reverse_iterator\n      rbegin() noexcept\n      { return reverse_iterator(end()); }\n\n      const_reverse_'
[#] parse_declaration, is_constructor=False, meet line: 'reverse_iterator\n      rbegin() noexcept\n      { return reverse_iterator(end()); }\n\n      const_reverse_iterator\n      rbegin() const noexcept\n      { return const_reverse_iterator(end()); }\n\n      re'
[#] parse_declaration, is_constructor=False, meet line: 'const_reverse_iterator\n      rbegin() const noexcept\n      { return const_reverse_iterator(end()); }\n\n      reverse_iterator\n      rend() noexcept\n      { return reverse_iterator(begin()); }\n\n      co'
[#] parse_declaration, is_constructor=False, meet line: 'reverse_iterator\n      rend() noexcept\n      { return reverse_iterator(begin()); }\n\n      const_reverse_iterator\n      rend() const noexcept\n      { return const_reverse_iterator(begin()); }\n\n      co'
[#] parse_declaration, is_constructor=False, meet line: 'const_reverse_iterator\n      rend() const noexcept\n      { return const_reverse_iterator(begin()); }\n\n      const_iterator\n      cbegin() const noexcept\n      { return const_iterator(data()); }\n\n     '
[#] parse_declaration, is_constructor=False, meet line: 'const_iterator\n      cbegin() const noexcept\n      { return const_iterator(data()); }\n\n      const_iterator\n      cend() const noexcept\n      { return const_iterator(data() + _Nm); }\n\n      const_reve'
[#] parse_declaration, is_constructor=False, meet line: 'const_iterator\n      cend() const noexcept\n      { return const_iterator(data() + _Nm); }\n\n      const_reverse_iterator\n      crbegin() const noexcept\n      { return const_reverse_iterator(end()); }\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'const_reverse_iterator\n      crbegin() const noexcept\n      { return const_reverse_iterator(end()); }\n\n      const_reverse_iterator\n      crend() const noexcept\n      { return const_reverse_iterator(b'
[#] parse_declaration, is_constructor=False, meet line: 'const_reverse_iterator\n      crend() const noexcept\n      { return const_reverse_iterator(begin()); }\n\n\n      constexpr size_type\n      size() const noexcept { return _Nm; }\n\n      constexpr size_type'
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      size() const noexcept { return _Nm; }\n\n      constexpr size_type\n      max_size() const noexcept { return _Nm; }\n\n      constexpr bool\n      empty() const noexcept { return size() == 0'
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      max_size() const noexcept { return _Nm; }\n\n      constexpr bool\n      empty() const noexcept { return size() == 0; }\n\n\n      reference\n      operator[](size_type __n) noexcept\n      { '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      empty() const noexcept { return size() == 0; }\n\n\n      reference\n      operator[](size_type __n) noexcept\n      { return _AT_Type::_S_ref(_M_elems, __n); }\n\n      constexpr const_reference\n'
[#] parse_declaration, is_constructor=False, meet line: 'reference\n      operator[](size_type __n) noexcept\n      { return _AT_Type::_S_ref(_M_elems, __n); }\n\n      constexpr const_reference\n      operator[](size_type __n) const noexcept\n      { return _AT_'
[#] parse_declaration, is_constructor=False, meet line: 'const_reference\n      operator[](size_type __n) const noexcept\n      { return _AT_Type::_S_ref(_M_elems, __n); }\n\n      reference\n      at(size_type __n)\n      {\n if (__n >= _Nm)\n   std::__throw_out_o'
[#] parse_declaration, is_constructor=False, meet line: 'reference\n      at(size_type __n)\n      {\n if (__n >= _Nm)\n   std::__throw_out_of_range_fmt(("array::at: __n (which is %zu) " ">= _Nm (which is %zu)")\n                                 ,\n     __n, _Nm)'
[#] parse_declaration, is_constructor=False, meet line: 'const_reference\n      at(size_type __n) const\n      {\n\n\n return __n < _Nm ? _AT_Type::_S_ref(_M_elems, __n)\n   : (std::__throw_out_of_range_fmt(("array::at: __n (which is %zu) " ">= _Nm (which is %zu)'
[#] parse_declaration, is_constructor=False, meet line: 'reference\n      front() noexcept\n      { return *begin(); }\n\n      constexpr const_reference\n      front() const noexcept\n      { return _AT_Type::_S_ref(_M_elems, 0); }\n\n      reference\n      back() '
[#] parse_declaration, is_constructor=False, meet line: 'const_reference\n      front() const noexcept\n      { return _AT_Type::_S_ref(_M_elems, 0); }\n\n      reference\n      back() noexcept\n      { return _Nm ? *(end() - 1) : *end(); }\n\n      constexpr const'
[#] parse_declaration, is_constructor=False, meet line: 'reference\n      back() noexcept\n      { return _Nm ? *(end() - 1) : *end(); }\n\n      constexpr const_reference\n      back() const noexcept\n      {\n return _Nm ? _AT_Type::_S_ref(_M_elems, _Nm - 1)\n   '
[#] parse_declaration, is_constructor=False, meet line: 'const_reference\n      back() const noexcept\n      {\n return _Nm ? _AT_Type::_S_ref(_M_elems, _Nm - 1)\n             : _AT_Type::_S_ref(_M_elems, 0);\n      }\n\n      pointer\n      data() noexcept\n      {'
[#] parse_declaration, is_constructor=False, meet line: 'pointer\n      data() noexcept\n      { return _AT_Type::_S_ptr(_M_elems); }\n\n      const_pointer\n      data() const noexcept\n      { return _AT_Type::_S_ptr(_M_elems); }\n    };\n# 250 "/usr/include/c++/'
[#] parse_declaration, is_constructor=False, meet line: 'const_pointer\n      data() const noexcept\n      { return _AT_Type::_S_ptr(_M_elems); }\n    };\n# 250 "/usr/include/c++/7/array" 3\n  template<typename _Tp, std::size_t _Nm>\n    inline bool\n    operator='
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator==(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)\n    { return std::equal(__one.begin(), __one.end(), __two.begin()); }\n\n  template<typename _Tp, std::size_t _Nm>\n    inl'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)\n    { return !(__one == __two); }\n\n  template<typename _Tp, std::size_t _Nm>\n    inline bool\n    operator<(const array<_'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<(const array<_Tp, _Nm>& __a, const array<_Tp, _Nm>& __b)\n    {\n      return std::lexicographical_compare(__a.begin(), __a.end(),\n       __b.begin(), __b.end());\n    }\n\n  template<typ'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)\n    { return __two < __one; }\n\n  template<typename _Tp, std::size_t _Nm>\n    inline bool\n    operator<=(const array<_Tp, '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)\n    { return !(__one > __two); }\n\n  template<typename _Tp, std::size_t _Nm>\n    inline bool\n    operator>=(const array<_'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)\n    { return !(__one < __two); }\n\n\n  template<typename _Tp, std::size_t _Nm>\n    inline\n\n\n    typename enable_if<\n      '
[#] parse_declaration, is_constructor=False, meet line: 'enable_if<\n      std::__array_traits<_Tp, _Nm>::_Is_swappable::value\n    >::type\n\n\n\n    swap(array<_Tp, _Nm>& __one, array<_Tp, _Nm>& __two)\n    noexcept(noexcept(__one.swap(__two)))\n    { __one.swap('
[#] parse_declaration, is_constructor=False, meet line: 'enable_if<\n      !std::__array_traits<_Tp, _Nm>::_Is_swappable::value>::type\n    swap(array<_Tp, _Nm>&, array<_Tp, _Nm>&) = delete;\n\n\n  template<std::size_t _Int, typename _Tp, std::size_t _Nm>\n    co'
[#] parse_declaration, is_constructor=False, meet line: '_Tp&\n    get(array<_Tp, _Nm>& __arr) noexcept\n    {\n      static_assert(_Int < _Nm, "array index is within bounds");\n      return std::__array_traits<_Tp, _Nm>::\n _S_ref(__arr._M_elems, _Int);\n    }\n\n'
[#] parse_declaration, is_constructor=False, meet line: '_Tp&&\n    get(array<_Tp, _Nm>&& __arr) noexcept\n    {\n      static_assert(_Int < _Nm, "array index is within bounds");\n      return std::move(std::get<_Int>(__arr));\n    }\n\n  template<std::size_t _Int'
[#] parse_declaration, is_constructor=False, meet line: '_Tp&\n    get(const array<_Tp, _Nm>& __arr) noexcept\n    {\n      static_assert(_Int < _Nm, "array index is within bounds");\n      return std::__array_traits<_Tp, _Nm>::\n _S_ref(__arr._M_elems, _Int);\n '
[#] parse_declaration, is_constructor=True, meet line: 'allocator_arg_t() = default; };\n\n  constexpr allocator_arg_t allocator_arg =\n    allocator_arg_t();\n\n  template<typename _Tp, typename _Alloc, typename = __void_t<>>\n    struct __uses_allocator_helper'
[#] parse_declaration, is_constructor=False, meet line: 'allocator_arg_t allocator_arg =\n    allocator_arg_t();\n\n  template<typename _Tp, typename _Alloc, typename = __void_t<>>\n    struct __uses_allocator_helper\n    : false_type { };\n\n  template<typename _'
[#] parse_declaration, is_constructor=False, meet line: 'void operator=(const void*) { } } _M_a;\n  };\n\n  template<typename _Alloc>\n    struct __uses_alloc1 : __uses_alloc_base { const _Alloc* _M_a; };\n\n  template<typename _Alloc>\n    struct __uses_alloc2 : '
[#] parse_declaration, is_constructor=False, meet line: '_Alloc* _M_a; };\n\n  template<typename _Alloc>\n    struct __uses_alloc2 : __uses_alloc_base { const _Alloc* _M_a; };\n\n  template<bool, typename _Tp, typename _Alloc, typename... _Args>\n    struct __use'
[#] parse_declaration, is_constructor=False, meet line: '_Alloc* _M_a; };\n\n  template<bool, typename _Tp, typename _Alloc, typename... _Args>\n    struct __uses_alloc;\n\n  template<typename _Tp, typename _Alloc, typename... _Args>\n    struct __uses_alloc<true'
[#] parse_declaration, is_constructor=False, meet line: '__uses_alloc_t<_Tp, _Alloc, _Args...>\n    __use_alloc(const _Alloc& __a)\n    {\n      __uses_alloc_t<_Tp, _Alloc, _Args...> __ret;\n      __ret._M_a = std::__addressof(__a);\n      return __ret;\n    }\n\n '
[#] parse_declaration, is_constructor=False, meet line: 'void\n    __use_alloc(const _Alloc&&) = delete;\n\n\n\n\n\n\n\n  template<template<typename...> class _Predicate,\n    typename _Tp, typename _Alloc, typename... _Args>\n    struct __is_uses_allocator_predicate\n'
[#] parse_declaration, is_constructor=False, meet line: 'bool __is_uses_allocator_constructible_v =\n      __is_uses_allocator_constructible<_Tp, _Alloc, _Args...>::value;\n\n\n  template<typename _Tp, typename _Alloc, typename... _Args>\n    struct __is_nothrow'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    __is_nothrow_uses_allocator_constructible_v =\n      __is_nothrow_uses_allocator_constructible<_Tp, _Alloc, _Args...>::value;\n\n\n  template<typename _Tp, typename... _Args>\n    void __uses_allo'
[#] parse_declaration, is_constructor=False, meet line: 'void __uses_allocator_construct_impl(__uses_alloc0 __a, _Tp* __ptr,\n      _Args&&... __args)\n    { ::new ((void*)__ptr) _Tp(std::forward<_Args>(__args)...); }\n\n  template<typename _Tp, typename _Alloc'
[#] parse_declaration, is_constructor=False, meet line: 'void __uses_allocator_construct_impl(__uses_alloc1<_Alloc> __a, _Tp* __ptr,\n      _Args&&... __args)\n    {\n      ::new ((void*)__ptr) _Tp(allocator_arg, *__a._M_a,\n          std::forward<_Args>(__args'
[#] parse_declaration, is_constructor=False, meet line: 'void __uses_allocator_construct_impl(__uses_alloc2<_Alloc> __a, _Tp* __ptr,\n      _Args&&... __args)\n    { ::new ((void*)__ptr) _Tp(std::forward<_Args>(__args)..., *__a._M_a); }\n\n  template<typename _'
[#] parse_declaration, is_constructor=False, meet line: 'void __uses_allocator_construct(const _Alloc& __a, _Tp* __ptr,\n        _Args&&... __args)\n    {\n      __uses_allocator_construct_impl(__use_alloc<_Tp, _Alloc, _Args...>(__a),\n          __ptr, std::for'
[#] parse_declaration, is_constructor=False, meet line: '_Up&&\n    __invfwd(typename remove_reference<_Tp>::type& __t) noexcept\n    { return static_cast<_Up&&>(__t); }\n\n  template<typename _Res, typename _Fn, typename... _Args>\n    constexpr _Res\n    __invo'
[#] parse_declaration, is_constructor=False, meet line: '_Res\n    __invoke_impl(__invoke_other, _Fn&& __f, _Args&&... __args)\n    { return std::forward<_Fn>(__f)(std::forward<_Args>(__args)...); }\n\n  template<typename _Res, typename _MemFun, typename _Tp, t'
[#] parse_declaration, is_constructor=False, meet line: '_Res\n    __invoke_impl(__invoke_memfun_ref, _MemFun&& __f, _Tp&& __t,\n    _Args&&... __args)\n    { return (__invfwd<_Tp>(__t).*__f)(std::forward<_Args>(__args)...); }\n\n  template<typename _Res, typena'
[#] parse_declaration, is_constructor=False, meet line: '_Res\n    __invoke_impl(__invoke_memfun_deref, _MemFun&& __f, _Tp&& __t,\n    _Args&&... __args)\n    {\n      return ((*std::forward<_Tp>(__t)).*__f)(std::forward<_Args>(__args)...);\n    }\n\n  template<ty'
[#] parse_declaration, is_constructor=False, meet line: '_Res\n    __invoke_impl(__invoke_memobj_ref, _MemPtr&& __f, _Tp&& __t)\n    { return __invfwd<_Tp>(__t).*__f; }\n\n  template<typename _Res, typename _MemPtr, typename _Tp>\n    constexpr _Res\n    __invoke'
[#] parse_declaration, is_constructor=False, meet line: '_Res\n    __invoke_impl(__invoke_memobj_deref, _MemPtr&& __f, _Tp&& __t)\n    { return (*std::forward<_Tp>(__t)).*__f; }\n\n\n  template<typename _Callable, typename... _Args>\n    constexpr typename __invo'
[#] parse_declaration, is_constructor=False, meet line: '__invoke_result<_Callable, _Args...>::type\n    __invoke(_Callable&& __fn, _Args&&... __args)\n    noexcept(__is_nothrow_invocable<_Callable, _Args...>::value)\n    {\n      using __result = __invoke_resu'
[#] parse_declaration, is_constructor=True, meet line: '_Head_base()\n      : _Head() { }\n\n      constexpr _Head_base(const _Head& __h)\n      : _Head(__h) { }\n\n      constexpr _Head_base(const _Head_base&) = default;\n      constexpr _Head_base(_Head_base&&)'
[#] parse_declaration, is_constructor=True, meet line: '_Head_base(const _Head& __h)\n      : _Head(__h) { }\n\n      constexpr _Head_base(const _Head_base&) = default;\n      constexpr _Head_base(_Head_base&&) = default;\n\n      template<typename _UHead>\n     '
[#] parse_declaration, is_constructor=True, meet line: '_Head_base(const _Head_base&) = default;\n      constexpr _Head_base(_Head_base&&) = default;\n\n      template<typename _UHead>\n        constexpr _Head_base(_UHead&& __h)\n : _Head(std::forward<_UHead>(_'
[#] parse_declaration, is_constructor=True, meet line: '_Head_base(_Head_base&&) = default;\n\n      template<typename _UHead>\n        constexpr _Head_base(_UHead&& __h)\n : _Head(std::forward<_UHead>(__h)) { }\n\n      _Head_base(allocator_arg_t, __uses_alloc0'
[#] parse_declaration, is_constructor=True, meet line: '_Head_base(_UHead&& __h)\n : _Head(std::forward<_UHead>(__h)) { }\n\n      _Head_base(allocator_arg_t, __uses_alloc0)\n      : _Head() { }\n\n      template<typename _Alloc>\n _Head_base(allocator_arg_t, __u'
[#] parse_declaration, is_constructor=True, meet line: '_Head_base(allocator_arg_t, __uses_alloc0)\n      : _Head() { }\n\n      template<typename _Alloc>\n _Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)\n : _Head(allocator_arg, *__a._M_a) { }\n\n      te'
[#] parse_declaration, is_constructor=True, meet line: '_Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)\n : _Head(allocator_arg, *__a._M_a) { }\n\n      template<typename _Alloc>\n _Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)\n : _Head(*__a._M_'
[#] parse_declaration, is_constructor=True, meet line: '_Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)\n : _Head(*__a._M_a) { }\n\n      template<typename _UHead>\n _Head_base(__uses_alloc0, _UHead&& __uhead)\n : _Head(std::forward<_UHead>(__uhead)) { }'
[#] parse_declaration, is_constructor=True, meet line: '_Head_base(__uses_alloc0, _UHead&& __uhead)\n : _Head(std::forward<_UHead>(__uhead)) { }\n\n      template<typename _Alloc, typename _UHead>\n _Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)\n : _H'
[#] parse_declaration, is_constructor=True, meet line: '_Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)\n : _Head(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead)) { }\n\n      template<typename _Alloc, typename _UHead>\n _Head_base(__uses_alloc'
[#] parse_declaration, is_constructor=True, meet line: '_Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)\n : _Head(std::forward<_UHead>(__uhead), *__a._M_a) { }\n\n      static constexpr _Head&\n      _M_head(_Head_base& __b) noexcept { return __b; }\n\n '
[#] parse_declaration, is_constructor=False, meet line: '_Head&\n      _M_head(_Head_base& __b) noexcept { return __b; }\n\n      static constexpr const _Head&\n      _M_head(const _Head_base& __b) noexcept { return __b; }\n    };\n\n  template<std::size_t _Idx, t'
[#] parse_declaration, is_constructor=False, meet line: '_Head&\n      _M_head(const _Head_base& __b) noexcept { return __b; }\n    };\n\n  template<std::size_t _Idx, typename _Head>\n    struct _Head_base<_Idx, _Head, false>\n    {\n      constexpr _Head_base()\n '
[#] parse_declaration, is_constructor=True, meet line: '_Head_base()\n      : _M_head_impl() { }\n\n      constexpr _Head_base(const _Head& __h)\n      : _M_head_impl(__h) { }\n\n      constexpr _Head_base(const _Head_base&) = default;\n      constexpr _Head_base'
[#] parse_declaration, is_constructor=True, meet line: '_Head_base(const _Head& __h)\n      : _M_head_impl(__h) { }\n\n      constexpr _Head_base(const _Head_base&) = default;\n      constexpr _Head_base(_Head_base&&) = default;\n\n      template<typename _UHead'
[#] parse_declaration, is_constructor=True, meet line: '_Head_base(const _Head_base&) = default;\n      constexpr _Head_base(_Head_base&&) = default;\n\n      template<typename _UHead>\n        constexpr _Head_base(_UHead&& __h)\n : _M_head_impl(std::forward<_U'
[#] parse_declaration, is_constructor=True, meet line: '_Head_base(_Head_base&&) = default;\n\n      template<typename _UHead>\n        constexpr _Head_base(_UHead&& __h)\n : _M_head_impl(std::forward<_UHead>(__h)) { }\n\n      _Head_base(allocator_arg_t, __uses'
[#] parse_declaration, is_constructor=True, meet line: '_Head_base(_UHead&& __h)\n : _M_head_impl(std::forward<_UHead>(__h)) { }\n\n      _Head_base(allocator_arg_t, __uses_alloc0)\n      : _M_head_impl() { }\n\n      template<typename _Alloc>\n _Head_base(alloca'
[#] parse_declaration, is_constructor=True, meet line: '_Head_base(allocator_arg_t, __uses_alloc0)\n      : _M_head_impl() { }\n\n      template<typename _Alloc>\n _Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)\n : _M_head_impl(allocator_arg, *__a._M_a)'
[#] parse_declaration, is_constructor=True, meet line: '_Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)\n : _M_head_impl(allocator_arg, *__a._M_a) { }\n\n      template<typename _Alloc>\n _Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)\n : _M_head'
[#] parse_declaration, is_constructor=True, meet line: '_Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)\n : _M_head_impl(*__a._M_a) { }\n\n      template<typename _UHead>\n _Head_base(__uses_alloc0, _UHead&& __uhead)\n : _M_head_impl(std::forward<_UHead>'
[#] parse_declaration, is_constructor=True, meet line: '_Head_base(__uses_alloc0, _UHead&& __uhead)\n : _M_head_impl(std::forward<_UHead>(__uhead)) { }\n\n      template<typename _Alloc, typename _UHead>\n _Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead'
[#] parse_declaration, is_constructor=True, meet line: '_Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)\n : _M_head_impl(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead))\n { }\n\n      template<typename _Alloc, typename _UHead>\n _Head_base(__us'
[#] parse_declaration, is_constructor=True, meet line: '_Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)\n : _M_head_impl(std::forward<_UHead>(__uhead), *__a._M_a) { }\n\n      static constexpr _Head&\n      _M_head(_Head_base& __b) noexcept { return __'
[#] parse_declaration, is_constructor=False, meet line: '_Head&\n      _M_head(_Head_base& __b) noexcept { return __b._M_head_impl; }\n\n      static constexpr const _Head&\n      _M_head(const _Head_base& __b) noexcept { return __b._M_head_impl; }\n\n      _Head'
[#] parse_declaration, is_constructor=False, meet line: '_Head&\n      _M_head(const _Head_base& __b) noexcept { return __b._M_head_impl; }\n\n      _Head _M_head_impl;\n    };\n# 176 "/usr/include/c++/7/tuple" 3\n  template<std::size_t _Idx, typename... _Element'
[#] parse_declaration, is_constructor=False, meet line: '_Head _M_head_impl;\n    };\n# 176 "/usr/include/c++/7/tuple" 3\n  template<std::size_t _Idx, typename... _Elements>\n    struct _Tuple_impl;\n\n\n\n\n\n\n  template<std::size_t _Idx, typename _Head, typename...'
[#] parse_declaration, is_constructor=False, meet line: '_Head&\n      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }\n\n      static constexpr const _Head&\n      _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }\n\n   '
[#] parse_declaration, is_constructor=False, meet line: '_Head&\n      _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }\n\n      static constexpr _Inherited&\n      _M_tail(_Tuple_impl& __t) noexcept { return __t; }\n\n      static constex'
[#] parse_declaration, is_constructor=False, meet line: '_Inherited&\n      _M_tail(_Tuple_impl& __t) noexcept { return __t; }\n\n      static constexpr const _Inherited&\n      _M_tail(const _Tuple_impl& __t) noexcept { return __t; }\n\n      constexpr _Tuple_im'
[#] parse_declaration, is_constructor=False, meet line: '_Inherited&\n      _M_tail(const _Tuple_impl& __t) noexcept { return __t; }\n\n      constexpr _Tuple_impl()\n      : _Inherited(), _Base() { }\n\n      explicit\n      constexpr _Tuple_impl(const _Head& __h'
[#] parse_declaration, is_constructor=True, meet line: '_Tuple_impl()\n      : _Inherited(), _Base() { }\n\n      explicit\n      constexpr _Tuple_impl(const _Head& __head, const _Tail&... __tail)\n      : _Inherited(__tail...), _Base(__head) { }\n\n      templat'
[#] parse_declaration, is_constructor=True, meet line: '_Tuple_impl(const _Head& __head, const _Tail&... __tail)\n      : _Inherited(__tail...), _Base(__head) { }\n\n      template<typename _UHead, typename... _UTail, typename = typename\n               enable'
[#] parse_declaration, is_constructor=True, meet line: '_Tuple_impl(_UHead&& __head, _UTail&&... __tail)\n : _Inherited(std::forward<_UTail>(__tail)...),\n   _Base(std::forward<_UHead>(__head)) { }\n\n      constexpr _Tuple_impl(const _Tuple_impl&) = default;\n'
[#] parse_declaration, is_constructor=True, meet line: '_Tuple_impl(const _Tuple_impl&) = default;\n\n      constexpr\n      _Tuple_impl(_Tuple_impl&& __in)\n      noexcept(__and_<is_nothrow_move_constructible<_Head>,\n               is_nothrow_move_constructib'
[#] parse_declaration, is_constructor=True, meet line: '_Tuple_impl(_Tuple_impl&& __in)\n      noexcept(__and_<is_nothrow_move_constructible<_Head>,\n               is_nothrow_move_constructible<_Inherited>>::value)\n      : _Inherited(std::move(_M_tail(__in)'
[#] parse_declaration, is_constructor=True, meet line: '_Tuple_impl(const _Tuple_impl<_Idx, _UElements...>& __in)\n : _Inherited(_Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),\n   _Base(_Tuple_impl<_Idx, _UElements...>::_M_head(__in)) { }\n\n      template<'
[#] parse_declaration, is_constructor=True, meet line: '_Tuple_impl(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)\n : _Inherited(std::move\n       (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),\n   _Base(std::forward<_UHead>\n  (_Tuple_impl<_Idx, _UH'
[#] parse_declaration, is_constructor=True, meet line: '_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a)\n : _Inherited(__tag, __a),\n          _Base(__tag, __use_alloc<_Head>(__a)) { }\n\n      template<typename _Alloc>\n _Tuple_impl(allocator_arg_t __tag'
[#] parse_declaration, is_constructor=True, meet line: '_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,\n      const _Head& __head, const _Tail&... __tail)\n : _Inherited(__tag, __a, __tail...),\n          _Base(__use_alloc<_Head, _Alloc, _Head>(__a), _'
[#] parse_declaration, is_constructor=True, meet line: '_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,\n             _UHead&& __head, _UTail&&... __tail)\n : _Inherited(__tag, __a, std::forward<_UTail>(__tail)...),\n          _Base(__use_alloc<_Head, _'
[#] parse_declaration, is_constructor=True, meet line: '_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,\n             const _Tuple_impl& __in)\n : _Inherited(__tag, __a, _M_tail(__in)),\n          _Base(__use_alloc<_Head, _Alloc, _Head>(__a), _M_head(__'
[#] parse_declaration, is_constructor=True, meet line: '_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,\n             _Tuple_impl&& __in)\n : _Inherited(__tag, __a, std::move(_M_tail(__in))),\n   _Base(__use_alloc<_Head, _Alloc, _Head>(__a),\n         st'
[#] parse_declaration, is_constructor=True, meet line: '_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,\n             const _Tuple_impl<_Idx, _UElements...>& __in)\n : _Inherited(__tag, __a,\n       _Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),\n   _'
[#] parse_declaration, is_constructor=True, meet line: '_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,\n             _Tuple_impl<_Idx, _UHead, _UTails...>&& __in)\n : _Inherited(__tag, __a, std::move\n       (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_t'
[#] parse_declaration, is_constructor=True, meet line: '_Tuple_impl&\n      operator=(const _Tuple_impl& __in)\n      {\n _M_head(*this) = _M_head(__in);\n _M_tail(*this) = _M_tail(__in);\n return *this;\n      }\n\n      _Tuple_impl&\n      operator=(_Tuple_impl&&'
[#] parse_declaration, is_constructor=True, meet line: '_Tuple_impl&\n      operator=(_Tuple_impl&& __in)\n      noexcept(__and_<is_nothrow_move_assignable<_Head>,\n               is_nothrow_move_assignable<_Inherited>>::value)\n      {\n _M_head(*this) = std::'
[#] parse_declaration, is_constructor=True, meet line: '_Tuple_impl&\n        operator=(const _Tuple_impl<_Idx, _UElements...>& __in)\n        {\n   _M_head(*this) = _Tuple_impl<_Idx, _UElements...>::_M_head(__in);\n   _M_tail(*this) = _Tuple_impl<_Idx, _UElem'
[#] parse_declaration, is_constructor=True, meet line: '_Tuple_impl&\n        operator=(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)\n        {\n   _M_head(*this) = std::forward<_UHead>\n     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in));\n   _M_tail('
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_swap(_Tuple_impl& __in)\n      noexcept(__is_nothrow_swappable<_Head>::value\n               && noexcept(_M_tail(__in)._M_swap(_M_tail(__in))))\n      {\n using std::swap;\n swap(_M_head(*thi'
[#] parse_declaration, is_constructor=False, meet line: '_Head&\n      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }\n\n      static constexpr const _Head&\n      _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }\n\n   '
[#] parse_declaration, is_constructor=False, meet line: '_Head&\n      _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }\n\n      constexpr _Tuple_impl()\n      : _Base() { }\n\n      explicit\n      constexpr _Tuple_impl(const _Head& __head'
[#] parse_declaration, is_constructor=True, meet line: '_Tuple_impl()\n      : _Base() { }\n\n      explicit\n      constexpr _Tuple_impl(const _Head& __head)\n      : _Base(__head) { }\n\n      template<typename _UHead>\n        explicit\n        constexpr _Tuple_'
[#] parse_declaration, is_constructor=True, meet line: '_Tuple_impl(const _Head& __head)\n      : _Base(__head) { }\n\n      template<typename _UHead>\n        explicit\n        constexpr _Tuple_impl(_UHead&& __head)\n : _Base(std::forward<_UHead>(__head)) { }\n\n'
[#] parse_declaration, is_constructor=True, meet line: '_Tuple_impl(_UHead&& __head)\n : _Base(std::forward<_UHead>(__head)) { }\n\n      constexpr _Tuple_impl(const _Tuple_impl&) = default;\n\n      constexpr\n      _Tuple_impl(_Tuple_impl&& __in)\n      noexcep'
[#] parse_declaration, is_constructor=True, meet line: '_Tuple_impl(const _Tuple_impl&) = default;\n\n      constexpr\n      _Tuple_impl(_Tuple_impl&& __in)\n      noexcept(is_nothrow_move_constructible<_Head>::value)\n      : _Base(std::forward<_Head>(_M_head('
[#] parse_declaration, is_constructor=True, meet line: '_Tuple_impl(_Tuple_impl&& __in)\n      noexcept(is_nothrow_move_constructible<_Head>::value)\n      : _Base(std::forward<_Head>(_M_head(__in))) { }\n\n      template<typename _UHead>\n        constexpr _Tu'
[#] parse_declaration, is_constructor=True, meet line: '_Tuple_impl(const _Tuple_impl<_Idx, _UHead>& __in)\n : _Base(_Tuple_impl<_Idx, _UHead>::_M_head(__in)) { }\n\n      template<typename _UHead>\n        constexpr _Tuple_impl(_Tuple_impl<_Idx, _UHead>&& __i'
[#] parse_declaration, is_constructor=True, meet line: '_Tuple_impl(_Tuple_impl<_Idx, _UHead>&& __in)\n : _Base(std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))\n { }\n\n      template<typename _Alloc>\n _Tuple_impl(allocator_arg_t __tag, const _'
[#] parse_declaration, is_constructor=True, meet line: '_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a)\n : _Base(__tag, __use_alloc<_Head>(__a)) { }\n\n      template<typename _Alloc>\n _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,\n      const _'
[#] parse_declaration, is_constructor=True, meet line: '_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,\n      const _Head& __head)\n : _Base(__use_alloc<_Head, _Alloc, _Head>(__a), __head) { }\n\n      template<typename _Alloc, typename _UHead>\n _Tuple_'
[#] parse_declaration, is_constructor=True, meet line: '_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,\n             _UHead&& __head)\n : _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),\n         std::forward<_UHead>(__head)) { }\n\n      template<typenam'
[#] parse_declaration, is_constructor=True, meet line: '_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,\n             const _Tuple_impl& __in)\n : _Base(__use_alloc<_Head, _Alloc, _Head>(__a), _M_head(__in)) { }\n\n      template<typename _Alloc>\n _Tuple'
[#] parse_declaration, is_constructor=True, meet line: '_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,\n             _Tuple_impl&& __in)\n : _Base(__use_alloc<_Head, _Alloc, _Head>(__a),\n         std::forward<_Head>(_M_head(__in))) { }\n\n      template'
[#] parse_declaration, is_constructor=True, meet line: '_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,\n             const _Tuple_impl<_Idx, _UHead>& __in)\n : _Base(__use_alloc<_Head, _Alloc, _Head>(__a),\n  _Tuple_impl<_Idx, _UHead>::_M_head(__in)) {'
[#] parse_declaration, is_constructor=True, meet line: '_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,\n             _Tuple_impl<_Idx, _UHead>&& __in)\n : _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),\n                std::forward<_UHead>(_Tuple_impl<'
[#] parse_declaration, is_constructor=True, meet line: '_Tuple_impl&\n      operator=(const _Tuple_impl& __in)\n      {\n _M_head(*this) = _M_head(__in);\n return *this;\n      }\n\n      _Tuple_impl&\n      operator=(_Tuple_impl&& __in)\n      noexcept(is_nothrow_'
[#] parse_declaration, is_constructor=True, meet line: '_Tuple_impl&\n      operator=(_Tuple_impl&& __in)\n      noexcept(is_nothrow_move_assignable<_Head>::value)\n      {\n _M_head(*this) = std::forward<_Head>(_M_head(__in));\n return *this;\n      }\n\n      te'
[#] parse_declaration, is_constructor=True, meet line: '_Tuple_impl&\n        operator=(const _Tuple_impl<_Idx, _UHead>& __in)\n        {\n   _M_head(*this) = _Tuple_impl<_Idx, _UHead>::_M_head(__in);\n   return *this;\n }\n\n      template<typename _UHead>\n     '
[#] parse_declaration, is_constructor=True, meet line: '_Tuple_impl&\n        operator=(_Tuple_impl<_Idx, _UHead>&& __in)\n        {\n   _M_head(*this)\n     = std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in));\n   return *this;\n }\n\n    protected:\n'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_swap(_Tuple_impl& __in)\n      noexcept(__is_nothrow_swappable<_Head>::value)\n      {\n using std::swap;\n swap(_M_head(*this), _M_head(__in));\n      }\n    };\n\n\n\n  template<bool, typename..'
[#] parse_declaration, is_constructor=False, meet line: 'bool _ConstructibleTuple()\n    {\n      return __and_<is_constructible<_Elements, const _UElements&>...>::value;\n    }\n\n    template<typename... _UElements>\n    static constexpr bool _ImplicitlyConvert'
[#] parse_declaration, is_constructor=False, meet line: 'bool _ImplicitlyConvertibleTuple()\n    {\n      return __and_<is_convertible<const _UElements&, _Elements>...>::value;\n    }\n\n    template<typename... _UElements>\n    static constexpr bool _MoveConstru'
[#] parse_declaration, is_constructor=False, meet line: 'bool _MoveConstructibleTuple()\n    {\n      return __and_<is_constructible<_Elements, _UElements&&>...>::value;\n    }\n\n    template<typename... _UElements>\n    static constexpr bool _ImplicitlyMoveConv'
[#] parse_declaration, is_constructor=False, meet line: 'bool _ImplicitlyMoveConvertibleTuple()\n    {\n      return __and_<is_convertible<_UElements&&, _Elements>...>::value;\n    }\n\n    template<typename _SrcTuple>\n    static constexpr bool _NonNestedTuple()'
[#] parse_declaration, is_constructor=False, meet line: 'bool _NonNestedTuple()\n    {\n      return __and_<__not_<is_same<tuple<_Elements...>,\n                                   typename remove_cv<\n                                     typename remove_referen'
[#] parse_declaration, is_constructor=False, meet line: 'bool _NotSameTuple()\n    {\n      return __not_<is_same<tuple<_Elements...>,\n        typename remove_const<\n          typename remove_reference<_UElements...>::type\n          >::type>>::value;\n    }\n  '
[#] parse_declaration, is_constructor=False, meet line: 'bool _ConstructibleTuple()\n    {\n      return false;\n    }\n\n    template<typename... _UElements>\n    static constexpr bool _ImplicitlyConvertibleTuple()\n    {\n      return false;\n    }\n\n    template<t'
[#] parse_declaration, is_constructor=False, meet line: 'bool _ImplicitlyConvertibleTuple()\n    {\n      return false;\n    }\n\n    template<typename... _UElements>\n    static constexpr bool _MoveConstructibleTuple()\n    {\n      return false;\n    }\n\n    templa'
[#] parse_declaration, is_constructor=False, meet line: 'bool _MoveConstructibleTuple()\n    {\n      return false;\n    }\n\n    template<typename... _UElements>\n    static constexpr bool _ImplicitlyMoveConvertibleTuple()\n    {\n      return false;\n    }\n\n    te'
[#] parse_declaration, is_constructor=False, meet line: 'bool _ImplicitlyMoveConvertibleTuple()\n    {\n      return false;\n    }\n\n    template<typename... _UElements>\n    static constexpr bool _NonNestedTuple()\n    {\n      return true;\n    }\n    template<typ'
[#] parse_declaration, is_constructor=False, meet line: 'bool _NonNestedTuple()\n    {\n      return true;\n    }\n    template<typename... _UElements>\n    static constexpr bool _NotSameTuple()\n    {\n      return true;\n    }\n  };\n\n\n  template<typename... _Eleme'
[#] parse_declaration, is_constructor=False, meet line: 'bool _NotSameTuple()\n    {\n      return true;\n    }\n  };\n\n\n  template<typename... _Elements>\n    class tuple : public _Tuple_impl<0, _Elements...>\n    {\n      typedef _Tuple_impl<0, _Elements...> _Inh'
[#] parse_declaration, is_constructor=False, meet line: 'bool _DefaultConstructibleTuple()\n        {\n          return __and_<is_default_constructible<_Elements>...>::value;\n        }\n        static constexpr bool _ImplicitlyDefaultConstructibleTuple()\n     '
[#] parse_declaration, is_constructor=False, meet line: 'bool _ImplicitlyDefaultConstructibleTuple()\n        {\n          return __and_<__is_implicitly_default_constructible<_Elements>...>\n            ::value;\n        }\n      };\n\n    public:\n      template<t'
[#] parse_declaration, is_constructor=True, meet line: 'tuple()\n      : _Inherited() { }\n\n      template<typename _Dummy = void,\n               typename enable_if<_TC2<_Dummy>::\n                                    _DefaultConstructibleTuple()\n             '
[#] parse_declaration, is_constructor=True, meet line: 'tuple()\n      : _Inherited() { }\n\n\n\n      template<typename _Dummy> using _TCC =\n        _TC<is_same<_Dummy, void>::value,\n            _Elements...>;\n\n      template<typename _Dummy = void,\n          '
[#] parse_declaration, is_constructor=True, meet line: 'tuple(const _Elements&... __elements)\n      : _Inherited(__elements...) { }\n\n      template<typename _Dummy = void,\n               typename enable_if<\n                 _TCC<_Dummy>::template\n         '
[#] parse_declaration, is_constructor=True, meet line: 'tuple(const _Elements&... __elements)\n      : _Inherited(__elements...) { }\n\n\n\n      template<typename... _UElements> using _TMC =\n                  _TC<(sizeof...(_Elements) == sizeof...(_UElements))'
[#] parse_declaration, is_constructor=True, meet line: 'tuple(_UElements&&... __elements)\n        : _Inherited(std::forward<_UElements>(__elements)...) { }\n\n      template<typename... _UElements, typename\n        enable_if<\n    _TMC<_UElements...>::templat'
[#] parse_declaration, is_constructor=True, meet line: 'tuple(_UElements&&... __elements)\n : _Inherited(std::forward<_UElements>(__elements)...) { }\n\n      constexpr tuple(const tuple&) = default;\n\n      constexpr tuple(tuple&&) = default;\n\n\n\n      templat'
[#] parse_declaration, is_constructor=True, meet line: 'tuple(const tuple&) = default;\n\n      constexpr tuple(tuple&&) = default;\n\n\n\n      template<typename _Dummy> using _TNTC =\n        _TC<is_same<_Dummy, void>::value && sizeof...(_Elements) == 1,\n      '
[#] parse_declaration, is_constructor=True, meet line: 'tuple(tuple&&) = default;\n\n\n\n      template<typename _Dummy> using _TNTC =\n        _TC<is_same<_Dummy, void>::value && sizeof...(_Elements) == 1,\n            _Elements...>;\n\n      template<typename...'
[#] parse_declaration, is_constructor=True, meet line: 'tuple(const tuple<_UElements...>& __in)\n        : _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))\n        { }\n\n      template<typename... _UElements, typename _Dummy = void, typena'
[#] parse_declaration, is_constructor=True, meet line: 'tuple(const tuple<_UElements...>& __in)\n        : _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))\n        { }\n\n      template<typename... _UElements, typename _Dummy = void, typena'
[#] parse_declaration, is_constructor=True, meet line: 'tuple(tuple<_UElements...>&& __in)\n        : _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in)) { }\n\n      template<typename... _UElements, typename _Dummy = void, typename\n        enable_'
[#] parse_declaration, is_constructor=True, meet line: 'tuple(tuple<_UElements...>&& __in)\n        : _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in)) { }\n\n\n\n      template<typename _Alloc>\n tuple(allocator_arg_t __tag, const _Alloc& __a)\n : _'
[#] parse_declaration, is_constructor=True, meet line: 'tuple(allocator_arg_t __tag, const _Alloc& __a)\n : _Inherited(__tag, __a) { }\n\n      template<typename _Alloc, typename _Dummy = void,\n               typename enable_if<\n                 _TCC<_Dummy>:'
[#] parse_declaration, is_constructor=True, meet line: 'tuple(allocator_arg_t __tag, const _Alloc& __a,\n       const _Elements&... __elements)\n : _Inherited(__tag, __a, __elements...) { }\n\n      template<typename _Alloc, typename _Dummy = void,\n           '
[#] parse_declaration, is_constructor=True, meet line: 'tuple(allocator_arg_t __tag, const _Alloc& __a,\n                       const _Elements&... __elements)\n : _Inherited(__tag, __a, __elements...) { }\n\n      template<typename _Alloc, typename... _UEleme'
[#] parse_declaration, is_constructor=True, meet line: 'tuple(allocator_arg_t __tag, const _Alloc& __a,\n       _UElements&&... __elements)\n : _Inherited(__tag, __a, std::forward<_UElements>(__elements)...)\n        { }\n\n      template<typename _Alloc, typen'
[#] parse_declaration, is_constructor=True, meet line: 'tuple(allocator_arg_t __tag, const _Alloc& __a,\n       _UElements&&... __elements)\n : _Inherited(__tag, __a, std::forward<_UElements>(__elements)...)\n        { }\n\n      template<typename _Alloc>\n tupl'
[#] parse_declaration, is_constructor=True, meet line: 'tuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __in)\n : _Inherited(__tag, __a, static_cast<const _Inherited&>(__in)) { }\n\n      template<typename _Alloc>\n tuple(allocator_arg_t __tag, co'
[#] parse_declaration, is_constructor=True, meet line: 'tuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)\n : _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }\n\n      template<typename _Alloc, typename _Dummy = void,\n        typename..'
[#] parse_declaration, is_constructor=True, meet line: 'tuple(allocator_arg_t __tag, const _Alloc& __a,\n       const tuple<_UElements...>& __in)\n : _Inherited(__tag, __a,\n              static_cast<const _Tuple_impl<0, _UElements...>&>(__in))\n { }\n\n      te'
[#] parse_declaration, is_constructor=True, meet line: 'tuple(allocator_arg_t __tag, const _Alloc& __a,\n       const tuple<_UElements...>& __in)\n : _Inherited(__tag, __a,\n              static_cast<const _Tuple_impl<0, _UElements...>&>(__in))\n { }\n\n      te'
[#] parse_declaration, is_constructor=True, meet line: 'tuple(allocator_arg_t __tag, const _Alloc& __a,\n       tuple<_UElements...>&& __in)\n : _Inherited(__tag, __a,\n              static_cast<_Tuple_impl<0, _UElements...>&&>(__in))\n { }\n\n      template<typ'
[#] parse_declaration, is_constructor=True, meet line: 'tuple(allocator_arg_t __tag, const _Alloc& __a,\n       tuple<_UElements...>&& __in)\n : _Inherited(__tag, __a,\n              static_cast<_Tuple_impl<0, _UElements...>&&>(__in))\n { }\n\n      tuple&\n     '
[#] parse_declaration, is_constructor=True, meet line: 'tuple&\n      operator=(const tuple& __in)\n      {\n static_cast<_Inherited&>(*this) = __in;\n return *this;\n      }\n\n      tuple&\n      operator=(tuple&& __in)\n      noexcept(is_nothrow_move_assignable<'
[#] parse_declaration, is_constructor=True, meet line: 'tuple&\n      operator=(tuple&& __in)\n      noexcept(is_nothrow_move_assignable<_Inherited>::value)\n      {\n static_cast<_Inherited&>(*this) = std::move(__in);\n return *this;\n      }\n\n      template<ty'
[#] parse_declaration, is_constructor=False, meet line: 'enable_if<sizeof...(_UElements)\n    == sizeof...(_Elements), tuple&>::type\n        operator=(const tuple<_UElements...>& __in)\n        {\n   static_cast<_Inherited&>(*this) = __in;\n   return *this;\n }\n'
[#] parse_declaration, is_constructor=False, meet line: 'enable_if<sizeof...(_UElements)\n    == sizeof...(_Elements), tuple&>::type\n        operator=(tuple<_UElements...>&& __in)\n        {\n   static_cast<_Inherited&>(*this) = std::move(__in);\n   return *thi'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      swap(tuple& __in)\n      noexcept(noexcept(__in._M_swap(__in)))\n      { _Inherited::_M_swap(__in); }\n    };\n# 889 "/usr/include/c++/7/tuple" 3\n  template<>\n    class tuple<>\n    {\n    public'
[#] parse_declaration, is_constructor=False, meet line: 'void swap(tuple&) noexcept { }\n\n\n      tuple() = default;\n\n      template<typename _Alloc>\n tuple(allocator_arg_t, const _Alloc&) { }\n      template<typename _Alloc>\n tuple(allocator_arg_t, const _All'
[#] parse_declaration, is_constructor=True, meet line: 'tuple() = default;\n\n      template<typename _Alloc>\n tuple(allocator_arg_t, const _Alloc&) { }\n      template<typename _Alloc>\n tuple(allocator_arg_t, const _Alloc&, const tuple&) { }\n    };\n\n\n\n  temp'
[#] parse_declaration, is_constructor=True, meet line: 'tuple(allocator_arg_t, const _Alloc&) { }\n      template<typename _Alloc>\n tuple(allocator_arg_t, const _Alloc&, const tuple&) { }\n    };\n\n\n\n  template<typename _T1, typename _T2>\n    class tuple<_T1,'
[#] parse_declaration, is_constructor=True, meet line: 'tuple(allocator_arg_t, const _Alloc&, const tuple&) { }\n    };\n\n\n\n  template<typename _T1, typename _T2>\n    class tuple<_T1, _T2> : public _Tuple_impl<0, _T1, _T2>\n    {\n      typedef _Tuple_impl<0, '
[#] parse_declaration, is_constructor=True, meet line: 'tuple()\n      : _Inherited() { }\n\n      template <typename _U1 = _T1,\n                typename _U2 = _T2,\n                typename enable_if<\n                  __and_<\n                    is_default_c'
[#] parse_declaration, is_constructor=True, meet line: 'tuple()\n      : _Inherited() { }\n\n\n\n      template<typename _Dummy> using _TCC =\n        _TC<is_same<_Dummy, void>::value, _T1, _T2>;\n\n      template<typename _Dummy = void, typename\n               en'
[#] parse_declaration, is_constructor=True, meet line: 'tuple(const _T1& __a1, const _T2& __a2)\n        : _Inherited(__a1, __a2) { }\n\n      template<typename _Dummy = void, typename\n               enable_if<_TCC<_Dummy>::template\n                          '
[#] parse_declaration, is_constructor=True, meet line: 'tuple(const _T1& __a1, const _T2& __a2)\n        : _Inherited(__a1, __a2) { }\n\n\n\n      using _TMC = _TC<true, _T1, _T2>;\n\n      template<typename _U1, typename _U2, typename\n        enable_if<_TMC::tem'
[#] parse_declaration, is_constructor=True, meet line: 'tuple(_U1&& __a1, _U2&& __a2)\n : _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) { }\n\n      template<typename _U1, typename _U2, typename\n        enable_if<_TMC::template\n                '
[#] parse_declaration, is_constructor=True, meet line: 'tuple(_U1&& __a1, _U2&& __a2)\n : _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) { }\n\n      constexpr tuple(const tuple&) = default;\n\n      constexpr tuple(tuple&&) = default;\n\n      temp'
[#] parse_declaration, is_constructor=True, meet line: 'tuple(const tuple&) = default;\n\n      constexpr tuple(tuple&&) = default;\n\n      template<typename _U1, typename _U2, typename\n        enable_if<_TMC::template\n                    _ConstructibleTuple<'
[#] parse_declaration, is_constructor=True, meet line: 'tuple(tuple&&) = default;\n\n      template<typename _U1, typename _U2, typename\n        enable_if<_TMC::template\n                    _ConstructibleTuple<_U1, _U2>()\n                  && _TMC::template\n'
[#] parse_declaration, is_constructor=True, meet line: 'tuple(const tuple<_U1, _U2>& __in)\n : _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in)) { }\n\n      template<typename _U1, typename _U2, typename\n        enable_if<_TMC::template\n         '
[#] parse_declaration, is_constructor=True, meet line: 'tuple(const tuple<_U1, _U2>& __in)\n : _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in)) { }\n\n      template<typename _U1, typename _U2, typename\n        enable_if<_TMC::template\n         '
[#] parse_declaration, is_constructor=True, meet line: 'tuple(tuple<_U1, _U2>&& __in)\n : _Inherited(static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in)) { }\n\n      template<typename _U1, typename _U2, typename\n        enable_if<_TMC::template\n                   '
[#] parse_declaration, is_constructor=True, meet line: 'tuple(tuple<_U1, _U2>&& __in)\n : _Inherited(static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in)) { }\n\n      template<typename _U1, typename _U2, typename\n        enable_if<_TMC::template\n                   '
[#] parse_declaration, is_constructor=True, meet line: 'tuple(const pair<_U1, _U2>& __in)\n : _Inherited(__in.first, __in.second) { }\n\n      template<typename _U1, typename _U2, typename\n        enable_if<_TMC::template\n                    _ConstructibleTup'
[#] parse_declaration, is_constructor=True, meet line: 'tuple(const pair<_U1, _U2>& __in)\n : _Inherited(__in.first, __in.second) { }\n\n      template<typename _U1, typename _U2, typename\n        enable_if<_TMC::template\n                    _MoveConstructibl'
[#] parse_declaration, is_constructor=True, meet line: 'tuple(pair<_U1, _U2>&& __in)\n : _Inherited(std::forward<_U1>(__in.first),\n       std::forward<_U2>(__in.second)) { }\n\n      template<typename _U1, typename _U2, typename\n        enable_if<_TMC::templa'
[#] parse_declaration, is_constructor=True, meet line: 'tuple(pair<_U1, _U2>&& __in)\n : _Inherited(std::forward<_U1>(__in.first),\n       std::forward<_U2>(__in.second)) { }\n\n\n\n      template<typename _Alloc>\n tuple(allocator_arg_t __tag, const _Alloc& __a)'
[#] parse_declaration, is_constructor=True, meet line: 'tuple(allocator_arg_t __tag, const _Alloc& __a)\n : _Inherited(__tag, __a) { }\n\n      template<typename _Alloc, typename _Dummy = void,\n               typename enable_if<\n                 _TCC<_Dummy>:'
[#] parse_declaration, is_constructor=True, meet line: 'tuple(allocator_arg_t __tag, const _Alloc& __a,\n       const _T1& __a1, const _T2& __a2)\n : _Inherited(__tag, __a, __a1, __a2) { }\n\n      template<typename _Alloc, typename _Dummy = void,\n            '
[#] parse_declaration, is_constructor=True, meet line: 'tuple(allocator_arg_t __tag, const _Alloc& __a,\n       const _T1& __a1, const _T2& __a2)\n : _Inherited(__tag, __a, __a1, __a2) { }\n\n      template<typename _Alloc, typename _U1, typename _U2, typename'
[#] parse_declaration, is_constructor=True, meet line: 'tuple(allocator_arg_t __tag, const _Alloc& __a, _U1&& __a1, _U2&& __a2)\n : _Inherited(__tag, __a, std::forward<_U1>(__a1),\n              std::forward<_U2>(__a2)) { }\n\n      template<typename _Alloc, t'
[#] parse_declaration, is_constructor=True, meet line: 'tuple(allocator_arg_t __tag, const _Alloc& __a,\n                       _U1&& __a1, _U2&& __a2)\n : _Inherited(__tag, __a, std::forward<_U1>(__a1),\n              std::forward<_U2>(__a2)) { }\n\n      temp'
[#] parse_declaration, is_constructor=True, meet line: 'tuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __in)\n : _Inherited(__tag, __a, static_cast<const _Inherited&>(__in)) { }\n\n      template<typename _Alloc>\n tuple(allocator_arg_t __tag, co'
[#] parse_declaration, is_constructor=True, meet line: 'tuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)\n : _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }\n\n      template<typename _Alloc, typename _U1, typename _U2, typename\n     '
[#] parse_declaration, is_constructor=True, meet line: 'tuple(allocator_arg_t __tag, const _Alloc& __a,\n       const tuple<_U1, _U2>& __in)\n : _Inherited(__tag, __a,\n              static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in))\n { }\n\n      template<typ'
[#] parse_declaration, is_constructor=True, meet line: 'tuple(allocator_arg_t __tag, const _Alloc& __a,\n       const tuple<_U1, _U2>& __in)\n : _Inherited(__tag, __a,\n              static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in))\n { }\n\n      template<typ'
[#] parse_declaration, is_constructor=True, meet line: 'tuple(allocator_arg_t __tag, const _Alloc& __a, tuple<_U1, _U2>&& __in)\n : _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in))\n { }\n\n      template<typename _Alloc, typename _U1, typ'
[#] parse_declaration, is_constructor=True, meet line: 'tuple(allocator_arg_t __tag, const _Alloc& __a,\n                       tuple<_U1, _U2>&& __in)\n : _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in))\n { }\n\n      template<typename _A'
[#] parse_declaration, is_constructor=True, meet line: 'tuple(allocator_arg_t __tag, const _Alloc& __a,\n       const pair<_U1, _U2>& __in)\n : _Inherited(__tag, __a, __in.first, __in.second) { }\n\n      template<typename _Alloc, typename _U1, typename _U2, t'
[#] parse_declaration, is_constructor=True, meet line: 'tuple(allocator_arg_t __tag, const _Alloc& __a,\n       const pair<_U1, _U2>& __in)\n : _Inherited(__tag, __a, __in.first, __in.second) { }\n\n      template<typename _Alloc, typename _U1, typename _U2, t'
[#] parse_declaration, is_constructor=True, meet line: 'tuple(allocator_arg_t __tag, const _Alloc& __a, pair<_U1, _U2>&& __in)\n : _Inherited(__tag, __a, std::forward<_U1>(__in.first),\n       std::forward<_U2>(__in.second)) { }\n\n      template<typename _All'
[#] parse_declaration, is_constructor=True, meet line: 'tuple(allocator_arg_t __tag, const _Alloc& __a,\n                       pair<_U1, _U2>&& __in)\n : _Inherited(__tag, __a, std::forward<_U1>(__in.first),\n       std::forward<_U2>(__in.second)) { }\n\n     '
[#] parse_declaration, is_constructor=True, meet line: 'tuple&\n      operator=(const tuple& __in)\n      {\n static_cast<_Inherited&>(*this) = __in;\n return *this;\n      }\n\n      tuple&\n      operator=(tuple&& __in)\n      noexcept(is_nothrow_move_assignable<'
[#] parse_declaration, is_constructor=True, meet line: 'tuple&\n      operator=(tuple&& __in)\n      noexcept(is_nothrow_move_assignable<_Inherited>::value)\n      {\n static_cast<_Inherited&>(*this) = std::move(__in);\n return *this;\n      }\n\n      template<ty'
[#] parse_declaration, is_constructor=True, meet line: 'tuple&\n        operator=(const tuple<_U1, _U2>& __in)\n        {\n   static_cast<_Inherited&>(*this) = __in;\n   return *this;\n }\n\n      template<typename _U1, typename _U2>\n        tuple&\n        operat'
[#] parse_declaration, is_constructor=True, meet line: 'tuple&\n        operator=(tuple<_U1, _U2>&& __in)\n        {\n   static_cast<_Inherited&>(*this) = std::move(__in);\n   return *this;\n }\n\n      template<typename _U1, typename _U2>\n        tuple&\n        '
[#] parse_declaration, is_constructor=True, meet line: 'tuple&\n        operator=(const pair<_U1, _U2>& __in)\n        {\n   this->_M_head(*this) = __in.first;\n   this->_M_tail(*this)._M_head(*this) = __in.second;\n   return *this;\n }\n\n      template<typename '
[#] parse_declaration, is_constructor=True, meet line: 'tuple&\n        operator=(pair<_U1, _U2>&& __in)\n        {\n   this->_M_head(*this) = std::forward<_U1>(__in.first);\n   this->_M_tail(*this)._M_head(*this) = std::forward<_U2>(__in.second);\n   return *t'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      swap(tuple& __in)\n      noexcept(noexcept(__in._M_swap(__in)))\n      { _Inherited::_M_swap(__in); }\n    };\n\n\n\n  template<typename... _Elements>\n    struct tuple_size<tuple<_Elements...>>\n  '
[#] parse_declaration, is_constructor=False, meet line: '_Head&\n    __get_helper(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept\n    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }\n\n  template<std::size_t __i, typename _Head, typename... _Tail>'
[#] parse_declaration, is_constructor=False, meet line: '_Head&\n    __get_helper(const _Tuple_impl<__i, _Head, _Tail...>& __t) noexcept\n    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }\n\n\n  template<std::size_t __i, typename... _Elements>\n    '
[#] parse_declaration, is_constructor=False, meet line: '__tuple_element_t<__i, tuple<_Elements...>>&\n    get(tuple<_Elements...>& __t) noexcept\n    { return std::__get_helper<__i>(__t); }\n\n\n  template<std::size_t __i, typename... _Elements>\n    constexpr c'
[#] parse_declaration, is_constructor=False, meet line: '__tuple_element_t<__i, tuple<_Elements...>>&\n    get(const tuple<_Elements...>& __t) noexcept\n    { return std::__get_helper<__i>(__t); }\n\n\n  template<std::size_t __i, typename... _Elements>\n    const'
[#] parse_declaration, is_constructor=False, meet line: '__tuple_element_t<__i, tuple<_Elements...>>&&\n    get(tuple<_Elements...>&& __t) noexcept\n    {\n      typedef __tuple_element_t<__i, tuple<_Elements...>> __element_type;\n      return std::forward<__el'
[#] parse_declaration, is_constructor=False, meet line: '_Head&\n    __get_helper2(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept\n    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }\n\n  template<typename _Head, size_t __i, typename... _Tail>\n   '
[#] parse_declaration, is_constructor=False, meet line: '_Head&\n    __get_helper2(const _Tuple_impl<__i, _Head, _Tail...>& __t) noexcept\n    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }\n\n\n  template <typename _Tp, typename... _Types>\n    cons'
[#] parse_declaration, is_constructor=False, meet line: '_Tp&\n    get(tuple<_Types...>& __t) noexcept\n    { return std::__get_helper2<_Tp>(__t); }\n\n\n  template <typename _Tp, typename... _Types>\n    constexpr _Tp&&\n    get(tuple<_Types...>&& __t) noexcept\n '
[#] parse_declaration, is_constructor=False, meet line: '_Tp&&\n    get(tuple<_Types...>&& __t) noexcept\n    { return std::forward<_Tp&&>(std::__get_helper2<_Tp>(__t)); }\n\n\n  template <typename _Tp, typename... _Types>\n    constexpr const _Tp&\n    get(const '
[#] parse_declaration, is_constructor=False, meet line: '_Tp&\n    get(const tuple<_Types...>& __t) noexcept\n    { return std::__get_helper2<_Tp>(__t); }\n\n\n\n  template<typename _Tp, typename _Up, size_t __i, size_t __size>\n    struct __tuple_compare\n    {\n  '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      __eq(const _Tp& __t, const _Up& __u)\n      {\n return bool(std::get<__i>(__t) == std::get<__i>(__u))\n   && __tuple_compare<_Tp, _Up, __i + 1, __size>::__eq(__t, __u);\n      }\n\n      static c'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      __less(const _Tp& __t, const _Up& __u)\n      {\n return bool(std::get<__i>(__t) < std::get<__i>(__u))\n   || (!bool(std::get<__i>(__u) < std::get<__i>(__t))\n       && __tuple_compare<_Tp, _Up'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      __eq(const _Tp&, const _Up&) { return true; }\n\n      static constexpr bool\n      __less(const _Tp&, const _Up&) { return false; }\n    };\n\n  template<typename... _TElements, typename... _UEl'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      __less(const _Tp&, const _Up&) { return false; }\n    };\n\n  template<typename... _TElements, typename... _UElements>\n    constexpr bool\n    operator==(const tuple<_TElements...>& __t,\n      '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator==(const tuple<_TElements...>& __t,\n        const tuple<_UElements...>& __u)\n    {\n      static_assert(sizeof...(_TElements) == sizeof...(_UElements),\n   "tuple objects can only be co'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<(const tuple<_TElements...>& __t,\n       const tuple<_UElements...>& __u)\n    {\n      static_assert(sizeof...(_TElements) == sizeof...(_UElements),\n   "tuple objects can only be comp'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator!=(const tuple<_TElements...>& __t,\n        const tuple<_UElements...>& __u)\n    { return !(__t == __u); }\n\n  template<typename... _TElements, typename... _UElements>\n    constexpr bo'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>(const tuple<_TElements...>& __t,\n       const tuple<_UElements...>& __u)\n    { return __u < __t; }\n\n  template<typename... _TElements, typename... _UElements>\n    constexpr bool\n   '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<=(const tuple<_TElements...>& __t,\n        const tuple<_UElements...>& __u)\n    { return !(__u < __t); }\n\n  template<typename... _TElements, typename... _UElements>\n    constexpr boo'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>=(const tuple<_TElements...>& __t,\n        const tuple<_UElements...>& __u)\n    { return !(__t < __u); }\n\n\n  template<typename... _Elements>\n    constexpr tuple<typename __decay_and_'
[#] parse_declaration, is_constructor=False, meet line: 'tuple<typename __decay_and_strip<_Elements>::__type...>\n    make_tuple(_Elements&&... __args)\n    {\n      typedef tuple<typename __decay_and_strip<_Elements>::__type...>\n __result_type;\n      return _'
[#] parse_declaration, is_constructor=False, meet line: 'tuple<_Elements&&...>\n    forward_as_tuple(_Elements&&... __args) noexcept\n    { return tuple<_Elements&&...>(std::forward<_Elements>(__args)...); }\n\n  template<size_t, typename, typename, size_t>\n   '
[#] parse_declaration, is_constructor=False, meet line: '_Ret\n        _S_do(_Tp&& __tp, _Tpls&&... __tps, _Us&&... __us)\n        {\n   typedef typename __make_1st_indices<_Tpls...>::__type __idx;\n   typedef __tuple_concater<_Ret, __idx, _Tpls...> __next;\n   '
[#] parse_declaration, is_constructor=False, meet line: '_Ret\n _S_do(_Us&&... __us)\n        {\n   return _Ret(std::forward<_Us>(__us)...);\n }\n    };\n\n\n  template<typename... _Tpls, typename = typename\n           enable_if<__and_<__is_tuple_like<_Tpls>...>::v'
[#] parse_declaration, is_constructor=False, meet line: 'auto\n    tuple_cat(_Tpls&&... __tpls)\n    -> typename __tuple_cat_result<_Tpls...>::__type\n    {\n      typedef typename __tuple_cat_result<_Tpls...>::__type __ret;\n      typedef typename __make_1st_in'
[#] parse_declaration, is_constructor=False, meet line: 'tuple<_Elements&...>\n    tie(_Elements&... __args) noexcept\n    { return tuple<_Elements&...>(__args...); }\n\n\n  template<typename... _Elements>\n    inline\n\n\n    typename enable_if<__and_<__is_swappabl'
[#] parse_declaration, is_constructor=False, meet line: 'enable_if<__and_<__is_swappable<_Elements>...>::value\n      >::type\n\n\n\n    swap(tuple<_Elements...>& __x, tuple<_Elements...>& __y)\n    noexcept(noexcept(__x.swap(__y)))\n    { __x.swap(__y); }\n\n\n  tem'
[#] parse_declaration, is_constructor=False, meet line: 'enable_if<!__and_<__is_swappable<_Elements>...>::value>::type\n    swap(tuple<_Elements...>&, tuple<_Elements...>&) = delete;\n\n\n\n\n\n\n  struct _Swallow_assign\n  {\n    template<class _Tp>\n      constexpr '
[#] parse_declaration, is_constructor=True, meet line: '_Swallow_assign&\n      operator=(const _Tp&) const\n      { return *this; }\n  };\n\n\n\n  constexpr _Swallow_assign ignore{};\n\n\n  template<typename... _Types, typename _Alloc>\n    struct uses_allocator<tup'
[#] parse_declaration, is_constructor=False, meet line: '_Swallow_assign ignore{};\n\n\n  template<typename... _Types, typename _Alloc>\n    struct uses_allocator<tuple<_Types...>, _Alloc> : true_type { };\n\n\n  template<class _T1, class _T2>\n    template<typenam'
[#] parse_declaration, is_constructor=False, meet line: 'pair<_T1, _T2>::\n      pair(piecewise_construct_t,\n    tuple<_Args1...> __first, tuple<_Args2...> __second)\n      : pair(__first, __second,\n      typename _Build_index_tuple<sizeof...(_Args1)>::__type'
[#] parse_declaration, is_constructor=False, meet line: 'pair<_T1, _T2>::\n      pair(tuple<_Args1...>& __tuple1, tuple<_Args2...>& __tuple2,\n    _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>)\n      : first(std::forward<_Args1>(std::get<_Indexes1>(_'
[#] parse_declaration, is_constructor=True, meet line: 'default_delete() noexcept = default;\n\n\n\n\n\n\n      template<typename _Up, typename = typename\n        enable_if<is_convertible<_Up*, _Tp*>::value>::type>\n        default_delete(const default_delete<_Up>'
[#] parse_declaration, is_constructor=True, meet line: 'default_delete(const default_delete<_Up>&) noexcept { }\n\n\n      void\n      operator()(_Tp* __ptr) const\n      {\n static_assert(!is_void<_Tp>::value,\n        "can\'t delete pointer to incomplete type");'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      operator()(_Tp* __ptr) const\n      {\n static_assert(!is_void<_Tp>::value,\n        "can\'t delete pointer to incomplete type");\n static_assert(sizeof(_Tp)>0,\n        "can\'t delete pointer to '
[#] parse_declaration, is_constructor=True, meet line: 'default_delete() noexcept = default;\n# 101 "/usr/include/c++/7/bits/unique_ptr.h" 3\n      template<typename _Up, typename = typename\n        enable_if<is_convertible<_Up(*)[], _Tp(*)[]>::value>::type>'
[#] parse_declaration, is_constructor=True, meet line: 'default_delete(const default_delete<_Up[]>&) noexcept { }\n\n\n      template<typename _Up>\n      typename enable_if<is_convertible<_Up(*)[], _Tp(*)[]>::value>::type\n operator()(_Up* __ptr) const\n      {'
[#] parse_declaration, is_constructor=False, meet line: 'enable_if<is_convertible<_Up(*)[], _Tp(*)[]>::value>::type\n operator()(_Up* __ptr) const\n      {\n static_assert(sizeof(_Tp)>0,\n        "can\'t delete pointer to incomplete type");\n delete [] __ptr;\n   '
[#] parse_declaration, is_constructor=True, meet line: '__uniq_ptr_impl() = default;\n      __uniq_ptr_impl(pointer __p) : _M_t() { _M_ptr() = __p; }\n\n      template<typename _Del>\n      __uniq_ptr_impl(pointer __p, _Del&& __d)\n : _M_t(__p, std::forward<_De'
[#] parse_declaration, is_constructor=True, meet line: '__uniq_ptr_impl(pointer __p) : _M_t() { _M_ptr() = __p; }\n\n      template<typename _Del>\n      __uniq_ptr_impl(pointer __p, _Del&& __d)\n : _M_t(__p, std::forward<_Del>(__d)) { }\n\n      pointer& _M_ptr'
[#] parse_declaration, is_constructor=True, meet line: '__uniq_ptr_impl(pointer __p, _Del&& __d)\n : _M_t(__p, std::forward<_Del>(__d)) { }\n\n      pointer& _M_ptr() { return std::get<0>(_M_t); }\n      pointer _M_ptr() const { return std::get<0>(_M_t); }\n   '
[#] parse_declaration, is_constructor=False, meet line: 'pointer& _M_ptr() { return std::get<0>(_M_t); }\n      pointer _M_ptr() const { return std::get<0>(_M_t); }\n      _Dp& _M_deleter() { return std::get<1>(_M_t); }\n      const _Dp& _M_deleter() const { r'
[#] parse_declaration, is_constructor=False, meet line: 'pointer _M_ptr() const { return std::get<0>(_M_t); }\n      _Dp& _M_deleter() { return std::get<1>(_M_t); }\n      const _Dp& _M_deleter() const { return std::get<1>(_M_t); }\n\n    private:\n      tuple<p'
[#] parse_declaration, is_constructor=False, meet line: '_Dp& _M_deleter() { return std::get<1>(_M_t); }\n      const _Dp& _M_deleter() const { return std::get<1>(_M_t); }\n\n    private:\n      tuple<pointer, _Dp> _M_t;\n    };\n\n\n  template <typename _Tp, typen'
[#] parse_declaration, is_constructor=False, meet line: '_Dp& _M_deleter() const { return std::get<1>(_M_t); }\n\n    private:\n      tuple<pointer, _Dp> _M_t;\n    };\n\n\n  template <typename _Tp, typename _Dp = default_delete<_Tp>>\n    class unique_ptr\n    {\n  '
[#] parse_declaration, is_constructor=False, meet line: 'tuple<pointer, _Dp> _M_t;\n    };\n\n\n  template <typename _Tp, typename _Dp = default_delete<_Tp>>\n    class unique_ptr\n    {\n      template <class _Up>\n      using _DeleterConstraint =\n typename __uniq'
[#] parse_declaration, is_constructor=False, meet line: '__uniq_ptr_impl<_Tp, _Dp> _M_t;\n\n    public:\n      using pointer = typename __uniq_ptr_impl<_Tp, _Dp>::pointer;\n      using element_type = _Tp;\n      using deleter_type = _Dp;\n\n\n\n      template<typena'
[#] parse_declaration, is_constructor=True, meet line: 'unique_ptr() noexcept\n : _M_t()\n { }\n\n\n\n\n\n\n\n      template <typename _Up = _Dp,\n  typename = _DeleterConstraint<_Up>>\n explicit\n unique_ptr(pointer __p) noexcept\n : _M_t(__p)\n        { }\n# 212 "/usr/i'
[#] parse_declaration, is_constructor=True, meet line: 'unique_ptr(pointer __p) noexcept\n : _M_t(__p)\n        { }\n# 212 "/usr/include/c++/7/bits/unique_ptr.h" 3\n      unique_ptr(pointer __p,\n   typename conditional<is_reference<deleter_type>::value,\n     d'
[#] parse_declaration, is_constructor=True, meet line: 'unique_ptr(pointer __p,\n   typename conditional<is_reference<deleter_type>::value,\n     deleter_type, const deleter_type&>::type __d) noexcept\n      : _M_t(__p, __d) { }\n# 224 "/usr/include/c++/7/bits'
[#] parse_declaration, is_constructor=True, meet line: 'unique_ptr(pointer __p,\n   typename remove_reference<deleter_type>::type&& __d) noexcept\n      : _M_t(std::move(__p), std::move(__d))\n      { static_assert(!std::is_reference<deleter_type>::value,\n   '
[#] parse_declaration, is_constructor=True, meet line: 'unique_ptr(nullptr_t) noexcept : _M_t() { }\n\n\n\n\n      unique_ptr(unique_ptr&& __u) noexcept\n      : _M_t(__u.release(), std::forward<deleter_type>(__u.get_deleter())) { }\n\n\n\n\n\n\n\n      template<typenam'
[#] parse_declaration, is_constructor=True, meet line: 'unique_ptr(unique_ptr&& __u) noexcept\n      : _M_t(__u.release(), std::forward<deleter_type>(__u.get_deleter())) { }\n\n\n\n\n\n\n\n      template<typename _Up, typename _Ep, typename = _Require<\n            '
[#] parse_declaration, is_constructor=True, meet line: 'unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept\n : _M_t(__u.release(), std::forward<_Ep>(__u.get_deleter()))\n { }\n\n\n\n      template<typename _Up, typename = _Require<\n        is_convertible<_Up*, _Tp*'
[#] parse_declaration, is_constructor=True, meet line: 'unique_ptr(auto_ptr<_Up>&& __u) noexcept;\n\n\n\n      ~unique_ptr() noexcept\n      {\n auto& __ptr = _M_t._M_ptr();\n if (__ptr != nullptr)\n   get_deleter()(__ptr);\n __ptr = pointer();\n      }\n# 280 "/usr/'
[#] parse_declaration, is_constructor=True, meet line: 'unique_ptr() noexcept\n      {\n auto& __ptr = _M_t._M_ptr();\n if (__ptr != nullptr)\n   get_deleter()(__ptr);\n __ptr = pointer();\n      }\n# 280 "/usr/include/c++/7/bits/unique_ptr.h" 3\n      unique_ptr&'
[#] parse_declaration, is_constructor=True, meet line: 'unique_ptr&\n      operator=(unique_ptr&& __u) noexcept\n      {\n reset(__u.release());\n get_deleter() = std::forward<deleter_type>(__u.get_deleter());\n return *this;\n      }\n# 295 "/usr/include/c++/7/b'
[#] parse_declaration, is_constructor=False, meet line: 'enable_if< __and_<\n          __safe_conversion_up<_Up, _Ep>,\n          is_assignable<deleter_type&, _Ep&&>\n          >::value,\n          unique_ptr&>::type\n operator=(unique_ptr<_Up, _Ep>&& __u) noexc'
[#] parse_declaration, is_constructor=True, meet line: 'unique_ptr&\n      operator=(nullptr_t) noexcept\n      {\n reset();\n return *this;\n      }\n\n\n\n\n      typename add_lvalue_reference<element_type>::type\n      operator*() const\n      {\n ;\n return *get();\n'
[#] parse_declaration, is_constructor=False, meet line: 'add_lvalue_reference<element_type>::type\n      operator*() const\n      {\n ;\n return *get();\n      }\n\n\n      pointer\n      operator->() const noexcept\n      {\n ;\n return get();\n      }\n\n\n      pointer\n'
[#] parse_declaration, is_constructor=False, meet line: 'pointer\n      operator->() const noexcept\n      {\n ;\n return get();\n      }\n\n\n      pointer\n      get() const noexcept\n      { return _M_t._M_ptr(); }\n\n\n      deleter_type&\n      get_deleter() noexcep'
[#] parse_declaration, is_constructor=False, meet line: 'pointer\n      get() const noexcept\n      { return _M_t._M_ptr(); }\n\n\n      deleter_type&\n      get_deleter() noexcept\n      { return _M_t._M_deleter(); }\n\n\n      const deleter_type&\n      get_deleter('
[#] parse_declaration, is_constructor=False, meet line: 'deleter_type&\n      get_deleter() noexcept\n      { return _M_t._M_deleter(); }\n\n\n      const deleter_type&\n      get_deleter() const noexcept\n      { return _M_t._M_deleter(); }\n\n\n      explicit opera'
[#] parse_declaration, is_constructor=False, meet line: 'deleter_type&\n      get_deleter() const noexcept\n      { return _M_t._M_deleter(); }\n\n\n      explicit operator bool() const noexcept\n      { return get() == pointer() ? false : true; }\n\n\n\n\n      point'
[#] parse_declaration, is_constructor=False, meet line: 'operator bool() const noexcept\n      { return get() == pointer() ? false : true; }\n\n\n\n\n      pointer\n      release() noexcept\n      {\n pointer __p = get();\n _M_t._M_ptr() = pointer();\n return __p;\n   '
[#] parse_declaration, is_constructor=False, meet line: 'pointer\n      release() noexcept\n      {\n pointer __p = get();\n _M_t._M_ptr() = pointer();\n return __p;\n      }\n\n\n\n\n\n\n\n      void\n      reset(pointer __p = pointer()) noexcept\n      {\n using std::swap'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      reset(pointer __p = pointer()) noexcept\n      {\n using std::swap;\n swap(_M_t._M_ptr(), __p);\n if (__p != pointer())\n   get_deleter()(__p);\n      }\n\n\n      void\n      swap(unique_ptr& __u) n'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      swap(unique_ptr& __u) noexcept\n      {\n using std::swap;\n swap(_M_t, __u._M_t);\n      }\n\n\n      unique_ptr(const unique_ptr&) = delete;\n      unique_ptr& operator=(const unique_ptr&) = dele'
[#] parse_declaration, is_constructor=True, meet line: 'unique_ptr(const unique_ptr&) = delete;\n      unique_ptr& operator=(const unique_ptr&) = delete;\n  };\n\n\n\n\n\n  template<typename _Tp, typename _Dp>\n    class unique_ptr<_Tp[], _Dp>\n    {\n      template '
[#] parse_declaration, is_constructor=True, meet line: 'unique_ptr& operator=(const unique_ptr&) = delete;\n  };\n\n\n\n\n\n  template<typename _Tp, typename _Dp>\n    class unique_ptr<_Tp[], _Dp>\n    {\n      template <typename _Up>\n      using _DeleterConstraint '
[#] parse_declaration, is_constructor=False, meet line: '__uniq_ptr_impl<_Tp, _Dp> _M_t;\n\n      template<typename _Up>\n using __remove_cv = typename remove_cv<_Up>::type;\n\n\n      template<typename _Up>\n using __is_derived_Tp\n   = __and_< is_base_of<_Tp, _Up'
[#] parse_declaration, is_constructor=True, meet line: 'unique_ptr() noexcept\n : _M_t()\n { }\n# 464 "/usr/include/c++/7/bits/unique_ptr.h" 3\n      template<typename _Up,\n        typename _Vp = _Dp,\n        typename = _DeleterConstraint<_Vp>,\n        typenam'
[#] parse_declaration, is_constructor=True, meet line: 'unique_ptr(_Up __p) noexcept\n : _M_t(__p)\n        { }\n# 482 "/usr/include/c++/7/bits/unique_ptr.h" 3\n      template<typename _Up,\n               typename = typename enable_if<\n                 __safe_'
[#] parse_declaration, is_constructor=True, meet line: 'unique_ptr(_Up __p,\n                 typename conditional<is_reference<deleter_type>::value,\n                 deleter_type, const deleter_type&>::type __d) noexcept\n      : _M_t(__p, __d) { }\n# 498 "/'
[#] parse_declaration, is_constructor=True, meet line: 'unique_ptr(_Up __p, typename\n   remove_reference<deleter_type>::type&& __d) noexcept\n      : _M_t(std::move(__p), std::move(__d))\n      { static_assert(!is_reference<deleter_type>::value,\n        "rva'
[#] parse_declaration, is_constructor=True, meet line: 'unique_ptr(unique_ptr&& __u) noexcept\n      : _M_t(__u.release(), std::forward<deleter_type>(__u.get_deleter())) { }\n\n\n      template <typename _Up = _Dp,\n  typename = _DeleterConstraint<_Up>>\n conste'
[#] parse_declaration, is_constructor=True, meet line: 'unique_ptr(nullptr_t) noexcept : _M_t() { }\n\n      template<typename _Up, typename _Ep,\n        typename = _Require<__safe_conversion_up<_Up, _Ep>>>\n unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept\n :'
[#] parse_declaration, is_constructor=True, meet line: 'unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept\n : _M_t(__u.release(), std::forward<_Ep>(__u.get_deleter()))\n { }\n\n\n      ~unique_ptr()\n      {\n auto& __ptr = _M_t._M_ptr();\n if (__ptr != nullptr)\n   '
[#] parse_declaration, is_constructor=True, meet line: 'unique_ptr()\n      {\n auto& __ptr = _M_t._M_ptr();\n if (__ptr != nullptr)\n   get_deleter()(__ptr);\n __ptr = pointer();\n      }\n# 539 "/usr/include/c++/7/bits/unique_ptr.h" 3\n      unique_ptr&\n      op'
[#] parse_declaration, is_constructor=True, meet line: 'unique_ptr&\n      operator=(unique_ptr&& __u) noexcept\n      {\n reset(__u.release());\n get_deleter() = std::forward<deleter_type>(__u.get_deleter());\n return *this;\n      }\n# 554 "/usr/include/c++/7/b'
[#] parse_declaration, is_constructor=False, meet line: 'enable_if<__and_<__safe_conversion_up<_Up, _Ep>,\n                         is_assignable<deleter_type&, _Ep&&>\n                  >::value,\n                  unique_ptr&>::type\n operator=(unique_ptr<_Up'
[#] parse_declaration, is_constructor=True, meet line: 'unique_ptr&\n      operator=(nullptr_t) noexcept\n      {\n reset();\n return *this;\n      }\n\n\n\n\n      typename std::add_lvalue_reference<element_type>::type\n      operator[](size_t __i) const\n      {\n ;\n'
[#] parse_declaration, is_constructor=False, meet line: 'std::add_lvalue_reference<element_type>::type\n      operator[](size_t __i) const\n      {\n ;\n return get()[__i];\n      }\n\n\n      pointer\n      get() const noexcept\n      { return _M_t._M_ptr(); }\n\n\n   '
[#] parse_declaration, is_constructor=False, meet line: 'pointer\n      get() const noexcept\n      { return _M_t._M_ptr(); }\n\n\n      deleter_type&\n      get_deleter() noexcept\n      { return _M_t._M_deleter(); }\n\n\n      const deleter_type&\n      get_deleter('
[#] parse_declaration, is_constructor=False, meet line: 'deleter_type&\n      get_deleter() noexcept\n      { return _M_t._M_deleter(); }\n\n\n      const deleter_type&\n      get_deleter() const noexcept\n      { return _M_t._M_deleter(); }\n\n\n      explicit opera'
[#] parse_declaration, is_constructor=False, meet line: 'deleter_type&\n      get_deleter() const noexcept\n      { return _M_t._M_deleter(); }\n\n\n      explicit operator bool() const noexcept\n      { return get() == pointer() ? false : true; }\n\n\n\n\n      point'
[#] parse_declaration, is_constructor=False, meet line: 'operator bool() const noexcept\n      { return get() == pointer() ? false : true; }\n\n\n\n\n      pointer\n      release() noexcept\n      {\n pointer __p = get();\n _M_t._M_ptr() = pointer();\n return __p;\n   '
[#] parse_declaration, is_constructor=False, meet line: 'pointer\n      release() noexcept\n      {\n pointer __p = get();\n _M_t._M_ptr() = pointer();\n return __p;\n      }\n\n\n\n\n\n\n\n      template <typename _Up,\n                typename = _Require<\n              '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      reset(_Up __p) noexcept\n      {\n pointer __ptr = __p;\n using std::swap;\n swap(_M_t._M_ptr(), __ptr);\n if (__ptr != nullptr)\n   get_deleter()(__ptr);\n      }\n\n      void reset(nullptr_t = nu'
[#] parse_declaration, is_constructor=False, meet line: 'void reset(nullptr_t = nullptr) noexcept\n      {\n        reset(pointer());\n      }\n\n\n      void\n      swap(unique_ptr& __u) noexcept\n      {\n using std::swap;\n swap(_M_t, __u._M_t);\n      }\n\n\n      un'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      swap(unique_ptr& __u) noexcept\n      {\n using std::swap;\n swap(_M_t, __u._M_t);\n      }\n\n\n      unique_ptr(const unique_ptr&) = delete;\n      unique_ptr& operator=(const unique_ptr&) = dele'
[#] parse_declaration, is_constructor=True, meet line: 'unique_ptr(const unique_ptr&) = delete;\n      unique_ptr& operator=(const unique_ptr&) = delete;\n    };\n\n  template<typename _Tp, typename _Dp>\n    inline\n\n\n    typename enable_if<__is_swappable<_Dp>:'
[#] parse_declaration, is_constructor=True, meet line: 'unique_ptr& operator=(const unique_ptr&) = delete;\n    };\n\n  template<typename _Tp, typename _Dp>\n    inline\n\n\n    typename enable_if<__is_swappable<_Dp>::value>::type\n\n\n\n    swap(unique_ptr<_Tp, _Dp>'
[#] parse_declaration, is_constructor=False, meet line: 'enable_if<__is_swappable<_Dp>::value>::type\n\n\n\n    swap(unique_ptr<_Tp, _Dp>& __x,\n  unique_ptr<_Tp, _Dp>& __y) noexcept\n    { __x.swap(__y); }\n\n\n  template<typename _Tp, typename _Dp>\n    typename en'
[#] parse_declaration, is_constructor=False, meet line: 'enable_if<!__is_swappable<_Dp>::value>::type\n    swap(unique_ptr<_Tp, _Dp>&,\n  unique_ptr<_Tp, _Dp>&) = delete;\n\n\n  template<typename _Tp, typename _Dp,\n    typename _Up, typename _Ep>\n    inline bool'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator==(const unique_ptr<_Tp, _Dp>& __x,\n        const unique_ptr<_Up, _Ep>& __y)\n    { return __x.get() == __y.get(); }\n\n  template<typename _Tp, typename _Dp>\n    inline bool\n    operato'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator==(const unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept\n    { return !__x; }\n\n  template<typename _Tp, typename _Dp>\n    inline bool\n    operator==(nullptr_t, const unique_ptr<_Tp, _D'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator==(nullptr_t, const unique_ptr<_Tp, _Dp>& __x) noexcept\n    { return !__x; }\n\n  template<typename _Tp, typename _Dp,\n    typename _Up, typename _Ep>\n    inline bool\n    operator!=(con'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator!=(const unique_ptr<_Tp, _Dp>& __x,\n        const unique_ptr<_Up, _Ep>& __y)\n    { return __x.get() != __y.get(); }\n\n  template<typename _Tp, typename _Dp>\n    inline bool\n    operato'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator!=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept\n    { return (bool)__x; }\n\n  template<typename _Tp, typename _Dp>\n    inline bool\n    operator!=(nullptr_t, const unique_ptr<_T'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator!=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x) noexcept\n    { return (bool)__x; }\n\n  template<typename _Tp, typename _Dp,\n    typename _Up, typename _Ep>\n    inline bool\n    operator<'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<(const unique_ptr<_Tp, _Dp>& __x,\n       const unique_ptr<_Up, _Ep>& __y)\n    {\n      typedef typename\n std::common_type<typename unique_ptr<_Tp, _Dp>::pointer,\n                  typ'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)\n    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(__x.get(),\n         nullptr); }\n\n  template<typename _Tp, typename _Dp>\n'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)\n    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(nullptr,\n         __x.get()); }\n\n  template<typename _Tp, typename _Dp,\n'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<=(const unique_ptr<_Tp, _Dp>& __x,\n        const unique_ptr<_Up, _Ep>& __y)\n    { return !(__y < __x); }\n\n  template<typename _Tp, typename _Dp>\n    inline bool\n    operator<=(const '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)\n    { return !(nullptr < __x); }\n\n  template<typename _Tp, typename _Dp>\n    inline bool\n    operator<=(nullptr_t, const unique_ptr<_Tp,'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)\n    { return !(__x < nullptr); }\n\n  template<typename _Tp, typename _Dp,\n    typename _Up, typename _Ep>\n    inline bool\n    operator>(c'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>(const unique_ptr<_Tp, _Dp>& __x,\n       const unique_ptr<_Up, _Ep>& __y)\n    { return (__y < __x); }\n\n  template<typename _Tp, typename _Dp>\n    inline bool\n    operator>(const uniq'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)\n    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(nullptr,\n         __x.get()); }\n\n  template<typename _Tp, typename _Dp>\n'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)\n    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(__x.get(),\n         nullptr); }\n\n  template<typename _Tp, typename _Dp,\n'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>=(const unique_ptr<_Tp, _Dp>& __x,\n        const unique_ptr<_Up, _Ep>& __y)\n    { return !(__x < __y); }\n\n  template<typename _Tp, typename _Dp>\n    inline bool\n    operator>=(const '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)\n    { return !(__x < nullptr); }\n\n  template<typename _Tp, typename _Dp>\n    inline bool\n    operator>=(nullptr_t, const unique_ptr<_Tp,'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)\n    { return !(nullptr < __x); }\n\n\n  template<typename _Tp, typename _Dp>\n    struct hash<unique_ptr<_Tp, _Dp>>\n    : public __hash_base'
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n      operator()(const unique_ptr<_Tp, _Dp>& __u) const noexcept\n      {\n typedef unique_ptr<_Tp, _Dp> _UP;\n return std::hash<typename _UP::pointer>()(__u.get());\n      }\n    };\n\n\n\n\n\n  template'
[#] parse_declaration, is_constructor=False, meet line: '_MakeUniq<_Tp>::__single_object\n    make_unique(_Args&&... __args)\n    { return unique_ptr<_Tp>(new _Tp(std::forward<_Args>(__args)...)); }\n\n\n  template<typename _Tp>\n    inline typename _MakeUniq<_Tp'
[#] parse_declaration, is_constructor=False, meet line: '_MakeUniq<_Tp>::__array\n    make_unique(size_t __num)\n    { return unique_ptr<_Tp>(new remove_extent_t<_Tp>[__num]()); }\n\n\n  template<typename _Tp, typename... _Args>\n    inline typename _MakeUniq<_Tp'
[#] parse_declaration, is_constructor=False, meet line: '_MakeUniq<_Tp>::__invalid_type\n    make_unique(_Args&&...) = delete;\n\n\n\n\n\n}\n# 42 "/usr/include/c++/7/bits/locale_conv.h" 2 3\n\nnamespace std __attribute__ ((__visibility__ ("default")))\n{\n\n\n\n\n\n\n\n  temp'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    __do_str_codecvt(const _InChar* __first, const _InChar* __last,\n       _OutStr& __outstr, const _Codecvt& __cvt, _State& __state,\n       size_t& __count, _Fn __fn)\n    {\n      if (__first == '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    __str_codecvt_in(const char* __first, const char* __last,\n       basic_string<_CharT, _Traits, _Alloc>& __outstr,\n       const codecvt<_CharT, char, _State>& __cvt,\n       _State& __state, si'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    __str_codecvt_in(const char* __first, const char* __last,\n       basic_string<_CharT, _Traits, _Alloc>& __outstr,\n       const codecvt<_CharT, char, _State>& __cvt)\n    {\n      _State __state'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    __str_codecvt_out(const _CharT* __first, const _CharT* __last,\n        basic_string<char, _Traits, _Alloc>& __outstr,\n        const codecvt<_CharT, char, _State>& __cvt,\n        _State& __sta'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    __str_codecvt_out(const _CharT* __first, const _CharT* __last,\n        basic_string<char, _Traits, _Alloc>& __outstr,\n        const codecvt<_CharT, char, _State>& __cvt)\n    {\n      _State __'
[#] parse_declaration, is_constructor=True, meet line: 'wstring_convert(_Codecvt* __pcvt = new _Codecvt()) : _M_cvt(__pcvt)\n      {\n if (!_M_cvt)\n   __throw_logic_error("wstring_convert");\n      }\n# 198 "/usr/include/c++/7/bits/locale_conv.h" 3\n      wstri'
[#] parse_declaration, is_constructor=True, meet line: 'wstring_convert(_Codecvt* __pcvt, state_type __state)\n      : _M_cvt(__pcvt), _M_state(__state), _M_with_cvtstate(true)\n      {\n if (!_M_cvt)\n   __throw_logic_error("wstring_convert");\n      }\n\n\n\n\n\n\n '
[#] parse_declaration, is_constructor=True, meet line: 'wstring_convert(const byte_string& __byte_err,\n        const wide_string& __wide_err = wide_string())\n      : _M_cvt(new _Codecvt),\n _M_byte_err_string(__byte_err), _M_wide_err_string(__wide_err),\n _M'
[#] parse_declaration, is_constructor=True, meet line: 'wstring_convert() = default;\n\n\n\n      wstring_convert(const wstring_convert&) = delete;\n      wstring_convert& operator=(const wstring_convert&) = delete;\n\n\n      wide_string\n      from_bytes(char __b'
[#] parse_declaration, is_constructor=True, meet line: 'wstring_convert(const wstring_convert&) = delete;\n      wstring_convert& operator=(const wstring_convert&) = delete;\n\n\n      wide_string\n      from_bytes(char __byte)\n      {\n char __bytes[2] = { __by'
[#] parse_declaration, is_constructor=True, meet line: 'wstring_convert& operator=(const wstring_convert&) = delete;\n\n\n      wide_string\n      from_bytes(char __byte)\n      {\n char __bytes[2] = { __byte };\n return from_bytes(__bytes, __bytes+1);\n      }\n\n '
[#] parse_declaration, is_constructor=False, meet line: 'wide_string\n      from_bytes(char __byte)\n      {\n char __bytes[2] = { __byte };\n return from_bytes(__bytes, __bytes+1);\n      }\n\n      wide_string\n      from_bytes(const char* __ptr)\n      { return f'
[#] parse_declaration, is_constructor=False, meet line: 'wide_string\n      from_bytes(const char* __ptr)\n      { return from_bytes(__ptr, __ptr+char_traits<char>::length(__ptr)); }\n\n      wide_string\n      from_bytes(const byte_string& __str)\n      {\n auto '
[#] parse_declaration, is_constructor=False, meet line: 'wide_string\n      from_bytes(const byte_string& __str)\n      {\n auto __ptr = __str.data();\n return from_bytes(__ptr, __ptr + __str.size());\n      }\n\n      wide_string\n      from_bytes(const char* __fi'
[#] parse_declaration, is_constructor=False, meet line: 'wide_string\n      from_bytes(const char* __first, const char* __last)\n      {\n if (!_M_with_cvtstate)\n   _M_state = state_type();\n wide_string __out{ _M_wide_err_string.get_allocator() };\n if (__str_c'
[#] parse_declaration, is_constructor=False, meet line: 'byte_string\n      to_bytes(_Elem __wchar)\n      {\n _Elem __wchars[2] = { __wchar };\n return to_bytes(__wchars, __wchars+1);\n      }\n\n      byte_string\n      to_bytes(const _Elem* __ptr)\n      {\n retur'
[#] parse_declaration, is_constructor=False, meet line: 'byte_string\n      to_bytes(const _Elem* __ptr)\n      {\n return to_bytes(__ptr, __ptr+wide_string::traits_type::length(__ptr));\n      }\n\n      byte_string\n      to_bytes(const wide_string& __wstr)\n    '
[#] parse_declaration, is_constructor=False, meet line: 'byte_string\n      to_bytes(const wide_string& __wstr)\n      {\n auto __ptr = __wstr.data();\n return to_bytes(__ptr, __ptr + __wstr.size());\n      }\n\n      byte_string\n      to_bytes(const _Elem* __firs'
[#] parse_declaration, is_constructor=False, meet line: 'byte_string\n      to_bytes(const _Elem* __first, const _Elem* __last)\n      {\n if (!_M_with_cvtstate)\n   _M_state = state_type();\n byte_string __out{ _M_byte_err_string.get_allocator() };\n if (__str_c'
[#] parse_declaration, is_constructor=False, meet line: 'size_t converted() const noexcept { return _M_count; }\n\n\n      state_type state() const { return _M_state; }\n\n    private:\n      unique_ptr<_Codecvt> _M_cvt;\n      byte_string _M_byte_err_string;\n    '
[#] parse_declaration, is_constructor=False, meet line: 'state_type state() const { return _M_state; }\n\n    private:\n      unique_ptr<_Codecvt> _M_cvt;\n      byte_string _M_byte_err_string;\n      wide_string _M_wide_err_string;\n      state_type _M_state = s'
[#] parse_declaration, is_constructor=False, meet line: 'unique_ptr<_Codecvt> _M_cvt;\n      byte_string _M_byte_err_string;\n      wide_string _M_wide_err_string;\n      state_type _M_state = state_type();\n      size_t _M_count = 0;\n      bool _M_with_cvtstat'
[#] parse_declaration, is_constructor=False, meet line: 'byte_string _M_byte_err_string;\n      wide_string _M_wide_err_string;\n      state_type _M_state = state_type();\n      size_t _M_count = 0;\n      bool _M_with_cvtstate = false;\n      bool _M_with_strin'
[#] parse_declaration, is_constructor=False, meet line: 'wide_string _M_wide_err_string;\n      state_type _M_state = state_type();\n      size_t _M_count = 0;\n      bool _M_with_cvtstate = false;\n      bool _M_with_strings = false;\n    };\n\n}\n\n\n  template<typ'
[#] parse_declaration, is_constructor=False, meet line: 'state_type _M_state = state_type();\n      size_t _M_count = 0;\n      bool _M_with_cvtstate = false;\n      bool _M_with_strings = false;\n    };\n\n}\n\n\n  template<typename _Codecvt, typename _Elem = wchar'
[#] parse_declaration, is_constructor=False, meet line: 'size_t _M_count = 0;\n      bool _M_with_cvtstate = false;\n      bool _M_with_strings = false;\n    };\n\n}\n\n\n  template<typename _Codecvt, typename _Elem = wchar_t,\n    typename _Tr = char_traits<_Elem>>'
[#] parse_declaration, is_constructor=False, meet line: 'bool _M_with_cvtstate = false;\n      bool _M_with_strings = false;\n    };\n\n}\n\n\n  template<typename _Codecvt, typename _Elem = wchar_t,\n    typename _Tr = char_traits<_Elem>>\n    class wbuffer_convert '
[#] parse_declaration, is_constructor=False, meet line: 'bool _M_with_strings = false;\n    };\n\n}\n\n\n  template<typename _Codecvt, typename _Elem = wchar_t,\n    typename _Tr = char_traits<_Elem>>\n    class wbuffer_convert : public basic_streambuf<_Elem, _Tr>\n'
[#] parse_declaration, is_constructor=True, meet line: 'wbuffer_convert(streambuf* __bytebuf = 0, _Codecvt* __pcvt = new _Codecvt,\n        state_type __state = state_type())\n      : _M_buf(__bytebuf), _M_cvt(__pcvt), _M_state(__state)\n      {\n if (!_M_cvt)'
[#] parse_declaration, is_constructor=True, meet line: 'wbuffer_convert() = default;\n\n\n\n      wbuffer_convert(const wbuffer_convert&) = delete;\n      wbuffer_convert& operator=(const wbuffer_convert&) = delete;\n\n      streambuf* rdbuf() const noexcept { re'
[#] parse_declaration, is_constructor=True, meet line: 'wbuffer_convert(const wbuffer_convert&) = delete;\n      wbuffer_convert& operator=(const wbuffer_convert&) = delete;\n\n      streambuf* rdbuf() const noexcept { return _M_buf; }\n\n      streambuf*\n     '
[#] parse_declaration, is_constructor=True, meet line: 'wbuffer_convert& operator=(const wbuffer_convert&) = delete;\n\n      streambuf* rdbuf() const noexcept { return _M_buf; }\n\n      streambuf*\n      rdbuf(streambuf *__bytebuf) noexcept\n      {\n auto __pr'
[#] parse_declaration, is_constructor=False, meet line: 'streambuf* rdbuf() const noexcept { return _M_buf; }\n\n      streambuf*\n      rdbuf(streambuf *__bytebuf) noexcept\n      {\n auto __prev = _M_buf;\n _M_buf = __bytebuf;\n return __prev;\n      }\n\n\n      st'
[#] parse_declaration, is_constructor=False, meet line: 'streambuf*\n      rdbuf(streambuf *__bytebuf) noexcept\n      {\n auto __prev = _M_buf;\n _M_buf = __bytebuf;\n return __prev;\n      }\n\n\n      state_type state() const noexcept { return _M_state; }\n\n    pr'
[#] parse_declaration, is_constructor=False, meet line: 'state_type state() const noexcept { return _M_state; }\n\n    protected:\n      int\n      sync()\n      { return _M_buf && _M_conv_put() && !_M_buf->pubsync() ? 0 : -1; }\n\n      typename _Wide_streambuf::'
[#] parse_declaration, is_constructor=False, meet line: 'int\n      sync()\n      { return _M_buf && _M_conv_put() && !_M_buf->pubsync() ? 0 : -1; }\n\n      typename _Wide_streambuf::int_type\n      overflow(typename _Wide_streambuf::int_type __out)\n      {\n if'
[#] parse_declaration, is_constructor=False, meet line: '_Wide_streambuf::int_type\n      overflow(typename _Wide_streambuf::int_type __out)\n      {\n if (!_M_buf || !_M_conv_put())\n   return _Tr::eof();\n else if (!_Tr::eq_int_type(__out, _Tr::eof()))\n   retu'
[#] parse_declaration, is_constructor=False, meet line: '_Wide_streambuf::int_type\n      underflow()\n      {\n if (!_M_buf)\n   return _Tr::eof();\n\n if (this->gptr() < this->egptr() || (_M_buf && _M_conv_get()))\n   return _Tr::to_int_type(*this->gptr());\n els'
[#] parse_declaration, is_constructor=False, meet line: 'streamsize\n      xsputn(const typename _Wide_streambuf::char_type* __s, streamsize __n)\n      {\n if (!_M_buf || __n == 0)\n   return 0;\n streamsize __done = 0;\n do\n {\n   auto __nn = std::min<streamsize'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      _M_conv_get()\n      {\n const streamsize __pb1 = this->gptr() - this->eback();\n const streamsize __pb2 = _S_putback_length;\n const streamsize __npb = std::min(__pb1, __pb2);\n\n _Tr::move(_M_g'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      _M_put(...)\n      { return false; }\n\n      bool\n      _M_put(const char* __p, streamsize __n)\n      {\n if (_M_buf->sputn(__p, __n) < __n)\n   return false;\n return true;\n      }\n\n\n      bool'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      _M_put(const char* __p, streamsize __n)\n      {\n if (_M_buf->sputn(__p, __n) < __n)\n   return false;\n return true;\n      }\n\n\n      bool\n      _M_conv_put()\n      {\n _Elem* const __first = t'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      _M_conv_put()\n      {\n _Elem* const __first = this->pbase();\n const _Elem* const __last = this->pptr();\n const streamsize __pending = __last - __first;\n\n if (_M_always_noconv)\n   return _M_'
[#] parse_declaration, is_constructor=False, meet line: 'streambuf* _M_buf;\n      unique_ptr<_Codecvt> _M_cvt;\n      state_type _M_state;\n\n      static const streamsize _S_buffer_length = 32;\n      static const streamsize _S_putback_length = 3;\n      _Elem '
[#] parse_declaration, is_constructor=False, meet line: 'unique_ptr<_Codecvt> _M_cvt;\n      state_type _M_state;\n\n      static const streamsize _S_buffer_length = 32;\n      static const streamsize _S_putback_length = 3;\n      _Elem _M_put_area[_S_buffer_len'
[#] parse_declaration, is_constructor=False, meet line: 'state_type _M_state;\n\n      static const streamsize _S_buffer_length = 32;\n      static const streamsize _S_putback_length = 3;\n      _Elem _M_put_area[_S_buffer_length];\n      _Elem _M_get_area[_S_bu'
[#] parse_declaration, is_constructor=False, meet line: 'streamsize _S_buffer_length = 32;\n      static const streamsize _S_putback_length = 3;\n      _Elem _M_put_area[_S_buffer_length];\n      _Elem _M_get_area[_S_buffer_length];\n      streamsize _M_unconv '
[#] parse_declaration, is_constructor=False, meet line: 'streamsize _S_putback_length = 3;\n      _Elem _M_put_area[_S_buffer_length];\n      _Elem _M_get_area[_S_buffer_length];\n      streamsize _M_unconv = 0;\n      char _M_get_buf[_S_buffer_length-_S_putbac'
[#] parse_declaration, is_constructor=False, meet line: '_Elem _M_put_area[_S_buffer_length];\n      _Elem _M_get_area[_S_buffer_length];\n      streamsize _M_unconv = 0;\n      char _M_get_buf[_S_buffer_length-_S_putback_length];\n      bool _M_always_noconv;\n'
[#] parse_declaration, is_constructor=False, meet line: '_Elem _M_get_area[_S_buffer_length];\n      streamsize _M_unconv = 0;\n      char _M_get_buf[_S_buffer_length-_S_putback_length];\n      bool _M_always_noconv;\n    };\n\n\n\n\n\n\n}\n# 44 "/usr/include/c++/7/loc'
[#] parse_declaration, is_constructor=False, meet line: 'streamsize _M_unconv = 0;\n      char _M_get_buf[_S_buffer_length-_S_putback_length];\n      bool _M_always_noconv;\n    };\n\n\n\n\n\n\n}\n# 44 "/usr/include/c++/7/locale" 2 3\n# 45 "/usr/include/c++/7/regex" 2 '
[#] parse_declaration, is_constructor=False, meet line: 'char _M_get_buf[_S_buffer_length-_S_putback_length];\n      bool _M_always_noconv;\n    };\n\n\n\n\n\n\n}\n# 44 "/usr/include/c++/7/locale" 2 3\n# 45 "/usr/include/c++/7/regex" 2 3\n# 1 "/usr/include/c++/7/memory'
[#] parse_declaration, is_constructor=False, meet line: 'bool _M_always_noconv;\n    };\n\n\n\n\n\n\n}\n# 44 "/usr/include/c++/7/locale" 2 3\n# 45 "/usr/include/c++/7/regex" 2 3\n# 1 "/usr/include/c++/7/memory" 1 3\n# 46 "/usr/include/c++/7/memory" 3\n       \n# 47 "/usr'
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n        __uninit_copy(_InputIterator __first, _InputIterator __last,\n        _ForwardIterator __result)\n        {\n   _ForwardIterator __cur = __result;\n   try\n     {\n       for (; __f'
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n        __uninit_copy(_InputIterator __first, _InputIterator __last,\n        _ForwardIterator __result)\n        { return std::copy(__first, __last, __result); }\n    };\n# 113 "/usr/inc'
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n    uninitialized_copy(_InputIterator __first, _InputIterator __last,\n         _ForwardIterator __result)\n    {\n      typedef typename iterator_traits<_InputIterator>::value_type\n _Va'
[#] parse_declaration, is_constructor=False, meet line: 'void\n        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,\n        const _Tp& __x)\n        {\n   _ForwardIterator __cur = __first;\n   try\n     {\n       for (; __cur != __last; ++__cu'
[#] parse_declaration, is_constructor=False, meet line: 'void\n        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,\n        const _Tp& __x)\n        { std::fill(__first, __last, __x); }\n    };\n# 179 "/usr/include/c++/7/bits/stl_uninitializ'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last,\n         const _Tp& __x)\n    {\n      typedef typename iterator_traits<_ForwardIterator>::value_type\n _ValueType;\n\n\n\n\n    '
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n        __uninit_fill_n(_ForwardIterator __first, _Size __n,\n   const _Tp& __x)\n        {\n   _ForwardIterator __cur = __first;\n   try\n     {\n       for (; __n > 0; --__n, ++__cur)\n  s'
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n        __uninit_fill_n(_ForwardIterator __first, _Size __n,\n   const _Tp& __x)\n        { return std::fill_n(__first, __n, __x); }\n    };\n# 242 "/usr/include/c++/7/bits/stl_uninitiali'
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n    uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)\n    {\n      typedef typename iterator_traits<_ForwardIterator>::value_type\n _ValueType;\n\n\n\n\n      const b'
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,\n      _ForwardIterator __result, _Allocator& __alloc)\n    {\n      _ForwardIterator __cur = __result;\n      tr'
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,\n      _ForwardIterator __result, allocator<_Tp>&)\n    { return std::uninitialized_copy(__first, __last, __res'
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n    __uninitialized_move_a(_InputIterator __first, _InputIterator __last,\n      _ForwardIterator __result, _Allocator& __alloc)\n    {\n      return std::__uninitialized_copy_a(std::mak'
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n    __uninitialized_move_if_noexcept_a(_InputIterator __first,\n           _InputIterator __last,\n           _ForwardIterator __result,\n           _Allocator& __alloc)\n    {\n      retu'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,\n      const _Tp& __x, _Allocator& __alloc)\n    {\n      _ForwardIterator __cur = __first;\n      try\n {\n   typedef __gn'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,\n      const _Tp& __x, allocator<_Tp2>&)\n    { std::uninitialized_fill(__first, __last, __x); }\n\n  template<typename _'
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,\n        const _Tp& __x, _Allocator& __alloc)\n    {\n      _ForwardIterator __cur = __first;\n      try\n {\n   typedef __'
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,\n        const _Tp& __x, allocator<_Tp2>&)\n    { return std::uninitialized_fill_n(__first, __n, __x); }\n# 378 "/usr/in'
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n    __uninitialized_copy_move(_InputIterator1 __first1,\n         _InputIterator1 __last1,\n         _InputIterator2 __first2,\n         _InputIterator2 __last2,\n         _ForwardIterato'
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n    __uninitialized_move_copy(_InputIterator1 __first1,\n         _InputIterator1 __last1,\n         _InputIterator2 __first2,\n         _InputIterator2 __last2,\n         _ForwardIterato'
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n    __uninitialized_fill_move(_ForwardIterator __result, _ForwardIterator __mid,\n         const _Tp& __x, _InputIterator __first,\n         _InputIterator __last, _Allocator& __alloc)\n'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    __uninitialized_move_fill(_InputIterator __first1, _InputIterator __last1,\n         _ForwardIterator __first2,\n         _ForwardIterator __last2, const _Tp& __x,\n         _Allocator& __alloc)'
[#] parse_declaration, is_constructor=False, meet line: 'void\n        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)\n        {\n   _ForwardIterator __cur = __first;\n   try\n     {\n       for (; __cur != __last; ++__cur)\n  std::_Construct('
[#] parse_declaration, is_constructor=False, meet line: 'void\n        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)\n        {\n   typedef typename iterator_traits<_ForwardIterator>::value_type\n     _ValueType;\n\n   std::fill(__first, __l'
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n        __uninit_default_n(_ForwardIterator __first, _Size __n)\n        {\n   _ForwardIterator __cur = __first;\n   try\n     {\n       for (; __n > 0; --__n, ++__cur)\n  std::_Construct(s'
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n        __uninit_default_n(_ForwardIterator __first, _Size __n)\n        {\n   typedef typename iterator_traits<_ForwardIterator>::value_type\n     _ValueType;\n\n   return std::fill_n(__f'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    __uninitialized_default(_ForwardIterator __first,\n       _ForwardIterator __last)\n    {\n      typedef typename iterator_traits<_ForwardIterator>::value_type\n _ValueType;\n\n      const bool __a'
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n    __uninitialized_default_n(_ForwardIterator __first, _Size __n)\n    {\n      typedef typename iterator_traits<_ForwardIterator>::value_type\n _ValueType;\n\n      const bool __assignab'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    __uninitialized_default_a(_ForwardIterator __first,\n         _ForwardIterator __last,\n         _Allocator& __alloc)\n    {\n      _ForwardIterator __cur = __first;\n      try\n {\n   typedef __gnu'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    __uninitialized_default_a(_ForwardIterator __first,\n         _ForwardIterator __last,\n         allocator<_Tp>&)\n    { std::__uninitialized_default(__first, __last); }\n\n\n\n\n\n  template<typename'
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n,\n    _Allocator& __alloc)\n    {\n      _ForwardIterator __cur = __first;\n      try\n {\n   typedef __gnu_cxx::__alloc_'
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n,\n    allocator<_Tp>&)\n    { return std::__uninitialized_default_n(__first, __n); }\n\n  template<bool _TrivialValueTy'
[#] parse_declaration, is_constructor=False, meet line: 'void\n __uninit_default_novalue(_ForwardIterator __first,\n     _ForwardIterator __last)\n {\n   _ForwardIterator __cur = __first;\n   try\n     {\n       for (; __cur != __last; ++__cur)\n  std::_Construct_n'
[#] parse_declaration, is_constructor=False, meet line: 'void\n        __uninit_default_novalue(_ForwardIterator __first,\n     _ForwardIterator __last)\n {\n }\n    };\n\n  template<bool _TrivialValueType>\n    struct __uninitialized_default_novalue_n_1\n    {\n    '
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n __uninit_default_novalue_n(_ForwardIterator __first, _Size __n)\n {\n   _ForwardIterator __cur = __first;\n   try\n     {\n       for (; __n > 0; --__n, ++__cur)\n  std::_Construct_novalue'
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n __uninit_default_novalue_n(_ForwardIterator __first, _Size __n)\n { return std::next(__first, __n); }\n    };\n\n\n\n\n  template<typename _ForwardIterator>\n    inline void\n    __uninitiali'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    __uninitialized_default_novalue(_ForwardIterator __first,\n        _ForwardIterator __last)\n    {\n      typedef typename iterator_traits<_ForwardIterator>::value_type\n _ValueType;\n\n      std::'
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n    __uninitialized_default_novalue_n(_ForwardIterator __first, _Size __n)\n    {\n      typedef typename iterator_traits<_ForwardIterator>::value_type\n _ValueType;\n\n      return __unin'
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n    __uninitialized_copy_n(_InputIterator __first, _Size __n,\n      _ForwardIterator __result, input_iterator_tag)\n    {\n      _ForwardIterator __cur = __result;\n      try\n {\n   for ('
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n    __uninitialized_copy_n(_RandomAccessIterator __first, _Size __n,\n      _ForwardIterator __result,\n      random_access_iterator_tag)\n    { return std::uninitialized_copy(__first, _'
[#] parse_declaration, is_constructor=False, meet line: 'pair<_InputIterator, _ForwardIterator>\n    __uninitialized_copy_n_pair(_InputIterator __first, _Size __n,\n      _ForwardIterator __result, input_iterator_tag)\n    {\n      _ForwardIterator __cur = __re'
[#] parse_declaration, is_constructor=False, meet line: 'pair<_RandomAccessIterator, _ForwardIterator>\n    __uninitialized_copy_n_pair(_RandomAccessIterator __first, _Size __n,\n      _ForwardIterator __result,\n      random_access_iterator_tag)\n    {\n      a'
[#] parse_declaration, is_constructor=False, meet line: '_ForwardIterator\n    uninitialized_copy_n(_InputIterator __first, _Size __n,\n    _ForwardIterator __result)\n    { return std::__uninitialized_copy_n(__first, __n, __result,\n      std::__iterator_categ'
[#] parse_declaration, is_constructor=False, meet line: 'pair<_InputIterator, _ForwardIterator>\n    __uninitialized_copy_n_pair(_InputIterator __first, _Size __n,\n         _ForwardIterator __result)\n    {\n      return\n std::__uninitialized_copy_n_pair(__fir'
[#] parse_declaration, is_constructor=False, meet line: '_OutputIterator _M_iter;\n\n    public:\n      explicit\n      raw_storage_iterator(_OutputIterator __x)\n      : _M_iter(__x) {}\n\n      raw_storage_iterator&\n      operator*() { return *this; }\n\n      raw'
[#] parse_declaration, is_constructor=True, meet line: 'raw_storage_iterator(_OutputIterator __x)\n      : _M_iter(__x) {}\n\n      raw_storage_iterator&\n      operator*() { return *this; }\n\n      raw_storage_iterator&\n      operator=(const _Tp& __element)\n  '
[#] parse_declaration, is_constructor=True, meet line: 'raw_storage_iterator&\n      operator*() { return *this; }\n\n      raw_storage_iterator&\n      operator=(const _Tp& __element)\n      {\n std::_Construct(std::__addressof(*_M_iter), __element);\n return *t'
[#] parse_declaration, is_constructor=True, meet line: 'raw_storage_iterator&\n      operator=(const _Tp& __element)\n      {\n std::_Construct(std::__addressof(*_M_iter), __element);\n return *this;\n      }\n\n\n\n\n      raw_storage_iterator&\n      operator=(_Tp&'
[#] parse_declaration, is_constructor=True, meet line: 'raw_storage_iterator&\n      operator=(_Tp&& __element)\n      {\n std::_Construct(std::__addressof(*_M_iter), std::move(__element));\n return *this;\n      }\n\n\n      raw_storage_iterator&\n      operator++'
[#] parse_declaration, is_constructor=True, meet line: 'raw_storage_iterator&\n      operator++()\n      {\n ++_M_iter;\n return *this;\n      }\n\n      raw_storage_iterator\n      operator++(int)\n      {\n raw_storage_iterator __tmp = *this;\n ++_M_iter;\n return _'
[#] parse_declaration, is_constructor=True, meet line: 'raw_storage_iterator\n      operator++(int)\n      {\n raw_storage_iterator __tmp = *this;\n ++_M_iter;\n return __tmp;\n      }\n\n\n\n      _OutputIterator base() const { return _M_iter; }\n    };\n\n\n}\n# 68 "/u'
[#] parse_declaration, is_constructor=False, meet line: '_OutputIterator base() const { return _M_iter; }\n    };\n\n\n}\n# 68 "/usr/include/c++/7/memory" 2 3\n\n\n\n\n\n\n# 1 "/usr/include/c++/7/ext/concurrence.h" 1 3\n# 32 "/usr/include/c++/7/ext/concurrence.h" 3\n    '
[#] parse_declaration, is_constructor=False, meet line: '_Lock_policy __default_lock_policy =\n\n\n\n  _S_atomic;\n# 67 "/usr/include/c++/7/ext/concurrence.h" 3\n  class __concurrence_lock_error : public std::exception\n  {\n  public:\n    virtual char const*\n    wh'
[#] parse_declaration, is_constructor=False, meet line: 'char const*\n    what() const throw()\n    { return "__gnu_cxx::__concurrence_lock_error"; }\n  };\n\n  class __concurrence_unlock_error : public std::exception\n  {\n  public:\n    virtual char const*\n    wh'
[#] parse_declaration, is_constructor=False, meet line: 'char const*\n    what() const throw()\n    { return "__gnu_cxx::__concurrence_unlock_error"; }\n  };\n\n  class __concurrence_broadcast_error : public std::exception\n  {\n  public:\n    virtual char const*\n '
[#] parse_declaration, is_constructor=False, meet line: 'char const*\n    what() const throw()\n    { return "__gnu_cxx::__concurrence_broadcast_error"; }\n  };\n\n  class __concurrence_wait_error : public std::exception\n  {\n  public:\n    virtual char const*\n   '
[#] parse_declaration, is_constructor=False, meet line: 'char const*\n    what() const throw()\n    { return "__gnu_cxx::__concurrence_wait_error"; }\n  };\n\n\n  inline void\n  __throw_concurrence_lock_error()\n  { (throw (__concurrence_lock_error())); }\n\n  inline'
[#] parse_declaration, is_constructor=False, meet line: 'void\n  __throw_concurrence_lock_error()\n  { (throw (__concurrence_lock_error())); }\n\n  inline void\n  __throw_concurrence_unlock_error()\n  { (throw (__concurrence_unlock_error())); }\n\n\n  inline void\n  '
[#] parse_declaration, is_constructor=False, meet line: 'void\n  __throw_concurrence_unlock_error()\n  { (throw (__concurrence_unlock_error())); }\n\n\n  inline void\n  __throw_concurrence_broadcast_error()\n  { (throw (__concurrence_broadcast_error())); }\n\n  inli'
[#] parse_declaration, is_constructor=False, meet line: 'void\n  __throw_concurrence_broadcast_error()\n  { (throw (__concurrence_broadcast_error())); }\n\n  inline void\n  __throw_concurrence_wait_error()\n  { (throw (__concurrence_wait_error())); }\n\n\n  class __'
[#] parse_declaration, is_constructor=False, meet line: 'void\n  __throw_concurrence_wait_error()\n  { (throw (__concurrence_wait_error())); }\n\n\n  class __mutex\n  {\n  private:\n\n    __gthread_mutex_t _M_mutex = { { 0, 0, 0, 0, 0, 0, 0, { 0, 0 } } };\n\n\n\n\n    __'
[#] parse_declaration, is_constructor=False, meet line: '__gthread_mutex_t _M_mutex = { { 0, 0, 0, 0, 0, 0, 0, { 0, 0 } } };\n\n\n\n\n    __mutex(const __mutex&);\n    __mutex& operator=(const __mutex&);\n\n  public:\n    __mutex()\n    {\n\n\n\n\n    }\n# 147 "/usr/includ'
[#] parse_declaration, is_constructor=True, meet line: '__mutex(const __mutex&);\n    __mutex& operator=(const __mutex&);\n\n  public:\n    __mutex()\n    {\n\n\n\n\n    }\n# 147 "/usr/include/c++/7/ext/concurrence.h" 3\n    void lock()\n    {\n\n      if (__gthread_acti'
[#] parse_declaration, is_constructor=True, meet line: '__mutex& operator=(const __mutex&);\n\n  public:\n    __mutex()\n    {\n\n\n\n\n    }\n# 147 "/usr/include/c++/7/ext/concurrence.h" 3\n    void lock()\n    {\n\n      if (__gthread_active_p())\n {\n   if (__gthread_m'
[#] parse_declaration, is_constructor=True, meet line: '__mutex()\n    {\n\n\n\n\n    }\n# 147 "/usr/include/c++/7/ext/concurrence.h" 3\n    void lock()\n    {\n\n      if (__gthread_active_p())\n {\n   if (__gthread_mutex_lock(&_M_mutex) != 0)\n     __throw_concurrence'
[#] parse_declaration, is_constructor=False, meet line: 'void lock()\n    {\n\n      if (__gthread_active_p())\n {\n   if (__gthread_mutex_lock(&_M_mutex) != 0)\n     __throw_concurrence_lock_error();\n }\n\n    }\n\n    void unlock()\n    {\n\n      if (__gthread_active'
[#] parse_declaration, is_constructor=False, meet line: 'void unlock()\n    {\n\n      if (__gthread_active_p())\n {\n   if (__gthread_mutex_unlock(&_M_mutex) != 0)\n     __throw_concurrence_unlock_error();\n }\n\n    }\n\n    __gthread_mutex_t* gthread_mutex(void)\n  '
[#] parse_declaration, is_constructor=False, meet line: '__gthread_mutex_t* gthread_mutex(void)\n      { return &_M_mutex; }\n  };\n\n  class __recursive_mutex\n  {\n  private:\n\n    __gthread_recursive_mutex_t _M_mutex = { { 0, 0, 0, 0, PTHREAD_MUTEX_RECURSIVE_NP'
[#] parse_declaration, is_constructor=False, meet line: '__gthread_recursive_mutex_t _M_mutex = { { 0, 0, 0, 0, PTHREAD_MUTEX_RECURSIVE_NP, 0, 0, { 0, 0 } } };\n\n\n\n\n    __recursive_mutex(const __recursive_mutex&);\n    __recursive_mutex& operator=(const __rec'
[#] parse_declaration, is_constructor=True, meet line: '__recursive_mutex(const __recursive_mutex&);\n    __recursive_mutex& operator=(const __recursive_mutex&);\n\n  public:\n    __recursive_mutex()\n    {\n\n\n\n\n    }\n# 202 "/usr/include/c++/7/ext/concurrence.h"'
[#] parse_declaration, is_constructor=True, meet line: '__recursive_mutex& operator=(const __recursive_mutex&);\n\n  public:\n    __recursive_mutex()\n    {\n\n\n\n\n    }\n# 202 "/usr/include/c++/7/ext/concurrence.h" 3\n    void lock()\n    {\n\n      if (__gthread_act'
[#] parse_declaration, is_constructor=True, meet line: '__recursive_mutex()\n    {\n\n\n\n\n    }\n# 202 "/usr/include/c++/7/ext/concurrence.h" 3\n    void lock()\n    {\n\n      if (__gthread_active_p())\n {\n   if (__gthread_recursive_mutex_lock(&_M_mutex) != 0)\n    '
[#] parse_declaration, is_constructor=False, meet line: 'void lock()\n    {\n\n      if (__gthread_active_p())\n {\n   if (__gthread_recursive_mutex_lock(&_M_mutex) != 0)\n     __throw_concurrence_lock_error();\n }\n\n    }\n\n    void unlock()\n    {\n\n      if (__gthr'
[#] parse_declaration, is_constructor=False, meet line: 'void unlock()\n    {\n\n      if (__gthread_active_p())\n {\n   if (__gthread_recursive_mutex_unlock(&_M_mutex) != 0)\n     __throw_concurrence_unlock_error();\n }\n\n    }\n\n    __gthread_recursive_mutex_t* gt'
[#] parse_declaration, is_constructor=False, meet line: '__gthread_recursive_mutex_t* gthread_recursive_mutex(void)\n    { return &_M_mutex; }\n  };\n\n\n\n\n  class __scoped_lock\n  {\n  public:\n    typedef __mutex __mutex_type;\n\n  private:\n    __mutex_type& _M_dev'
[#] parse_declaration, is_constructor=False, meet line: '__mutex_type& _M_device;\n\n    __scoped_lock(const __scoped_lock&);\n    __scoped_lock& operator=(const __scoped_lock&);\n\n  public:\n    explicit __scoped_lock(__mutex_type& __name) : _M_device(__name)\n '
[#] parse_declaration, is_constructor=True, meet line: '__scoped_lock(const __scoped_lock&);\n    __scoped_lock& operator=(const __scoped_lock&);\n\n  public:\n    explicit __scoped_lock(__mutex_type& __name) : _M_device(__name)\n    { _M_device.lock(); }\n\n    '
[#] parse_declaration, is_constructor=True, meet line: '__scoped_lock& operator=(const __scoped_lock&);\n\n  public:\n    explicit __scoped_lock(__mutex_type& __name) : _M_device(__name)\n    { _M_device.lock(); }\n\n    ~__scoped_lock() throw()\n    { _M_device.'
[#] parse_declaration, is_constructor=True, meet line: '__scoped_lock(__mutex_type& __name) : _M_device(__name)\n    { _M_device.lock(); }\n\n    ~__scoped_lock() throw()\n    { _M_device.unlock(); }\n  };\n\n\n  class __cond\n  {\n  private:\n\n    __gthread_cond_t _'
[#] parse_declaration, is_constructor=True, meet line: '__scoped_lock() throw()\n    { _M_device.unlock(); }\n  };\n\n\n  class __cond\n  {\n  private:\n\n    __gthread_cond_t _M_cond = { { {0}, {0}, {0, 0}, {0, 0}, 0, 0, {0, 0} } };\n\n\n\n\n    __cond(const __cond&);\n'
[#] parse_declaration, is_constructor=False, meet line: '__gthread_cond_t _M_cond = { { {0}, {0}, {0, 0}, {0, 0}, 0, 0, {0, 0} } };\n\n\n\n\n    __cond(const __cond&);\n    __cond& operator=(const __cond&);\n\n  public:\n    __cond()\n    {\n\n\n\n\n    }\n# 280 "/usr/incl'
[#] parse_declaration, is_constructor=True, meet line: '__cond(const __cond&);\n    __cond& operator=(const __cond&);\n\n  public:\n    __cond()\n    {\n\n\n\n\n    }\n# 280 "/usr/include/c++/7/ext/concurrence.h" 3\n    void broadcast()\n    {\n\n      if (__gthread_acti'
[#] parse_declaration, is_constructor=True, meet line: '__cond& operator=(const __cond&);\n\n  public:\n    __cond()\n    {\n\n\n\n\n    }\n# 280 "/usr/include/c++/7/ext/concurrence.h" 3\n    void broadcast()\n    {\n\n      if (__gthread_active_p())\n {\n   if (__gthread'
[#] parse_declaration, is_constructor=True, meet line: '__cond()\n    {\n\n\n\n\n    }\n# 280 "/usr/include/c++/7/ext/concurrence.h" 3\n    void broadcast()\n    {\n\n      if (__gthread_active_p())\n {\n   if (__gthread_cond_broadcast(&_M_cond) != 0)\n     __throw_conc'
[#] parse_declaration, is_constructor=False, meet line: 'void broadcast()\n    {\n\n      if (__gthread_active_p())\n {\n   if (__gthread_cond_broadcast(&_M_cond) != 0)\n     __throw_concurrence_broadcast_error();\n }\n\n    }\n\n    void wait(__mutex *mutex)\n    {\n\n '
[#] parse_declaration, is_constructor=False, meet line: 'void wait(__mutex *mutex)\n    {\n\n      {\n   if (__gthread_cond_wait(&_M_cond, mutex->gthread_mutex()) != 0)\n     __throw_concurrence_wait_error();\n      }\n\n    }\n\n    void wait_recursive(__recursive_m'
[#] parse_declaration, is_constructor=False, meet line: 'void wait_recursive(__recursive_mutex *mutex)\n    {\n\n      {\n   if (__gthread_cond_wait_recursive(&_M_cond,\n         mutex->gthread_recursive_mutex())\n       != 0)\n     __throw_concurrence_wait_error('
[#] parse_declaration, is_constructor=True, meet line: '__allocated_ptr(_Alloc& __a, pointer __ptr) noexcept\n      : _M_alloc(std::__addressof(__a)), _M_ptr(__ptr)\n      { }\n\n\n      template<typename _Ptr,\n        typename _Req = _Require<is_same<_Ptr, val'
[#] parse_declaration, is_constructor=True, meet line: '__allocated_ptr(_Alloc& __a, _Ptr __ptr)\n      : _M_alloc(std::__addressof(__a)),\n _M_ptr(pointer_traits<pointer>::pointer_to(*__ptr))\n      { }\n\n\n      __allocated_ptr(__allocated_ptr&& __gd) noexcep'
[#] parse_declaration, is_constructor=True, meet line: '__allocated_ptr(__allocated_ptr&& __gd) noexcept\n      : _M_alloc(__gd._M_alloc), _M_ptr(__gd._M_ptr)\n      { __gd._M_ptr = nullptr; }\n\n\n      ~__allocated_ptr()\n      {\n if (_M_ptr != nullptr)\n   std'
[#] parse_declaration, is_constructor=True, meet line: '__allocated_ptr()\n      {\n if (_M_ptr != nullptr)\n   std::allocator_traits<_Alloc>::deallocate(*_M_alloc, _M_ptr, 1);\n      }\n\n\n      __allocated_ptr&\n      operator=(std::nullptr_t) noexcept\n      {\n'
[#] parse_declaration, is_constructor=True, meet line: '__allocated_ptr&\n      operator=(std::nullptr_t) noexcept\n      {\n _M_ptr = nullptr;\n return *this;\n      }\n\n\n      value_type* get() { return _S_raw_ptr(_M_ptr); }\n\n    private:\n      static value_ty'
[#] parse_declaration, is_constructor=False, meet line: 'value_type* get() { return _S_raw_ptr(_M_ptr); }\n\n    private:\n      static value_type* _S_raw_ptr(value_type* __ptr) { return __ptr; }\n\n      template<typename _Ptr>\n static auto\n _S_raw_ptr(_Ptr __p'
[#] parse_declaration, is_constructor=False, meet line: 'value_type* _S_raw_ptr(value_type* __ptr) { return __ptr; }\n\n      template<typename _Ptr>\n static auto\n _S_raw_ptr(_Ptr __ptr) -> decltype(_S_raw_ptr(__ptr.operator->()))\n { return _S_raw_ptr(__ptr.o'
[#] parse_declaration, is_constructor=False, meet line: 'auto\n _S_raw_ptr(_Ptr __ptr) -> decltype(_S_raw_ptr(__ptr.operator->()))\n { return _S_raw_ptr(__ptr.operator->()); }\n\n      _Alloc* _M_alloc;\n      pointer _M_ptr;\n    };\n\n\n  template<typename _Alloc>'
[#] parse_declaration, is_constructor=False, meet line: '_Alloc* _M_alloc;\n      pointer _M_ptr;\n    };\n\n\n  template<typename _Alloc>\n    __allocated_ptr<_Alloc>\n    __allocate_guarded(_Alloc& __a)\n    {\n      return { __a, std::allocator_traits<_Alloc>::al'
[#] parse_declaration, is_constructor=False, meet line: 'pointer _M_ptr;\n    };\n\n\n  template<typename _Alloc>\n    __allocated_ptr<_Alloc>\n    __allocate_guarded(_Alloc& __a)\n    {\n      return { __a, std::allocator_traits<_Alloc>::allocate(__a, 1) };\n    }\n'
[#] parse_declaration, is_constructor=False, meet line: '__allocated_ptr<_Alloc>\n    __allocate_guarded(_Alloc& __a)\n    {\n      return { __a, std::allocator_traits<_Alloc>::allocate(__a, 1) };\n    }\n\n\n}\n# 56 "/usr/include/c++/7/bits/shared_ptr_base.h" 2 3\n'
[#] parse_declaration, is_constructor=False, meet line: '_Tp* _M_data;\n\n    public:\n      typedef _Tp type;\n\n      reference_wrapper(_Tp& __indata) noexcept\n      : _M_data(std::__addressof(__indata))\n      { }\n\n      reference_wrapper(_Tp&&) = delete;\n\n   '
[#] parse_declaration, is_constructor=True, meet line: 'reference_wrapper(_Tp& __indata) noexcept\n      : _M_data(std::__addressof(__indata))\n      { }\n\n      reference_wrapper(_Tp&&) = delete;\n\n      reference_wrapper(const reference_wrapper&) = default;\n'
[#] parse_declaration, is_constructor=True, meet line: 'reference_wrapper(_Tp&&) = delete;\n\n      reference_wrapper(const reference_wrapper&) = default;\n\n      reference_wrapper&\n      operator=(const reference_wrapper&) = default;\n\n      operator _Tp&() c'
[#] parse_declaration, is_constructor=True, meet line: 'reference_wrapper(const reference_wrapper&) = default;\n\n      reference_wrapper&\n      operator=(const reference_wrapper&) = default;\n\n      operator _Tp&() const noexcept\n      { return this->get(); '
[#] parse_declaration, is_constructor=True, meet line: 'reference_wrapper&\n      operator=(const reference_wrapper&) = default;\n\n      operator _Tp&() const noexcept\n      { return this->get(); }\n\n      _Tp&\n      get() const noexcept\n      { return *_M_da'
[#] parse_declaration, is_constructor=False, meet line: 'operator _Tp&() const noexcept\n      { return this->get(); }\n\n      _Tp&\n      get() const noexcept\n      { return *_M_data; }\n\n      template<typename... _Args>\n typename result_of<_Tp&(_Args&&...)>:'
[#] parse_declaration, is_constructor=False, meet line: '_Tp&\n      get() const noexcept\n      { return *_M_data; }\n\n      template<typename... _Args>\n typename result_of<_Tp&(_Args&&...)>::type\n operator()(_Args&&... __args) const\n {\n   return std::__invok'
[#] parse_declaration, is_constructor=False, meet line: 'result_of<_Tp&(_Args&&...)>::type\n operator()(_Args&&... __args) const\n {\n   return std::__invoke(get(), std::forward<_Args>(__args)...);\n }\n    };\n\n\n\n  template<typename _Tp>\n    inline reference_wra'
[#] parse_declaration, is_constructor=False, meet line: 'reference_wrapper<_Tp>\n    ref(_Tp& __t) noexcept\n    { return reference_wrapper<_Tp>(__t); }\n\n\n  template<typename _Tp>\n    inline reference_wrapper<const _Tp>\n    cref(const _Tp& __t) noexcept\n    {'
[#] parse_declaration, is_constructor=False, meet line: 'reference_wrapper<const _Tp>\n    cref(const _Tp& __t) noexcept\n    { return reference_wrapper<const _Tp>(__t); }\n\n  template<typename _Tp>\n    void ref(const _Tp&&) = delete;\n\n  template<typename _Tp>'
[#] parse_declaration, is_constructor=False, meet line: 'void ref(const _Tp&&) = delete;\n\n  template<typename _Tp>\n    void cref(const _Tp&&) = delete;\n\n\n  template<typename _Tp>\n    inline reference_wrapper<_Tp>\n    ref(reference_wrapper<_Tp> __t) noexcept'
[#] parse_declaration, is_constructor=False, meet line: 'void cref(const _Tp&&) = delete;\n\n\n  template<typename _Tp>\n    inline reference_wrapper<_Tp>\n    ref(reference_wrapper<_Tp> __t) noexcept\n    { return ref(__t.get()); }\n\n\n  template<typename _Tp>\n   '
[#] parse_declaration, is_constructor=False, meet line: 'reference_wrapper<_Tp>\n    ref(reference_wrapper<_Tp> __t) noexcept\n    { return ref(__t.get()); }\n\n\n  template<typename _Tp>\n    inline reference_wrapper<const _Tp>\n    cref(reference_wrapper<_Tp> __'
[#] parse_declaration, is_constructor=False, meet line: 'reference_wrapper<const _Tp>\n    cref(reference_wrapper<_Tp> __t) noexcept\n    { return cref(__t.get()); }\n\n\n\n\n}\n# 57 "/usr/include/c++/7/bits/shared_ptr_base.h" 2 3\n\n# 1 "/usr/include/c++/7/ext/align'
[#] parse_declaration, is_constructor=False, meet line: '_Tp _M_t; };\n\n      alignas(__alignof__(_Tp2::_M_t)) unsigned char _M_storage[sizeof(_Tp)];\n\n      __aligned_membuf() = default;\n\n\n      __aligned_membuf(std::nullptr_t) { }\n\n      void*\n      _M_addr'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned char _M_storage[sizeof(_Tp)];\n\n      __aligned_membuf() = default;\n\n\n      __aligned_membuf(std::nullptr_t) { }\n\n      void*\n      _M_addr() noexcept\n      { return static_cast<void*>(&_M_sto'
[#] parse_declaration, is_constructor=True, meet line: '__aligned_membuf() = default;\n\n\n      __aligned_membuf(std::nullptr_t) { }\n\n      void*\n      _M_addr() noexcept\n      { return static_cast<void*>(&_M_storage); }\n\n      const void*\n      _M_addr() co'
[#] parse_declaration, is_constructor=True, meet line: '__aligned_membuf(std::nullptr_t) { }\n\n      void*\n      _M_addr() noexcept\n      { return static_cast<void*>(&_M_storage); }\n\n      const void*\n      _M_addr() const noexcept\n      { return static_cas'
[#] parse_declaration, is_constructor=False, meet line: 'void*\n      _M_addr() noexcept\n      { return static_cast<void*>(&_M_storage); }\n\n      const void*\n      _M_addr() const noexcept\n      { return static_cast<const void*>(&_M_storage); }\n\n      _Tp*\n '
[#] parse_declaration, is_constructor=False, meet line: 'void*\n      _M_addr() const noexcept\n      { return static_cast<const void*>(&_M_storage); }\n\n      _Tp*\n      _M_ptr() noexcept\n      { return static_cast<_Tp*>(_M_addr()); }\n\n      const _Tp*\n      '
[#] parse_declaration, is_constructor=False, meet line: '_Tp*\n      _M_ptr() noexcept\n      { return static_cast<_Tp*>(_M_addr()); }\n\n      const _Tp*\n      _M_ptr() const noexcept\n      { return static_cast<const _Tp*>(_M_addr()); }\n    };\n\n\n\n\n\n\n  template'
[#] parse_declaration, is_constructor=False, meet line: '_Tp*\n      _M_ptr() const noexcept\n      { return static_cast<const _Tp*>(_M_addr()); }\n    };\n\n\n\n\n\n\n  template<typename _Tp>\n    struct __aligned_buffer\n    : std::aligned_storage<sizeof(_Tp), std::a'
[#] parse_declaration, is_constructor=False, meet line: 'std::aligned_storage<sizeof(_Tp), std::alignment_of<_Tp>::value>::type\n _M_storage;\n\n      __aligned_buffer() = default;\n\n\n      __aligned_buffer(std::nullptr_t) { }\n\n      void*\n      _M_addr() noexc'
[#] parse_declaration, is_constructor=True, meet line: '__aligned_buffer() = default;\n\n\n      __aligned_buffer(std::nullptr_t) { }\n\n      void*\n      _M_addr() noexcept\n      {\n        return static_cast<void*>(&_M_storage);\n      }\n\n      const void*\n    '
[#] parse_declaration, is_constructor=True, meet line: '__aligned_buffer(std::nullptr_t) { }\n\n      void*\n      _M_addr() noexcept\n      {\n        return static_cast<void*>(&_M_storage);\n      }\n\n      const void*\n      _M_addr() const noexcept\n      {\n   '
[#] parse_declaration, is_constructor=False, meet line: 'void*\n      _M_addr() noexcept\n      {\n        return static_cast<void*>(&_M_storage);\n      }\n\n      const void*\n      _M_addr() const noexcept\n      {\n        return static_cast<const void*>(&_M_sto'
[#] parse_declaration, is_constructor=False, meet line: 'void*\n      _M_addr() const noexcept\n      {\n        return static_cast<const void*>(&_M_storage);\n      }\n\n      _Tp*\n      _M_ptr() noexcept\n      { return static_cast<_Tp*>(_M_addr()); }\n\n      con'
[#] parse_declaration, is_constructor=False, meet line: '_Tp*\n      _M_ptr() noexcept\n      { return static_cast<_Tp*>(_M_addr()); }\n\n      const _Tp*\n      _M_ptr() const noexcept\n      { return static_cast<const _Tp*>(_M_addr()); }\n    };\n\n}\n# 59 "/usr/in'
[#] parse_declaration, is_constructor=False, meet line: '_Tp*\n      _M_ptr() const noexcept\n      { return static_cast<const _Tp*>(_M_addr()); }\n    };\n\n}\n# 59 "/usr/include/c++/7/bits/shared_ptr_base.h" 2 3\n\nnamespace std __attribute__ ((__visibility__ ("d'
[#] parse_declaration, is_constructor=False, meet line: 'char const* what() const noexcept;\n\n    virtual ~bad_weak_ptr() noexcept;\n  };\n\n\n  inline void\n  __throw_bad_weak_ptr()\n  { (throw (bad_weak_ptr())); }\n\n  using __gnu_cxx::_Lock_policy;\n  using __gnu_'
[#] parse_declaration, is_constructor=True, meet line: 'bad_weak_ptr() noexcept;\n  };\n\n\n  inline void\n  __throw_bad_weak_ptr()\n  { (throw (bad_weak_ptr())); }\n\n  using __gnu_cxx::_Lock_policy;\n  using __gnu_cxx::__default_lock_policy;\n  using __gnu_cxx::_S'
[#] parse_declaration, is_constructor=False, meet line: 'void\n  __throw_bad_weak_ptr()\n  { (throw (bad_weak_ptr())); }\n\n  using __gnu_cxx::_Lock_policy;\n  using __gnu_cxx::__default_lock_policy;\n  using __gnu_cxx::_S_single;\n  using __gnu_cxx::_S_mutex;\n  u'
[#] parse_declaration, is_constructor=True, meet line: '_Sp_counted_base() noexcept\n      : _M_use_count(1), _M_weak_count(1) { }\n\n      virtual\n      ~_Sp_counted_base() noexcept\n      { }\n\n\n\n      virtual void\n      _M_dispose() noexcept = 0;\n\n\n      vir'
[#] parse_declaration, is_constructor=True, meet line: '_Sp_counted_base() noexcept\n      { }\n\n\n\n      virtual void\n      _M_dispose() noexcept = 0;\n\n\n      virtual void\n      _M_destroy() noexcept\n      { delete this; }\n\n      virtual void*\n      _M_get_d'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_dispose() noexcept = 0;\n\n\n      virtual void\n      _M_destroy() noexcept\n      { delete this; }\n\n      virtual void*\n      _M_get_deleter(const std::type_info&) noexcept = 0;\n\n      void'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_destroy() noexcept\n      { delete this; }\n\n      virtual void*\n      _M_get_deleter(const std::type_info&) noexcept = 0;\n\n      void\n      _M_add_ref_copy()\n      { __gnu_cxx::__atomic_a'
[#] parse_declaration, is_constructor=False, meet line: 'void*\n      _M_get_deleter(const std::type_info&) noexcept = 0;\n\n      void\n      _M_add_ref_copy()\n      { __gnu_cxx::__atomic_add_dispatch(&_M_use_count, 1); }\n\n      void\n      _M_add_ref_lock();\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_add_ref_copy()\n      { __gnu_cxx::__atomic_add_dispatch(&_M_use_count, 1); }\n\n      void\n      _M_add_ref_lock();\n\n      bool\n      _M_add_ref_lock_nothrow();\n\n      void\n      _M_releas'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_add_ref_lock();\n\n      bool\n      _M_add_ref_lock_nothrow();\n\n      void\n      _M_release() noexcept\n      {\n\n        ;\n if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, -1) == '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      _M_add_ref_lock_nothrow();\n\n      void\n      _M_release() noexcept\n      {\n\n        ;\n if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, -1) == 1)\n   {\n            ;\n     _M_dispose'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_release() noexcept\n      {\n\n        ;\n if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, -1) == 1)\n   {\n            ;\n     _M_dispose();\n\n\n\n\n     if (_Mutex_base<_Lp>::_S_need_ba'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_weak_add_ref() noexcept\n      { __gnu_cxx::__atomic_add_dispatch(&_M_weak_count, 1); }\n\n      void\n      _M_weak_release() noexcept\n      {\n\n        ;\n if (__gnu_cxx::__exchange_and_add_'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_weak_release() noexcept\n      {\n\n        ;\n if (__gnu_cxx::__exchange_and_add_dispatch(&_M_weak_count, -1) == 1)\n   {\n            ;\n     if (_Mutex_base<_Lp>::_S_need_barriers)\n       {\n'
[#] parse_declaration, is_constructor=False, meet line: 'long\n      _M_get_use_count() const noexcept\n      {\n\n\n        return __atomic_load_n(&_M_use_count, 0);\n      }\n\n    private:\n      _Sp_counted_base(_Sp_counted_base const&) = delete;\n      _Sp_count'
[#] parse_declaration, is_constructor=True, meet line: '_Sp_counted_base(_Sp_counted_base const&) = delete;\n      _Sp_counted_base& operator=(_Sp_counted_base const&) = delete;\n\n      _Atomic_word _M_use_count;\n      _Atomic_word _M_weak_count;\n    };\n\n  t'
[#] parse_declaration, is_constructor=True, meet line: '_Sp_counted_base& operator=(_Sp_counted_base const&) = delete;\n\n      _Atomic_word _M_use_count;\n      _Atomic_word _M_weak_count;\n    };\n\n  template<>\n    inline void\n    _Sp_counted_base<_S_single>:'
[#] parse_declaration, is_constructor=False, meet line: '_Atomic_word _M_use_count;\n      _Atomic_word _M_weak_count;\n    };\n\n  template<>\n    inline void\n    _Sp_counted_base<_S_single>::\n    _M_add_ref_lock()\n    {\n      if (_M_use_count == 0)\n __throw_ba'
[#] parse_declaration, is_constructor=False, meet line: '_Atomic_word _M_weak_count;\n    };\n\n  template<>\n    inline void\n    _Sp_counted_base<_S_single>::\n    _M_add_ref_lock()\n    {\n      if (_M_use_count == 0)\n __throw_bad_weak_ptr();\n      ++_M_use_coun'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _Sp_counted_base<_S_single>::\n    _M_add_ref_lock()\n    {\n      if (_M_use_count == 0)\n __throw_bad_weak_ptr();\n      ++_M_use_count;\n    }\n\n  template<>\n    inline void\n    _Sp_counted_base<'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _Sp_counted_base<_S_mutex>::\n    _M_add_ref_lock()\n    {\n      __gnu_cxx::__scoped_lock sentry(*this);\n      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, 1) == 0)\n {\n   _M_use_co'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _Sp_counted_base<_S_atomic>::\n    _M_add_ref_lock()\n    {\n\n      _Atomic_word __count = _M_get_use_count();\n      do\n {\n   if (__count == 0)\n     __throw_bad_weak_ptr();\n\n\n }\n      while (!__'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    _Sp_counted_base<_S_single>::\n    _M_add_ref_lock_nothrow()\n    {\n      if (_M_use_count == 0)\n return false;\n      ++_M_use_count;\n      return true;\n    }\n\n  template<>\n    inline bool\n    '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    _Sp_counted_base<_S_mutex>::\n    _M_add_ref_lock_nothrow()\n    {\n      __gnu_cxx::__scoped_lock sentry(*this);\n      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, 1) == 0)\n {\n   _'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    _Sp_counted_base<_S_atomic>::\n    _M_add_ref_lock_nothrow()\n    {\n\n      _Atomic_word __count = _M_get_use_count();\n      do\n {\n   if (__count == 0)\n     return false;\n\n\n }\n      while (!__at'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _Sp_counted_base<_S_single>::_M_add_ref_copy()\n    { ++_M_use_count; }\n\n  template<>\n    inline void\n    _Sp_counted_base<_S_single>::_M_release() noexcept\n    {\n      if (--_M_use_count == 0'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _Sp_counted_base<_S_single>::_M_release() noexcept\n    {\n      if (--_M_use_count == 0)\n        {\n          _M_dispose();\n          if (--_M_weak_count == 0)\n            _M_destroy();\n       '
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _Sp_counted_base<_S_single>::_M_weak_add_ref() noexcept\n    { ++_M_weak_count; }\n\n  template<>\n    inline void\n    _Sp_counted_base<_S_single>::_M_weak_release() noexcept\n    {\n      if (--_M'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _Sp_counted_base<_S_single>::_M_weak_release() noexcept\n    {\n      if (--_M_weak_count == 0)\n        _M_destroy();\n    }\n\n  template<>\n    inline long\n    _Sp_counted_base<_S_single>::_M_get'
[#] parse_declaration, is_constructor=False, meet line: 'long\n    _Sp_counted_base<_S_single>::_M_get_use_count() const noexcept\n    { return _M_use_count; }\n\n\n\n  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>\n    class __shared_ptr;\n\n  te'
[#] parse_declaration, is_constructor=True, meet line: '_Sp_counted_ptr(_Ptr __p) noexcept\n      : _M_ptr(__p) { }\n\n      virtual void\n      _M_dispose() noexcept\n      { delete _M_ptr; }\n\n      virtual void\n      _M_destroy() noexcept\n      { delete this;'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_dispose() noexcept\n      { delete _M_ptr; }\n\n      virtual void\n      _M_destroy() noexcept\n      { delete this; }\n\n      virtual void*\n      _M_get_deleter(const std::type_info&) noexce'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_destroy() noexcept\n      { delete this; }\n\n      virtual void*\n      _M_get_deleter(const std::type_info&) noexcept\n      { return nullptr; }\n\n      _Sp_counted_ptr(const _Sp_counted_ptr'
[#] parse_declaration, is_constructor=False, meet line: 'void*\n      _M_get_deleter(const std::type_info&) noexcept\n      { return nullptr; }\n\n      _Sp_counted_ptr(const _Sp_counted_ptr&) = delete;\n      _Sp_counted_ptr& operator=(const _Sp_counted_ptr&) ='
[#] parse_declaration, is_constructor=True, meet line: '_Sp_counted_ptr(const _Sp_counted_ptr&) = delete;\n      _Sp_counted_ptr& operator=(const _Sp_counted_ptr&) = delete;\n\n    private:\n      _Ptr _M_ptr;\n    };\n\n  template<>\n    inline void\n    _Sp_count'
[#] parse_declaration, is_constructor=True, meet line: '_Sp_counted_ptr& operator=(const _Sp_counted_ptr&) = delete;\n\n    private:\n      _Ptr _M_ptr;\n    };\n\n  template<>\n    inline void\n    _Sp_counted_ptr<nullptr_t, _S_single>::_M_dispose() noexcept { }\n'
[#] parse_declaration, is_constructor=False, meet line: '_Ptr _M_ptr;\n    };\n\n  template<>\n    inline void\n    _Sp_counted_ptr<nullptr_t, _S_single>::_M_dispose() noexcept { }\n\n  template<>\n    inline void\n    _Sp_counted_ptr<nullptr_t, _S_mutex>::_M_dispos'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _Sp_counted_ptr<nullptr_t, _S_single>::_M_dispose() noexcept { }\n\n  template<>\n    inline void\n    _Sp_counted_ptr<nullptr_t, _S_mutex>::_M_dispose() noexcept { }\n\n  template<>\n    inline voi'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _Sp_counted_ptr<nullptr_t, _S_mutex>::_M_dispose() noexcept { }\n\n  template<>\n    inline void\n    _Sp_counted_ptr<nullptr_t, _S_atomic>::_M_dispose() noexcept { }\n\n  template<int _Nm, typenam'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _Sp_counted_ptr<nullptr_t, _S_atomic>::_M_dispose() noexcept { }\n\n  template<int _Nm, typename _Tp,\n    bool __use_ebo = !__is_final(_Tp) && __is_empty(_Tp)>\n    struct _Sp_ebo_helper;\n\n\n  te'
[#] parse_declaration, is_constructor=True, meet line: '_Sp_ebo_helper(const _Tp& __tp) : _Tp(__tp) { }\n      explicit _Sp_ebo_helper(_Tp&& __tp) : _Tp(std::move(__tp)) { }\n\n      static _Tp&\n      _S_get(_Sp_ebo_helper& __eboh) { return static_cast<_Tp&>('
[#] parse_declaration, is_constructor=True, meet line: '_Sp_ebo_helper(_Tp&& __tp) : _Tp(std::move(__tp)) { }\n\n      static _Tp&\n      _S_get(_Sp_ebo_helper& __eboh) { return static_cast<_Tp&>(__eboh); }\n    };\n\n\n  template<int _Nm, typename _Tp>\n    struc'
[#] parse_declaration, is_constructor=False, meet line: '_Tp&\n      _S_get(_Sp_ebo_helper& __eboh) { return static_cast<_Tp&>(__eboh); }\n    };\n\n\n  template<int _Nm, typename _Tp>\n    struct _Sp_ebo_helper<_Nm, _Tp, false>\n    {\n      explicit _Sp_ebo_helpe'
[#] parse_declaration, is_constructor=True, meet line: '_Sp_ebo_helper(const _Tp& __tp) : _M_tp(__tp) { }\n      explicit _Sp_ebo_helper(_Tp&& __tp) : _M_tp(std::move(__tp)) { }\n\n      static _Tp&\n      _S_get(_Sp_ebo_helper& __eboh)\n      { return __eboh._'
[#] parse_declaration, is_constructor=True, meet line: '_Sp_ebo_helper(_Tp&& __tp) : _M_tp(std::move(__tp)) { }\n\n      static _Tp&\n      _S_get(_Sp_ebo_helper& __eboh)\n      { return __eboh._M_tp; }\n\n    private:\n      _Tp _M_tp;\n    };\n\n\n  template<typena'
[#] parse_declaration, is_constructor=False, meet line: '_Tp&\n      _S_get(_Sp_ebo_helper& __eboh)\n      { return __eboh._M_tp; }\n\n    private:\n      _Tp _M_tp;\n    };\n\n\n  template<typename _Ptr, typename _Deleter, typename _Alloc, _Lock_policy _Lp>\n    cla'
[#] parse_declaration, is_constructor=False, meet line: '_Tp _M_tp;\n    };\n\n\n  template<typename _Ptr, typename _Deleter, typename _Alloc, _Lock_policy _Lp>\n    class _Sp_counted_deleter final : public _Sp_counted_base<_Lp>\n    {\n      class _Impl : _Sp_ebo'
[#] parse_declaration, is_constructor=True, meet line: '_Impl(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept\n : _M_ptr(__p), _Del_base(std::move(__d)), _Alloc_base(__a)\n { }\n\n _Deleter& _M_del() noexcept { return _Del_base::_S_get(*this); }\n _Alloc& _'
[#] parse_declaration, is_constructor=False, meet line: '_Deleter& _M_del() noexcept { return _Del_base::_S_get(*this); }\n _Alloc& _M_alloc() noexcept { return _Alloc_base::_S_get(*this); }\n\n _Ptr _M_ptr;\n      };\n\n    public:\n      using __allocator_type ='
[#] parse_declaration, is_constructor=False, meet line: '_Alloc& _M_alloc() noexcept { return _Alloc_base::_S_get(*this); }\n\n _Ptr _M_ptr;\n      };\n\n    public:\n      using __allocator_type = __alloc_rebind<_Alloc, _Sp_counted_deleter>;\n\n\n      _Sp_counted_'
[#] parse_declaration, is_constructor=False, meet line: '_Ptr _M_ptr;\n      };\n\n    public:\n      using __allocator_type = __alloc_rebind<_Alloc, _Sp_counted_deleter>;\n\n\n      _Sp_counted_deleter(_Ptr __p, _Deleter __d) noexcept\n      : _M_impl(__p, std::mo'
[#] parse_declaration, is_constructor=True, meet line: '_Sp_counted_deleter(_Ptr __p, _Deleter __d) noexcept\n      : _M_impl(__p, std::move(__d), _Alloc()) { }\n\n\n      _Sp_counted_deleter(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept\n      : _M_impl('
[#] parse_declaration, is_constructor=True, meet line: '_Sp_counted_deleter(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept\n      : _M_impl(__p, std::move(__d), __a) { }\n\n      ~_Sp_counted_deleter() noexcept { }\n\n      virtual void\n      _M_dispose() '
[#] parse_declaration, is_constructor=True, meet line: '_Sp_counted_deleter() noexcept { }\n\n      virtual void\n      _M_dispose() noexcept\n      { _M_impl._M_del()(_M_impl._M_ptr); }\n\n      virtual void\n      _M_destroy() noexcept\n      {\n __allocator_type'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_dispose() noexcept\n      { _M_impl._M_del()(_M_impl._M_ptr); }\n\n      virtual void\n      _M_destroy() noexcept\n      {\n __allocator_type __a(_M_impl._M_alloc());\n __allocated_ptr<__alloc'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_destroy() noexcept\n      {\n __allocator_type __a(_M_impl._M_alloc());\n __allocated_ptr<__allocator_type> __guard_ptr{ __a, this };\n this->~_Sp_counted_deleter();\n      }\n\n      virtual v'
[#] parse_declaration, is_constructor=False, meet line: 'void*\n      _M_get_deleter(const std::type_info& __ti) noexcept\n      {\n\n\n\n        return __ti == typeid(_Deleter)\n   ? std::__addressof(_M_impl._M_del())\n   : nullptr;\n\n\n\n      }\n\n    private:\n      '
[#] parse_declaration, is_constructor=False, meet line: '_Impl _M_impl;\n    };\n\n\n\n  struct _Sp_make_shared_tag { };\n\n  template<typename _Tp, typename _Alloc, _Lock_policy _Lp>\n    class _Sp_counted_ptr_inplace final : public _Sp_counted_base<_Lp>\n    {\n   '
[#] parse_declaration, is_constructor=True, meet line: '_Impl(_Alloc __a) noexcept : _A_base(__a) { }\n\n _Alloc& _M_alloc() noexcept { return _A_base::_S_get(*this); }\n\n __gnu_cxx::__aligned_buffer<_Tp> _M_storage;\n      };\n\n    public:\n      using __alloca'
[#] parse_declaration, is_constructor=False, meet line: '_Alloc& _M_alloc() noexcept { return _A_base::_S_get(*this); }\n\n __gnu_cxx::__aligned_buffer<_Tp> _M_storage;\n      };\n\n    public:\n      using __allocator_type = __alloc_rebind<_Alloc, _Sp_counted_pt'
[#] parse_declaration, is_constructor=False, meet line: '__gnu_cxx::__aligned_buffer<_Tp> _M_storage;\n      };\n\n    public:\n      using __allocator_type = __alloc_rebind<_Alloc, _Sp_counted_ptr_inplace>;\n\n      template<typename... _Args>\n _Sp_counted_ptr_i'
[#] parse_declaration, is_constructor=True, meet line: '_Sp_counted_ptr_inplace(_Alloc __a, _Args&&... __args)\n : _M_impl(__a)\n {\n\n\n   allocator_traits<_Alloc>::construct(__a, _M_ptr(),\n       std::forward<_Args>(__args)...);\n }\n\n      ~_Sp_counted_ptr_inp'
[#] parse_declaration, is_constructor=True, meet line: '_Sp_counted_ptr_inplace() noexcept { }\n\n      virtual void\n      _M_dispose() noexcept\n      {\n allocator_traits<_Alloc>::destroy(_M_impl._M_alloc(), _M_ptr());\n      }\n\n\n      virtual void\n      _M_d'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_dispose() noexcept\n      {\n allocator_traits<_Alloc>::destroy(_M_impl._M_alloc(), _M_ptr());\n      }\n\n\n      virtual void\n      _M_destroy() noexcept\n      {\n __allocator_type __a(_M_imp'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_destroy() noexcept\n      {\n __allocator_type __a(_M_impl._M_alloc());\n __allocated_ptr<__allocator_type> __guard_ptr{ __a, this };\n this->~_Sp_counted_ptr_inplace();\n      }\n\n\n      virt'
[#] parse_declaration, is_constructor=False, meet line: 'void*\n      _M_get_deleter(const std::type_info& __ti) noexcept\n      {\n\n if (__ti == typeid(_Sp_make_shared_tag))\n   return const_cast<typename remove_cv<_Tp>::type*>(_M_ptr());\n\n return nullptr;\n   '
[#] parse_declaration, is_constructor=False, meet line: '_Tp* _M_ptr() noexcept { return _M_impl._M_storage._M_ptr(); }\n\n      _Impl _M_impl;\n    };\n\n\n  struct __sp_array_delete\n  {\n    template<typename _Yp>\n      void operator()(_Yp* __p) const { delete[]'
[#] parse_declaration, is_constructor=False, meet line: '_Impl _M_impl;\n    };\n\n\n  struct __sp_array_delete\n  {\n    template<typename _Yp>\n      void operator()(_Yp* __p) const { delete[] __p; }\n  };\n\n  template<_Lock_policy _Lp>\n    class __shared_count\n  '
[#] parse_declaration, is_constructor=False, meet line: 'void operator()(_Yp* __p) const { delete[] __p; }\n  };\n\n  template<_Lock_policy _Lp>\n    class __shared_count\n    {\n    public:\n      constexpr __shared_count() noexcept : _M_pi(0)\n      { }\n\n      te'
[#] parse_declaration, is_constructor=True, meet line: '__shared_count() noexcept : _M_pi(0)\n      { }\n\n      template<typename _Ptr>\n        explicit\n __shared_count(_Ptr __p) : _M_pi(0)\n {\n   try\n     {\n       _M_pi = new _Sp_counted_ptr<_Ptr, _Lp>(__p);'
[#] parse_declaration, is_constructor=True, meet line: '__shared_count(_Ptr __p) : _M_pi(0)\n {\n   try\n     {\n       _M_pi = new _Sp_counted_ptr<_Ptr, _Lp>(__p);\n     }\n   catch(...)\n     {\n       delete __p;\n       throw;\n     }\n }\n\n      template<typename'
[#] parse_declaration, is_constructor=True, meet line: '__shared_count(_Ptr __p, false_type)\n : __shared_count(__p)\n { }\n\n      template<typename _Ptr>\n __shared_count(_Ptr __p, true_type)\n : __shared_count(__p, __sp_array_delete{}, allocator<void>())\n { }'
[#] parse_declaration, is_constructor=True, meet line: '__shared_count(_Ptr __p, true_type)\n : __shared_count(__p, __sp_array_delete{}, allocator<void>())\n { }\n\n      template<typename _Ptr, typename _Deleter>\n __shared_count(_Ptr __p, _Deleter __d)\n : __s'
[#] parse_declaration, is_constructor=True, meet line: '__shared_count(_Ptr __p, _Deleter __d)\n : __shared_count(__p, std::move(__d), allocator<void>())\n { }\n\n      template<typename _Ptr, typename _Deleter, typename _Alloc>\n __shared_count(_Ptr __p, _Dele'
[#] parse_declaration, is_constructor=True, meet line: '__shared_count(_Ptr __p, _Deleter __d, _Alloc __a) : _M_pi(0)\n {\n   typedef _Sp_counted_deleter<_Ptr, _Deleter, _Alloc, _Lp> _Sp_cd_type;\n   try\n     {\n       typename _Sp_cd_type::__allocator_type __'
[#] parse_declaration, is_constructor=True, meet line: '__shared_count(_Sp_make_shared_tag, _Tp*, const _Alloc& __a,\n         _Args&&... __args)\n : _M_pi(0)\n {\n   typedef _Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp> _Sp_cp_type;\n   typename _Sp_cp_type::__all'
[#] parse_declaration, is_constructor=True, meet line: '__shared_count(std::auto_ptr<_Tp>&& __r);\n\n\n\n      template<typename _Tp, typename _Del>\n        explicit\n __shared_count(std::unique_ptr<_Tp, _Del>&& __r) : _M_pi(0)\n {\n\n\n   if (__r.get() == nullptr)'
[#] parse_declaration, is_constructor=True, meet line: '__shared_count(std::unique_ptr<_Tp, _Del>&& __r) : _M_pi(0)\n {\n\n\n   if (__r.get() == nullptr)\n     return;\n\n   using _Ptr = typename unique_ptr<_Tp, _Del>::pointer;\n   using _Del2 = typename condition'
[#] parse_declaration, is_constructor=True, meet line: '__shared_count(const __weak_count<_Lp>& __r);\n\n\n      explicit __shared_count(const __weak_count<_Lp>& __r, std::nothrow_t);\n\n      ~__shared_count() noexcept\n      {\n if (_M_pi != nullptr)\n   _M_pi->'
[#] parse_declaration, is_constructor=True, meet line: '__shared_count(const __weak_count<_Lp>& __r, std::nothrow_t);\n\n      ~__shared_count() noexcept\n      {\n if (_M_pi != nullptr)\n   _M_pi->_M_release();\n      }\n\n      __shared_count(const __shared_coun'
[#] parse_declaration, is_constructor=True, meet line: '__shared_count() noexcept\n      {\n if (_M_pi != nullptr)\n   _M_pi->_M_release();\n      }\n\n      __shared_count(const __shared_count& __r) noexcept\n      : _M_pi(__r._M_pi)\n      {\n if (_M_pi != 0)\n   '
[#] parse_declaration, is_constructor=True, meet line: '__shared_count(const __shared_count& __r) noexcept\n      : _M_pi(__r._M_pi)\n      {\n if (_M_pi != 0)\n   _M_pi->_M_add_ref_copy();\n      }\n\n      __shared_count&\n      operator=(const __shared_count& _'
[#] parse_declaration, is_constructor=True, meet line: '__shared_count&\n      operator=(const __shared_count& __r) noexcept\n      {\n _Sp_counted_base<_Lp>* __tmp = __r._M_pi;\n if (__tmp != _M_pi)\n   {\n     if (__tmp != 0)\n       __tmp->_M_add_ref_copy();\n '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_swap(__shared_count& __r) noexcept\n      {\n _Sp_counted_base<_Lp>* __tmp = __r._M_pi;\n __r._M_pi = _M_pi;\n _M_pi = __tmp;\n      }\n\n      long\n      _M_get_use_count() const noexcept\n    '
[#] parse_declaration, is_constructor=False, meet line: 'long\n      _M_get_use_count() const noexcept\n      { return _M_pi != 0 ? _M_pi->_M_get_use_count() : 0; }\n\n      bool\n      _M_unique() const noexcept\n      { return this->_M_get_use_count() == 1; }\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      _M_unique() const noexcept\n      { return this->_M_get_use_count() == 1; }\n\n      void*\n      _M_get_deleter(const std::type_info& __ti) const noexcept\n      { return _M_pi ? _M_pi->_M_get_'
[#] parse_declaration, is_constructor=False, meet line: 'void*\n      _M_get_deleter(const std::type_info& __ti) const noexcept\n      { return _M_pi ? _M_pi->_M_get_deleter(__ti) : nullptr; }\n\n      bool\n      _M_less(const __shared_count& __rhs) const noexc'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      _M_less(const __shared_count& __rhs) const noexcept\n      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }\n\n      bool\n      _M_less(const __weak_count<_Lp>& __rhs)'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      _M_less(const __weak_count<_Lp>& __rhs) const noexcept\n      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }\n\n\n      friend inline bool\n      operator==(const __sh'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      operator==(const __shared_count& __a, const __shared_count& __b) noexcept\n      { return __a._M_pi == __b._M_pi; }\n\n    private:\n      friend class __weak_count<_Lp>;\n\n      _Sp_counted_bas'
[#] parse_declaration, is_constructor=False, meet line: '_Sp_counted_base<_Lp>* _M_pi;\n    };\n\n\n  template<_Lock_policy _Lp>\n    class __weak_count\n    {\n    public:\n      constexpr __weak_count() noexcept : _M_pi(nullptr)\n      { }\n\n      __weak_count(cons'
[#] parse_declaration, is_constructor=True, meet line: '__weak_count() noexcept : _M_pi(nullptr)\n      { }\n\n      __weak_count(const __shared_count<_Lp>& __r) noexcept\n      : _M_pi(__r._M_pi)\n      {\n if (_M_pi != nullptr)\n   _M_pi->_M_weak_add_ref();\n   '
[#] parse_declaration, is_constructor=True, meet line: '__weak_count(const __shared_count<_Lp>& __r) noexcept\n      : _M_pi(__r._M_pi)\n      {\n if (_M_pi != nullptr)\n   _M_pi->_M_weak_add_ref();\n      }\n\n      __weak_count(const __weak_count& __r) noexcept'
[#] parse_declaration, is_constructor=True, meet line: '__weak_count(const __weak_count& __r) noexcept\n      : _M_pi(__r._M_pi)\n      {\n if (_M_pi != nullptr)\n   _M_pi->_M_weak_add_ref();\n      }\n\n      __weak_count(__weak_count&& __r) noexcept\n      : _M_'
[#] parse_declaration, is_constructor=True, meet line: '__weak_count(__weak_count&& __r) noexcept\n      : _M_pi(__r._M_pi)\n      { __r._M_pi = nullptr; }\n\n      ~__weak_count() noexcept\n      {\n if (_M_pi != nullptr)\n   _M_pi->_M_weak_release();\n      }\n\n '
[#] parse_declaration, is_constructor=True, meet line: '__weak_count() noexcept\n      {\n if (_M_pi != nullptr)\n   _M_pi->_M_weak_release();\n      }\n\n      __weak_count&\n      operator=(const __shared_count<_Lp>& __r) noexcept\n      {\n _Sp_counted_base<_Lp>'
[#] parse_declaration, is_constructor=True, meet line: '__weak_count&\n      operator=(const __shared_count<_Lp>& __r) noexcept\n      {\n _Sp_counted_base<_Lp>* __tmp = __r._M_pi;\n if (__tmp != nullptr)\n   __tmp->_M_weak_add_ref();\n if (_M_pi != nullptr)\n   '
[#] parse_declaration, is_constructor=True, meet line: '__weak_count&\n      operator=(const __weak_count& __r) noexcept\n      {\n _Sp_counted_base<_Lp>* __tmp = __r._M_pi;\n if (__tmp != nullptr)\n   __tmp->_M_weak_add_ref();\n if (_M_pi != nullptr)\n   _M_pi->'
[#] parse_declaration, is_constructor=True, meet line: '__weak_count&\n      operator=(__weak_count&& __r) noexcept\n      {\n if (_M_pi != nullptr)\n   _M_pi->_M_weak_release();\n _M_pi = __r._M_pi;\n        __r._M_pi = nullptr;\n return *this;\n      }\n\n      vo'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_swap(__weak_count& __r) noexcept\n      {\n _Sp_counted_base<_Lp>* __tmp = __r._M_pi;\n __r._M_pi = _M_pi;\n _M_pi = __tmp;\n      }\n\n      long\n      _M_get_use_count() const noexcept\n      '
[#] parse_declaration, is_constructor=False, meet line: 'long\n      _M_get_use_count() const noexcept\n      { return _M_pi != nullptr ? _M_pi->_M_get_use_count() : 0; }\n\n      bool\n      _M_less(const __weak_count& __rhs) const noexcept\n      { return std::'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      _M_less(const __weak_count& __rhs) const noexcept\n      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }\n\n      bool\n      _M_less(const __shared_count<_Lp>& __rhs)'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      _M_less(const __shared_count<_Lp>& __rhs) const noexcept\n      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }\n\n\n      friend inline bool\n      operator==(const __'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      operator==(const __weak_count& __a, const __weak_count& __b) noexcept\n      { return __a._M_pi == __b._M_pi; }\n\n    private:\n      friend class __shared_count<_Lp>;\n\n      _Sp_counted_base<'
[#] parse_declaration, is_constructor=False, meet line: '_Sp_counted_base<_Lp>* _M_pi;\n    };\n\n\n  template<_Lock_policy _Lp>\n    inline\n    __shared_count<_Lp>::__shared_count(const __weak_count<_Lp>& __r)\n    : _M_pi(__r._M_pi)\n    {\n      if (_M_pi != nul'
[#] parse_declaration, is_constructor=False, meet line: '__shared_count<_Lp>::__shared_count(const __weak_count<_Lp>& __r)\n    : _M_pi(__r._M_pi)\n    {\n      if (_M_pi != nullptr)\n _M_pi->_M_add_ref_lock();\n      else\n __throw_bad_weak_ptr();\n    }\n\n\n  temp'
[#] parse_declaration, is_constructor=False, meet line: '__shared_count<_Lp>::\n    __shared_count(const __weak_count<_Lp>& __r, std::nothrow_t)\n    : _M_pi(__r._M_pi)\n    {\n      if (_M_pi != nullptr)\n if (!_M_pi->_M_add_ref_lock_nothrow())\n   _M_pi = nullp'
[#] parse_declaration, is_constructor=False, meet line: 'element_type&\n      operator*() const noexcept\n      {\n ;\n return *_M_get();\n      }\n\n      element_type*\n      operator->() const noexcept\n      {\n ;\n return _M_get();\n      }\n\n    private:\n      ele'
[#] parse_declaration, is_constructor=False, meet line: 'element_type*\n      operator->() const noexcept\n      {\n ;\n return _M_get();\n      }\n\n    private:\n      element_type*\n      _M_get() const noexcept\n      { return static_cast<const __shared_ptr<_Tp, '
[#] parse_declaration, is_constructor=False, meet line: 'element_type*\n      _M_get() const noexcept\n      { return static_cast<const __shared_ptr<_Tp, _Lp>*>(this)->get(); }\n    };\n\n\n  template<typename _Tp, _Lock_policy _Lp>\n    class __shared_ptr_access<'
[#] parse_declaration, is_constructor=False, meet line: 'element_type*\n      operator->() const noexcept\n      {\n auto __ptr = static_cast<const __shared_ptr<_Tp, _Lp>*>(this)->get();\n ;\n return __ptr;\n      }\n    };\n\n\n  template<typename _Tp, _Lock_policy '
[#] parse_declaration, is_constructor=False, meet line: 'element_type&\n      operator*() const noexcept\n      {\n ;\n return *_M_get();\n      }\n\n      [[__deprecated__("shared_ptr<T[]>::operator-> is absent from C++17")]]\n      element_type*\n      operator->('
[#] parse_declaration, is_constructor=False, meet line: 'element_type*\n      operator->() const noexcept\n      {\n ;\n return _M_get();\n      }\n\n\n      element_type&\n      operator[](ptrdiff_t __i) const\n      {\n ;\n ;\n return _M_get()[__i];\n      }\n\n    priva'
[#] parse_declaration, is_constructor=False, meet line: 'element_type&\n      operator[](ptrdiff_t __i) const\n      {\n ;\n ;\n return _M_get()[__i];\n      }\n\n    private:\n      element_type*\n      _M_get() const noexcept\n      { return static_cast<const __shar'
[#] parse_declaration, is_constructor=False, meet line: 'element_type*\n      _M_get() const noexcept\n      { return static_cast<const __shared_ptr<_Tp, _Lp>*>(this)->get(); }\n    };\n\n  template<typename _Tp, _Lock_policy _Lp>\n    class __shared_ptr\n    : pu'
[#] parse_declaration, is_constructor=True, meet line: '__shared_ptr() noexcept\n      : _M_ptr(0), _M_refcount()\n      { }\n\n      template<typename _Yp, typename = _SafeConv<_Yp>>\n explicit\n __shared_ptr(_Yp* __p)\n : _M_ptr(__p), _M_refcount(__p, typename '
[#] parse_declaration, is_constructor=True, meet line: '__shared_ptr(_Yp* __p)\n : _M_ptr(__p), _M_refcount(__p, typename is_array<_Tp>::type())\n {\n   static_assert( !is_void<_Yp>::value, "incomplete type" );\n   static_assert( sizeof(_Yp) > 0, "incomplete t'
[#] parse_declaration, is_constructor=True, meet line: '__shared_ptr(_Yp* __p, _Deleter __d)\n : _M_ptr(__p), _M_refcount(__p, std::move(__d))\n {\n   static_assert(__is_invocable<_Deleter&, _Yp*&>::value,\n       "deleter expression d(p) is well-formed");\n   '
[#] parse_declaration, is_constructor=True, meet line: '__shared_ptr(_Yp* __p, _Deleter __d, _Alloc __a)\n : _M_ptr(__p), _M_refcount(__p, std::move(__d), std::move(__a))\n {\n   static_assert(__is_invocable<_Deleter&, _Yp*&>::value,\n       "deleter expressio'
[#] parse_declaration, is_constructor=True, meet line: '__shared_ptr(nullptr_t __p, _Deleter __d)\n : _M_ptr(0), _M_refcount(__p, std::move(__d))\n { }\n\n      template<typename _Deleter, typename _Alloc>\n        __shared_ptr(nullptr_t __p, _Deleter __d, _All'
[#] parse_declaration, is_constructor=True, meet line: '__shared_ptr(nullptr_t __p, _Deleter __d, _Alloc __a)\n : _M_ptr(0), _M_refcount(__p, std::move(__d), std::move(__a))\n { }\n\n      template<typename _Yp>\n __shared_ptr(const __shared_ptr<_Yp, _Lp>& __r,'
[#] parse_declaration, is_constructor=True, meet line: '__shared_ptr(const __shared_ptr<_Yp, _Lp>& __r,\n       element_type* __p) noexcept\n : _M_ptr(__p), _M_refcount(__r._M_refcount)\n { }\n\n      __shared_ptr(const __shared_ptr&) noexcept = default;\n      '
[#] parse_declaration, is_constructor=True, meet line: '__shared_ptr(const __shared_ptr&) noexcept = default;\n      __shared_ptr& operator=(const __shared_ptr&) noexcept = default;\n      ~__shared_ptr() = default;\n\n      template<typename _Yp, typename = _'
[#] parse_declaration, is_constructor=True, meet line: '__shared_ptr& operator=(const __shared_ptr&) noexcept = default;\n      ~__shared_ptr() = default;\n\n      template<typename _Yp, typename = _Compatible<_Yp>>\n __shared_ptr(const __shared_ptr<_Yp, _Lp>&'
[#] parse_declaration, is_constructor=True, meet line: '__shared_ptr() = default;\n\n      template<typename _Yp, typename = _Compatible<_Yp>>\n __shared_ptr(const __shared_ptr<_Yp, _Lp>& __r) noexcept\n : _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount)\n { }\n'
[#] parse_declaration, is_constructor=True, meet line: '__shared_ptr(const __shared_ptr<_Yp, _Lp>& __r) noexcept\n : _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount)\n { }\n\n      __shared_ptr(__shared_ptr&& __r) noexcept\n      : _M_ptr(__r._M_ptr), _M_refcou'
[#] parse_declaration, is_constructor=True, meet line: '__shared_ptr(__shared_ptr&& __r) noexcept\n      : _M_ptr(__r._M_ptr), _M_refcount()\n      {\n _M_refcount._M_swap(__r._M_refcount);\n __r._M_ptr = 0;\n      }\n\n      template<typename _Yp, typename = _Co'
[#] parse_declaration, is_constructor=True, meet line: '__shared_ptr(__shared_ptr<_Yp, _Lp>&& __r) noexcept\n : _M_ptr(__r._M_ptr), _M_refcount()\n {\n   _M_refcount._M_swap(__r._M_refcount);\n   __r._M_ptr = 0;\n }\n\n      template<typename _Yp, typename = _Com'
[#] parse_declaration, is_constructor=True, meet line: '__shared_ptr(const __weak_ptr<_Yp, _Lp>& __r)\n : _M_refcount(__r._M_refcount)\n {\n\n\n   _M_ptr = __r._M_ptr;\n }\n\n\n      template<typename _Yp, typename _Del,\n        typename = _UniqCompatible<_Yp, _Del'
[#] parse_declaration, is_constructor=True, meet line: '__shared_ptr(unique_ptr<_Yp, _Del>&& __r)\n : _M_ptr(__r.get()), _M_refcount()\n {\n   auto __raw = _S_raw_ptr(__r.get());\n   _M_refcount = __shared_count<_Lp>(std::move(__r));\n   _M_enable_shared_from_t'
[#] parse_declaration, is_constructor=True, meet line: '__shared_ptr(unique_ptr<_Tp1, _Del>&& __r, __sp_array_delete)\n : _M_ptr(__r.get()), _M_refcount()\n {\n   auto __raw = _S_raw_ptr(__r.get());\n   _M_refcount = __shared_count<_Lp>(std::move(__r));\n   _M_'
[#] parse_declaration, is_constructor=True, meet line: '__shared_ptr(auto_ptr<_Yp>&& __r);\n\n\n      constexpr __shared_ptr(nullptr_t) noexcept : __shared_ptr() { }\n\n      template<typename _Yp>\n _Assignable<_Yp>\n operator=(const __shared_ptr<_Yp, _Lp>& __r)'
[#] parse_declaration, is_constructor=True, meet line: '__shared_ptr(nullptr_t) noexcept : __shared_ptr() { }\n\n      template<typename _Yp>\n _Assignable<_Yp>\n operator=(const __shared_ptr<_Yp, _Lp>& __r) noexcept\n {\n   _M_ptr = __r._M_ptr;\n   _M_refcount ='
[#] parse_declaration, is_constructor=False, meet line: '_Assignable<_Yp>\n operator=(const __shared_ptr<_Yp, _Lp>& __r) noexcept\n {\n   _M_ptr = __r._M_ptr;\n   _M_refcount = __r._M_refcount;\n   return *this;\n }\n\n\n      template<typename _Yp>\n _Assignable<_Yp'
[#] parse_declaration, is_constructor=False, meet line: '_Assignable<_Yp>\n operator=(auto_ptr<_Yp>&& __r)\n {\n   __shared_ptr(std::move(__r)).swap(*this);\n   return *this;\n }\n\n\n      __shared_ptr&\n      operator=(__shared_ptr&& __r) noexcept\n      {\n __share'
[#] parse_declaration, is_constructor=True, meet line: '__shared_ptr&\n      operator=(__shared_ptr&& __r) noexcept\n      {\n __shared_ptr(std::move(__r)).swap(*this);\n return *this;\n      }\n\n      template<class _Yp>\n _Assignable<_Yp>\n operator=(__shared_pt'
[#] parse_declaration, is_constructor=False, meet line: '_Assignable<_Yp>\n operator=(__shared_ptr<_Yp, _Lp>&& __r) noexcept\n {\n   __shared_ptr(std::move(__r)).swap(*this);\n   return *this;\n }\n\n      template<typename _Yp, typename _Del>\n _UniqAssignable<_Yp'
[#] parse_declaration, is_constructor=False, meet line: '_UniqAssignable<_Yp, _Del>\n operator=(unique_ptr<_Yp, _Del>&& __r)\n {\n   __shared_ptr(std::move(__r)).swap(*this);\n   return *this;\n }\n\n      void\n      reset() noexcept\n      { __shared_ptr().swap(*t'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      reset() noexcept\n      { __shared_ptr().swap(*this); }\n\n      template<typename _Yp>\n _SafeConv<_Yp>\n reset(_Yp* __p)\n {\n\n   ;\n   __shared_ptr(__p).swap(*this);\n }\n\n      template<typename '
[#] parse_declaration, is_constructor=False, meet line: '_SafeConv<_Yp>\n reset(_Yp* __p)\n {\n\n   ;\n   __shared_ptr(__p).swap(*this);\n }\n\n      template<typename _Yp, typename _Deleter>\n _SafeConv<_Yp>\n reset(_Yp* __p, _Deleter __d)\n { __shared_ptr(__p, std::'
[#] parse_declaration, is_constructor=False, meet line: '_SafeConv<_Yp>\n reset(_Yp* __p, _Deleter __d)\n { __shared_ptr(__p, std::move(__d)).swap(*this); }\n\n      template<typename _Yp, typename _Deleter, typename _Alloc>\n _SafeConv<_Yp>\n reset(_Yp* __p, _De'
[#] parse_declaration, is_constructor=False, meet line: '_SafeConv<_Yp>\n reset(_Yp* __p, _Deleter __d, _Alloc __a)\n        { __shared_ptr(__p, std::move(__d), std::move(__a)).swap(*this); }\n\n      element_type*\n      get() const noexcept\n      { return _M_p'
[#] parse_declaration, is_constructor=False, meet line: 'element_type*\n      get() const noexcept\n      { return _M_ptr; }\n\n      explicit operator bool() const\n      { return _M_ptr == 0 ? false : true; }\n\n      bool\n      unique() const noexcept\n      { r'
[#] parse_declaration, is_constructor=False, meet line: 'operator bool() const\n      { return _M_ptr == 0 ? false : true; }\n\n      bool\n      unique() const noexcept\n      { return _M_refcount._M_unique(); }\n\n      long\n      use_count() const noexcept\n    '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      unique() const noexcept\n      { return _M_refcount._M_unique(); }\n\n      long\n      use_count() const noexcept\n      { return _M_refcount._M_get_use_count(); }\n\n      void\n      swap(__shar'
[#] parse_declaration, is_constructor=False, meet line: 'long\n      use_count() const noexcept\n      { return _M_refcount._M_get_use_count(); }\n\n      void\n      swap(__shared_ptr<_Tp, _Lp>& __other) noexcept\n      {\n std::swap(_M_ptr, __other._M_ptr);\n _M_'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      swap(__shared_ptr<_Tp, _Lp>& __other) noexcept\n      {\n std::swap(_M_ptr, __other._M_ptr);\n _M_refcount._M_swap(__other._M_refcount);\n      }\n\n      template<typename _Tp1>\n bool\n owner_bef'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n owner_before(__shared_ptr<_Tp1, _Lp> const& __rhs) const noexcept\n { return _M_refcount._M_less(__rhs._M_refcount); }\n\n      template<typename _Tp1>\n bool\n owner_before(__weak_ptr<_Tp1, _Lp> con'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n owner_before(__weak_ptr<_Tp1, _Lp> const& __rhs) const noexcept\n { return _M_refcount._M_less(__rhs._M_refcount); }\n\n\n    protected:\n\n      template<typename _Alloc, typename... _Args>\n __shared'
[#] parse_declaration, is_constructor=True, meet line: '__shared_ptr(_Sp_make_shared_tag __tag, const _Alloc& __a,\n       _Args&&... __args)\n : _M_ptr(), _M_refcount(__tag, (_Tp*)0, __a,\n    std::forward<_Args>(__args)...)\n {\n\n\n   void* __p = _M_refcount._'
[#] parse_declaration, is_constructor=True, meet line: '__shared_ptr<_Tp1, _Lp1>\n __allocate_shared(const _Alloc& __a, _Args&&... __args);\n\n\n\n      __shared_ptr(const __weak_ptr<_Tp, _Lp>& __r, std::nothrow_t)\n      : _M_refcount(__r._M_refcount, std::noth'
[#] parse_declaration, is_constructor=True, meet line: '__shared_ptr(const __weak_ptr<_Tp, _Lp>& __r, std::nothrow_t)\n      : _M_refcount(__r._M_refcount, std::nothrow)\n      {\n _M_ptr = _M_refcount._M_get_use_count() ? __r._M_ptr : nullptr;\n      }\n\n     '
[#] parse_declaration, is_constructor=False, meet line: 'enable_if<__has_esft_base<_Yp2>::value>::type\n _M_enable_shared_from_this_with(_Yp* __p) noexcept\n {\n   if (auto __base = __enable_shared_from_this_base(_M_refcount, __p))\n     __base->_M_weak_assign('
[#] parse_declaration, is_constructor=False, meet line: 'enable_if<!__has_esft_base<_Yp2>::value>::type\n _M_enable_shared_from_this_with(_Yp*) noexcept\n { }\n\n      void*\n      _M_get_deleter(const std::type_info& __ti) const noexcept\n      { return _M_refco'
[#] parse_declaration, is_constructor=False, meet line: 'void*\n      _M_get_deleter(const std::type_info& __ti) const noexcept\n      { return _M_refcount._M_get_deleter(__ti); }\n\n      template<typename _Tp1>\n static _Tp1*\n _S_raw_ptr(_Tp1* __ptr)\n { return'
[#] parse_declaration, is_constructor=False, meet line: '_Tp1*\n _S_raw_ptr(_Tp1* __ptr)\n { return __ptr; }\n\n      template<typename _Tp1>\n static auto\n _S_raw_ptr(_Tp1 __ptr) -> decltype(std::__addressof(*__ptr))\n { return std::__addressof(*__ptr); }\n\n     '
[#] parse_declaration, is_constructor=False, meet line: 'auto\n _S_raw_ptr(_Tp1 __ptr) -> decltype(std::__addressof(*__ptr))\n { return std::__addressof(*__ptr); }\n\n      template<typename _Tp1, _Lock_policy _Lp1> friend class __shared_ptr;\n      template<typ'
[#] parse_declaration, is_constructor=False, meet line: '_Del* get_deleter(const __shared_ptr<_Tp1, _Lp1>&) noexcept;\n\n      element_type* _M_ptr;\n      __shared_count<_Lp> _M_refcount;\n    };\n\n\n\n  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>\n  '
[#] parse_declaration, is_constructor=False, meet line: 'element_type* _M_ptr;\n      __shared_count<_Lp> _M_refcount;\n    };\n\n\n\n  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>\n    inline bool\n    operator==(const __shared_ptr<_Tp1, _Lp>& __a,\n   '
[#] parse_declaration, is_constructor=False, meet line: '__shared_count<_Lp> _M_refcount;\n    };\n\n\n\n  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>\n    inline bool\n    operator==(const __shared_ptr<_Tp1, _Lp>& __a,\n        const __shared_ptr<_Tp2'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator==(const __shared_ptr<_Tp1, _Lp>& __a,\n        const __shared_ptr<_Tp2, _Lp>& __b) noexcept\n    { return __a.get() == __b.get(); }\n\n  template<typename _Tp, _Lock_policy _Lp>\n    inli'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator==(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept\n    { return !__a; }\n\n  template<typename _Tp, _Lock_policy _Lp>\n    inline bool\n    operator==(nullptr_t, const __shared_ptr'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator==(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept\n    { return !__a; }\n\n  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>\n    inline bool\n    operator!=(const __share'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator!=(const __shared_ptr<_Tp1, _Lp>& __a,\n        const __shared_ptr<_Tp2, _Lp>& __b) noexcept\n    { return __a.get() != __b.get(); }\n\n  template<typename _Tp, _Lock_policy _Lp>\n    inli'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator!=(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept\n    { return (bool)__a; }\n\n  template<typename _Tp, _Lock_policy _Lp>\n    inline bool\n    operator!=(nullptr_t, const __share'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator!=(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept\n    { return (bool)__a; }\n\n  template<typename _Tp, typename _Up, _Lock_policy _Lp>\n    inline bool\n    operator<(const __sha'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<(const __shared_ptr<_Tp, _Lp>& __a,\n       const __shared_ptr<_Up, _Lp>& __b) noexcept\n    {\n      using _Tp_elt = typename __shared_ptr<_Tp, _Lp>::element_type;\n      using _Up_elt '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept\n    {\n      using _Tp_elt = typename __shared_ptr<_Tp, _Lp>::element_type;\n      return less<_Tp_elt*>()(__a.get(), nullptr);\n'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept\n    {\n      using _Tp_elt = typename __shared_ptr<_Tp, _Lp>::element_type;\n      return less<_Tp_elt*>()(nullptr, __a.get());\n'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<=(const __shared_ptr<_Tp1, _Lp>& __a,\n        const __shared_ptr<_Tp2, _Lp>& __b) noexcept\n    { return !(__b < __a); }\n\n  template<typename _Tp, _Lock_policy _Lp>\n    inline bool\n  '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<=(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept\n    { return !(nullptr < __a); }\n\n  template<typename _Tp, _Lock_policy _Lp>\n    inline bool\n    operator<=(nullptr_t, const '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<=(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept\n    { return !(__a < nullptr); }\n\n  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>\n    inline bool\n    operator>(co'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>(const __shared_ptr<_Tp1, _Lp>& __a,\n       const __shared_ptr<_Tp2, _Lp>& __b) noexcept\n    { return (__b < __a); }\n\n  template<typename _Tp, _Lock_policy _Lp>\n    inline bool\n    o'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept\n    { return nullptr < __a; }\n\n  template<typename _Tp, _Lock_policy _Lp>\n    inline bool\n    operator>(nullptr_t, const __sha'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept\n    { return __a < nullptr; }\n\n  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>\n    inline bool\n    operator>=(const'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>=(const __shared_ptr<_Tp1, _Lp>& __a,\n        const __shared_ptr<_Tp2, _Lp>& __b) noexcept\n    { return !(__a < __b); }\n\n  template<typename _Tp, _Lock_policy _Lp>\n    inline bool\n  '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>=(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept\n    { return !(__a < nullptr); }\n\n  template<typename _Tp, _Lock_policy _Lp>\n    inline bool\n    operator>=(nullptr_t, const '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>=(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept\n    { return !(nullptr < __a); }\n\n  template<typename _Sp>\n    struct _Sp_less : public binary_function<_Sp, _Sp, bool>\n    {'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      operator()(const _Sp& __lhs, const _Sp& __rhs) const noexcept\n      {\n typedef typename _Sp::element_type element_type;\n return std::less<element_type*>()(__lhs.get(), __rhs.get());\n      }'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    swap(__shared_ptr<_Tp, _Lp>& __a, __shared_ptr<_Tp, _Lp>& __b) noexcept\n    { __a.swap(__b); }\n# 1543 "/usr/include/c++/7/bits/shared_ptr_base.h" 3\n  template<typename _Tp, typename _Tp1, _Lo'
[#] parse_declaration, is_constructor=False, meet line: '__shared_ptr<_Tp, _Lp>\n    static_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r) noexcept\n    {\n      using _Sp = __shared_ptr<_Tp, _Lp>;\n      return _Sp(__r, static_cast<typename _Sp::element_type'
[#] parse_declaration, is_constructor=False, meet line: '__shared_ptr<_Tp, _Lp>\n    const_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r) noexcept\n    {\n      using _Sp = __shared_ptr<_Tp, _Lp>;\n      return _Sp(__r, const_cast<typename _Sp::element_type*>'
[#] parse_declaration, is_constructor=False, meet line: '__shared_ptr<_Tp, _Lp>\n    dynamic_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r) noexcept\n    {\n      using _Sp = __shared_ptr<_Tp, _Lp>;\n      if (auto* __p = dynamic_cast<typename _Sp::element_ty'
[#] parse_declaration, is_constructor=True, meet line: '__weak_ptr() noexcept\n      : _M_ptr(nullptr), _M_refcount()\n      { }\n\n      __weak_ptr(const __weak_ptr&) noexcept = default;\n\n      ~__weak_ptr() = default;\n# 1625 "/usr/include/c++/7/bits/shared_p'
[#] parse_declaration, is_constructor=True, meet line: '__weak_ptr(const __weak_ptr&) noexcept = default;\n\n      ~__weak_ptr() = default;\n# 1625 "/usr/include/c++/7/bits/shared_ptr_base.h" 3\n      template<typename _Yp, typename = _Compatible<_Yp>>\n __weak'
[#] parse_declaration, is_constructor=True, meet line: '__weak_ptr() = default;\n# 1625 "/usr/include/c++/7/bits/shared_ptr_base.h" 3\n      template<typename _Yp, typename = _Compatible<_Yp>>\n __weak_ptr(const __weak_ptr<_Yp, _Lp>& __r) noexcept\n : _M_refco'
[#] parse_declaration, is_constructor=True, meet line: '__weak_ptr(const __weak_ptr<_Yp, _Lp>& __r) noexcept\n : _M_refcount(__r._M_refcount)\n        { _M_ptr = __r.lock().get(); }\n\n      template<typename _Yp, typename = _Compatible<_Yp>>\n __weak_ptr(const'
[#] parse_declaration, is_constructor=True, meet line: '__weak_ptr(const __shared_ptr<_Yp, _Lp>& __r) noexcept\n : _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount)\n { }\n\n      __weak_ptr(__weak_ptr&& __r) noexcept\n      : _M_ptr(__r._M_ptr), _M_refcount(std'
[#] parse_declaration, is_constructor=True, meet line: '__weak_ptr(__weak_ptr&& __r) noexcept\n      : _M_ptr(__r._M_ptr), _M_refcount(std::move(__r._M_refcount))\n      { __r._M_ptr = nullptr; }\n\n      template<typename _Yp, typename = _Compatible<_Yp>>\n __'
[#] parse_declaration, is_constructor=True, meet line: '__weak_ptr(__weak_ptr<_Yp, _Lp>&& __r) noexcept\n : _M_ptr(__r.lock().get()), _M_refcount(std::move(__r._M_refcount))\n        { __r._M_ptr = nullptr; }\n\n      __weak_ptr&\n      operator=(const __weak_p'
[#] parse_declaration, is_constructor=True, meet line: '__weak_ptr&\n      operator=(const __weak_ptr& __r) noexcept = default;\n\n      template<typename _Yp>\n _Assignable<_Yp>\n operator=(const __weak_ptr<_Yp, _Lp>& __r) noexcept\n {\n   _M_ptr = __r.lock().ge'
[#] parse_declaration, is_constructor=False, meet line: '_Assignable<_Yp>\n operator=(const __weak_ptr<_Yp, _Lp>& __r) noexcept\n {\n   _M_ptr = __r.lock().get();\n   _M_refcount = __r._M_refcount;\n   return *this;\n }\n\n      template<typename _Yp>\n _Assignable<'
[#] parse_declaration, is_constructor=False, meet line: '_Assignable<_Yp>\n operator=(const __shared_ptr<_Yp, _Lp>& __r) noexcept\n {\n   _M_ptr = __r._M_ptr;\n   _M_refcount = __r._M_refcount;\n   return *this;\n }\n\n      __weak_ptr&\n      operator=(__weak_ptr&&'
[#] parse_declaration, is_constructor=True, meet line: '__weak_ptr&\n      operator=(__weak_ptr&& __r) noexcept\n      {\n _M_ptr = __r._M_ptr;\n _M_refcount = std::move(__r._M_refcount);\n __r._M_ptr = nullptr;\n return *this;\n      }\n\n      template<typename _'
[#] parse_declaration, is_constructor=False, meet line: '_Assignable<_Yp>\n operator=(__weak_ptr<_Yp, _Lp>&& __r) noexcept\n {\n   _M_ptr = __r.lock().get();\n   _M_refcount = std::move(__r._M_refcount);\n   __r._M_ptr = nullptr;\n   return *this;\n }\n\n      __sha'
[#] parse_declaration, is_constructor=False, meet line: '__shared_ptr<_Tp, _Lp>\n      lock() const noexcept\n      { return __shared_ptr<element_type, _Lp>(*this, std::nothrow); }\n\n      long\n      use_count() const noexcept\n      { return _M_refcount._M_get'
[#] parse_declaration, is_constructor=False, meet line: 'long\n      use_count() const noexcept\n      { return _M_refcount._M_get_use_count(); }\n\n      bool\n      expired() const noexcept\n      { return _M_refcount._M_get_use_count() == 0; }\n\n      template<'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      expired() const noexcept\n      { return _M_refcount._M_get_use_count() == 0; }\n\n      template<typename _Tp1>\n bool\n owner_before(const __shared_ptr<_Tp1, _Lp>& __rhs) const noexcept\n { ret'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n owner_before(const __shared_ptr<_Tp1, _Lp>& __rhs) const noexcept\n { return _M_refcount._M_less(__rhs._M_refcount); }\n\n      template<typename _Tp1>\n bool\n owner_before(const __weak_ptr<_Tp1, _L'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n owner_before(const __weak_ptr<_Tp1, _Lp>& __rhs) const noexcept\n { return _M_refcount._M_less(__rhs._M_refcount); }\n\n      void\n      reset() noexcept\n      { __weak_ptr().swap(*this); }\n\n      '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      reset() noexcept\n      { __weak_ptr().swap(*this); }\n\n      void\n      swap(__weak_ptr& __s) noexcept\n      {\n std::swap(_M_ptr, __s._M_ptr);\n _M_refcount._M_swap(__s._M_refcount);\n      }\n'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      swap(__weak_ptr& __s) noexcept\n      {\n std::swap(_M_ptr, __s._M_ptr);\n _M_refcount._M_swap(__s._M_refcount);\n      }\n\n    private:\n\n      void\n      _M_assign(_Tp* __ptr, const __shared_co'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_assign(_Tp* __ptr, const __shared_count<_Lp>& __refcount) noexcept\n      {\n if (use_count() == 0)\n   {\n     _M_ptr = __ptr;\n     _M_refcount = __refcount;\n   }\n      }\n\n      template<ty'
[#] parse_declaration, is_constructor=False, meet line: 'element_type* _M_ptr;\n      __weak_count<_Lp> _M_refcount;\n    };\n\n\n  template<typename _Tp, _Lock_policy _Lp>\n    inline void\n    swap(__weak_ptr<_Tp, _Lp>& __a, __weak_ptr<_Tp, _Lp>& __b) noexcept\n '
[#] parse_declaration, is_constructor=False, meet line: '__weak_count<_Lp> _M_refcount;\n    };\n\n\n  template<typename _Tp, _Lock_policy _Lp>\n    inline void\n    swap(__weak_ptr<_Tp, _Lp>& __a, __weak_ptr<_Tp, _Lp>& __b) noexcept\n    { __a.swap(__b); }\n\n  tem'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    swap(__weak_ptr<_Tp, _Lp>& __a, __weak_ptr<_Tp, _Lp>& __b) noexcept\n    { __a.swap(__b); }\n\n  template<typename _Tp, typename _Tp1>\n    struct _Sp_owner_less : public binary_function<_Tp, _Tp'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      operator()(const _Tp& __lhs, const _Tp& __rhs) const noexcept\n      { return __lhs.owner_before(__rhs); }\n\n      bool\n      operator()(const _Tp& __lhs, const _Tp1& __rhs) const noexcept\n  '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      operator()(const _Tp& __lhs, const _Tp1& __rhs) const noexcept\n      { return __lhs.owner_before(__rhs); }\n\n      bool\n      operator()(const _Tp1& __lhs, const _Tp& __rhs) const noexcept\n '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      operator()(const _Tp1& __lhs, const _Tp& __rhs) const noexcept\n      { return __lhs.owner_before(__rhs); }\n    };\n\n  template<>\n    struct _Sp_owner_less<void, void>\n    {\n      template<ty'
[#] parse_declaration, is_constructor=False, meet line: 'auto\n operator()(const _Tp& __lhs, const _Up& __rhs) const noexcept\n -> decltype(__lhs.owner_before(__rhs))\n { return __lhs.owner_before(__rhs); }\n\n      using is_transparent = void;\n    };\n\n  templat'
[#] parse_declaration, is_constructor=True, meet line: '__enable_shared_from_this() noexcept { }\n\n      __enable_shared_from_this(const __enable_shared_from_this&) noexcept { }\n\n      __enable_shared_from_this&\n      operator=(const __enable_shared_from_th'
[#] parse_declaration, is_constructor=True, meet line: '__enable_shared_from_this(const __enable_shared_from_this&) noexcept { }\n\n      __enable_shared_from_this&\n      operator=(const __enable_shared_from_this&) noexcept\n      { return *this; }\n\n      ~__'
[#] parse_declaration, is_constructor=True, meet line: '__enable_shared_from_this&\n      operator=(const __enable_shared_from_this&) noexcept\n      { return *this; }\n\n      ~__enable_shared_from_this() { }\n\n    public:\n      __shared_ptr<_Tp, _Lp>\n      sh'
[#] parse_declaration, is_constructor=True, meet line: '__enable_shared_from_this() { }\n\n    public:\n      __shared_ptr<_Tp, _Lp>\n      shared_from_this()\n      { return __shared_ptr<_Tp, _Lp>(this->_M_weak_this); }\n\n      __shared_ptr<const _Tp, _Lp>\n    '
[#] parse_declaration, is_constructor=False, meet line: '__shared_ptr<_Tp, _Lp>\n      shared_from_this()\n      { return __shared_ptr<_Tp, _Lp>(this->_M_weak_this); }\n\n      __shared_ptr<const _Tp, _Lp>\n      shared_from_this() const\n      { return __shared_'
[#] parse_declaration, is_constructor=False, meet line: '__shared_ptr<const _Tp, _Lp>\n      shared_from_this() const\n      { return __shared_ptr<const _Tp, _Lp>(this->_M_weak_this); }\n\n\n      __weak_ptr<_Tp, _Lp>\n      weak_from_this() noexcept\n      { retu'
[#] parse_declaration, is_constructor=False, meet line: '__weak_ptr<_Tp, _Lp>\n      weak_from_this() noexcept\n      { return this->_M_weak_this; }\n\n      __weak_ptr<const _Tp, _Lp>\n      weak_from_this() const noexcept\n      { return this->_M_weak_this; }\n\n'
[#] parse_declaration, is_constructor=False, meet line: '__weak_ptr<const _Tp, _Lp>\n      weak_from_this() const noexcept\n      { return this->_M_weak_this; }\n\n\n    private:\n      template<typename _Tp1>\n void\n _M_weak_assign(_Tp1* __p, const __shared_count'
[#] parse_declaration, is_constructor=False, meet line: 'void\n _M_weak_assign(_Tp1* __p, const __shared_count<_Lp>& __n) const noexcept\n { _M_weak_this._M_assign(__p, __n); }\n\n      friend const __enable_shared_from_this*\n      __enable_shared_from_this_bas'
[#] parse_declaration, is_constructor=True, meet line: '__enable_shared_from_this*\n      __enable_shared_from_this_base(const __shared_count<_Lp>&,\n         const __enable_shared_from_this* __p)\n      { return __p; }\n\n      template<typename, _Lock_policy>'
[#] parse_declaration, is_constructor=False, meet line: '__weak_ptr<_Tp, _Lp> _M_weak_this;\n    };\n\n  template<typename _Tp, _Lock_policy _Lp, typename _Alloc, typename... _Args>\n    inline __shared_ptr<_Tp, _Lp>\n    __allocate_shared(const _Alloc& __a, _Ar'
[#] parse_declaration, is_constructor=False, meet line: '__shared_ptr<_Tp, _Lp>\n    __allocate_shared(const _Alloc& __a, _Args&&... __args)\n    {\n      return __shared_ptr<_Tp, _Lp>(_Sp_make_shared_tag(), __a,\n        std::forward<_Args>(__args)...);\n    }\n'
[#] parse_declaration, is_constructor=False, meet line: '__shared_ptr<_Tp, _Lp>\n    __make_shared(_Args&&... __args)\n    {\n      typedef typename std::remove_const<_Tp>::type _Tp_nc;\n      return std::__allocate_shared<_Tp, _Lp>(std::allocator<_Tp_nc>(),\n  '
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n      operator()(const __shared_ptr<_Tp, _Lp>& __s) const noexcept\n      {\n return hash<typename __shared_ptr<_Tp, _Lp>::element_type*>()(\n     __s.get());\n      }\n    };\n\n\n}\n# 53 "/usr/include'
[#] parse_declaration, is_constructor=False, meet line: 'std::basic_ostream<_Ch, _Tr>&\n    operator<<(std::basic_ostream<_Ch, _Tr>& __os,\n        const __shared_ptr<_Tp, _Lp>& __p)\n    {\n      __os << __p.get();\n      return __os;\n    }\n\n\n  template<typenam'
[#] parse_declaration, is_constructor=False, meet line: '_Del*\n    get_deleter(const __shared_ptr<_Tp, _Lp>& __p) noexcept\n    {\n\n      return static_cast<_Del*>(__p._M_get_deleter(typeid(_Del)));\n\n\n\n    }\n# 92 "/usr/include/c++/7/bits/shared_ptr.h" 3\n  tem'
[#] parse_declaration, is_constructor=True, meet line: 'shared_ptr() noexcept : __shared_ptr<_Tp>() { }\n\n      shared_ptr(const shared_ptr&) noexcept = default;\n\n\n\n\n\n\n\n      template<typename _Yp, typename = _Constructible<_Yp*>>\n explicit\n shared_ptr(_Yp*'
[#] parse_declaration, is_constructor=True, meet line: 'shared_ptr(const shared_ptr&) noexcept = default;\n\n\n\n\n\n\n\n      template<typename _Yp, typename = _Constructible<_Yp*>>\n explicit\n shared_ptr(_Yp* __p) : __shared_ptr<_Tp>(__p) { }\n# 144 "/usr/include/'
[#] parse_declaration, is_constructor=True, meet line: 'shared_ptr(_Yp* __p) : __shared_ptr<_Tp>(__p) { }\n# 144 "/usr/include/c++/7/bits/shared_ptr.h" 3\n      template<typename _Yp, typename _Deleter,\n        typename = _Constructible<_Yp*, _Deleter>>\n sha'
[#] parse_declaration, is_constructor=True, meet line: 'shared_ptr(_Yp* __p, _Deleter __d)\n        : __shared_ptr<_Tp>(__p, std::move(__d)) { }\n# 162 "/usr/include/c++/7/bits/shared_ptr.h" 3\n      template<typename _Deleter>\n shared_ptr(nullptr_t __p, _Del'
[#] parse_declaration, is_constructor=True, meet line: 'shared_ptr(nullptr_t __p, _Deleter __d)\n        : __shared_ptr<_Tp>(__p, std::move(__d)) { }\n# 181 "/usr/include/c++/7/bits/shared_ptr.h" 3\n      template<typename _Yp, typename _Deleter, typename _Al'
[#] parse_declaration, is_constructor=True, meet line: 'shared_ptr(_Yp* __p, _Deleter __d, _Alloc __a)\n : __shared_ptr<_Tp>(__p, std::move(__d), std::move(__a)) { }\n# 201 "/usr/include/c++/7/bits/shared_ptr.h" 3\n      template<typename _Deleter, typename _'
[#] parse_declaration, is_constructor=True, meet line: 'shared_ptr(nullptr_t __p, _Deleter __d, _Alloc __a)\n : __shared_ptr<_Tp>(__p, std::move(__d), std::move(__a)) { }\n# 223 "/usr/include/c++/7/bits/shared_ptr.h" 3\n      template<typename _Yp>\n shared_pt'
[#] parse_declaration, is_constructor=True, meet line: 'shared_ptr(const shared_ptr<_Yp>& __r, element_type* __p) noexcept\n : __shared_ptr<_Tp>(__r, __p) { }\n# 234 "/usr/include/c++/7/bits/shared_ptr.h" 3\n      template<typename _Yp,\n        typename = _Co'
[#] parse_declaration, is_constructor=True, meet line: 'shared_ptr(const shared_ptr<_Yp>& __r) noexcept\n        : __shared_ptr<_Tp>(__r) { }\n\n\n\n\n\n\n      shared_ptr(shared_ptr&& __r) noexcept\n      : __shared_ptr<_Tp>(std::move(__r)) { }\n\n\n\n\n\n\n      templat'
[#] parse_declaration, is_constructor=True, meet line: 'shared_ptr(shared_ptr&& __r) noexcept\n      : __shared_ptr<_Tp>(std::move(__r)) { }\n\n\n\n\n\n\n      template<typename _Yp, typename = _Constructible<shared_ptr<_Yp>>>\n shared_ptr(shared_ptr<_Yp>&& __r) no'
[#] parse_declaration, is_constructor=True, meet line: 'shared_ptr(shared_ptr<_Yp>&& __r) noexcept\n : __shared_ptr<_Tp>(std::move(__r)) { }\n# 264 "/usr/include/c++/7/bits/shared_ptr.h" 3\n      template<typename _Yp, typename = _Constructible<const weak_ptr'
[#] parse_declaration, is_constructor=True, meet line: 'shared_ptr(const weak_ptr<_Yp>& __r)\n : __shared_ptr<_Tp>(__r) { }\n\n\n      template<typename _Yp, typename = _Constructible<auto_ptr<_Yp>>>\n shared_ptr(auto_ptr<_Yp>&& __r);\n\n\n\n\n      template<typenam'
[#] parse_declaration, is_constructor=True, meet line: 'shared_ptr(auto_ptr<_Yp>&& __r);\n\n\n\n\n      template<typename _Yp, typename _Del,\n        typename = _Constructible<unique_ptr<_Yp, _Del>>>\n shared_ptr(unique_ptr<_Yp, _Del>&& __r)\n : __shared_ptr<_Tp>'
[#] parse_declaration, is_constructor=True, meet line: 'shared_ptr(unique_ptr<_Yp, _Del>&& __r)\n : __shared_ptr<_Tp>(std::move(__r)) { }\n\n\n\n\n\n      template<typename _Yp, typename _Del,\n  _Constructible<unique_ptr<_Yp, _Del>, __sp_array_delete>* = 0>\n shar'
[#] parse_declaration, is_constructor=True, meet line: 'shared_ptr(unique_ptr<_Yp, _Del>&& __r)\n : __shared_ptr<_Tp>(std::move(__r), __sp_array_delete()) { }\n\n\n\n\n\n\n      constexpr shared_ptr(nullptr_t) noexcept : shared_ptr() { }\n\n      shared_ptr& operato'
[#] parse_declaration, is_constructor=True, meet line: 'shared_ptr(nullptr_t) noexcept : shared_ptr() { }\n\n      shared_ptr& operator=(const shared_ptr&) noexcept = default;\n\n      template<typename _Yp>\n _Assignable<const shared_ptr<_Yp>&>\n operator=(cons'
[#] parse_declaration, is_constructor=True, meet line: 'shared_ptr& operator=(const shared_ptr&) noexcept = default;\n\n      template<typename _Yp>\n _Assignable<const shared_ptr<_Yp>&>\n operator=(const shared_ptr<_Yp>& __r) noexcept\n {\n   this->__shared_ptr'
[#] parse_declaration, is_constructor=False, meet line: '_Assignable<const shared_ptr<_Yp>&>\n operator=(const shared_ptr<_Yp>& __r) noexcept\n {\n   this->__shared_ptr<_Tp>::operator=(__r);\n   return *this;\n }\n\n\n      template<typename _Yp>\n _Assignable<auto_'
[#] parse_declaration, is_constructor=False, meet line: '_Assignable<auto_ptr<_Yp>>\n operator=(auto_ptr<_Yp>&& __r)\n {\n   this->__shared_ptr<_Tp>::operator=(std::move(__r));\n   return *this;\n }\n\n\n      shared_ptr&\n      operator=(shared_ptr&& __r) noexcept\n'
[#] parse_declaration, is_constructor=True, meet line: 'shared_ptr&\n      operator=(shared_ptr&& __r) noexcept\n      {\n this->__shared_ptr<_Tp>::operator=(std::move(__r));\n return *this;\n      }\n\n      template<class _Yp>\n _Assignable<shared_ptr<_Yp>>\n ope'
[#] parse_declaration, is_constructor=False, meet line: '_Assignable<shared_ptr<_Yp>>\n operator=(shared_ptr<_Yp>&& __r) noexcept\n {\n   this->__shared_ptr<_Tp>::operator=(std::move(__r));\n   return *this;\n }\n\n      template<typename _Yp, typename _Del>\n _Ass'
[#] parse_declaration, is_constructor=False, meet line: '_Assignable<unique_ptr<_Yp, _Del>>\n operator=(unique_ptr<_Yp, _Del>&& __r)\n {\n   this->__shared_ptr<_Tp>::operator=(std::move(__r));\n   return *this;\n }\n\n    private:\n\n      template<typename _Alloc, '
[#] parse_declaration, is_constructor=True, meet line: 'shared_ptr(_Sp_make_shared_tag __tag, const _Alloc& __a,\n     _Args&&... __args)\n : __shared_ptr<_Tp>(__tag, __a, std::forward<_Args>(__args)...)\n { }\n\n      template<typename _Yp, typename _Alloc, ty'
[#] parse_declaration, is_constructor=True, meet line: 'shared_ptr<_Yp>\n allocate_shared(const _Alloc& __a, _Args&&... __args);\n\n\n      shared_ptr(const weak_ptr<_Tp>& __r, std::nothrow_t)\n      : __shared_ptr<_Tp>(__r, std::nothrow) { }\n\n      friend clas'
[#] parse_declaration, is_constructor=True, meet line: 'shared_ptr(const weak_ptr<_Tp>& __r, std::nothrow_t)\n      : __shared_ptr<_Tp>(__r, std::nothrow) { }\n\n      friend class weak_ptr<_Tp>;\n    };\n# 366 "/usr/include/c++/7/bits/shared_ptr.h" 3\n  templat'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator==(const shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept\n    { return __a.get() == __b.get(); }\n\n  template<typename _Tp>\n    inline bool\n    operator==(const shared_ptr<_T'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator==(const shared_ptr<_Tp>& __a, nullptr_t) noexcept\n    { return !__a; }\n\n  template<typename _Tp>\n    inline bool\n    operator==(nullptr_t, const shared_ptr<_Tp>& __a) noexcept\n    { '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator==(nullptr_t, const shared_ptr<_Tp>& __a) noexcept\n    { return !__a; }\n\n  template<typename _Tp, typename _Up>\n    inline bool\n    operator!=(const shared_ptr<_Tp>& __a, const shared'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator!=(const shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept\n    { return __a.get() != __b.get(); }\n\n  template<typename _Tp>\n    inline bool\n    operator!=(const shared_ptr<_T'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator!=(const shared_ptr<_Tp>& __a, nullptr_t) noexcept\n    { return (bool)__a; }\n\n  template<typename _Tp>\n    inline bool\n    operator!=(nullptr_t, const shared_ptr<_Tp>& __a) noexcept\n '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator!=(nullptr_t, const shared_ptr<_Tp>& __a) noexcept\n    { return (bool)__a; }\n\n  template<typename _Tp, typename _Up>\n    inline bool\n    operator<(const shared_ptr<_Tp>& __a, const sh'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<(const shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept\n    {\n      using _Tp_elt = typename shared_ptr<_Tp>::element_type;\n      using _Up_elt = typename shared_ptr<_Up>::'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<(const shared_ptr<_Tp>& __a, nullptr_t) noexcept\n    {\n      using _Tp_elt = typename shared_ptr<_Tp>::element_type;\n      return less<_Tp_elt*>()(__a.get(), nullptr);\n    }\n\n  templ'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<(nullptr_t, const shared_ptr<_Tp>& __a) noexcept\n    {\n      using _Tp_elt = typename shared_ptr<_Tp>::element_type;\n      return less<_Tp_elt*>()(nullptr, __a.get());\n    }\n\n  templ'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<=(const shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept\n    { return !(__b < __a); }\n\n  template<typename _Tp>\n    inline bool\n    operator<=(const shared_ptr<_Tp>& __a, n'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<=(const shared_ptr<_Tp>& __a, nullptr_t) noexcept\n    { return !(nullptr < __a); }\n\n  template<typename _Tp>\n    inline bool\n    operator<=(nullptr_t, const shared_ptr<_Tp>& __a) noe'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<=(nullptr_t, const shared_ptr<_Tp>& __a) noexcept\n    { return !(__a < nullptr); }\n\n  template<typename _Tp, typename _Up>\n    inline bool\n    operator>(const shared_ptr<_Tp>& __a, c'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>(const shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept\n    { return (__b < __a); }\n\n  template<typename _Tp>\n    inline bool\n    operator>(const shared_ptr<_Tp>& __a, null'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>(const shared_ptr<_Tp>& __a, nullptr_t) noexcept\n    { return nullptr < __a; }\n\n  template<typename _Tp>\n    inline bool\n    operator>(nullptr_t, const shared_ptr<_Tp>& __a) noexcept'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>(nullptr_t, const shared_ptr<_Tp>& __a) noexcept\n    { return __a < nullptr; }\n\n  template<typename _Tp, typename _Up>\n    inline bool\n    operator>=(const shared_ptr<_Tp>& __a, cons'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>=(const shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept\n    { return !(__a < __b); }\n\n  template<typename _Tp>\n    inline bool\n    operator>=(const shared_ptr<_Tp>& __a, n'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>=(const shared_ptr<_Tp>& __a, nullptr_t) noexcept\n    { return !(__a < nullptr); }\n\n  template<typename _Tp>\n    inline bool\n    operator>=(nullptr_t, const shared_ptr<_Tp>& __a) noe'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>=(nullptr_t, const shared_ptr<_Tp>& __a) noexcept\n    { return !(nullptr < __a); }\n\n  template<typename _Tp>\n    struct less<shared_ptr<_Tp>> : public _Sp_less<shared_ptr<_Tp>>\n    {'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    swap(shared_ptr<_Tp>& __a, shared_ptr<_Tp>& __b) noexcept\n    { __a.swap(__b); }\n\n\n  template<typename _Tp, typename _Up>\n    inline shared_ptr<_Tp>\n    static_pointer_cast(const shared_ptr<_'
[#] parse_declaration, is_constructor=False, meet line: 'shared_ptr<_Tp>\n    static_pointer_cast(const shared_ptr<_Up>& __r) noexcept\n    {\n      using _Sp = shared_ptr<_Tp>;\n      return _Sp(__r, static_cast<typename _Sp::element_type*>(__r.get()));\n    }\n'
[#] parse_declaration, is_constructor=False, meet line: 'shared_ptr<_Tp>\n    const_pointer_cast(const shared_ptr<_Up>& __r) noexcept\n    {\n      using _Sp = shared_ptr<_Tp>;\n      return _Sp(__r, const_cast<typename _Sp::element_type*>(__r.get()));\n    }\n\n '
[#] parse_declaration, is_constructor=False, meet line: 'shared_ptr<_Tp>\n    dynamic_pointer_cast(const shared_ptr<_Up>& __r) noexcept\n    {\n      using _Sp = shared_ptr<_Tp>;\n      if (auto* __p = dynamic_cast<typename _Sp::element_type*>(__r.get()))\n retu'
[#] parse_declaration, is_constructor=True, meet line: 'weak_ptr() noexcept = default;\n\n      template<typename _Yp,\n        typename = _Constructible<const shared_ptr<_Yp>&>>\n weak_ptr(const shared_ptr<_Yp>& __r) noexcept\n : __weak_ptr<_Tp>(__r) { }\n\n    '
[#] parse_declaration, is_constructor=True, meet line: 'weak_ptr(const shared_ptr<_Yp>& __r) noexcept\n : __weak_ptr<_Tp>(__r) { }\n\n      weak_ptr(const weak_ptr&) noexcept = default;\n\n      template<typename _Yp, typename = _Constructible<const weak_ptr<_Y'
[#] parse_declaration, is_constructor=True, meet line: 'weak_ptr(const weak_ptr&) noexcept = default;\n\n      template<typename _Yp, typename = _Constructible<const weak_ptr<_Yp>&>>\n weak_ptr(const weak_ptr<_Yp>& __r) noexcept\n : __weak_ptr<_Tp>(__r) { }\n\n '
[#] parse_declaration, is_constructor=True, meet line: 'weak_ptr(const weak_ptr<_Yp>& __r) noexcept\n : __weak_ptr<_Tp>(__r) { }\n\n      weak_ptr(weak_ptr&&) noexcept = default;\n\n      template<typename _Yp, typename = _Constructible<weak_ptr<_Yp>>>\n weak_pt'
[#] parse_declaration, is_constructor=True, meet line: 'weak_ptr(weak_ptr&&) noexcept = default;\n\n      template<typename _Yp, typename = _Constructible<weak_ptr<_Yp>>>\n weak_ptr(weak_ptr<_Yp>&& __r) noexcept\n : __weak_ptr<_Tp>(std::move(__r)) { }\n\n      w'
[#] parse_declaration, is_constructor=True, meet line: 'weak_ptr(weak_ptr<_Yp>&& __r) noexcept\n : __weak_ptr<_Tp>(std::move(__r)) { }\n\n      weak_ptr&\n      operator=(const weak_ptr& __r) noexcept = default;\n\n      template<typename _Yp>\n _Assignable<const'
[#] parse_declaration, is_constructor=True, meet line: 'weak_ptr&\n      operator=(const weak_ptr& __r) noexcept = default;\n\n      template<typename _Yp>\n _Assignable<const weak_ptr<_Yp>&>\n operator=(const weak_ptr<_Yp>& __r) noexcept\n {\n   this->__weak_ptr'
[#] parse_declaration, is_constructor=False, meet line: '_Assignable<const weak_ptr<_Yp>&>\n operator=(const weak_ptr<_Yp>& __r) noexcept\n {\n   this->__weak_ptr<_Tp>::operator=(__r);\n   return *this;\n }\n\n      template<typename _Yp>\n _Assignable<const shared'
[#] parse_declaration, is_constructor=False, meet line: '_Assignable<const shared_ptr<_Yp>&>\n operator=(const shared_ptr<_Yp>& __r) noexcept\n {\n   this->__weak_ptr<_Tp>::operator=(__r);\n   return *this;\n }\n\n      weak_ptr&\n      operator=(weak_ptr&& __r) no'
[#] parse_declaration, is_constructor=True, meet line: 'weak_ptr&\n      operator=(weak_ptr&& __r) noexcept = default;\n\n      template<typename _Yp>\n _Assignable<weak_ptr<_Yp>>\n operator=(weak_ptr<_Yp>&& __r) noexcept\n {\n   this->__weak_ptr<_Tp>::operator=('
[#] parse_declaration, is_constructor=False, meet line: '_Assignable<weak_ptr<_Yp>>\n operator=(weak_ptr<_Yp>&& __r) noexcept\n {\n   this->__weak_ptr<_Tp>::operator=(std::move(__r));\n   return *this;\n }\n\n      shared_ptr<_Tp>\n      lock() const noexcept\n     '
[#] parse_declaration, is_constructor=False, meet line: 'shared_ptr<_Tp>\n      lock() const noexcept\n      { return shared_ptr<_Tp>(*this, std::nothrow); }\n    };\n\n\n\n\n\n\n\n  template<typename _Tp>\n    inline void\n    swap(weak_ptr<_Tp>& __a, weak_ptr<_Tp>& __'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    swap(weak_ptr<_Tp>& __a, weak_ptr<_Tp>& __b) noexcept\n    { __a.swap(__b); }\n\n\n\n  template<typename _Tp = void>\n    struct owner_less;\n\n\n  template<>\n    struct owner_less<void> : _Sp_owner_l'
[#] parse_declaration, is_constructor=True, meet line: 'enable_shared_from_this() noexcept { }\n\n      enable_shared_from_this(const enable_shared_from_this&) noexcept { }\n\n      enable_shared_from_this&\n      operator=(const enable_shared_from_this&) noexc'
[#] parse_declaration, is_constructor=True, meet line: 'enable_shared_from_this(const enable_shared_from_this&) noexcept { }\n\n      enable_shared_from_this&\n      operator=(const enable_shared_from_this&) noexcept\n      { return *this; }\n\n      ~enable_sha'
[#] parse_declaration, is_constructor=True, meet line: 'enable_shared_from_this&\n      operator=(const enable_shared_from_this&) noexcept\n      { return *this; }\n\n      ~enable_shared_from_this() { }\n\n    public:\n      shared_ptr<_Tp>\n      shared_from_thi'
[#] parse_declaration, is_constructor=True, meet line: 'enable_shared_from_this() { }\n\n    public:\n      shared_ptr<_Tp>\n      shared_from_this()\n      { return shared_ptr<_Tp>(this->_M_weak_this); }\n\n      shared_ptr<const _Tp>\n      shared_from_this() co'
[#] parse_declaration, is_constructor=False, meet line: 'shared_ptr<_Tp>\n      shared_from_this()\n      { return shared_ptr<_Tp>(this->_M_weak_this); }\n\n      shared_ptr<const _Tp>\n      shared_from_this() const\n      { return shared_ptr<const _Tp>(this->_M'
[#] parse_declaration, is_constructor=False, meet line: 'shared_ptr<const _Tp>\n      shared_from_this() const\n      { return shared_ptr<const _Tp>(this->_M_weak_this); }\n\n\n\n      weak_ptr<_Tp>\n      weak_from_this() noexcept\n      { return this->_M_weak_thi'
[#] parse_declaration, is_constructor=False, meet line: 'weak_ptr<_Tp>\n      weak_from_this() noexcept\n      { return this->_M_weak_this; }\n\n      weak_ptr<const _Tp>\n      weak_from_this() const noexcept\n      { return this->_M_weak_this; }\n\n\n    private:\n'
[#] parse_declaration, is_constructor=False, meet line: 'weak_ptr<const _Tp>\n      weak_from_this() const noexcept\n      { return this->_M_weak_this; }\n\n\n    private:\n      template<typename _Tp1>\n void\n _M_weak_assign(_Tp1* __p, const __shared_count<>& __n'
[#] parse_declaration, is_constructor=False, meet line: 'void\n _M_weak_assign(_Tp1* __p, const __shared_count<>& __n) const noexcept\n { _M_weak_this._M_assign(__p, __n); }\n\n\n      friend const enable_shared_from_this*\n      __enable_shared_from_this_base(co'
[#] parse_declaration, is_constructor=True, meet line: 'enable_shared_from_this*\n      __enable_shared_from_this_base(const __shared_count<>&,\n         const enable_shared_from_this* __p)\n      { return __p; }\n\n      template<typename, _Lock_policy>\n frien'
[#] parse_declaration, is_constructor=False, meet line: 'weak_ptr<_Tp> _M_weak_this;\n    };\n# 686 "/usr/include/c++/7/bits/shared_ptr.h" 3\n  template<typename _Tp, typename _Alloc, typename... _Args>\n    inline shared_ptr<_Tp>\n    allocate_shared(const _All'
[#] parse_declaration, is_constructor=False, meet line: 'shared_ptr<_Tp>\n    allocate_shared(const _Alloc& __a, _Args&&... __args)\n    {\n      return shared_ptr<_Tp>(_Sp_make_shared_tag(), __a,\n        std::forward<_Args>(__args)...);\n    }\n# 701 "/usr/incl'
[#] parse_declaration, is_constructor=False, meet line: 'shared_ptr<_Tp>\n    make_shared(_Args&&... __args)\n    {\n      typedef typename std::remove_const<_Tp>::type _Tp_nc;\n      return std::allocate_shared<_Tp>(std::allocator<_Tp_nc>(),\n           std::fo'
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n      operator()(const shared_ptr<_Tp>& __s) const noexcept\n      {\n return std::hash<typename shared_ptr<_Tp>::element_type*>()(__s.get());\n      }\n    };\n\n\n\n\n}\n# 82 "/usr/include/c++/7/memory'
[#] parse_declaration, is_constructor=False, meet line: 'memory_order\n  operator|(memory_order __m, __memory_order_modifier __mod)\n  {\n    return memory_order(__m | int(__mod));\n  }\n\n  constexpr memory_order\n  operator&(memory_order __m, __memory_order_modi'
[#] parse_declaration, is_constructor=False, meet line: 'memory_order\n  operator&(memory_order __m, __memory_order_modifier __mod)\n  {\n    return memory_order(__m & int(__mod));\n  }\n\n\n  constexpr memory_order\n  __cmpexch_failure_order2(memory_order __m) noe'
[#] parse_declaration, is_constructor=False, meet line: 'memory_order\n  __cmpexch_failure_order2(memory_order __m) noexcept\n  {\n    return __m == memory_order_acq_rel ? memory_order_acquire\n      : __m == memory_order_release ? memory_order_relaxed : __m;\n '
[#] parse_declaration, is_constructor=False, meet line: 'memory_order\n  __cmpexch_failure_order(memory_order __m) noexcept\n  {\n    return memory_order(__cmpexch_failure_order2(__m & __memory_order_mask)\n      | (__m & __memory_order_modifier_mask));\n  }\n\n  '
[#] parse_declaration, is_constructor=False, meet line: '__attribute__((__always_inline__)) void\n  atomic_thread_fence(memory_order __m) noexcept\n  { __atomic_thread_fence(__m); }\n\n  inline __attribute__((__always_inline__)) void\n  atomic_signal_fence(memor'
[#] parse_declaration, is_constructor=False, meet line: '__attribute__((__always_inline__)) void\n  atomic_signal_fence(memory_order __m) noexcept\n  { __atomic_signal_fence(__m); }\n\n\n  template<typename _Tp>\n    inline _Tp\n    kill_dependency(_Tp __y) noexce'
[#] parse_declaration, is_constructor=False, meet line: '_Tp\n    kill_dependency(_Tp __y) noexcept\n    {\n      _Tp __ret(__y);\n      return __ret;\n    }\n\n\n\n  template<typename _IntTp>\n    struct __atomic_base;\n\n\n\n\n  template<typename _Tp>\n    struct atomic;'
[#] parse_declaration, is_constructor=False, meet line: '__atomic_flag_data_type _M_i;\n  };\n\n  }\n\n\n\n\n  struct atomic_flag : public __atomic_flag_base\n  {\n    atomic_flag() noexcept = default;\n    ~atomic_flag() noexcept = default;\n    atomic_flag(const atom'
[#] parse_declaration, is_constructor=True, meet line: 'atomic_flag() noexcept = default;\n    ~atomic_flag() noexcept = default;\n    atomic_flag(const atomic_flag&) = delete;\n    atomic_flag& operator=(const atomic_flag&) = delete;\n    atomic_flag& operato'
[#] parse_declaration, is_constructor=True, meet line: 'atomic_flag() noexcept = default;\n    atomic_flag(const atomic_flag&) = delete;\n    atomic_flag& operator=(const atomic_flag&) = delete;\n    atomic_flag& operator=(const atomic_flag&) volatile = delet'
[#] parse_declaration, is_constructor=True, meet line: 'atomic_flag(const atomic_flag&) = delete;\n    atomic_flag& operator=(const atomic_flag&) = delete;\n    atomic_flag& operator=(const atomic_flag&) volatile = delete;\n\n\n    constexpr atomic_flag(bool __'
[#] parse_declaration, is_constructor=True, meet line: 'atomic_flag& operator=(const atomic_flag&) = delete;\n    atomic_flag& operator=(const atomic_flag&) volatile = delete;\n\n\n    constexpr atomic_flag(bool __i) noexcept\n      : __atomic_flag_base{ _S_ini'
[#] parse_declaration, is_constructor=True, meet line: 'atomic_flag& operator=(const atomic_flag&) volatile = delete;\n\n\n    constexpr atomic_flag(bool __i) noexcept\n      : __atomic_flag_base{ _S_init(__i) }\n    { }\n\n    inline __attribute__((__always_inli'
[#] parse_declaration, is_constructor=True, meet line: 'atomic_flag(bool __i) noexcept\n      : __atomic_flag_base{ _S_init(__i) }\n    { }\n\n    inline __attribute__((__always_inline__)) bool\n    test_and_set(memory_order __m = memory_order_seq_cst) noexcept'
[#] parse_declaration, is_constructor=False, meet line: '__attribute__((__always_inline__)) bool\n    test_and_set(memory_order __m = memory_order_seq_cst) noexcept\n    {\n      return __atomic_test_and_set (&_M_i, __m);\n    }\n\n    inline __attribute__((__alw'
[#] parse_declaration, is_constructor=False, meet line: '__attribute__((__always_inline__)) bool\n    test_and_set(memory_order __m = memory_order_seq_cst) volatile noexcept\n    {\n      return __atomic_test_and_set (&_M_i, __m);\n    }\n\n    inline __attribute'
[#] parse_declaration, is_constructor=False, meet line: '__attribute__((__always_inline__)) void\n    clear(memory_order __m = memory_order_seq_cst) noexcept\n    {\n      memory_order __b = __m & __memory_order_mask;\n      ;\n      ;\n      ;\n\n      __atomic_cl'
[#] parse_declaration, is_constructor=False, meet line: '__attribute__((__always_inline__)) void\n    clear(memory_order __m = memory_order_seq_cst) volatile noexcept\n    {\n      memory_order __b = __m & __memory_order_mask;\n      ;\n      ;\n      ;\n\n      __'
[#] parse_declaration, is_constructor=False, meet line: '__atomic_flag_data_type\n    _S_init(bool __i)\n    { return __i ? 1 : 0; }\n  };\n# 237 "/usr/include/c++/7/bits/atomic_base.h" 3\n  template<typename _ITp>\n    struct __atomic_base\n    {\n    private:\n   '
[#] parse_declaration, is_constructor=False, meet line: 'int _S_alignment =\n sizeof(_ITp) > alignof(_ITp) ? sizeof(_ITp) : alignof(_ITp);\n\n      alignas(_S_alignment) __int_type _M_i;\n\n    public:\n      __atomic_base() noexcept = default;\n      ~__atomic_ba'
[#] parse_declaration, is_constructor=False, meet line: '__int_type _M_i;\n\n    public:\n      __atomic_base() noexcept = default;\n      ~__atomic_base() noexcept = default;\n      __atomic_base(const __atomic_base&) = delete;\n      __atomic_base& operator=(co'
[#] parse_declaration, is_constructor=True, meet line: '__atomic_base() noexcept = default;\n      ~__atomic_base() noexcept = default;\n      __atomic_base(const __atomic_base&) = delete;\n      __atomic_base& operator=(const __atomic_base&) = delete;\n      '
[#] parse_declaration, is_constructor=True, meet line: '__atomic_base() noexcept = default;\n      __atomic_base(const __atomic_base&) = delete;\n      __atomic_base& operator=(const __atomic_base&) = delete;\n      __atomic_base& operator=(const __atomic_bas'
[#] parse_declaration, is_constructor=True, meet line: '__atomic_base(const __atomic_base&) = delete;\n      __atomic_base& operator=(const __atomic_base&) = delete;\n      __atomic_base& operator=(const __atomic_base&) volatile = delete;\n\n\n      constexpr _'
[#] parse_declaration, is_constructor=True, meet line: '__atomic_base& operator=(const __atomic_base&) = delete;\n      __atomic_base& operator=(const __atomic_base&) volatile = delete;\n\n\n      constexpr __atomic_base(__int_type __i) noexcept : _M_i (__i) {'
[#] parse_declaration, is_constructor=True, meet line: '__atomic_base& operator=(const __atomic_base&) volatile = delete;\n\n\n      constexpr __atomic_base(__int_type __i) noexcept : _M_i (__i) { }\n\n      operator __int_type() const noexcept\n      { return l'
[#] parse_declaration, is_constructor=True, meet line: '__atomic_base(__int_type __i) noexcept : _M_i (__i) { }\n\n      operator __int_type() const noexcept\n      { return load(); }\n\n      operator __int_type() const volatile noexcept\n      { return load();'
[#] parse_declaration, is_constructor=False, meet line: 'operator __int_type() const noexcept\n      { return load(); }\n\n      operator __int_type() const volatile noexcept\n      { return load(); }\n\n      __int_type\n      operator=(__int_type __i) noexcept\n '
[#] parse_declaration, is_constructor=False, meet line: 'operator __int_type() const volatile noexcept\n      { return load(); }\n\n      __int_type\n      operator=(__int_type __i) noexcept\n      {\n store(__i);\n return __i;\n      }\n\n      __int_type\n      oper'
[#] parse_declaration, is_constructor=False, meet line: '__int_type\n      operator=(__int_type __i) noexcept\n      {\n store(__i);\n return __i;\n      }\n\n      __int_type\n      operator=(__int_type __i) volatile noexcept\n      {\n store(__i);\n return __i;\n    '
[#] parse_declaration, is_constructor=False, meet line: '__int_type\n      operator=(__int_type __i) volatile noexcept\n      {\n store(__i);\n return __i;\n      }\n\n      __int_type\n      operator++(int) noexcept\n      { return fetch_add(1); }\n\n      __int_type'
[#] parse_declaration, is_constructor=False, meet line: '__int_type\n      operator++(int) noexcept\n      { return fetch_add(1); }\n\n      __int_type\n      operator++(int) volatile noexcept\n      { return fetch_add(1); }\n\n      __int_type\n      operator--(int'
[#] parse_declaration, is_constructor=False, meet line: '__int_type\n      operator++(int) volatile noexcept\n      { return fetch_add(1); }\n\n      __int_type\n      operator--(int) noexcept\n      { return fetch_sub(1); }\n\n      __int_type\n      operator--(int'
[#] parse_declaration, is_constructor=False, meet line: '__int_type\n      operator--(int) noexcept\n      { return fetch_sub(1); }\n\n      __int_type\n      operator--(int) volatile noexcept\n      { return fetch_sub(1); }\n\n      __int_type\n      operator++() n'
[#] parse_declaration, is_constructor=False, meet line: '__int_type\n      operator--(int) volatile noexcept\n      { return fetch_sub(1); }\n\n      __int_type\n      operator++() noexcept\n      { return __atomic_add_fetch(&_M_i, 1, memory_order_seq_cst); }\n\n  '
[#] parse_declaration, is_constructor=False, meet line: '__int_type\n      operator++() noexcept\n      { return __atomic_add_fetch(&_M_i, 1, memory_order_seq_cst); }\n\n      __int_type\n      operator++() volatile noexcept\n      { return __atomic_add_fetch(&_M'
[#] parse_declaration, is_constructor=False, meet line: '__int_type\n      operator++() volatile noexcept\n      { return __atomic_add_fetch(&_M_i, 1, memory_order_seq_cst); }\n\n      __int_type\n      operator--() noexcept\n      { return __atomic_sub_fetch(&_M'
[#] parse_declaration, is_constructor=False, meet line: '__int_type\n      operator--() noexcept\n      { return __atomic_sub_fetch(&_M_i, 1, memory_order_seq_cst); }\n\n      __int_type\n      operator--() volatile noexcept\n      { return __atomic_sub_fetch(&_M'
[#] parse_declaration, is_constructor=False, meet line: '__int_type\n      operator--() volatile noexcept\n      { return __atomic_sub_fetch(&_M_i, 1, memory_order_seq_cst); }\n\n      __int_type\n      operator+=(__int_type __i) noexcept\n      { return __atomic'
[#] parse_declaration, is_constructor=False, meet line: '__int_type\n      operator+=(__int_type __i) noexcept\n      { return __atomic_add_fetch(&_M_i, __i, memory_order_seq_cst); }\n\n      __int_type\n      operator+=(__int_type __i) volatile noexcept\n      {'
[#] parse_declaration, is_constructor=False, meet line: '__int_type\n      operator+=(__int_type __i) volatile noexcept\n      { return __atomic_add_fetch(&_M_i, __i, memory_order_seq_cst); }\n\n      __int_type\n      operator-=(__int_type __i) noexcept\n      {'
[#] parse_declaration, is_constructor=False, meet line: '__int_type\n      operator-=(__int_type __i) noexcept\n      { return __atomic_sub_fetch(&_M_i, __i, memory_order_seq_cst); }\n\n      __int_type\n      operator-=(__int_type __i) volatile noexcept\n      {'
[#] parse_declaration, is_constructor=False, meet line: '__int_type\n      operator-=(__int_type __i) volatile noexcept\n      { return __atomic_sub_fetch(&_M_i, __i, memory_order_seq_cst); }\n\n      __int_type\n      operator&=(__int_type __i) noexcept\n      {'
[#] parse_declaration, is_constructor=False, meet line: '__int_type\n      operator&=(__int_type __i) noexcept\n      { return __atomic_and_fetch(&_M_i, __i, memory_order_seq_cst); }\n\n      __int_type\n      operator&=(__int_type __i) volatile noexcept\n      {'
[#] parse_declaration, is_constructor=False, meet line: '__int_type\n      operator&=(__int_type __i) volatile noexcept\n      { return __atomic_and_fetch(&_M_i, __i, memory_order_seq_cst); }\n\n      __int_type\n      operator|=(__int_type __i) noexcept\n      {'
[#] parse_declaration, is_constructor=False, meet line: '__int_type\n      operator|=(__int_type __i) noexcept\n      { return __atomic_or_fetch(&_M_i, __i, memory_order_seq_cst); }\n\n      __int_type\n      operator|=(__int_type __i) volatile noexcept\n      { '
[#] parse_declaration, is_constructor=False, meet line: '__int_type\n      operator|=(__int_type __i) volatile noexcept\n      { return __atomic_or_fetch(&_M_i, __i, memory_order_seq_cst); }\n\n      __int_type\n      operator^=(__int_type __i) noexcept\n      { '
[#] parse_declaration, is_constructor=False, meet line: '__int_type\n      operator^=(__int_type __i) noexcept\n      { return __atomic_xor_fetch(&_M_i, __i, memory_order_seq_cst); }\n\n      __int_type\n      operator^=(__int_type __i) volatile noexcept\n      {'
[#] parse_declaration, is_constructor=False, meet line: '__int_type\n      operator^=(__int_type __i) volatile noexcept\n      { return __atomic_xor_fetch(&_M_i, __i, memory_order_seq_cst); }\n\n      bool\n      is_lock_free() const noexcept\n      {\n\n return __'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      is_lock_free() const noexcept\n      {\n\n return __atomic_is_lock_free(sizeof(_M_i),\n     reinterpret_cast<void *>(-__alignof(_M_i)));\n      }\n\n      bool\n      is_lock_free() const volatile '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      is_lock_free() const volatile noexcept\n      {\n\n return __atomic_is_lock_free(sizeof(_M_i),\n     reinterpret_cast<void *>(-__alignof(_M_i)));\n      }\n\n      inline __attribute__((__always_i'
[#] parse_declaration, is_constructor=False, meet line: '__attribute__((__always_inline__)) void\n      store(__int_type __i, memory_order __m = memory_order_seq_cst) noexcept\n      {\n memory_order __b = __m & __memory_order_mask;\n ;\n ;\n ;\n\n __atomic_store_n'
[#] parse_declaration, is_constructor=False, meet line: '__attribute__((__always_inline__)) void\n      store(__int_type __i,\n     memory_order __m = memory_order_seq_cst) volatile noexcept\n      {\n memory_order __b = __m & __memory_order_mask;\n ;\n ;\n ;\n\n __'
[#] parse_declaration, is_constructor=False, meet line: '__attribute__((__always_inline__)) __int_type\n      load(memory_order __m = memory_order_seq_cst) const noexcept\n      {\n memory_order __b = __m & __memory_order_mask;\n ;\n ;\n\n return __atomic_load_n(&'
[#] parse_declaration, is_constructor=False, meet line: '__attribute__((__always_inline__)) __int_type\n      load(memory_order __m = memory_order_seq_cst) const volatile noexcept\n      {\n memory_order __b = __m & __memory_order_mask;\n ;\n ;\n\n return __atomic'
[#] parse_declaration, is_constructor=False, meet line: '__attribute__((__always_inline__)) __int_type\n      exchange(__int_type __i,\n        memory_order __m = memory_order_seq_cst) noexcept\n      {\n return __atomic_exchange_n(&_M_i, __i, __m);\n      }\n\n\n '
[#] parse_declaration, is_constructor=False, meet line: '__attribute__((__always_inline__)) __int_type\n      exchange(__int_type __i,\n        memory_order __m = memory_order_seq_cst) volatile noexcept\n      {\n return __atomic_exchange_n(&_M_i, __i, __m);\n  '
[#] parse_declaration, is_constructor=False, meet line: '__attribute__((__always_inline__)) bool\n      compare_exchange_weak(__int_type& __i1, __int_type __i2,\n       memory_order __m1, memory_order __m2) noexcept\n      {\n memory_order __b2 = __m2 & __memor'
[#] parse_declaration, is_constructor=False, meet line: '__attribute__((__always_inline__)) bool\n      compare_exchange_weak(__int_type& __i1, __int_type __i2,\n       memory_order __m1,\n       memory_order __m2) volatile noexcept\n      {\n memory_order __b2 '
[#] parse_declaration, is_constructor=False, meet line: '__attribute__((__always_inline__)) bool\n      compare_exchange_weak(__int_type& __i1, __int_type __i2,\n       memory_order __m = memory_order_seq_cst) noexcept\n      {\n return compare_exchange_weak(__'
[#] parse_declaration, is_constructor=False, meet line: '__attribute__((__always_inline__)) bool\n      compare_exchange_weak(__int_type& __i1, __int_type __i2,\n     memory_order __m = memory_order_seq_cst) volatile noexcept\n      {\n return compare_exchange_'
[#] parse_declaration, is_constructor=False, meet line: '__attribute__((__always_inline__)) bool\n      compare_exchange_strong(__int_type& __i1, __int_type __i2,\n         memory_order __m1, memory_order __m2) noexcept\n      {\n memory_order __b2 = __m2 & __m'
[#] parse_declaration, is_constructor=False, meet line: '__attribute__((__always_inline__)) bool\n      compare_exchange_strong(__int_type& __i1, __int_type __i2,\n         memory_order __m1,\n         memory_order __m2) volatile noexcept\n      {\n memory_order'
[#] parse_declaration, is_constructor=False, meet line: '__attribute__((__always_inline__)) bool\n      compare_exchange_strong(__int_type& __i1, __int_type __i2,\n         memory_order __m = memory_order_seq_cst) noexcept\n      {\n return compare_exchange_str'
[#] parse_declaration, is_constructor=False, meet line: '__attribute__((__always_inline__)) bool\n      compare_exchange_strong(__int_type& __i1, __int_type __i2,\n   memory_order __m = memory_order_seq_cst) volatile noexcept\n      {\n return compare_exchange_'
[#] parse_declaration, is_constructor=False, meet line: '__attribute__((__always_inline__)) __int_type\n      fetch_add(__int_type __i,\n  memory_order __m = memory_order_seq_cst) noexcept\n      { return __atomic_fetch_add(&_M_i, __i, __m); }\n\n      inline __'
[#] parse_declaration, is_constructor=False, meet line: '__attribute__((__always_inline__)) __int_type\n      fetch_add(__int_type __i,\n  memory_order __m = memory_order_seq_cst) volatile noexcept\n      { return __atomic_fetch_add(&_M_i, __i, __m); }\n\n      '
[#] parse_declaration, is_constructor=False, meet line: '__attribute__((__always_inline__)) __int_type\n      fetch_sub(__int_type __i,\n  memory_order __m = memory_order_seq_cst) noexcept\n      { return __atomic_fetch_sub(&_M_i, __i, __m); }\n\n      inline __'
[#] parse_declaration, is_constructor=False, meet line: '__attribute__((__always_inline__)) __int_type\n      fetch_sub(__int_type __i,\n  memory_order __m = memory_order_seq_cst) volatile noexcept\n      { return __atomic_fetch_sub(&_M_i, __i, __m); }\n\n      '
[#] parse_declaration, is_constructor=False, meet line: '__attribute__((__always_inline__)) __int_type\n      fetch_and(__int_type __i,\n  memory_order __m = memory_order_seq_cst) noexcept\n      { return __atomic_fetch_and(&_M_i, __i, __m); }\n\n      inline __'
[#] parse_declaration, is_constructor=False, meet line: '__attribute__((__always_inline__)) __int_type\n      fetch_and(__int_type __i,\n  memory_order __m = memory_order_seq_cst) volatile noexcept\n      { return __atomic_fetch_and(&_M_i, __i, __m); }\n\n      '
[#] parse_declaration, is_constructor=False, meet line: '__attribute__((__always_inline__)) __int_type\n      fetch_or(__int_type __i,\n        memory_order __m = memory_order_seq_cst) noexcept\n      { return __atomic_fetch_or(&_M_i, __i, __m); }\n\n      inlin'
[#] parse_declaration, is_constructor=False, meet line: '__attribute__((__always_inline__)) __int_type\n      fetch_or(__int_type __i,\n        memory_order __m = memory_order_seq_cst) volatile noexcept\n      { return __atomic_fetch_or(&_M_i, __i, __m); }\n\n  '
[#] parse_declaration, is_constructor=False, meet line: '__attribute__((__always_inline__)) __int_type\n      fetch_xor(__int_type __i,\n  memory_order __m = memory_order_seq_cst) noexcept\n      { return __atomic_fetch_xor(&_M_i, __i, __m); }\n\n      inline __'
[#] parse_declaration, is_constructor=False, meet line: '__attribute__((__always_inline__)) __int_type\n      fetch_xor(__int_type __i,\n  memory_order __m = memory_order_seq_cst) volatile noexcept\n      { return __atomic_fetch_xor(&_M_i, __i, __m); }\n    };\n'
[#] parse_declaration, is_constructor=False, meet line: '__pointer_type _M_p;\n\n\n      constexpr ptrdiff_t\n      _M_type_size(ptrdiff_t __d) const { return __d * sizeof(_PTp); }\n\n      constexpr ptrdiff_t\n      _M_type_size(ptrdiff_t __d) const volatile { re'
[#] parse_declaration, is_constructor=False, meet line: 'ptrdiff_t\n      _M_type_size(ptrdiff_t __d) const { return __d * sizeof(_PTp); }\n\n      constexpr ptrdiff_t\n      _M_type_size(ptrdiff_t __d) const volatile { return __d * sizeof(_PTp); }\n\n    public:'
[#] parse_declaration, is_constructor=False, meet line: 'ptrdiff_t\n      _M_type_size(ptrdiff_t __d) const volatile { return __d * sizeof(_PTp); }\n\n    public:\n      __atomic_base() noexcept = default;\n      ~__atomic_base() noexcept = default;\n      __atom'
[#] parse_declaration, is_constructor=True, meet line: '__atomic_base() noexcept = default;\n      ~__atomic_base() noexcept = default;\n      __atomic_base(const __atomic_base&) = delete;\n      __atomic_base& operator=(const __atomic_base&) = delete;\n      '
[#] parse_declaration, is_constructor=True, meet line: '__atomic_base() noexcept = default;\n      __atomic_base(const __atomic_base&) = delete;\n      __atomic_base& operator=(const __atomic_base&) = delete;\n      __atomic_base& operator=(const __atomic_bas'
[#] parse_declaration, is_constructor=True, meet line: '__atomic_base(const __atomic_base&) = delete;\n      __atomic_base& operator=(const __atomic_base&) = delete;\n      __atomic_base& operator=(const __atomic_base&) volatile = delete;\n\n\n      constexpr _'
[#] parse_declaration, is_constructor=True, meet line: '__atomic_base& operator=(const __atomic_base&) = delete;\n      __atomic_base& operator=(const __atomic_base&) volatile = delete;\n\n\n      constexpr __atomic_base(__pointer_type __p) noexcept : _M_p (__'
[#] parse_declaration, is_constructor=True, meet line: '__atomic_base& operator=(const __atomic_base&) volatile = delete;\n\n\n      constexpr __atomic_base(__pointer_type __p) noexcept : _M_p (__p) { }\n\n      operator __pointer_type() const noexcept\n      { '
[#] parse_declaration, is_constructor=True, meet line: '__atomic_base(__pointer_type __p) noexcept : _M_p (__p) { }\n\n      operator __pointer_type() const noexcept\n      { return load(); }\n\n      operator __pointer_type() const volatile noexcept\n      { re'
[#] parse_declaration, is_constructor=False, meet line: 'operator __pointer_type() const noexcept\n      { return load(); }\n\n      operator __pointer_type() const volatile noexcept\n      { return load(); }\n\n      __pointer_type\n      operator=(__pointer_type'
[#] parse_declaration, is_constructor=False, meet line: 'operator __pointer_type() const volatile noexcept\n      { return load(); }\n\n      __pointer_type\n      operator=(__pointer_type __p) noexcept\n      {\n store(__p);\n return __p;\n      }\n\n      __pointer'
[#] parse_declaration, is_constructor=False, meet line: '__pointer_type\n      operator=(__pointer_type __p) noexcept\n      {\n store(__p);\n return __p;\n      }\n\n      __pointer_type\n      operator=(__pointer_type __p) volatile noexcept\n      {\n store(__p);\n '
[#] parse_declaration, is_constructor=False, meet line: '__pointer_type\n      operator=(__pointer_type __p) volatile noexcept\n      {\n store(__p);\n return __p;\n      }\n\n      __pointer_type\n      operator++(int) noexcept\n      { return fetch_add(1); }\n\n    '
[#] parse_declaration, is_constructor=False, meet line: '__pointer_type\n      operator++(int) noexcept\n      { return fetch_add(1); }\n\n      __pointer_type\n      operator++(int) volatile noexcept\n      { return fetch_add(1); }\n\n      __pointer_type\n      op'
[#] parse_declaration, is_constructor=False, meet line: '__pointer_type\n      operator++(int) volatile noexcept\n      { return fetch_add(1); }\n\n      __pointer_type\n      operator--(int) noexcept\n      { return fetch_sub(1); }\n\n      __pointer_type\n      op'
[#] parse_declaration, is_constructor=False, meet line: '__pointer_type\n      operator--(int) noexcept\n      { return fetch_sub(1); }\n\n      __pointer_type\n      operator--(int) volatile noexcept\n      { return fetch_sub(1); }\n\n      __pointer_type\n      op'
[#] parse_declaration, is_constructor=False, meet line: '__pointer_type\n      operator--(int) volatile noexcept\n      { return fetch_sub(1); }\n\n      __pointer_type\n      operator++() noexcept\n      { return __atomic_add_fetch(&_M_p, _M_type_size(1),\n      '
[#] parse_declaration, is_constructor=False, meet line: '__pointer_type\n      operator++() noexcept\n      { return __atomic_add_fetch(&_M_p, _M_type_size(1),\n      memory_order_seq_cst); }\n\n      __pointer_type\n      operator++() volatile noexcept\n      { r'
[#] parse_declaration, is_constructor=False, meet line: '__pointer_type\n      operator++() volatile noexcept\n      { return __atomic_add_fetch(&_M_p, _M_type_size(1),\n      memory_order_seq_cst); }\n\n      __pointer_type\n      operator--() noexcept\n      { r'
[#] parse_declaration, is_constructor=False, meet line: '__pointer_type\n      operator--() noexcept\n      { return __atomic_sub_fetch(&_M_p, _M_type_size(1),\n      memory_order_seq_cst); }\n\n      __pointer_type\n      operator--() volatile noexcept\n      { r'
[#] parse_declaration, is_constructor=False, meet line: '__pointer_type\n      operator--() volatile noexcept\n      { return __atomic_sub_fetch(&_M_p, _M_type_size(1),\n      memory_order_seq_cst); }\n\n      __pointer_type\n      operator+=(ptrdiff_t __d) noexc'
[#] parse_declaration, is_constructor=False, meet line: '__pointer_type\n      operator+=(ptrdiff_t __d) noexcept\n      { return __atomic_add_fetch(&_M_p, _M_type_size(__d),\n      memory_order_seq_cst); }\n\n      __pointer_type\n      operator+=(ptrdiff_t __d)'
[#] parse_declaration, is_constructor=False, meet line: '__pointer_type\n      operator+=(ptrdiff_t __d) volatile noexcept\n      { return __atomic_add_fetch(&_M_p, _M_type_size(__d),\n      memory_order_seq_cst); }\n\n      __pointer_type\n      operator-=(ptrdi'
[#] parse_declaration, is_constructor=False, meet line: '__pointer_type\n      operator-=(ptrdiff_t __d) noexcept\n      { return __atomic_sub_fetch(&_M_p, _M_type_size(__d),\n      memory_order_seq_cst); }\n\n      __pointer_type\n      operator-=(ptrdiff_t __d)'
[#] parse_declaration, is_constructor=False, meet line: '__pointer_type\n      operator-=(ptrdiff_t __d) volatile noexcept\n      { return __atomic_sub_fetch(&_M_p, _M_type_size(__d),\n      memory_order_seq_cst); }\n\n      bool\n      is_lock_free() const noexc'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      is_lock_free() const noexcept\n      {\n\n return __atomic_is_lock_free(sizeof(_M_p),\n     reinterpret_cast<void *>(-__alignof(_M_p)));\n      }\n\n      bool\n      is_lock_free() const volatile '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      is_lock_free() const volatile noexcept\n      {\n\n return __atomic_is_lock_free(sizeof(_M_p),\n     reinterpret_cast<void *>(-__alignof(_M_p)));\n      }\n\n      inline __attribute__((__always_i'
[#] parse_declaration, is_constructor=False, meet line: '__attribute__((__always_inline__)) void\n      store(__pointer_type __p,\n     memory_order __m = memory_order_seq_cst) noexcept\n      {\n        memory_order __b = __m & __memory_order_mask;\n\n ;\n ;\n ;\n\n'
[#] parse_declaration, is_constructor=False, meet line: '__attribute__((__always_inline__)) void\n      store(__pointer_type __p,\n     memory_order __m = memory_order_seq_cst) volatile noexcept\n      {\n memory_order __b = __m & __memory_order_mask;\n ;\n ;\n ;\n'
[#] parse_declaration, is_constructor=False, meet line: '__attribute__((__always_inline__)) __pointer_type\n      load(memory_order __m = memory_order_seq_cst) const noexcept\n      {\n memory_order __b = __m & __memory_order_mask;\n ;\n ;\n\n return __atomic_load'
[#] parse_declaration, is_constructor=False, meet line: '__attribute__((__always_inline__)) __pointer_type\n      load(memory_order __m = memory_order_seq_cst) const volatile noexcept\n      {\n memory_order __b = __m & __memory_order_mask;\n ;\n ;\n\n return __at'
[#] parse_declaration, is_constructor=False, meet line: '__attribute__((__always_inline__)) __pointer_type\n      exchange(__pointer_type __p,\n        memory_order __m = memory_order_seq_cst) noexcept\n      {\n return __atomic_exchange_n(&_M_p, __p, __m);\n   '
[#] parse_declaration, is_constructor=False, meet line: '__attribute__((__always_inline__)) __pointer_type\n      exchange(__pointer_type __p,\n        memory_order __m = memory_order_seq_cst) volatile noexcept\n      {\n return __atomic_exchange_n(&_M_p, __p, '
[#] parse_declaration, is_constructor=False, meet line: '__attribute__((__always_inline__)) bool\n      compare_exchange_strong(__pointer_type& __p1, __pointer_type __p2,\n         memory_order __m1,\n         memory_order __m2) noexcept\n      {\n memory_order '
[#] parse_declaration, is_constructor=False, meet line: '__attribute__((__always_inline__)) bool\n      compare_exchange_strong(__pointer_type& __p1, __pointer_type __p2,\n         memory_order __m1,\n         memory_order __m2) volatile noexcept\n      {\n memo'
[#] parse_declaration, is_constructor=False, meet line: '__attribute__((__always_inline__)) __pointer_type\n      fetch_add(ptrdiff_t __d,\n  memory_order __m = memory_order_seq_cst) noexcept\n      { return __atomic_fetch_add(&_M_p, _M_type_size(__d), __m); }'
[#] parse_declaration, is_constructor=False, meet line: '__attribute__((__always_inline__)) __pointer_type\n      fetch_add(ptrdiff_t __d,\n  memory_order __m = memory_order_seq_cst) volatile noexcept\n      { return __atomic_fetch_add(&_M_p, _M_type_size(__d)'
[#] parse_declaration, is_constructor=False, meet line: '__attribute__((__always_inline__)) __pointer_type\n      fetch_sub(ptrdiff_t __d,\n  memory_order __m = memory_order_seq_cst) noexcept\n      { return __atomic_fetch_sub(&_M_p, _M_type_size(__d), __m); }'
[#] parse_declaration, is_constructor=False, meet line: '__attribute__((__always_inline__)) __pointer_type\n      fetch_sub(ptrdiff_t __d,\n  memory_order __m = memory_order_seq_cst) volatile noexcept\n      { return __atomic_fetch_sub(&_M_p, _M_type_size(__d)'
[#] parse_declaration, is_constructor=True, meet line: '_Sp_locker(const _Sp_locker&) = delete;\n    _Sp_locker& operator=(const _Sp_locker&) = delete;\n\n\n    explicit\n    _Sp_locker(const void*) noexcept;\n    _Sp_locker(const void*, const void*) noexcept;\n '
[#] parse_declaration, is_constructor=True, meet line: '_Sp_locker& operator=(const _Sp_locker&) = delete;\n\n\n    explicit\n    _Sp_locker(const void*) noexcept;\n    _Sp_locker(const void*, const void*) noexcept;\n    ~_Sp_locker();\n\n  private:\n    unsigned c'
[#] parse_declaration, is_constructor=True, meet line: '_Sp_locker(const void*) noexcept;\n    _Sp_locker(const void*, const void*) noexcept;\n    ~_Sp_locker();\n\n  private:\n    unsigned char _M_key1;\n    unsigned char _M_key2;\n\n\n\n  };\n\n\n\n\n\n\n\n  template<type'
[#] parse_declaration, is_constructor=True, meet line: '_Sp_locker(const void*, const void*) noexcept;\n    ~_Sp_locker();\n\n  private:\n    unsigned char _M_key1;\n    unsigned char _M_key2;\n\n\n\n  };\n\n\n\n\n\n\n\n  template<typename _Tp, _Lock_policy _Lp>\n    inline'
[#] parse_declaration, is_constructor=True, meet line: '_Sp_locker();\n\n  private:\n    unsigned char _M_key1;\n    unsigned char _M_key2;\n\n\n\n  };\n\n\n\n\n\n\n\n  template<typename _Tp, _Lock_policy _Lp>\n    inline bool\n    atomic_is_lock_free(const __shared_ptr<_Tp'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned char _M_key1;\n    unsigned char _M_key2;\n\n\n\n  };\n\n\n\n\n\n\n\n  template<typename _Tp, _Lock_policy _Lp>\n    inline bool\n    atomic_is_lock_free(const __shared_ptr<_Tp, _Lp>* __p)\n    {\n\n      retu'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned char _M_key2;\n\n\n\n  };\n\n\n\n\n\n\n\n  template<typename _Tp, _Lock_policy _Lp>\n    inline bool\n    atomic_is_lock_free(const __shared_ptr<_Tp, _Lp>* __p)\n    {\n\n      return __gthread_active_p() == '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    atomic_is_lock_free(const __shared_ptr<_Tp, _Lp>* __p)\n    {\n\n      return __gthread_active_p() == 0;\n\n\n\n    }\n\n  template<typename _Tp>\n    inline bool\n    atomic_is_lock_free(const shared_p'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    atomic_is_lock_free(const shared_ptr<_Tp>* __p)\n    { return std::atomic_is_lock_free<_Tp, __default_lock_policy>(__p); }\n# 96 "/usr/include/c++/7/bits/shared_ptr_atomic.h" 3\n  template<typen'
[#] parse_declaration, is_constructor=False, meet line: 'shared_ptr<_Tp>\n    atomic_load_explicit(const shared_ptr<_Tp>* __p, memory_order)\n    {\n      _Sp_locker __lock{__p};\n      return *__p;\n    }\n\n  template<typename _Tp>\n    inline shared_ptr<_Tp>\n   '
[#] parse_declaration, is_constructor=False, meet line: 'shared_ptr<_Tp>\n    atomic_load(const shared_ptr<_Tp>* __p)\n    { return std::atomic_load_explicit(__p, memory_order_seq_cst); }\n\n  template<typename _Tp, _Lock_policy _Lp>\n    inline __shared_ptr<_Tp'
[#] parse_declaration, is_constructor=False, meet line: '__shared_ptr<_Tp, _Lp>\n    atomic_load_explicit(const __shared_ptr<_Tp, _Lp>* __p, memory_order)\n    {\n      _Sp_locker __lock{__p};\n      return *__p;\n    }\n\n  template<typename _Tp, _Lock_policy _Lp'
[#] parse_declaration, is_constructor=False, meet line: '__shared_ptr<_Tp, _Lp>\n    atomic_load(const __shared_ptr<_Tp, _Lp>* __p)\n    { return std::atomic_load_explicit(__p, memory_order_seq_cst); }\n# 132 "/usr/include/c++/7/bits/shared_ptr_atomic.h" 3\n  t'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    atomic_store_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r,\n     memory_order)\n    {\n      _Sp_locker __lock{__p};\n      __p->swap(__r);\n    }\n\n  template<typename _Tp>\n    inline void\n '
[#] parse_declaration, is_constructor=False, meet line: 'void\n    atomic_store(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)\n    { std::atomic_store_explicit(__p, std::move(__r), memory_order_seq_cst); }\n\n  template<typename _Tp, _Lock_policy _Lp>\n    inline v'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    atomic_store_explicit(__shared_ptr<_Tp, _Lp>* __p,\n     __shared_ptr<_Tp, _Lp> __r,\n     memory_order)\n    {\n      _Sp_locker __lock{__p};\n      __p->swap(__r);\n    }\n\n  template<typename _Tp'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    atomic_store(__shared_ptr<_Tp, _Lp>* __p, __shared_ptr<_Tp, _Lp> __r)\n    { std::atomic_store_explicit(__p, std::move(__r), memory_order_seq_cst); }\n# 169 "/usr/include/c++/7/bits/shared_ptr_'
[#] parse_declaration, is_constructor=False, meet line: 'shared_ptr<_Tp>\n    atomic_exchange_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r,\n        memory_order)\n    {\n      _Sp_locker __lock{__p};\n      __p->swap(__r);\n      return __r;\n    }\n\n  templ'
[#] parse_declaration, is_constructor=False, meet line: 'shared_ptr<_Tp>\n    atomic_exchange(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)\n    {\n      return std::atomic_exchange_explicit(__p, std::move(__r),\n        memory_order_seq_cst);\n    }\n\n  template<ty'
[#] parse_declaration, is_constructor=False, meet line: '__shared_ptr<_Tp, _Lp>\n    atomic_exchange_explicit(__shared_ptr<_Tp, _Lp>* __p,\n        __shared_ptr<_Tp, _Lp> __r,\n        memory_order)\n    {\n      _Sp_locker __lock{__p};\n      __p->swap(__r);\n   '
[#] parse_declaration, is_constructor=False, meet line: '__shared_ptr<_Tp, _Lp>\n    atomic_exchange(__shared_ptr<_Tp, _Lp>* __p, __shared_ptr<_Tp, _Lp> __r)\n    {\n      return std::atomic_exchange_explicit(__p, std::move(__r),\n        memory_order_seq_cst);'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    atomic_compare_exchange_strong_explicit(shared_ptr<_Tp>* __p,\n         shared_ptr<_Tp>* __v,\n         shared_ptr<_Tp> __w,\n         memory_order,\n         memory_order)\n    {\n      shared_ptr'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    atomic_compare_exchange_strong(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,\n     shared_ptr<_Tp> __w)\n    {\n      return std::atomic_compare_exchange_strong_explicit(__p, __v,\n   std::move(__w'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    atomic_compare_exchange_weak_explicit(shared_ptr<_Tp>* __p,\n       shared_ptr<_Tp>* __v,\n       shared_ptr<_Tp> __w,\n       memory_order __success,\n       memory_order __failure)\n    {\n      '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    atomic_compare_exchange_weak(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,\n     shared_ptr<_Tp> __w)\n    {\n      return std::atomic_compare_exchange_weak_explicit(__p, __v,\n   std::move(__w), m'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    atomic_compare_exchange_strong_explicit(__shared_ptr<_Tp, _Lp>* __p,\n         __shared_ptr<_Tp, _Lp>* __v,\n         __shared_ptr<_Tp, _Lp> __w,\n         memory_order,\n         memory_order)\n '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    atomic_compare_exchange_strong(__shared_ptr<_Tp, _Lp>* __p,\n       __shared_ptr<_Tp, _Lp>* __v,\n       __shared_ptr<_Tp, _Lp> __w)\n    {\n      return std::atomic_compare_exchange_strong_expli'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    atomic_compare_exchange_weak_explicit(__shared_ptr<_Tp, _Lp>* __p,\n       __shared_ptr<_Tp, _Lp>* __v,\n       __shared_ptr<_Tp, _Lp> __w,\n       memory_order __success,\n       memory_order __'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    atomic_compare_exchange_weak(__shared_ptr<_Tp, _Lp>* __p,\n     __shared_ptr<_Tp, _Lp>* __v,\n     __shared_ptr<_Tp, _Lp> __w)\n    {\n      return std::atomic_compare_exchange_weak_explicit(__p,'
[#] parse_declaration, is_constructor=False, meet line: '_Tp1* _M_ptr;\n\n      explicit\n      auto_ptr_ref(_Tp1* __p): _M_ptr(__p) { }\n    } __attribute__ ((__deprecated__));\n# 86 "/usr/include/c++/7/backward/auto_ptr.h" 3\n  template<typename _Tp>\n    class '
[#] parse_declaration, is_constructor=True, meet line: 'auto_ptr_ref(_Tp1* __p): _M_ptr(__p) { }\n    } __attribute__ ((__deprecated__));\n# 86 "/usr/include/c++/7/backward/auto_ptr.h" 3\n  template<typename _Tp>\n    class auto_ptr\n    {\n    private:\n      _T'
[#] parse_declaration, is_constructor=False, meet line: '_Tp* _M_ptr;\n\n    public:\n\n      typedef _Tp element_type;\n\n\n\n\n\n\n\n      explicit\n      auto_ptr(element_type* __p = 0) throw() : _M_ptr(__p) { }\n# 112 "/usr/include/c++/7/backward/auto_ptr.h" 3\n      '
[#] parse_declaration, is_constructor=True, meet line: 'auto_ptr(element_type* __p = 0) throw() : _M_ptr(__p) { }\n# 112 "/usr/include/c++/7/backward/auto_ptr.h" 3\n      auto_ptr(auto_ptr& __a) throw() : _M_ptr(__a.release()) { }\n# 124 "/usr/include/c++/7/b'
[#] parse_declaration, is_constructor=True, meet line: 'auto_ptr(auto_ptr& __a) throw() : _M_ptr(__a.release()) { }\n# 124 "/usr/include/c++/7/backward/auto_ptr.h" 3\n      template<typename _Tp1>\n        auto_ptr(auto_ptr<_Tp1>& __a) throw() : _M_ptr(__a.re'
[#] parse_declaration, is_constructor=True, meet line: 'auto_ptr(auto_ptr<_Tp1>& __a) throw() : _M_ptr(__a.release()) { }\n# 135 "/usr/include/c++/7/backward/auto_ptr.h" 3\n      auto_ptr&\n      operator=(auto_ptr& __a) throw()\n      {\n reset(__a.release());'
[#] parse_declaration, is_constructor=True, meet line: 'auto_ptr&\n      operator=(auto_ptr& __a) throw()\n      {\n reset(__a.release());\n return *this;\n      }\n# 152 "/usr/include/c++/7/backward/auto_ptr.h" 3\n      template<typename _Tp1>\n        auto_ptr&\n'
[#] parse_declaration, is_constructor=True, meet line: 'auto_ptr&\n        operator=(auto_ptr<_Tp1>& __a) throw()\n        {\n   reset(__a.release());\n   return *this;\n }\n# 170 "/usr/include/c++/7/backward/auto_ptr.h" 3\n      ~auto_ptr() { delete _M_ptr; }\n# '
[#] parse_declaration, is_constructor=True, meet line: 'auto_ptr() { delete _M_ptr; }\n# 180 "/usr/include/c++/7/backward/auto_ptr.h" 3\n      element_type&\n      operator*() const throw()\n      {\n ;\n return *_M_ptr;\n      }\n\n\n\n\n\n\n\n      element_type*\n      '
[#] parse_declaration, is_constructor=False, meet line: 'element_type&\n      operator*() const throw()\n      {\n ;\n return *_M_ptr;\n      }\n\n\n\n\n\n\n\n      element_type*\n      operator->() const throw()\n      {\n ;\n return _M_ptr;\n      }\n# 210 "/usr/include/c++'
[#] parse_declaration, is_constructor=False, meet line: 'element_type*\n      operator->() const throw()\n      {\n ;\n return _M_ptr;\n      }\n# 210 "/usr/include/c++/7/backward/auto_ptr.h" 3\n      element_type*\n      get() const throw() { return _M_ptr; }\n# 22'
[#] parse_declaration, is_constructor=False, meet line: 'element_type*\n      get() const throw() { return _M_ptr; }\n# 224 "/usr/include/c++/7/backward/auto_ptr.h" 3\n      element_type*\n      release() throw()\n      {\n element_type* __tmp = _M_ptr;\n _M_ptr ='
[#] parse_declaration, is_constructor=False, meet line: 'element_type*\n      release() throw()\n      {\n element_type* __tmp = _M_ptr;\n _M_ptr = 0;\n return __tmp;\n      }\n# 239 "/usr/include/c++/7/backward/auto_ptr.h" 3\n      void\n      reset(element_type* _'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      reset(element_type* __p = 0) throw()\n      {\n if (__p != _M_ptr)\n   {\n     delete _M_ptr;\n     _M_ptr = __p;\n   }\n      }\n# 264 "/usr/include/c++/7/backward/auto_ptr.h" 3\n      auto_ptr(aut'
[#] parse_declaration, is_constructor=True, meet line: 'auto_ptr(auto_ptr_ref<element_type> __ref) throw()\n      : _M_ptr(__ref._M_ptr) { }\n\n      auto_ptr&\n      operator=(auto_ptr_ref<element_type> __ref) throw()\n      {\n if (__ref._M_ptr != this->get())'
[#] parse_declaration, is_constructor=True, meet line: 'auto_ptr&\n      operator=(auto_ptr_ref<element_type> __ref) throw()\n      {\n if (__ref._M_ptr != this->get())\n   {\n     delete _M_ptr;\n     _M_ptr = __ref._M_ptr;\n   }\n return *this;\n      }\n\n      te'
[#] parse_declaration, is_constructor=False, meet line: 'operator auto_ptr_ref<_Tp1>() throw()\n        { return auto_ptr_ref<_Tp1>(this->release()); }\n\n      template<typename _Tp1>\n        operator auto_ptr<_Tp1>() throw()\n        { return auto_ptr<_Tp1>(t'
[#] parse_declaration, is_constructor=False, meet line: 'operator auto_ptr<_Tp1>() throw()\n        { return auto_ptr<_Tp1>(this->release()); }\n    } __attribute__ ((__deprecated__));\n\n\n\n  template<>\n    class auto_ptr<void>\n    {\n    public:\n      typedef v'
[#] parse_declaration, is_constructor=False, meet line: '__shared_count<_Lp>::__shared_count(std::auto_ptr<_Tp>&& __r)\n    : _M_pi(new _Sp_counted_ptr<_Tp*, _Lp>(__r.get()))\n    { __r.release(); }\n\n  template<typename _Tp, _Lock_policy _Lp>\n  template<typen'
[#] parse_declaration, is_constructor=False, meet line: '__shared_ptr<_Tp, _Lp>::__shared_ptr(std::auto_ptr<_Tp1>&& __r)\n    : _M_ptr(__r.get()), _M_refcount()\n    {\n     \n      static_assert( sizeof(_Tp1) > 0, "incomplete type" );\n      _Tp1* __tmp = __r.g'
[#] parse_declaration, is_constructor=False, meet line: 'shared_ptr<_Tp>::shared_ptr(std::auto_ptr<_Tp1>&& __r)\n    : __shared_ptr<_Tp>(std::move(__r)) { }\n\n  template<typename _Tp, typename _Dp>\n  template<typename _Up, typename>\n    inline\n    unique_ptr<'
[#] parse_declaration, is_constructor=False, meet line: 'unique_ptr<_Tp, _Dp>::unique_ptr(auto_ptr<_Up>&& __u) noexcept\n    : _M_t(__u.release(), deleter_type()) { }\n\n\n\n}\n# 85 "/usr/include/c++/7/memory" 2 3\n# 93 "/usr/include/c++/7/memory" 3\nnamespace std '
[#] parse_declaration, is_constructor=False, meet line: 'void*\nalign(size_t __align, size_t __size, void*& __ptr, size_t& __space) noexcept\n{\n  const auto __intptr = reinterpret_cast<uintptr_t>(__ptr);\n  const auto __aligned = (__intptr - 1u + __align) & -_'
[#] parse_declaration, is_constructor=False, meet line: 'void\ndeclare_reachable(void*) { }\n\ntemplate <typename _Tp>\n  inline _Tp*\n  undeclare_reachable(_Tp* __p) { return __p; }\n\ninline void\ndeclare_no_pointers(char*, size_t) { }\n\ninline void\nundeclare_no_p'
[#] parse_declaration, is_constructor=False, meet line: '_Tp*\n  undeclare_reachable(_Tp* __p) { return __p; }\n\ninline void\ndeclare_no_pointers(char*, size_t) { }\n\ninline void\nundeclare_no_pointers(char*, size_t) { }\n\ninline pointer_safety\nget_pointer_safety'
[#] parse_declaration, is_constructor=False, meet line: 'void\ndeclare_no_pointers(char*, size_t) { }\n\ninline void\nundeclare_no_pointers(char*, size_t) { }\n\ninline pointer_safety\nget_pointer_safety() noexcept { return pointer_safety::relaxed; }\n\n\n}\n# 46 "/us'
[#] parse_declaration, is_constructor=False, meet line: 'void\nundeclare_no_pointers(char*, size_t) { }\n\ninline pointer_safety\nget_pointer_safety() noexcept { return pointer_safety::relaxed; }\n\n\n}\n# 46 "/usr/include/c++/7/regex" 2 3\n# 1 "/usr/include/c++/7/s'
[#] parse_declaration, is_constructor=False, meet line: 'pointer_safety\nget_pointer_safety() noexcept { return pointer_safety::relaxed; }\n\n\n}\n# 46 "/usr/include/c++/7/regex" 2 3\n# 1 "/usr/include/c++/7/sstream" 1 3\n# 36 "/usr/include/c++/7/sstream" 3\n      '
[#] parse_declaration, is_constructor=False, meet line: 'ios_base::openmode _M_mode;\n\n\n      __string_type _M_string;\n\n    public:\n# 99 "/usr/include/c++/7/sstream" 3\n      explicit\n      basic_stringbuf(ios_base::openmode __mode = ios_base::in | ios_base::'
[#] parse_declaration, is_constructor=False, meet line: '__string_type _M_string;\n\n    public:\n# 99 "/usr/include/c++/7/sstream" 3\n      explicit\n      basic_stringbuf(ios_base::openmode __mode = ios_base::in | ios_base::out)\n      : __streambuf_type(), _M_'
[#] parse_declaration, is_constructor=True, meet line: 'basic_stringbuf(ios_base::openmode __mode = ios_base::in | ios_base::out)\n      : __streambuf_type(), _M_mode(__mode), _M_string()\n      { }\n# 112 "/usr/include/c++/7/sstream" 3\n      explicit\n      b'
[#] parse_declaration, is_constructor=True, meet line: 'basic_stringbuf(const __string_type& __str,\n        ios_base::openmode __mode = ios_base::in | ios_base::out)\n      : __streambuf_type(), _M_mode(), _M_string(__str.data(), __str.size())\n      { _M_st'
[#] parse_declaration, is_constructor=True, meet line: 'basic_stringbuf(const basic_stringbuf&) = delete;\n\n      basic_stringbuf(basic_stringbuf&& __rhs)\n      : basic_stringbuf(std::move(__rhs), __xfer_bufptrs(__rhs, this))\n      { __rhs._M_sync(const_cas'
[#] parse_declaration, is_constructor=True, meet line: 'basic_stringbuf(basic_stringbuf&& __rhs)\n      : basic_stringbuf(std::move(__rhs), __xfer_bufptrs(__rhs, this))\n      { __rhs._M_sync(const_cast<char_type*>(__rhs._M_string.data()), 0, 0); }\n\n\n\n      '
[#] parse_declaration, is_constructor=True, meet line: 'basic_stringbuf&\n      operator=(const basic_stringbuf&) = delete;\n\n      basic_stringbuf&\n      operator=(basic_stringbuf&& __rhs)\n      {\n __xfer_bufptrs __st{__rhs, this};\n const __streambuf_type& '
[#] parse_declaration, is_constructor=True, meet line: 'basic_stringbuf&\n      operator=(basic_stringbuf&& __rhs)\n      {\n __xfer_bufptrs __st{__rhs, this};\n const __streambuf_type& __base = __rhs;\n __streambuf_type::operator=(__base);\n this->pubimbue(__rh'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      swap(basic_stringbuf& __rhs)\n      {\n __xfer_bufptrs __l_st{*this, std::__addressof(__rhs)};\n __xfer_bufptrs __r_st{__rhs, this};\n __streambuf_type& __base = __rhs;\n __streambuf_type::swap('
[#] parse_declaration, is_constructor=False, meet line: '__string_type\n      str() const\n      {\n __string_type __ret;\n if (this->pptr())\n   {\n\n     if (this->pptr() > this->egptr())\n       __ret = __string_type(this->pbase(), this->pptr());\n     else\n     '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      str(const __string_type& __s)\n      {\n\n\n _M_string.assign(__s.data(), __s.size());\n _M_stringbuf_init(_M_mode);\n      }\n\n    protected:\n\n      void\n      _M_stringbuf_init(ios_base::openmod'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_stringbuf_init(ios_base::openmode __mode)\n      {\n _M_mode = __mode;\n __size_type __len = 0;\n if (_M_mode & (ios_base::ate | ios_base::app))\n   __len = _M_string.size();\n _M_sync(const_c'
[#] parse_declaration, is_constructor=False, meet line: 'streamsize\n      showmanyc()\n      {\n streamsize __ret = -1;\n if (_M_mode & ios_base::in)\n   {\n     _M_update_egptr();\n     __ret = this->egptr() - this->gptr();\n   }\n return __ret;\n      }\n\n      vir'
[#] parse_declaration, is_constructor=False, meet line: 'int_type\n      underflow();\n\n      virtual int_type\n      pbackfail(int_type __c = traits_type::eof());\n\n      virtual int_type\n      overflow(int_type __c = traits_type::eof());\n# 242 "/usr/include/c'
[#] parse_declaration, is_constructor=False, meet line: 'int_type\n      pbackfail(int_type __c = traits_type::eof());\n\n      virtual int_type\n      overflow(int_type __c = traits_type::eof());\n# 242 "/usr/include/c++/7/sstream" 3\n      virtual __streambuf_t'
[#] parse_declaration, is_constructor=False, meet line: 'int_type\n      overflow(int_type __c = traits_type::eof());\n# 242 "/usr/include/c++/7/sstream" 3\n      virtual __streambuf_type*\n      setbuf(char_type* __s, streamsize __n)\n      {\n if (__s && __n >='
[#] parse_declaration, is_constructor=False, meet line: '__streambuf_type*\n      setbuf(char_type* __s, streamsize __n)\n      {\n if (__s && __n >= 0)\n   {\n\n\n\n\n\n\n     _M_string.clear();\n\n\n     _M_sync(__s, __n, 0);\n   }\n return this;\n      }\n\n      virtual p'
[#] parse_declaration, is_constructor=False, meet line: 'pos_type\n      seekoff(off_type __off, ios_base::seekdir __way,\n       ios_base::openmode __mode = ios_base::in | ios_base::out);\n\n      virtual pos_type\n      seekpos(pos_type __sp,\n       ios_base::'
[#] parse_declaration, is_constructor=False, meet line: 'pos_type\n      seekpos(pos_type __sp,\n       ios_base::openmode __mode = ios_base::in | ios_base::out);\n\n\n\n\n      void\n      _M_sync(char_type* __base, __size_type __i, __size_type __o);\n\n\n\n      void'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_sync(char_type* __base, __size_type __i, __size_type __o);\n\n\n\n      void\n      _M_update_egptr()\n      {\n const bool __testin = _M_mode & ios_base::in;\n if (this->pptr() && this->pptr() '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_update_egptr()\n      {\n const bool __testin = _M_mode & ios_base::in;\n if (this->pptr() && this->pptr() > this->egptr())\n   {\n     if (__testin)\n       this->setg(this->eback(), this->gp'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_pbump(char_type* __pbeg, char_type* __pend, off_type __off);\n\n    private:\n\n\n\n\n      struct __xfer_bufptrs\n      {\n __xfer_bufptrs(const basic_stringbuf& __from, basic_stringbuf* __to)\n '
[#] parse_declaration, is_constructor=True, meet line: '__xfer_bufptrs(const basic_stringbuf& __from, basic_stringbuf* __to)\n : _M_to{__to}, _M_goff{-1, -1, -1}, _M_poff{-1, -1, -1}\n {\n   const _CharT* const __str = __from._M_string.data();\n   const _CharT'
[#] parse_declaration, is_constructor=True, meet line: '__xfer_bufptrs()\n {\n   char_type* __str = const_cast<char_type*>(_M_to->_M_string.data());\n   if (_M_goff[0] != -1)\n     _M_to->setg(__str+_M_goff[0], __str+_M_goff[1], __str+_M_goff[2]);\n   if (_M_po'
[#] parse_declaration, is_constructor=False, meet line: 'basic_stringbuf* _M_to;\n off_type _M_goff[3];\n off_type _M_poff[3];\n      };\n# 356 "/usr/include/c++/7/sstream" 3\n      basic_stringbuf(basic_stringbuf&& __rhs, __xfer_bufptrs&&)\n      : __streambuf_t'
[#] parse_declaration, is_constructor=False, meet line: 'off_type _M_goff[3];\n off_type _M_poff[3];\n      };\n# 356 "/usr/include/c++/7/sstream" 3\n      basic_stringbuf(basic_stringbuf&& __rhs, __xfer_bufptrs&&)\n      : __streambuf_type(static_cast<const __s'
[#] parse_declaration, is_constructor=False, meet line: 'off_type _M_poff[3];\n      };\n# 356 "/usr/include/c++/7/sstream" 3\n      basic_stringbuf(basic_stringbuf&& __rhs, __xfer_bufptrs&&)\n      : __streambuf_type(static_cast<const __streambuf_type&>(__rhs)'
[#] parse_declaration, is_constructor=True, meet line: 'basic_stringbuf(basic_stringbuf&& __rhs, __xfer_bufptrs&&)\n      : __streambuf_type(static_cast<const __streambuf_type&>(__rhs)),\n      _M_mode(__rhs._M_mode), _M_string(std::move(__rhs._M_string))\n  '
[#] parse_declaration, is_constructor=False, meet line: '__stringbuf_type _M_stringbuf;\n\n    public:\n# 415 "/usr/include/c++/7/sstream" 3\n      explicit\n      basic_istringstream(ios_base::openmode __mode = ios_base::in)\n      : __istream_type(), _M_stringb'
[#] parse_declaration, is_constructor=True, meet line: 'basic_istringstream(ios_base::openmode __mode = ios_base::in)\n      : __istream_type(), _M_stringbuf(__mode | ios_base::in)\n      { this->init(&_M_stringbuf); }\n# 433 "/usr/include/c++/7/sstream" 3\n  '
[#] parse_declaration, is_constructor=True, meet line: 'basic_istringstream(const __string_type& __str,\n     ios_base::openmode __mode = ios_base::in)\n      : __istream_type(), _M_stringbuf(__str, __mode | ios_base::in)\n      { this->init(&_M_stringbuf); }'
[#] parse_declaration, is_constructor=True, meet line: 'basic_istringstream()\n      { }\n\n\n      basic_istringstream(const basic_istringstream&) = delete;\n\n      basic_istringstream(basic_istringstream&& __rhs)\n      : __istream_type(std::move(__rhs)),\n    '
[#] parse_declaration, is_constructor=True, meet line: 'basic_istringstream(const basic_istringstream&) = delete;\n\n      basic_istringstream(basic_istringstream&& __rhs)\n      : __istream_type(std::move(__rhs)),\n      _M_stringbuf(std::move(__rhs._M_string'
[#] parse_declaration, is_constructor=True, meet line: 'basic_istringstream(basic_istringstream&& __rhs)\n      : __istream_type(std::move(__rhs)),\n      _M_stringbuf(std::move(__rhs._M_stringbuf))\n      { __istream_type::set_rdbuf(&_M_stringbuf); }\n\n\n\n    '
[#] parse_declaration, is_constructor=True, meet line: 'basic_istringstream&\n      operator=(const basic_istringstream&) = delete;\n\n      basic_istringstream&\n      operator=(basic_istringstream&& __rhs)\n      {\n __istream_type::operator=(std::move(__rhs))'
[#] parse_declaration, is_constructor=True, meet line: 'basic_istringstream&\n      operator=(basic_istringstream&& __rhs)\n      {\n __istream_type::operator=(std::move(__rhs));\n _M_stringbuf = std::move(__rhs._M_stringbuf);\n return *this;\n      }\n\n      voi'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      swap(basic_istringstream& __rhs)\n      {\n __istream_type::swap(__rhs);\n _M_stringbuf.swap(__rhs._M_stringbuf);\n      }\n# 484 "/usr/include/c++/7/sstream" 3\n      __stringbuf_type*\n      rdb'
[#] parse_declaration, is_constructor=False, meet line: '__stringbuf_type*\n      rdbuf() const\n      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }\n\n\n\n\n\n      __string_type\n      str() const\n      { return _M_stringbuf.str(); }\n\n\n\n\n\n\n\n      void\n '
[#] parse_declaration, is_constructor=False, meet line: '__string_type\n      str() const\n      { return _M_stringbuf.str(); }\n\n\n\n\n\n\n\n      void\n      str(const __string_type& __s)\n      { _M_stringbuf.str(__s); }\n    };\n# 523 "/usr/include/c++/7/sstream" 3\n'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      str(const __string_type& __s)\n      { _M_stringbuf.str(__s); }\n    };\n# 523 "/usr/include/c++/7/sstream" 3\n  template <typename _CharT, typename _Traits, typename _Alloc>\n    class basic_os'
[#] parse_declaration, is_constructor=False, meet line: '__stringbuf_type _M_stringbuf;\n\n    public:\n# 559 "/usr/include/c++/7/sstream" 3\n      explicit\n      basic_ostringstream(ios_base::openmode __mode = ios_base::out)\n      : __ostream_type(), _M_string'
[#] parse_declaration, is_constructor=True, meet line: 'basic_ostringstream(ios_base::openmode __mode = ios_base::out)\n      : __ostream_type(), _M_stringbuf(__mode | ios_base::out)\n      { this->init(&_M_stringbuf); }\n# 577 "/usr/include/c++/7/sstream" 3\n'
[#] parse_declaration, is_constructor=True, meet line: 'basic_ostringstream(const __string_type& __str,\n     ios_base::openmode __mode = ios_base::out)\n      : __ostream_type(), _M_stringbuf(__str, __mode | ios_base::out)\n      { this->init(&_M_stringbuf);'
[#] parse_declaration, is_constructor=True, meet line: 'basic_ostringstream()\n      { }\n\n\n      basic_ostringstream(const basic_ostringstream&) = delete;\n\n      basic_ostringstream(basic_ostringstream&& __rhs)\n      : __ostream_type(std::move(__rhs)),\n    '
[#] parse_declaration, is_constructor=True, meet line: 'basic_ostringstream(const basic_ostringstream&) = delete;\n\n      basic_ostringstream(basic_ostringstream&& __rhs)\n      : __ostream_type(std::move(__rhs)),\n      _M_stringbuf(std::move(__rhs._M_string'
[#] parse_declaration, is_constructor=True, meet line: 'basic_ostringstream(basic_ostringstream&& __rhs)\n      : __ostream_type(std::move(__rhs)),\n      _M_stringbuf(std::move(__rhs._M_stringbuf))\n      { __ostream_type::set_rdbuf(&_M_stringbuf); }\n\n\n\n    '
[#] parse_declaration, is_constructor=True, meet line: 'basic_ostringstream&\n      operator=(const basic_ostringstream&) = delete;\n\n      basic_ostringstream&\n      operator=(basic_ostringstream&& __rhs)\n      {\n __ostream_type::operator=(std::move(__rhs))'
[#] parse_declaration, is_constructor=True, meet line: 'basic_ostringstream&\n      operator=(basic_ostringstream&& __rhs)\n      {\n __ostream_type::operator=(std::move(__rhs));\n _M_stringbuf = std::move(__rhs._M_stringbuf);\n return *this;\n      }\n\n      voi'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      swap(basic_ostringstream& __rhs)\n      {\n __ostream_type::swap(__rhs);\n _M_stringbuf.swap(__rhs._M_stringbuf);\n      }\n# 628 "/usr/include/c++/7/sstream" 3\n      __stringbuf_type*\n      rdb'
[#] parse_declaration, is_constructor=False, meet line: '__stringbuf_type*\n      rdbuf() const\n      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }\n\n\n\n\n\n      __string_type\n      str() const\n      { return _M_stringbuf.str(); }\n\n\n\n\n\n\n\n      void\n '
[#] parse_declaration, is_constructor=False, meet line: '__string_type\n      str() const\n      { return _M_stringbuf.str(); }\n\n\n\n\n\n\n\n      void\n      str(const __string_type& __s)\n      { _M_stringbuf.str(__s); }\n    };\n# 667 "/usr/include/c++/7/sstream" 3\n'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      str(const __string_type& __s)\n      { _M_stringbuf.str(__s); }\n    };\n# 667 "/usr/include/c++/7/sstream" 3\n  template <typename _CharT, typename _Traits, typename _Alloc>\n    class basic_st'
[#] parse_declaration, is_constructor=False, meet line: '__stringbuf_type _M_stringbuf;\n\n    public:\n# 702 "/usr/include/c++/7/sstream" 3\n      explicit\n      basic_stringstream(ios_base::openmode __m = ios_base::out | ios_base::in)\n      : __iostream_type('
[#] parse_declaration, is_constructor=True, meet line: 'basic_stringstream(ios_base::openmode __m = ios_base::out | ios_base::in)\n      : __iostream_type(), _M_stringbuf(__m)\n      { this->init(&_M_stringbuf); }\n# 718 "/usr/include/c++/7/sstream" 3\n      e'
[#] parse_declaration, is_constructor=True, meet line: 'basic_stringstream(const __string_type& __str,\n    ios_base::openmode __m = ios_base::out | ios_base::in)\n      : __iostream_type(), _M_stringbuf(__str, __m)\n      { this->init(&_M_stringbuf); }\n\n\n\n\n\n'
[#] parse_declaration, is_constructor=True, meet line: 'basic_stringstream()\n      { }\n\n\n      basic_stringstream(const basic_stringstream&) = delete;\n\n      basic_stringstream(basic_stringstream&& __rhs)\n      : __iostream_type(std::move(__rhs)),\n      _M'
[#] parse_declaration, is_constructor=True, meet line: 'basic_stringstream(const basic_stringstream&) = delete;\n\n      basic_stringstream(basic_stringstream&& __rhs)\n      : __iostream_type(std::move(__rhs)),\n      _M_stringbuf(std::move(__rhs._M_stringbuf'
[#] parse_declaration, is_constructor=True, meet line: 'basic_stringstream(basic_stringstream&& __rhs)\n      : __iostream_type(std::move(__rhs)),\n      _M_stringbuf(std::move(__rhs._M_stringbuf))\n      { __iostream_type::set_rdbuf(&_M_stringbuf); }\n\n\n\n    '
[#] parse_declaration, is_constructor=True, meet line: 'basic_stringstream&\n      operator=(const basic_stringstream&) = delete;\n\n      basic_stringstream&\n      operator=(basic_stringstream&& __rhs)\n      {\n __iostream_type::operator=(std::move(__rhs));\n '
[#] parse_declaration, is_constructor=True, meet line: 'basic_stringstream&\n      operator=(basic_stringstream&& __rhs)\n      {\n __iostream_type::operator=(std::move(__rhs));\n _M_stringbuf = std::move(__rhs._M_stringbuf);\n return *this;\n      }\n\n      void'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      swap(basic_stringstream& __rhs)\n      {\n __iostream_type::swap(__rhs);\n _M_stringbuf.swap(__rhs._M_stringbuf);\n      }\n# 769 "/usr/include/c++/7/sstream" 3\n      __stringbuf_type*\n      rdb'
[#] parse_declaration, is_constructor=False, meet line: '__stringbuf_type*\n      rdbuf() const\n      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }\n\n\n\n\n\n      __string_type\n      str() const\n      { return _M_stringbuf.str(); }\n\n\n\n\n\n\n\n      void\n '
[#] parse_declaration, is_constructor=False, meet line: '__string_type\n      str() const\n      { return _M_stringbuf.str(); }\n\n\n\n\n\n\n\n      void\n      str(const __string_type& __s)\n      { _M_stringbuf.str(__s); }\n    };\n\n\n\n  template <class _CharT, class _T'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      str(const __string_type& __s)\n      { _M_stringbuf.str(__s); }\n    };\n\n\n\n  template <class _CharT, class _Traits, class _Allocator>\n    inline void\n    swap(basic_stringbuf<_CharT, _Traits,'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    swap(basic_stringbuf<_CharT, _Traits, _Allocator>& __x,\n  basic_stringbuf<_CharT, _Traits, _Allocator>& __y)\n    { __x.swap(__y); }\n\n\n  template <class _CharT, class _Traits, class _Allocator'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    swap(basic_istringstream<_CharT, _Traits, _Allocator>& __x,\n  basic_istringstream<_CharT, _Traits, _Allocator>& __y)\n    { __x.swap(__y); }\n\n\n  template <class _CharT, class _Traits, class _A'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    swap(basic_ostringstream<_CharT, _Traits, _Allocator>& __x,\n  basic_ostringstream<_CharT, _Traits, _Allocator>& __y)\n    { __x.swap(__y); }\n\n\n  template <class _CharT, class _Traits, class _A'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    swap(basic_stringstream<_CharT, _Traits, _Allocator>& __x,\n  basic_stringstream<_CharT, _Traits, _Allocator>& __y)\n    { __x.swap(__y); }\n\n\n}\n\n}\n\n# 1 "/usr/include/c++/7/bits/sstream.tcc" 1 3'
[#] parse_declaration, is_constructor=False, meet line: 'basic_stringbuf<_CharT, _Traits, _Alloc>::int_type\n    basic_stringbuf<_CharT, _Traits, _Alloc>::\n    pbackfail(int_type __c)\n    {\n      int_type __ret = traits_type::eof();\n      if (this->eback() <'
[#] parse_declaration, is_constructor=False, meet line: 'basic_stringbuf<_CharT, _Traits, _Alloc>::int_type\n    basic_stringbuf<_CharT, _Traits, _Alloc>::\n    overflow(int_type __c)\n    {\n      const bool __testout = this->_M_mode & ios_base::out;\n      if '
[#] parse_declaration, is_constructor=False, meet line: 'basic_stringbuf<_CharT, _Traits, _Alloc>::int_type\n    basic_stringbuf<_CharT, _Traits, _Alloc>::\n    underflow()\n    {\n      int_type __ret = traits_type::eof();\n      const bool __testin = this->_M_'
[#] parse_declaration, is_constructor=False, meet line: 'basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type\n    basic_stringbuf<_CharT, _Traits, _Alloc>::\n    seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __mode)\n    {\n      pos_type _'
[#] parse_declaration, is_constructor=False, meet line: 'basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type\n    basic_stringbuf<_CharT, _Traits, _Alloc>::\n    seekpos(pos_type __sp, ios_base::openmode __mode)\n    {\n      pos_type __ret = pos_type(off_type(-'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    basic_stringbuf<_CharT, _Traits, _Alloc>::\n    _M_sync(char_type* __base, __size_type __i, __size_type __o)\n    {\n      const bool __testin = _M_mode & ios_base::in;\n      const bool __testou'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    basic_stringbuf<_CharT, _Traits, _Alloc>::\n    _M_pbump(char_type* __pbeg, char_type* __pend, off_type __off)\n    {\n      this->setp(__pbeg, __pend);\n      while (__off > __gnu_cxx::__numeric'
[#] parse_declaration, is_constructor=False, meet line: 'template class basic_stringbuf<char>;\n  extern template class basic_istringstream<char>;\n  extern template class basic_ostringstream<char>;\n  extern template class basic_stringstream<char>;\n\n\n  extern'
[#] parse_declaration, is_constructor=False, meet line: 'template class basic_istringstream<char>;\n  extern template class basic_ostringstream<char>;\n  extern template class basic_stringstream<char>;\n\n\n  extern template class basic_stringbuf<wchar_t>;\n  ext'
[#] parse_declaration, is_constructor=False, meet line: 'template class basic_ostringstream<char>;\n  extern template class basic_stringstream<char>;\n\n\n  extern template class basic_stringbuf<wchar_t>;\n  extern template class basic_istringstream<wchar_t>;\n  '
[#] parse_declaration, is_constructor=False, meet line: 'template class basic_stringstream<char>;\n\n\n  extern template class basic_stringbuf<wchar_t>;\n  extern template class basic_istringstream<wchar_t>;\n  extern template class basic_ostringstream<wchar_t>;'
[#] parse_declaration, is_constructor=False, meet line: 'template class basic_stringbuf<wchar_t>;\n  extern template class basic_istringstream<wchar_t>;\n  extern template class basic_ostringstream<wchar_t>;\n  extern template class basic_stringstream<wchar_t>'
[#] parse_declaration, is_constructor=False, meet line: 'template class basic_istringstream<wchar_t>;\n  extern template class basic_ostringstream<wchar_t>;\n  extern template class basic_stringstream<wchar_t>;\n\n\n\n\n}\n# 827 "/usr/include/c++/7/sstream" 2 3\n# 4'
[#] parse_declaration, is_constructor=False, meet line: 'template class basic_ostringstream<wchar_t>;\n  extern template class basic_stringstream<wchar_t>;\n\n\n\n\n}\n# 827 "/usr/include/c++/7/sstream" 2 3\n# 47 "/usr/include/c++/7/regex" 2 3\n# 1 "/usr/include/c++'
[#] parse_declaration, is_constructor=False, meet line: 'template class basic_stringstream<wchar_t>;\n\n\n\n\n}\n# 827 "/usr/include/c++/7/sstream" 2 3\n# 47 "/usr/include/c++/7/regex" 2 3\n# 1 "/usr/include/c++/7/stack" 1 3\n# 58 "/usr/include/c++/7/stack" 3\n      '
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n  __deque_buf_size(size_t __size)\n  { return (__size < 512\n     ? size_t(512 / __size) : size_t(1)); }\n# 107 "/usr/include/c++/7/bits/stl_deque.h" 3\n  template<typename _Tp, typename _Ref, type'
[#] parse_declaration, is_constructor=False, meet line: 'size_t _S_buffer_size() noexcept\n      { return __deque_buf_size(sizeof(_Tp)); }\n\n      typedef std::random_access_iterator_tag iterator_category;\n      typedef _Tp value_type;\n      typedef _Ptr poin'
[#] parse_declaration, is_constructor=False, meet line: '_Elt_pointer _M_cur;\n      _Elt_pointer _M_first;\n      _Elt_pointer _M_last;\n      _Map_pointer _M_node;\n\n      _Deque_iterator(_Elt_pointer __x, _Map_pointer __y) noexcept\n      : _M_cur(__x), _M_fi'
[#] parse_declaration, is_constructor=False, meet line: '_Elt_pointer _M_first;\n      _Elt_pointer _M_last;\n      _Map_pointer _M_node;\n\n      _Deque_iterator(_Elt_pointer __x, _Map_pointer __y) noexcept\n      : _M_cur(__x), _M_first(*__y),\n _M_last(*__y + '
[#] parse_declaration, is_constructor=False, meet line: '_Elt_pointer _M_last;\n      _Map_pointer _M_node;\n\n      _Deque_iterator(_Elt_pointer __x, _Map_pointer __y) noexcept\n      : _M_cur(__x), _M_first(*__y),\n _M_last(*__y + _S_buffer_size()), _M_node(__'
[#] parse_declaration, is_constructor=False, meet line: '_Map_pointer _M_node;\n\n      _Deque_iterator(_Elt_pointer __x, _Map_pointer __y) noexcept\n      : _M_cur(__x), _M_first(*__y),\n _M_last(*__y + _S_buffer_size()), _M_node(__y) { }\n\n      _Deque_iterato'
[#] parse_declaration, is_constructor=True, meet line: '_Deque_iterator(_Elt_pointer __x, _Map_pointer __y) noexcept\n      : _M_cur(__x), _M_first(*__y),\n _M_last(*__y + _S_buffer_size()), _M_node(__y) { }\n\n      _Deque_iterator() noexcept\n      : _M_cur()'
[#] parse_declaration, is_constructor=True, meet line: '_Deque_iterator() noexcept\n      : _M_cur(), _M_first(), _M_last(), _M_node() { }\n\n      _Deque_iterator(const iterator& __x) noexcept\n      : _M_cur(__x._M_cur), _M_first(__x._M_first),\n _M_last(__x.'
[#] parse_declaration, is_constructor=True, meet line: '_Deque_iterator(const iterator& __x) noexcept\n      : _M_cur(__x._M_cur), _M_first(__x._M_first),\n _M_last(__x._M_last), _M_node(__x._M_node) { }\n\n      iterator\n      _M_const_cast() const noexcept\n '
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      _M_const_cast() const noexcept\n      { return iterator(_M_cur, _M_node); }\n\n      reference\n      operator*() const noexcept\n      { return *_M_cur; }\n\n      pointer\n      operator->() '
[#] parse_declaration, is_constructor=False, meet line: 'reference\n      operator*() const noexcept\n      { return *_M_cur; }\n\n      pointer\n      operator->() const noexcept\n      { return _M_cur; }\n\n      _Self&\n      operator++() noexcept\n      {\n ++_M_c'
[#] parse_declaration, is_constructor=False, meet line: 'pointer\n      operator->() const noexcept\n      { return _M_cur; }\n\n      _Self&\n      operator++() noexcept\n      {\n ++_M_cur;\n if (_M_cur == _M_last)\n   {\n     _M_set_node(_M_node + 1);\n     _M_cur '
[#] parse_declaration, is_constructor=False, meet line: '_Self&\n      operator++() noexcept\n      {\n ++_M_cur;\n if (_M_cur == _M_last)\n   {\n     _M_set_node(_M_node + 1);\n     _M_cur = _M_first;\n   }\n return *this;\n      }\n\n      _Self\n      operator++(int)'
[#] parse_declaration, is_constructor=False, meet line: '_Self\n      operator++(int) noexcept\n      {\n _Self __tmp = *this;\n ++*this;\n return __tmp;\n      }\n\n      _Self&\n      operator--() noexcept\n      {\n if (_M_cur == _M_first)\n   {\n     _M_set_node(_M_'
[#] parse_declaration, is_constructor=False, meet line: '_Self&\n      operator--() noexcept\n      {\n if (_M_cur == _M_first)\n   {\n     _M_set_node(_M_node - 1);\n     _M_cur = _M_last;\n   }\n --_M_cur;\n return *this;\n      }\n\n      _Self\n      operator--(int)'
[#] parse_declaration, is_constructor=False, meet line: '_Self\n      operator--(int) noexcept\n      {\n _Self __tmp = *this;\n --*this;\n return __tmp;\n      }\n\n      _Self&\n      operator+=(difference_type __n) noexcept\n      {\n const difference_type __offset'
[#] parse_declaration, is_constructor=False, meet line: '_Self&\n      operator+=(difference_type __n) noexcept\n      {\n const difference_type __offset = __n + (_M_cur - _M_first);\n if (__offset >= 0 && __offset < difference_type(_S_buffer_size()))\n   _M_cur'
[#] parse_declaration, is_constructor=False, meet line: '_Self\n      operator+(difference_type __n) const noexcept\n      {\n _Self __tmp = *this;\n return __tmp += __n;\n      }\n\n      _Self&\n      operator-=(difference_type __n) noexcept\n      { return *this '
[#] parse_declaration, is_constructor=False, meet line: '_Self&\n      operator-=(difference_type __n) noexcept\n      { return *this += -__n; }\n\n      _Self\n      operator-(difference_type __n) const noexcept\n      {\n _Self __tmp = *this;\n return __tmp -= __'
[#] parse_declaration, is_constructor=False, meet line: '_Self\n      operator-(difference_type __n) const noexcept\n      {\n _Self __tmp = *this;\n return __tmp -= __n;\n      }\n\n      reference\n      operator[](difference_type __n) const noexcept\n      { retu'
[#] parse_declaration, is_constructor=False, meet line: 'reference\n      operator[](difference_type __n) const noexcept\n      { return *(*this + __n); }\n\n\n\n\n\n\n      void\n      _M_set_node(_Map_pointer __new_node) noexcept\n      {\n _M_node = __new_node;\n _M_'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_set_node(_Map_pointer __new_node) noexcept\n      {\n _M_node = __new_node;\n _M_first = *__new_node;\n _M_last = _M_first + difference_type(_S_buffer_size());\n      }\n    };\n\n\n\n\n  template<'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,\n        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) noexcept\n    { return __x._M_cur == __y._M_cur; }\n\n  template<typename _Tp, typena'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator==(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) noexcept\n    { return __x._M_cur == __y._M_cur; }\n\n  template<typename _Tp, ty'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator!=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,\n        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) noexcept\n    { return !(__x == __y); }\n\n  template<typename _Tp, typename _RefL, t'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator!=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) noexcept\n    { return !(__x == __y); }\n\n  template<typename _Tp, typename _Ref'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,\n       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) noexcept\n    { return (__x._M_node == __y._M_node) ? (__x._M_cur < __y._M_cur)\n     '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) noexcept\n    { return (__x._M_node == __y._M_node) ? (__x._M_cur < __y._M_cur)\n '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,\n       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) noexcept\n    { return __y < __x; }\n\n  template<typename _Tp, typename _RefL, typenam'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) noexcept\n    { return __y < __x; }\n\n  template<typename _Tp, typename _Ref, type'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,\n        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) noexcept\n    { return !(__y < __x); }\n\n  template<typename _Tp, typename _RefL, ty'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) noexcept\n    { return !(__y < __x); }\n\n  template<typename _Tp, typename _Ref,'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,\n        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) noexcept\n    { return !(__x < __y); }\n\n  template<typename _Tp, typename _RefL, ty'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) noexcept\n    { return !(__x < __y); }\n\n\n\n\n\n  template<typename _Tp, typename _'
[#] parse_declaration, is_constructor=False, meet line: '_Deque_iterator<_Tp, _Ref, _Ptr>::difference_type\n    operator-(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,\n       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) noexcept\n    {\n      return typename _D'
[#] parse_declaration, is_constructor=False, meet line: '_Deque_iterator<_Tp, _RefL, _PtrL>::difference_type\n    operator-(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) noexcept\n    {\n      return typen'
[#] parse_declaration, is_constructor=False, meet line: '_Deque_iterator<_Tp, _Ref, _Ptr>\n    operator+(ptrdiff_t __n, const _Deque_iterator<_Tp, _Ref, _Ptr>& __x)\n    noexcept\n    { return __x + __n; }\n\n  template<typename _Tp>\n    void\n    fill(const _Deq'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    fill(const _Deque_iterator<_Tp, _Tp&, _Tp*>&,\n  const _Deque_iterator<_Tp, _Tp&, _Tp*>&, const _Tp&);\n\n  template<typename _Tp>\n    _Deque_iterator<_Tp, _Tp&, _Tp*>\n    copy(_Deque_iterator<_'
[#] parse_declaration, is_constructor=False, meet line: '_Deque_iterator<_Tp, _Tp&, _Tp*>\n    copy(_Deque_iterator<_Tp, const _Tp&, const _Tp*>,\n  _Deque_iterator<_Tp, const _Tp&, const _Tp*>,\n  _Deque_iterator<_Tp, _Tp&, _Tp*>);\n\n  template<typename _Tp>\n '
[#] parse_declaration, is_constructor=False, meet line: '_Deque_iterator<_Tp, _Tp&, _Tp*>\n    copy(_Deque_iterator<_Tp, _Tp&, _Tp*> __first,\n  _Deque_iterator<_Tp, _Tp&, _Tp*> __last,\n  _Deque_iterator<_Tp, _Tp&, _Tp*> __result)\n    { return std::copy(_Dequ'
[#] parse_declaration, is_constructor=False, meet line: '_Deque_iterator<_Tp, _Tp&, _Tp*>\n    copy_backward(_Deque_iterator<_Tp, const _Tp&, const _Tp*>,\n    _Deque_iterator<_Tp, const _Tp&, const _Tp*>,\n    _Deque_iterator<_Tp, _Tp&, _Tp*>);\n\n  template<ty'
[#] parse_declaration, is_constructor=False, meet line: '_Deque_iterator<_Tp, _Tp&, _Tp*>\n    copy_backward(_Deque_iterator<_Tp, _Tp&, _Tp*> __first,\n    _Deque_iterator<_Tp, _Tp&, _Tp*> __last,\n    _Deque_iterator<_Tp, _Tp&, _Tp*> __result)\n    { return st'
[#] parse_declaration, is_constructor=False, meet line: '_Deque_iterator<_Tp, _Tp&, _Tp*>\n    move(_Deque_iterator<_Tp, const _Tp&, const _Tp*>,\n  _Deque_iterator<_Tp, const _Tp&, const _Tp*>,\n  _Deque_iterator<_Tp, _Tp&, _Tp*>);\n\n  template<typename _Tp>\n '
[#] parse_declaration, is_constructor=False, meet line: '_Deque_iterator<_Tp, _Tp&, _Tp*>\n    move(_Deque_iterator<_Tp, _Tp&, _Tp*> __first,\n  _Deque_iterator<_Tp, _Tp&, _Tp*> __last,\n  _Deque_iterator<_Tp, _Tp&, _Tp*> __result)\n    { return std::move(_Dequ'
[#] parse_declaration, is_constructor=False, meet line: '_Deque_iterator<_Tp, _Tp&, _Tp*>\n    move_backward(_Deque_iterator<_Tp, const _Tp&, const _Tp*>,\n    _Deque_iterator<_Tp, const _Tp&, const _Tp*>,\n    _Deque_iterator<_Tp, _Tp&, _Tp*>);\n\n  template<ty'
[#] parse_declaration, is_constructor=False, meet line: '_Deque_iterator<_Tp, _Tp&, _Tp*>\n    move_backward(_Deque_iterator<_Tp, _Tp&, _Tp*> __first,\n    _Deque_iterator<_Tp, _Tp&, _Tp*> __last,\n    _Deque_iterator<_Tp, _Tp&, _Tp*> __result)\n    { return st'
[#] parse_declaration, is_constructor=False, meet line: 'allocator_type\n      get_allocator() const noexcept\n      { return allocator_type(_M_get_Tp_allocator()); }\n\n      typedef _Deque_iterator<_Tp, _Tp&, _Ptr> iterator;\n      typedef _Deque_iterator<_Tp,'
[#] parse_declaration, is_constructor=True, meet line: '_Deque_base()\n      : _M_impl()\n      { _M_initialize_map(0); }\n\n      _Deque_base(size_t __num_elements)\n      : _M_impl()\n      { _M_initialize_map(__num_elements); }\n\n      _Deque_base(const alloca'
[#] parse_declaration, is_constructor=True, meet line: '_Deque_base(size_t __num_elements)\n      : _M_impl()\n      { _M_initialize_map(__num_elements); }\n\n      _Deque_base(const allocator_type& __a, size_t __num_elements)\n      : _M_impl(__a)\n      { _M_i'
[#] parse_declaration, is_constructor=True, meet line: '_Deque_base(const allocator_type& __a, size_t __num_elements)\n      : _M_impl(__a)\n      { _M_initialize_map(__num_elements); }\n\n      _Deque_base(const allocator_type& __a)\n      : _M_impl(__a)\n     '
[#] parse_declaration, is_constructor=True, meet line: '_Deque_base(const allocator_type& __a)\n      : _M_impl(__a)\n      { }\n\n\n      _Deque_base(_Deque_base&& __x, false_type)\n      : _M_impl(__x._M_move_impl())\n      { }\n\n      _Deque_base(_Deque_base&& '
[#] parse_declaration, is_constructor=True, meet line: '_Deque_base(_Deque_base&& __x, false_type)\n      : _M_impl(__x._M_move_impl())\n      { }\n\n      _Deque_base(_Deque_base&& __x, true_type)\n      : _M_impl(std::move(__x._M_get_Tp_allocator()))\n      {\n'
[#] parse_declaration, is_constructor=True, meet line: '_Deque_base(_Deque_base&& __x, true_type)\n      : _M_impl(std::move(__x._M_get_Tp_allocator()))\n      {\n _M_initialize_map(0);\n if (__x._M_impl._M_map)\n   this->_M_impl._M_swap_data(__x._M_impl);\n    '
[#] parse_declaration, is_constructor=True, meet line: '_Deque_base(_Deque_base&& __x)\n      : _Deque_base(std::move(__x), typename _Alloc_traits::is_always_equal{})\n      { }\n\n      _Deque_base(_Deque_base&& __x, const allocator_type& __a, size_type __n)\n'
[#] parse_declaration, is_constructor=True, meet line: '_Deque_base(_Deque_base&& __x, const allocator_type& __a, size_type __n)\n      : _M_impl(__a)\n      {\n if (__x.get_allocator() == __a)\n   {\n     if (__x._M_impl._M_map)\n       {\n  _M_initialize_map(0)'
[#] parse_declaration, is_constructor=True, meet line: '_Deque_base() noexcept;\n\n    protected:\n      typedef typename iterator::_Map_pointer _Map_pointer;\n\n\n\n\n      struct _Deque_impl\n      : public _Tp_alloc_type\n      {\n _Map_pointer _M_map;\n size_t _M_'
[#] parse_declaration, is_constructor=False, meet line: '_Map_pointer _M_map;\n size_t _M_map_size;\n iterator _M_start;\n iterator _M_finish;\n\n _Deque_impl()\n : _Tp_alloc_type(), _M_map(), _M_map_size(0),\n   _M_start(), _M_finish()\n { }\n\n _Deque_impl(const _T'
[#] parse_declaration, is_constructor=False, meet line: 'size_t _M_map_size;\n iterator _M_start;\n iterator _M_finish;\n\n _Deque_impl()\n : _Tp_alloc_type(), _M_map(), _M_map_size(0),\n   _M_start(), _M_finish()\n { }\n\n _Deque_impl(const _Tp_alloc_type& __a) noe'
[#] parse_declaration, is_constructor=False, meet line: 'iterator _M_start;\n iterator _M_finish;\n\n _Deque_impl()\n : _Tp_alloc_type(), _M_map(), _M_map_size(0),\n   _M_start(), _M_finish()\n { }\n\n _Deque_impl(const _Tp_alloc_type& __a) noexcept\n : _Tp_alloc_ty'
[#] parse_declaration, is_constructor=False, meet line: 'iterator _M_finish;\n\n _Deque_impl()\n : _Tp_alloc_type(), _M_map(), _M_map_size(0),\n   _M_start(), _M_finish()\n { }\n\n _Deque_impl(const _Tp_alloc_type& __a) noexcept\n : _Tp_alloc_type(__a), _M_map(), _'
[#] parse_declaration, is_constructor=True, meet line: '_Deque_impl()\n : _Tp_alloc_type(), _M_map(), _M_map_size(0),\n   _M_start(), _M_finish()\n { }\n\n _Deque_impl(const _Tp_alloc_type& __a) noexcept\n : _Tp_alloc_type(__a), _M_map(), _M_map_size(0),\n   _M_s'
[#] parse_declaration, is_constructor=True, meet line: '_Deque_impl(const _Tp_alloc_type& __a) noexcept\n : _Tp_alloc_type(__a), _M_map(), _M_map_size(0),\n   _M_start(), _M_finish()\n { }\n\n\n _Deque_impl(_Deque_impl&&) = default;\n\n _Deque_impl(_Tp_alloc_type&'
[#] parse_declaration, is_constructor=True, meet line: '_Deque_impl(_Deque_impl&&) = default;\n\n _Deque_impl(_Tp_alloc_type&& __a) noexcept\n : _Tp_alloc_type(std::move(__a)), _M_map(), _M_map_size(0),\n   _M_start(), _M_finish()\n { }\n\n\n void _M_swap_data(_De'
[#] parse_declaration, is_constructor=True, meet line: '_Deque_impl(_Tp_alloc_type&& __a) noexcept\n : _Tp_alloc_type(std::move(__a)), _M_map(), _M_map_size(0),\n   _M_start(), _M_finish()\n { }\n\n\n void _M_swap_data(_Deque_impl& __x) noexcept\n {\n   using std:'
[#] parse_declaration, is_constructor=False, meet line: 'void _M_swap_data(_Deque_impl& __x) noexcept\n {\n   using std::swap;\n   swap(this->_M_start, __x._M_start);\n   swap(this->_M_finish, __x._M_finish);\n   swap(this->_M_map, __x._M_map);\n   swap(this->_M_'
[#] parse_declaration, is_constructor=False, meet line: '_Tp_alloc_type&\n      _M_get_Tp_allocator() noexcept\n      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }\n\n      const _Tp_alloc_type&\n      _M_get_Tp_allocator() const noexcept\n      { ret'
[#] parse_declaration, is_constructor=False, meet line: '_Tp_alloc_type&\n      _M_get_Tp_allocator() const noexcept\n      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }\n\n      _Map_alloc_type\n      _M_get_map_allocator() const noexcept\n    '
[#] parse_declaration, is_constructor=False, meet line: '_Map_alloc_type\n      _M_get_map_allocator() const noexcept\n      { return _Map_alloc_type(_M_get_Tp_allocator()); }\n\n      _Ptr\n      _M_allocate_node()\n      {\n typedef __gnu_cxx::__alloc_traits<_Tp'
[#] parse_declaration, is_constructor=False, meet line: '_Ptr\n      _M_allocate_node()\n      {\n typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Traits;\n return _Traits::allocate(_M_impl, __deque_buf_size(sizeof(_Tp)));\n      }\n\n      void\n      _M_deallo'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_deallocate_node(_Ptr __p) noexcept\n      {\n typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Traits;\n _Traits::deallocate(_M_impl, __p, __deque_buf_size(sizeof(_Tp)));\n      }\n\n      _'
[#] parse_declaration, is_constructor=False, meet line: '_Map_pointer\n      _M_allocate_map(size_t __n)\n      {\n _Map_alloc_type __map_alloc = _M_get_map_allocator();\n return _Map_alloc_traits::allocate(__map_alloc, __n);\n      }\n\n      void\n      _M_deallo'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_deallocate_map(_Map_pointer __p, size_t __n) noexcept\n      {\n _Map_alloc_type __map_alloc = _M_get_map_allocator();\n _Map_alloc_traits::deallocate(__map_alloc, __p, __n);\n      }\n\n    p'
[#] parse_declaration, is_constructor=False, meet line: 'void _M_initialize_map(size_t);\n      void _M_create_nodes(_Map_pointer __nstart, _Map_pointer __nfinish);\n      void _M_destroy_nodes(_Map_pointer __nstart,\n       _Map_pointer __nfinish) noexcept;\n '
[#] parse_declaration, is_constructor=False, meet line: 'void _M_create_nodes(_Map_pointer __nstart, _Map_pointer __nfinish);\n      void _M_destroy_nodes(_Map_pointer __nstart,\n       _Map_pointer __nfinish) noexcept;\n      enum { _S_initial_map_size = 8 };'
[#] parse_declaration, is_constructor=False, meet line: 'void _M_destroy_nodes(_Map_pointer __nstart,\n       _Map_pointer __nfinish) noexcept;\n      enum { _S_initial_map_size = 8 };\n\n      _Deque_impl _M_impl;\n\n\n    private:\n      _Deque_impl\n      _M_move'
[#] parse_declaration, is_constructor=False, meet line: '_Deque_impl _M_impl;\n\n\n    private:\n      _Deque_impl\n      _M_move_impl()\n      {\n if (!_M_impl._M_map)\n   return std::move(_M_impl);\n\n\n _Tp_alloc_type __alloc{_M_get_Tp_allocator()};\n\n _Tp_alloc_typ'
[#] parse_declaration, is_constructor=False, meet line: '_Deque_impl\n      _M_move_impl()\n      {\n if (!_M_impl._M_map)\n   return std::move(_M_impl);\n\n\n _Tp_alloc_type __alloc{_M_get_Tp_allocator()};\n\n _Tp_alloc_type __sink __attribute((__unused__)) {std::m'
[#] parse_declaration, is_constructor=False, meet line: '_Deque_base<_Tp, _Alloc>::\n    ~_Deque_base() noexcept\n    {\n      if (this->_M_impl._M_map)\n {\n   _M_destroy_nodes(this->_M_impl._M_start._M_node,\n      this->_M_impl._M_finish._M_node + 1);\n   _M_de'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _Deque_base<_Tp, _Alloc>::\n    _M_initialize_map(size_t __num_elements)\n    {\n      const size_t __num_nodes = (__num_elements/ __deque_buf_size(sizeof(_Tp))\n      + 1);\n\n      this->_M_impl.'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _Deque_base<_Tp, _Alloc>::\n    _M_create_nodes(_Map_pointer __nstart, _Map_pointer __nfinish)\n    {\n      _Map_pointer __cur;\n      try\n {\n   for (__cur = __nstart; __cur < __nfinish; ++__cur'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _Deque_base<_Tp, _Alloc>::\n    _M_destroy_nodes(_Map_pointer __nstart,\n       _Map_pointer __nfinish) noexcept\n    {\n      for (_Map_pointer __n = __nstart; __n < __nfinish; ++__n)\n _M_deallo'
[#] parse_declaration, is_constructor=False, meet line: 'size_t _S_buffer_size() noexcept\n      { return __deque_buf_size(sizeof(_Tp)); }\n\n\n      using _Base::_M_initialize_map;\n      using _Base::_M_create_nodes;\n      using _Base::_M_destroy_nodes;\n      '
[#] parse_declaration, is_constructor=True, meet line: 'deque() : _Base() { }\n\n\n\n\n\n      explicit\n      deque(const allocator_type& __a)\n      : _Base(__a, 0) { }\n# 907 "/usr/include/c++/7/bits/stl_deque.h" 3\n      explicit\n      deque(size_type __n, const'
[#] parse_declaration, is_constructor=True, meet line: 'deque(const allocator_type& __a)\n      : _Base(__a, 0) { }\n# 907 "/usr/include/c++/7/bits/stl_deque.h" 3\n      explicit\n      deque(size_type __n, const allocator_type& __a = allocator_type())\n      :'
[#] parse_declaration, is_constructor=True, meet line: 'deque(size_type __n, const allocator_type& __a = allocator_type())\n      : _Base(__a, __n)\n      { _M_default_initialize(); }\n# 920 "/usr/include/c++/7/bits/stl_deque.h" 3\n      deque(size_type __n, c'
[#] parse_declaration, is_constructor=True, meet line: 'deque(size_type __n, const value_type& __value,\n     const allocator_type& __a = allocator_type())\n      : _Base(__a, __n)\n      { _M_fill_initialize(__value); }\n# 947 "/usr/include/c++/7/bits/stl_deq'
[#] parse_declaration, is_constructor=True, meet line: 'deque(const deque& __x)\n      : _Base(_Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()),\n       __x.size())\n      { std::__uninitialized_copy_a(__x.begin(), __x.end(),\n        this->_M_impl.'
[#] parse_declaration, is_constructor=True, meet line: 'deque(deque&& __x)\n      : _Base(std::move(__x)) { }\n\n\n      deque(const deque& __x, const allocator_type& __a)\n      : _Base(__a, __x.size())\n      { std::__uninitialized_copy_a(__x.begin(), __x.end('
[#] parse_declaration, is_constructor=True, meet line: 'deque(const deque& __x, const allocator_type& __a)\n      : _Base(__a, __x.size())\n      { std::__uninitialized_copy_a(__x.begin(), __x.end(),\n        this->_M_impl._M_start,\n        _M_get_Tp_allocato'
[#] parse_declaration, is_constructor=True, meet line: 'deque(deque&& __x, const allocator_type& __a)\n      : _Base(std::move(__x), __a, __x.size())\n      {\n if (__x.get_allocator() != __a)\n   {\n     std::__uninitialized_move_a(__x.begin(), __x.end(),\n    '
[#] parse_declaration, is_constructor=True, meet line: 'deque(initializer_list<value_type> __l,\n     const allocator_type& __a = allocator_type())\n      : _Base(__a)\n      {\n _M_range_initialize(__l.begin(), __l.end(),\n       random_access_iterator_tag());'
[#] parse_declaration, is_constructor=True, meet line: 'deque(_InputIterator __first, _InputIterator __last,\n       const allocator_type& __a = allocator_type())\n : _Base(__a)\n { _M_initialize_dispatch(__first, __last, __false_type()); }\n# 1044 "/usr/inclu'
[#] parse_declaration, is_constructor=True, meet line: 'deque()\n      { _M_destroy_data(begin(), end(), _M_get_Tp_allocator()); }\n# 1056 "/usr/include/c++/7/bits/stl_deque.h" 3\n      deque&\n      operator=(const deque& __x);\n# 1068 "/usr/include/c++/7/bits'
[#] parse_declaration, is_constructor=True, meet line: 'deque&\n      operator=(const deque& __x);\n# 1068 "/usr/include/c++/7/bits/stl_deque.h" 3\n      deque&\n      operator=(deque&& __x) noexcept(_Alloc_traits::_S_always_equal())\n      {\n using __always_eq'
[#] parse_declaration, is_constructor=True, meet line: 'deque&\n      operator=(deque&& __x) noexcept(_Alloc_traits::_S_always_equal())\n      {\n using __always_equal = typename _Alloc_traits::is_always_equal;\n _M_move_assign1(std::move(__x), __always_equal{'
[#] parse_declaration, is_constructor=True, meet line: 'deque&\n      operator=(initializer_list<value_type> __l)\n      {\n _M_assign_aux(__l.begin(), __l.end(),\n        random_access_iterator_tag());\n return *this;\n      }\n# 1106 "/usr/include/c++/7/bits/st'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      assign(size_type __n, const value_type& __val)\n      { _M_fill_assign(__n, __val); }\n# 1123 "/usr/include/c++/7/bits/stl_deque.h" 3\n      template<typename _InputIterator,\n        typename '
[#] parse_declaration, is_constructor=False, meet line: 'void\n assign(_InputIterator __first, _InputIterator __last)\n { _M_assign_dispatch(__first, __last, __false_type()); }\n# 1150 "/usr/include/c++/7/bits/stl_deque.h" 3\n      void\n      assign(initializer'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      assign(initializer_list<value_type> __l)\n      { _M_assign_aux(__l.begin(), __l.end(), random_access_iterator_tag()); }\n\n\n\n      allocator_type\n      get_allocator() const noexcept\n      { '
[#] parse_declaration, is_constructor=False, meet line: 'allocator_type\n      get_allocator() const noexcept\n      { return _Base::get_allocator(); }\n\n\n\n\n\n\n      iterator\n      begin() noexcept\n      { return this->_M_impl._M_start; }\n\n\n\n\n\n      const_itera'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      begin() noexcept\n      { return this->_M_impl._M_start; }\n\n\n\n\n\n      const_iterator\n      begin() const noexcept\n      { return this->_M_impl._M_start; }\n\n\n\n\n\n\n      iterator\n      end('
[#] parse_declaration, is_constructor=False, meet line: 'const_iterator\n      begin() const noexcept\n      { return this->_M_impl._M_start; }\n\n\n\n\n\n\n      iterator\n      end() noexcept\n      { return this->_M_impl._M_finish; }\n\n\n\n\n\n\n      const_iterator\n    '
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      end() noexcept\n      { return this->_M_impl._M_finish; }\n\n\n\n\n\n\n      const_iterator\n      end() const noexcept\n      { return this->_M_impl._M_finish; }\n\n\n\n\n\n\n      reverse_iterator\n   '
[#] parse_declaration, is_constructor=False, meet line: 'const_iterator\n      end() const noexcept\n      { return this->_M_impl._M_finish; }\n\n\n\n\n\n\n      reverse_iterator\n      rbegin() noexcept\n      { return reverse_iterator(this->_M_impl._M_finish); }\n\n\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'reverse_iterator\n      rbegin() noexcept\n      { return reverse_iterator(this->_M_impl._M_finish); }\n\n\n\n\n\n\n      const_reverse_iterator\n      rbegin() const noexcept\n      { return const_reverse_itera'
[#] parse_declaration, is_constructor=False, meet line: 'const_reverse_iterator\n      rbegin() const noexcept\n      { return const_reverse_iterator(this->_M_impl._M_finish); }\n\n\n\n\n\n\n      reverse_iterator\n      rend() noexcept\n      { return reverse_iterato'
[#] parse_declaration, is_constructor=False, meet line: 'reverse_iterator\n      rend() noexcept\n      { return reverse_iterator(this->_M_impl._M_start); }\n\n\n\n\n\n\n      const_reverse_iterator\n      rend() const noexcept\n      { return const_reverse_iterator(t'
[#] parse_declaration, is_constructor=False, meet line: 'const_reverse_iterator\n      rend() const noexcept\n      { return const_reverse_iterator(this->_M_impl._M_start); }\n\n\n\n\n\n\n      const_iterator\n      cbegin() const noexcept\n      { return this->_M_imp'
[#] parse_declaration, is_constructor=False, meet line: 'const_iterator\n      cbegin() const noexcept\n      { return this->_M_impl._M_start; }\n\n\n\n\n\n\n      const_iterator\n      cend() const noexcept\n      { return this->_M_impl._M_finish; }\n\n\n\n\n\n\n      const'
[#] parse_declaration, is_constructor=False, meet line: 'const_iterator\n      cend() const noexcept\n      { return this->_M_impl._M_finish; }\n\n\n\n\n\n\n      const_reverse_iterator\n      crbegin() const noexcept\n      { return const_reverse_iterator(this->_M_im'
[#] parse_declaration, is_constructor=False, meet line: 'const_reverse_iterator\n      crbegin() const noexcept\n      { return const_reverse_iterator(this->_M_impl._M_finish); }\n\n\n\n\n\n\n      const_reverse_iterator\n      crend() const noexcept\n      { return c'
[#] parse_declaration, is_constructor=False, meet line: 'const_reverse_iterator\n      crend() const noexcept\n      { return const_reverse_iterator(this->_M_impl._M_start); }\n\n\n\n\n      size_type\n      size() const noexcept\n      { return this->_M_impl._M_fin'
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      size() const noexcept\n      { return this->_M_impl._M_finish - this->_M_impl._M_start; }\n\n\n      size_type\n      max_size() const noexcept\n      { return _Alloc_traits::max_size(_M_get'
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      max_size() const noexcept\n      { return _Alloc_traits::max_size(_M_get_Tp_allocator()); }\n# 1289 "/usr/include/c++/7/bits/stl_deque.h" 3\n      void\n      resize(size_type __new_size)\n'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      resize(size_type __new_size)\n      {\n const size_type __len = size();\n if (__new_size > __len)\n   _M_default_append(__new_size - __len);\n else if (__new_size < __len)\n   _M_erase_at_end(thi'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      resize(size_type __new_size, const value_type& __x)\n      {\n const size_type __len = size();\n if (__new_size > __len)\n   _M_fill_insert(this->_M_impl._M_finish, __new_size - __len, __x);\n e'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      shrink_to_fit() noexcept\n      { _M_shrink_to_fit(); }\n\n\n\n\n\n\n      bool\n      empty() const noexcept\n      { return this->_M_impl._M_finish == this->_M_impl._M_start; }\n# 1372 "/usr/include'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      empty() const noexcept\n      { return this->_M_impl._M_finish == this->_M_impl._M_start; }\n# 1372 "/usr/include/c++/7/bits/stl_deque.h" 3\n      reference\n      operator[](size_type __n) noe'
[#] parse_declaration, is_constructor=False, meet line: 'reference\n      operator[](size_type __n) noexcept\n      {\n ;\n return this->_M_impl._M_start[difference_type(__n)];\n      }\n# 1390 "/usr/include/c++/7/bits/stl_deque.h" 3\n      const_reference\n      o'
[#] parse_declaration, is_constructor=False, meet line: 'const_reference\n      operator[](size_type __n) const noexcept\n      {\n ;\n return this->_M_impl._M_start[difference_type(__n)];\n      }\n\n    protected:\n\n      void\n      _M_range_check(size_type __n) '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_range_check(size_type __n) const\n      {\n if (__n >= this->size())\n   __throw_out_of_range_fmt(("deque::_M_range_check: __n " "(which is %zu)>= this->size() " "(which is %zu)")\n\n        '
[#] parse_declaration, is_constructor=False, meet line: 'reference\n      at(size_type __n)\n      {\n _M_range_check(__n);\n return (*this)[__n];\n      }\n# 1439 "/usr/include/c++/7/bits/stl_deque.h" 3\n      const_reference\n      at(size_type __n) const\n      {'
[#] parse_declaration, is_constructor=False, meet line: 'const_reference\n      at(size_type __n) const\n      {\n _M_range_check(__n);\n return (*this)[__n];\n      }\n\n\n\n\n\n      reference\n      front() noexcept\n      {\n ;\n return *begin();\n      }\n\n\n\n\n\n      co'
[#] parse_declaration, is_constructor=False, meet line: 'reference\n      front() noexcept\n      {\n ;\n return *begin();\n      }\n\n\n\n\n\n      const_reference\n      front() const noexcept\n      {\n ;\n return *begin();\n      }\n\n\n\n\n\n      reference\n      back() noe'
[#] parse_declaration, is_constructor=False, meet line: 'const_reference\n      front() const noexcept\n      {\n ;\n return *begin();\n      }\n\n\n\n\n\n      reference\n      back() noexcept\n      {\n ;\n iterator __tmp = end();\n --__tmp;\n return *__tmp;\n      }\n\n\n\n\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'reference\n      back() noexcept\n      {\n ;\n iterator __tmp = end();\n --__tmp;\n return *__tmp;\n      }\n\n\n\n\n\n      const_reference\n      back() const noexcept\n      {\n ;\n const_iterator __tmp = end();\n '
[#] parse_declaration, is_constructor=False, meet line: 'const_reference\n      back() const noexcept\n      {\n ;\n const_iterator __tmp = end();\n --__tmp;\n return *__tmp;\n      }\n# 1504 "/usr/include/c++/7/bits/stl_deque.h" 3\n      void\n      push_front(const'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      push_front(const value_type& __x)\n      {\n if (this->_M_impl._M_start._M_cur != this->_M_impl._M_start._M_first)\n   {\n     _Alloc_traits::construct(this->_M_impl,\n         this->_M_impl._M_'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      push_front(value_type&& __x)\n      { emplace_front(std::move(__x)); }\n\n      template<typename... _Args>\n\n\n\n void\n\n emplace_front(_Args&&... __args);\n# 1541 "/usr/include/c++/7/bits/stl_deq'
[#] parse_declaration, is_constructor=False, meet line: 'void\n\n emplace_front(_Args&&... __args);\n# 1541 "/usr/include/c++/7/bits/stl_deque.h" 3\n      void\n      push_back(const value_type& __x)\n      {\n if (this->_M_impl._M_finish._M_cur\n     != this->_M_i'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      push_back(const value_type& __x)\n      {\n if (this->_M_impl._M_finish._M_cur\n     != this->_M_impl._M_finish._M_last - 1)\n   {\n     _Alloc_traits::construct(this->_M_impl,\n         this->_M'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      push_back(value_type&& __x)\n      { emplace_back(std::move(__x)); }\n\n      template<typename... _Args>\n\n\n\n void\n\n emplace_back(_Args&&... __args);\n# 1577 "/usr/include/c++/7/bits/stl_deque.'
[#] parse_declaration, is_constructor=False, meet line: 'void\n\n emplace_back(_Args&&... __args);\n# 1577 "/usr/include/c++/7/bits/stl_deque.h" 3\n      void\n      pop_front() noexcept\n      {\n ;\n if (this->_M_impl._M_start._M_cur\n     != this->_M_impl._M_star'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      pop_front() noexcept\n      {\n ;\n if (this->_M_impl._M_start._M_cur\n     != this->_M_impl._M_start._M_last - 1)\n   {\n     _Alloc_traits::destroy(this->_M_impl,\n       this->_M_impl._M_start.'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      pop_back() noexcept\n      {\n ;\n if (this->_M_impl._M_finish._M_cur\n     != this->_M_impl._M_finish._M_first)\n   {\n     --this->_M_impl._M_finish._M_cur;\n     _Alloc_traits::destroy(this->_M'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n emplace(const_iterator __position, _Args&&... __args);\n# 1638 "/usr/include/c++/7/bits/stl_deque.h" 3\n      iterator\n      insert(const_iterator __position, const value_type& __x);\n# 1664 "/'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      insert(const_iterator __position, const value_type& __x);\n# 1664 "/usr/include/c++/7/bits/stl_deque.h" 3\n      iterator\n      insert(const_iterator __position, value_type&& __x)\n      {'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      insert(const_iterator __position, value_type&& __x)\n      { return emplace(__position, std::move(__x)); }\n# 1677 "/usr/include/c++/7/bits/stl_deque.h" 3\n      iterator\n      insert(cons'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      insert(const_iterator __p, initializer_list<value_type> __l)\n      {\n auto __offset = __p - cbegin();\n _M_range_insert_aux(__p._M_const_cast(), __l.begin(), __l.end(),\n       std::rando'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      insert(const_iterator __position, size_type __n, const value_type& __x)\n      {\n difference_type __offset = __position - cbegin();\n _M_fill_insert(__position._M_const_cast(), __n, __x);'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n insert(const_iterator __position, _InputIterator __first,\n        _InputIterator __last)\n {\n   difference_type __offset = __position - cbegin();\n   _M_insert_dispatch(__position._M_const_cas'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n\n      erase(const_iterator __position)\n\n\n\n      { return _M_erase(__position._M_const_cast()); }\n# 1802 "/usr/include/c++/7/bits/stl_deque.h" 3\n      iterator\n\n      erase(const_iterator __f'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n\n      erase(const_iterator __first, const_iterator __last)\n\n\n\n      { return _M_erase(__first._M_const_cast(), __last._M_const_cast()); }\n# 1821 "/usr/include/c++/7/bits/stl_deque.h" 3\n     '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      swap(deque& __x) noexcept\n      {\n\n\n                                                          ;\n\n _M_impl._M_swap_data(__x._M_impl);\n _Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),\n      '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      clear() noexcept\n      { _M_erase_at_end(begin()); }\n\n    protected:\n\n\n\n\n\n\n      template<typename _Integer>\n void\n _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)\n {\n   _M_'
[#] parse_declaration, is_constructor=False, meet line: 'void\n _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)\n {\n   _M_initialize_map(static_cast<size_type>(__n));\n   _M_fill_initialize(__x);\n }\n\n\n      template<typename _InputIterator>\n vo'
[#] parse_declaration, is_constructor=False, meet line: 'void\n _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,\n          __false_type)\n {\n   _M_range_initialize(__first, __last,\n         std::__iterator_category(__first));\n }\n# 1880 "/'
[#] parse_declaration, is_constructor=False, meet line: 'void\n _M_range_initialize(_InputIterator __first, _InputIterator __last,\n       std::input_iterator_tag);\n\n\n      template<typename _ForwardIterator>\n void\n _M_range_initialize(_ForwardIterator __firs'
[#] parse_declaration, is_constructor=False, meet line: 'void\n _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,\n       std::forward_iterator_tag);\n# 1902 "/usr/include/c++/7/bits/stl_deque.h" 3\n      void\n      _M_fill_initialize(const'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_fill_initialize(const value_type& __value);\n\n\n\n      void\n      _M_default_initialize();\n# 1918 "/usr/include/c++/7/bits/stl_deque.h" 3\n      template<typename _Integer>\n void\n _M_assign'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_default_initialize();\n# 1918 "/usr/include/c++/7/bits/stl_deque.h" 3\n      template<typename _Integer>\n void\n _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)\n { _M_fill_ass'
[#] parse_declaration, is_constructor=False, meet line: 'void\n _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)\n { _M_fill_assign(__n, __val); }\n\n\n      template<typename _InputIterator>\n void\n _M_assign_dispatch(_InputIterator __first, _InputI'
[#] parse_declaration, is_constructor=False, meet line: 'void\n _M_assign_dispatch(_InputIterator __first, _InputIterator __last,\n      __false_type)\n { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }\n\n\n      template<typename _InputIter'
[#] parse_declaration, is_constructor=False, meet line: 'void\n _M_assign_aux(_InputIterator __first, _InputIterator __last,\n        std::input_iterator_tag);\n\n\n      template<typename _ForwardIterator>\n void\n _M_assign_aux(_ForwardIterator __first, _Forward'
[#] parse_declaration, is_constructor=False, meet line: 'void\n _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,\n        std::forward_iterator_tag)\n {\n   const size_type __len = std::distance(__first, __last);\n   if (__len > size())\n     {\n  '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_fill_assign(size_type __n, const value_type& __val)\n      {\n if (__n > size())\n   {\n     std::fill(begin(), end(), __val);\n     _M_fill_insert(end(), __n - size(), __val);\n   }\n else\n   '
[#] parse_declaration, is_constructor=False, meet line: 'void _M_push_back_aux(_Args&&... __args);\n\n      template<typename... _Args>\n void _M_push_front_aux(_Args&&... __args);\n\n\n      void _M_pop_back_aux();\n\n      void _M_pop_front_aux();\n# 1998 "/usr/in'
[#] parse_declaration, is_constructor=False, meet line: 'void _M_push_front_aux(_Args&&... __args);\n\n\n      void _M_pop_back_aux();\n\n      void _M_pop_front_aux();\n# 1998 "/usr/include/c++/7/bits/stl_deque.h" 3\n      template<typename _Integer>\n void\n _M_in'
[#] parse_declaration, is_constructor=False, meet line: 'void _M_pop_back_aux();\n\n      void _M_pop_front_aux();\n# 1998 "/usr/include/c++/7/bits/stl_deque.h" 3\n      template<typename _Integer>\n void\n _M_insert_dispatch(iterator __pos,\n      _Integer __n, _'
[#] parse_declaration, is_constructor=False, meet line: 'void _M_pop_front_aux();\n# 1998 "/usr/include/c++/7/bits/stl_deque.h" 3\n      template<typename _Integer>\n void\n _M_insert_dispatch(iterator __pos,\n      _Integer __n, _Integer __x, __true_type)\n { _M'
[#] parse_declaration, is_constructor=False, meet line: 'void\n _M_insert_dispatch(iterator __pos,\n      _Integer __n, _Integer __x, __true_type)\n { _M_fill_insert(__pos, __n, __x); }\n\n\n      template<typename _InputIterator>\n void\n _M_insert_dispatch(iterat'
[#] parse_declaration, is_constructor=False, meet line: 'void\n _M_insert_dispatch(iterator __pos,\n      _InputIterator __first, _InputIterator __last,\n      __false_type)\n {\n   _M_range_insert_aux(__pos, __first, __last,\n         std::__iterator_category(__'
[#] parse_declaration, is_constructor=False, meet line: 'void\n _M_range_insert_aux(iterator __pos, _InputIterator __first,\n       _InputIterator __last, std::input_iterator_tag);\n\n\n      template<typename _ForwardIterator>\n void\n _M_range_insert_aux(iterato'
[#] parse_declaration, is_constructor=False, meet line: 'void\n _M_range_insert_aux(iterator __pos, _ForwardIterator __first,\n       _ForwardIterator __last, std::forward_iterator_tag);\n\n\n\n\n      void\n      _M_fill_insert(iterator __pos, size_type __n, const'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);\n\n\n\n\n\n\n      template<typename... _Args>\n iterator\n _M_insert_aux(iterator __pos, _Args&&... __args);\n\n\n\n      void\n    '
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n _M_insert_aux(iterator __pos, _Args&&... __args);\n\n\n\n      void\n      _M_insert_aux(iterator __pos, size_type __n, const value_type& __x);\n\n\n      template<typename _ForwardIterator>\n void\n '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_insert_aux(iterator __pos, size_type __n, const value_type& __x);\n\n\n      template<typename _ForwardIterator>\n void\n _M_insert_aux(iterator __pos,\n        _ForwardIterator __first, _Forw'
[#] parse_declaration, is_constructor=False, meet line: 'void\n _M_insert_aux(iterator __pos,\n        _ForwardIterator __first, _ForwardIterator __last,\n        size_type __n);\n\n\n\n\n      void\n      _M_destroy_data_aux(iterator __first, iterator __last);\n\n\n\n '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_destroy_data_aux(iterator __first, iterator __last);\n\n\n\n      template<typename _Alloc1>\n void\n _M_destroy_data(iterator __first, iterator __last, const _Alloc1&)\n { _M_destroy_data_aux('
[#] parse_declaration, is_constructor=False, meet line: 'void\n _M_destroy_data(iterator __first, iterator __last, const _Alloc1&)\n { _M_destroy_data_aux(__first, __last); }\n\n      void\n      _M_destroy_data(iterator __first, iterator __last,\n        const s'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_destroy_data(iterator __first, iterator __last,\n        const std::allocator<_Tp>&)\n      {\n if (!__has_trivial_destructor(value_type))\n   _M_destroy_data_aux(__first, __last);\n      }\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_erase_at_begin(iterator __pos)\n      {\n _M_destroy_data(begin(), __pos, _M_get_Tp_allocator());\n _M_destroy_nodes(this->_M_impl._M_start._M_node, __pos._M_node);\n this->_M_impl._M_start '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_erase_at_end(iterator __pos)\n      {\n _M_destroy_data(__pos, end(), _M_get_Tp_allocator());\n _M_destroy_nodes(__pos._M_node + 1,\n    this->_M_impl._M_finish._M_node + 1);\n this->_M_impl.'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      _M_erase(iterator __pos);\n\n      iterator\n      _M_erase(iterator __first, iterator __last);\n\n\n\n      void\n      _M_default_append(size_type __n);\n\n      bool\n      _M_shrink_to_fit();\n'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      _M_erase(iterator __first, iterator __last);\n\n\n\n      void\n      _M_default_append(size_type __n);\n\n      bool\n      _M_shrink_to_fit();\n\n\n\n\n      iterator\n      _M_reserve_elements_at_'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_default_append(size_type __n);\n\n      bool\n      _M_shrink_to_fit();\n\n\n\n\n      iterator\n      _M_reserve_elements_at_front(size_type __n)\n      {\n const size_type __vacancies = this->_M_'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      _M_shrink_to_fit();\n\n\n\n\n      iterator\n      _M_reserve_elements_at_front(size_type __n)\n      {\n const size_type __vacancies = this->_M_impl._M_start._M_cur\n          - this->_M_impl._M_st'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      _M_reserve_elements_at_front(size_type __n)\n      {\n const size_type __vacancies = this->_M_impl._M_start._M_cur\n          - this->_M_impl._M_start._M_first;\n if (__n > __vacancies)\n   '
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      _M_reserve_elements_at_back(size_type __n)\n      {\n const size_type __vacancies = (this->_M_impl._M_finish._M_last\n           - this->_M_impl._M_finish._M_cur) - 1;\n if (__n > __vacanci'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_new_elements_at_front(size_type __new_elements);\n\n      void\n      _M_new_elements_at_back(size_type __new_elements);\n# 2148 "/usr/include/c++/7/bits/stl_deque.h" 3\n      void\n      _M_r'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_new_elements_at_back(size_type __new_elements);\n# 2148 "/usr/include/c++/7/bits/stl_deque.h" 3\n      void\n      _M_reserve_map_at_back(size_type __nodes_to_add = 1)\n      {\n if (__nodes_'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_reserve_map_at_back(size_type __nodes_to_add = 1)\n      {\n if (__nodes_to_add + 1 > this->_M_impl._M_map_size\n     - (this->_M_impl._M_finish._M_node - this->_M_impl._M_map))\n   _M_reall'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_reserve_map_at_front(size_type __nodes_to_add = 1)\n      {\n if (__nodes_to_add > size_type(this->_M_impl._M_start._M_node\n           - this->_M_impl._M_map))\n   _M_reallocate_map(__nodes'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front);\n\n\n\n\n\n      void\n      _M_move_assign1(deque&& __x, true_type) noexcept\n      {\n this->_M_impl._M_swap_data(__x._M_impl);\n _'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_move_assign1(deque&& __x, true_type) noexcept\n      {\n this->_M_impl._M_swap_data(__x._M_impl);\n __x.clear();\n std::__alloc_on_move(_M_get_Tp_allocator(), __x._M_get_Tp_allocator());\n   '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_move_assign1(deque&& __x, false_type)\n      {\n constexpr bool __move_storage =\n   _Alloc_traits::_S_propagate_on_move_assign();\n _M_move_assign2(std::move(__x), __bool_constant<__move_st'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_replace_map(_Args&&... __args)\n      {\n\n deque __newobj(std::forward<_Args>(__args)...);\n\n clear();\n _M_deallocate_node(*begin()._M_node);\n _M_deallocate_map(this->_M_impl._M_map, this->'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_move_assign2(deque&& __x, true_type)\n      {\n\n auto __alloc = __x._M_get_Tp_allocator();\n\n\n _M_replace_map(std::move(__x));\n\n _M_get_Tp_allocator() = std::move(__alloc);\n      }\n\n\n\n     '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_move_assign2(deque&& __x, false_type)\n      {\n if (__x._M_get_Tp_allocator() == this->_M_get_Tp_allocator())\n   {\n\n\n     _M_replace_map(std::move(__x), __x.get_allocator());\n   }\n else\n '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator==(const deque<_Tp, _Alloc>& __x,\n                         const deque<_Tp, _Alloc>& __y)\n    { return __x.size() == __y.size()\n      && std::equal(__x.begin(), __x.end(), __y.begin()'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<(const deque<_Tp, _Alloc>& __x,\n       const deque<_Tp, _Alloc>& __y)\n    { return std::lexicographical_compare(__x.begin(), __x.end(),\n       __y.begin(), __y.end()); }\n\n\n  template'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator!=(const deque<_Tp, _Alloc>& __x,\n        const deque<_Tp, _Alloc>& __y)\n    { return !(__x == __y); }\n\n\n  template<typename _Tp, typename _Alloc>\n    inline bool\n    operator>(const '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>(const deque<_Tp, _Alloc>& __x,\n       const deque<_Tp, _Alloc>& __y)\n    { return __y < __x; }\n\n\n  template<typename _Tp, typename _Alloc>\n    inline bool\n    operator<=(const deque'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<=(const deque<_Tp, _Alloc>& __x,\n        const deque<_Tp, _Alloc>& __y)\n    { return !(__y < __x); }\n\n\n  template<typename _Tp, typename _Alloc>\n    inline bool\n    operator>=(const '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>=(const deque<_Tp, _Alloc>& __x,\n        const deque<_Tp, _Alloc>& __y)\n    { return !(__x < __y); }\n\n\n  template<typename _Tp, typename _Alloc>\n    inline void\n    swap(deque<_Tp,_A'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    swap(deque<_Tp,_Alloc>& __x, deque<_Tp,_Alloc>& __y)\n    noexcept(noexcept(__x.swap(__y)))\n    { __x.swap(__y); }\n\n\n\n\n}\n# 65 "/usr/include/c++/7/deque" 2 3\n\n# 1 "/usr/include/c++/7/bits/deque'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    deque<_Tp, _Alloc>::\n    _M_default_initialize()\n    {\n      _Map_pointer __cur;\n      try\n        {\n          for (__cur = this->_M_impl._M_start._M_node;\n        __cur < this->_M_impl._M_fi'
[#] parse_declaration, is_constructor=False, meet line: 'deque<_Tp, _Alloc>&\n    deque<_Tp, _Alloc>::\n    operator=(const deque& __x)\n    {\n      if (&__x != this)\n {\n\n   if (_Alloc_traits::_S_propagate_on_copy_assign())\n     {\n       if (!_Alloc_traits::_S'
[#] parse_declaration, is_constructor=False, meet line: 'void\n\n      deque<_Tp, _Alloc>::\n      emplace_front(_Args&&... __args)\n      {\n if (this->_M_impl._M_start._M_cur != this->_M_impl._M_start._M_first)\n   {\n     _Alloc_traits::construct(this->_M_impl,'
[#] parse_declaration, is_constructor=False, meet line: 'void\n\n      deque<_Tp, _Alloc>::\n      emplace_back(_Args&&... __args)\n      {\n if (this->_M_impl._M_finish._M_cur\n     != this->_M_impl._M_finish._M_last - 1)\n   {\n     _Alloc_traits::construct(this-'
[#] parse_declaration, is_constructor=False, meet line: 'deque<_Tp, _Alloc>::iterator\n      deque<_Tp, _Alloc>::\n      emplace(const_iterator __position, _Args&&... __args)\n      {\n if (__position._M_cur == this->_M_impl._M_start._M_cur)\n   {\n     emplace_f'
[#] parse_declaration, is_constructor=False, meet line: 'deque<_Tp, _Alloc>::iterator\n    deque<_Tp, _Alloc>::\n\n    insert(const_iterator __position, const value_type& __x)\n\n\n\n    {\n      if (__position._M_cur == this->_M_impl._M_start._M_cur)\n {\n   push_fr'
[#] parse_declaration, is_constructor=False, meet line: 'deque<_Tp, _Alloc>::iterator\n    deque<_Tp, _Alloc>::\n    _M_erase(iterator __position)\n    {\n      iterator __next = __position;\n      ++__next;\n      const difference_type __index = __position - beg'
[#] parse_declaration, is_constructor=False, meet line: 'deque<_Tp, _Alloc>::iterator\n    deque<_Tp, _Alloc>::\n    _M_erase(iterator __first, iterator __last)\n    {\n      if (__first == __last)\n return __first;\n      else if (__first == begin() && __last =='
[#] parse_declaration, is_constructor=False, meet line: 'void\n      deque<_Tp, _Alloc>::\n      _M_assign_aux(_InputIterator __first, _InputIterator __last,\n      std::input_iterator_tag)\n      {\n        iterator __cur = begin();\n        for (; __first != __'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    deque<_Tp, _Alloc>::\n    _M_fill_insert(iterator __pos, size_type __n, const value_type& __x)\n    {\n      if (__pos._M_cur == this->_M_impl._M_start._M_cur)\n {\n   iterator __new_start = _M_re'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    deque<_Tp, _Alloc>::\n    _M_default_append(size_type __n)\n    {\n      if (__n)\n {\n   iterator __new_finish = _M_reserve_elements_at_back(__n);\n   try\n     {\n       std::__uninitialized_defaul'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    deque<_Tp, _Alloc>::\n    _M_shrink_to_fit()\n    {\n      const difference_type __front_capacity\n = (this->_M_impl._M_start._M_cur - this->_M_impl._M_start._M_first);\n      if (__front_capacity'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    deque<_Tp, _Alloc>::\n    _M_fill_initialize(const value_type& __value)\n    {\n      _Map_pointer __cur;\n      try\n        {\n          for (__cur = this->_M_impl._M_start._M_node;\n        __cur'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      deque<_Tp, _Alloc>::\n      _M_range_initialize(_InputIterator __first, _InputIterator __last,\n                          std::input_iterator_tag)\n      {\n        this->_M_initialize_map(0);\n'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      deque<_Tp, _Alloc>::\n      _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,\n                          std::forward_iterator_tag)\n      {\n        const size_type __n = '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      deque<_Tp, _Alloc>::\n      _M_push_back_aux(_Args&&... __args)\n\n\n\n\n\n      {\n _M_reserve_map_at_back();\n *(this->_M_impl._M_finish._M_node + 1) = this->_M_allocate_node();\n try\n   {\n\n     _A'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      deque<_Tp, _Alloc>::\n      _M_push_front_aux(_Args&&... __args)\n\n\n\n\n\n      {\n _M_reserve_map_at_front();\n *(this->_M_impl._M_start._M_node - 1) = this->_M_allocate_node();\n try\n   {\n     th'
[#] parse_declaration, is_constructor=False, meet line: 'void deque<_Tp, _Alloc>::\n    _M_pop_back_aux()\n    {\n      _M_deallocate_node(this->_M_impl._M_finish._M_first);\n      this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node - 1);\n      '
[#] parse_declaration, is_constructor=False, meet line: 'void deque<_Tp, _Alloc>::\n    _M_pop_front_aux()\n    {\n      _Alloc_traits::destroy(_M_get_Tp_allocator(),\n        this->_M_impl._M_start._M_cur);\n      _M_deallocate_node(this->_M_impl._M_start._M_fi'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      deque<_Tp, _Alloc>::\n      _M_range_insert_aux(iterator __pos,\n                          _InputIterator __first, _InputIterator __last,\n                          std::input_iterator_tag)\n  '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      deque<_Tp, _Alloc>::\n      _M_range_insert_aux(iterator __pos,\n                          _ForwardIterator __first, _ForwardIterator __last,\n                          std::forward_iterator_t'
[#] parse_declaration, is_constructor=False, meet line: 'deque<_Tp, _Alloc>::iterator\n      deque<_Tp, _Alloc>::\n      _M_insert_aux(iterator __pos, _Args&&... __args)\n      {\n value_type __x_copy(std::forward<_Args>(__args)...);\n\n\n\n\n\n\n\n difference_type __i'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    deque<_Tp, _Alloc>::\n    _M_insert_aux(iterator __pos, size_type __n, const value_type& __x)\n    {\n      const difference_type __elems_before = __pos - this->_M_impl._M_start;\n      const siz'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      deque<_Tp, _Alloc>::\n      _M_insert_aux(iterator __pos,\n                    _ForwardIterator __first, _ForwardIterator __last,\n                    size_type __n)\n      {\n        const diff'
[#] parse_declaration, is_constructor=False, meet line: 'void\n     deque<_Tp, _Alloc>::\n     _M_destroy_data_aux(iterator __first, iterator __last)\n     {\n       for (_Map_pointer __node = __first._M_node + 1;\n     __node < __last._M_node; ++__node)\n  std::'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    deque<_Tp, _Alloc>::\n    _M_new_elements_at_front(size_type __new_elems)\n    {\n      if (this->max_size() - this->size() < __new_elems)\n __throw_length_error(("deque::_M_new_elements_at_front'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    deque<_Tp, _Alloc>::\n    _M_new_elements_at_back(size_type __new_elems)\n    {\n      if (this->max_size() - this->size() < __new_elems)\n __throw_length_error(("deque::_M_new_elements_at_back")'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    deque<_Tp, _Alloc>::\n    _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front)\n    {\n      const size_type __old_num_nodes\n = this->_M_impl._M_finish._M_node - this->_M_impl._M_sta'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    fill(const _Deque_iterator<_Tp, _Tp&, _Tp*>& __first,\n  const _Deque_iterator<_Tp, _Tp&, _Tp*>& __last, const _Tp& __value)\n    {\n      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Sel'
[#] parse_declaration, is_constructor=False, meet line: '_Deque_iterator<_Tp, _Tp&, _Tp*>\n    copy(_Deque_iterator<_Tp, const _Tp&, const _Tp*> __first,\n  _Deque_iterator<_Tp, const _Tp&, const _Tp*> __last,\n  _Deque_iterator<_Tp, _Tp&, _Tp*> __result)\n    '
[#] parse_declaration, is_constructor=False, meet line: '_Deque_iterator<_Tp, _Tp&, _Tp*>\n    copy_backward(_Deque_iterator<_Tp, const _Tp&, const _Tp*> __first,\n    _Deque_iterator<_Tp, const _Tp&, const _Tp*> __last,\n    _Deque_iterator<_Tp, _Tp&, _Tp*> _'
[#] parse_declaration, is_constructor=False, meet line: '_Deque_iterator<_Tp, _Tp&, _Tp*>\n    move(_Deque_iterator<_Tp, const _Tp&, const _Tp*> __first,\n  _Deque_iterator<_Tp, const _Tp&, const _Tp*> __last,\n  _Deque_iterator<_Tp, _Tp&, _Tp*> __result)\n    '
[#] parse_declaration, is_constructor=False, meet line: '_Deque_iterator<_Tp, _Tp&, _Tp*>\n    move_backward(_Deque_iterator<_Tp, const _Tp&, const _Tp*> __first,\n    _Deque_iterator<_Tp, const _Tp&, const _Tp*> __last,\n    _Deque_iterator<_Tp, _Tp&, _Tp*> _'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n operator==(const stack<_Tp1, _Seq1>&, const stack<_Tp1, _Seq1>&);\n\n      template<typename _Tp1, typename _Seq1>\n friend bool\n operator<(const stack<_Tp1, _Seq1>&, const stack<_Tp1, _Seq1>&);\n\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n operator<(const stack<_Tp1, _Seq1>&, const stack<_Tp1, _Seq1>&);\n\n\n      template<typename _Alloc>\n using _Uses = typename\n   enable_if<uses_allocator<_Sequence, _Alloc>::value>::type;\n\n\n    pub'
[#] parse_declaration, is_constructor=False, meet line: '_Sequence c;\n\n    public:\n# 146 "/usr/include/c++/7/bits/stl_stack.h" 3\n      template<typename _Seq = _Sequence, typename _Requires = typename\n        enable_if<is_default_constructible<_Seq>::value>'
[#] parse_declaration, is_constructor=True, meet line: 'stack()\n : c() { }\n\n      explicit\n      stack(const _Sequence& __c)\n      : c(__c) { }\n\n      explicit\n      stack(_Sequence&& __c)\n      : c(std::move(__c)) { }\n\n      template<typename _Alloc, type'
[#] parse_declaration, is_constructor=True, meet line: 'stack(const _Sequence& __c)\n      : c(__c) { }\n\n      explicit\n      stack(_Sequence&& __c)\n      : c(std::move(__c)) { }\n\n      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>\n explicit'
[#] parse_declaration, is_constructor=True, meet line: 'stack(_Sequence&& __c)\n      : c(std::move(__c)) { }\n\n      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>\n explicit\n stack(const _Alloc& __a)\n : c(__a) { }\n\n      template<typename _Al'
[#] parse_declaration, is_constructor=True, meet line: 'stack(const _Alloc& __a)\n : c(__a) { }\n\n      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>\n stack(const _Sequence& __c, const _Alloc& __a)\n : c(__c, __a) { }\n\n      template<typename '
[#] parse_declaration, is_constructor=True, meet line: 'stack(const _Sequence& __c, const _Alloc& __a)\n : c(__c, __a) { }\n\n      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>\n stack(_Sequence&& __c, const _Alloc& __a)\n : c(std::move(__c), _'
[#] parse_declaration, is_constructor=True, meet line: 'stack(_Sequence&& __c, const _Alloc& __a)\n : c(std::move(__c), __a) { }\n\n      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>\n stack(const stack& __q, const _Alloc& __a)\n : c(__q.c, __a'
[#] parse_declaration, is_constructor=True, meet line: 'stack(const stack& __q, const _Alloc& __a)\n : c(__q.c, __a) { }\n\n      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>\n stack(stack&& __q, const _Alloc& __a)\n : c(std::move(__q.c), __a) '
[#] parse_declaration, is_constructor=True, meet line: 'stack(stack&& __q, const _Alloc& __a)\n : c(std::move(__q.c), __a) { }\n\n\n\n\n\n      bool\n      empty() const\n      { return c.empty(); }\n\n\n      size_type\n      size() const\n      { return c.size(); }\n\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      empty() const\n      { return c.empty(); }\n\n\n      size_type\n      size() const\n      { return c.size(); }\n\n\n\n\n\n      reference\n      top()\n      {\n ;\n return c.back();\n      }\n\n\n\n\n\n      co'
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      size() const\n      { return c.size(); }\n\n\n\n\n\n      reference\n      top()\n      {\n ;\n return c.back();\n      }\n\n\n\n\n\n      const_reference\n      top() const\n      {\n ;\n return c.back();\n'
[#] parse_declaration, is_constructor=False, meet line: 'reference\n      top()\n      {\n ;\n return c.back();\n      }\n\n\n\n\n\n      const_reference\n      top() const\n      {\n ;\n return c.back();\n      }\n# 224 "/usr/include/c++/7/bits/stl_stack.h" 3\n      void\n  '
[#] parse_declaration, is_constructor=False, meet line: 'const_reference\n      top() const\n      {\n ;\n return c.back();\n      }\n# 224 "/usr/include/c++/7/bits/stl_stack.h" 3\n      void\n      push(const value_type& __x)\n      { c.push_back(__x); }\n\n\n      vo'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      push(const value_type& __x)\n      { c.push_back(__x); }\n\n\n      void\n      push(value_type&& __x)\n      { c.push_back(std::move(__x)); }\n\n\n\n\n\n\n\n      template<typename... _Args>\n void\n empl'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      push(value_type&& __x)\n      { c.push_back(std::move(__x)); }\n\n\n\n\n\n\n\n      template<typename... _Args>\n void\n emplace(_Args&&... __args)\n { c.emplace_back(std::forward<_Args>(__args)...); }'
[#] parse_declaration, is_constructor=False, meet line: 'void\n emplace(_Args&&... __args)\n { c.emplace_back(std::forward<_Args>(__args)...); }\n# 257 "/usr/include/c++/7/bits/stl_stack.h" 3\n      void\n      pop()\n      {\n ;\n c.pop_back();\n      }\n\n\n      voi'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      pop()\n      {\n ;\n c.pop_back();\n      }\n\n\n      void\n      swap(stack& __s)\n\n      noexcept(__is_nothrow_swappable<_Sequence>::value)\n\n\n\n      {\n using std::swap;\n swap(c, __s.c);\n      }\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      swap(stack& __s)\n\n      noexcept(__is_nothrow_swappable<_Sequence>::value)\n\n\n\n      {\n using std::swap;\n swap(c, __s.c);\n      }\n\n    };\n# 291 "/usr/include/c++/7/bits/stl_stack.h" 3\n  temp'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator==(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)\n    { return __x.c == __y.c; }\n# 309 "/usr/include/c++/7/bits/stl_stack.h" 3\n  template<typename _Tp, typename _Seq>\n    i'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)\n    { return __x.c < __y.c; }\n\n\n  template<typename _Tp, typename _Seq>\n    inline bool\n    operator!=(const stack<_Tp, _Se'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator!=(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)\n    { return !(__x == __y); }\n\n\n  template<typename _Tp, typename _Seq>\n    inline bool\n    operator>(const stack<_Tp, _Se'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)\n    { return __y < __x; }\n\n\n  template<typename _Tp, typename _Seq>\n    inline bool\n    operator<=(const stack<_Tp, _Seq>& '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<=(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)\n    { return !(__y < __x); }\n\n\n  template<typename _Tp, typename _Seq>\n    inline bool\n    operator>=(const stack<_Tp, _Se'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>=(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)\n    { return !(__x < __y); }\n\n\n  template<typename _Tp, typename _Seq>\n    inline\n\n\n    typename enable_if<__is_swappable<'
[#] parse_declaration, is_constructor=False, meet line: 'enable_if<__is_swappable<_Seq>::value>::type\n\n\n\n    swap(stack<_Tp, _Seq>& __x, stack<_Tp, _Seq>& __y)\n    noexcept(noexcept(__x.swap(__y)))\n    { __x.swap(__y); }\n\n  template<typename _Tp, typename _'
[#] parse_declaration, is_constructor=False, meet line: 'pointer _M_start;\n pointer _M_finish;\n pointer _M_end_of_storage;\n\n _Vector_impl()\n : _Tp_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage()\n { }\n\n _Vector_impl(_Tp_alloc_type const& __a) noex'
[#] parse_declaration, is_constructor=False, meet line: 'pointer _M_finish;\n pointer _M_end_of_storage;\n\n _Vector_impl()\n : _Tp_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage()\n { }\n\n _Vector_impl(_Tp_alloc_type const& __a) noexcept\n : _Tp_alloc_t'
[#] parse_declaration, is_constructor=False, meet line: 'pointer _M_end_of_storage;\n\n _Vector_impl()\n : _Tp_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage()\n { }\n\n _Vector_impl(_Tp_alloc_type const& __a) noexcept\n : _Tp_alloc_type(__a), _M_start()'
[#] parse_declaration, is_constructor=True, meet line: '_Vector_impl()\n : _Tp_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage()\n { }\n\n _Vector_impl(_Tp_alloc_type const& __a) noexcept\n : _Tp_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_stor'
[#] parse_declaration, is_constructor=True, meet line: '_Vector_impl(_Tp_alloc_type const& __a) noexcept\n : _Tp_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage()\n { }\n\n\n _Vector_impl(_Tp_alloc_type&& __a) noexcept\n : _Tp_alloc_type(std::move(__'
[#] parse_declaration, is_constructor=True, meet line: '_Vector_impl(_Tp_alloc_type&& __a) noexcept\n : _Tp_alloc_type(std::move(__a)),\n   _M_start(), _M_finish(), _M_end_of_storage()\n { }\n\n\n void _M_swap_data(_Vector_impl& __x) noexcept\n {\n   std::swap(_M_'
[#] parse_declaration, is_constructor=False, meet line: 'void _M_swap_data(_Vector_impl& __x) noexcept\n {\n   std::swap(_M_start, __x._M_start);\n   std::swap(_M_finish, __x._M_finish);\n   std::swap(_M_end_of_storage, __x._M_end_of_storage);\n }\n      };\n\n    '
[#] parse_declaration, is_constructor=False, meet line: '_Tp_alloc_type&\n      _M_get_Tp_allocator() noexcept\n      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }\n\n      const _Tp_alloc_type&\n      _M_get_Tp_allocator() const noexcept\n      { ret'
[#] parse_declaration, is_constructor=False, meet line: '_Tp_alloc_type&\n      _M_get_Tp_allocator() const noexcept\n      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }\n\n      allocator_type\n      get_allocator() const noexcept\n      { retu'
[#] parse_declaration, is_constructor=False, meet line: 'allocator_type\n      get_allocator() const noexcept\n      { return allocator_type(_M_get_Tp_allocator()); }\n\n      _Vector_base()\n      : _M_impl() { }\n\n      _Vector_base(const allocator_type& __a) n'
[#] parse_declaration, is_constructor=True, meet line: '_Vector_base()\n      : _M_impl() { }\n\n      _Vector_base(const allocator_type& __a) noexcept\n      : _M_impl(__a) { }\n\n      _Vector_base(size_t __n)\n      : _M_impl()\n      { _M_create_storage(__n); '
[#] parse_declaration, is_constructor=True, meet line: '_Vector_base(const allocator_type& __a) noexcept\n      : _M_impl(__a) { }\n\n      _Vector_base(size_t __n)\n      : _M_impl()\n      { _M_create_storage(__n); }\n\n      _Vector_base(size_t __n, const allo'
[#] parse_declaration, is_constructor=True, meet line: '_Vector_base(size_t __n)\n      : _M_impl()\n      { _M_create_storage(__n); }\n\n      _Vector_base(size_t __n, const allocator_type& __a)\n      : _M_impl(__a)\n      { _M_create_storage(__n); }\n\n\n      _'
[#] parse_declaration, is_constructor=True, meet line: '_Vector_base(size_t __n, const allocator_type& __a)\n      : _M_impl(__a)\n      { _M_create_storage(__n); }\n\n\n      _Vector_base(_Tp_alloc_type&& __a) noexcept\n      : _M_impl(std::move(__a)) { }\n\n    '
[#] parse_declaration, is_constructor=True, meet line: '_Vector_base(_Tp_alloc_type&& __a) noexcept\n      : _M_impl(std::move(__a)) { }\n\n      _Vector_base(_Vector_base&& __x) noexcept\n      : _M_impl(std::move(__x._M_get_Tp_allocator()))\n      { this->_M_'
[#] parse_declaration, is_constructor=True, meet line: '_Vector_base(_Vector_base&& __x) noexcept\n      : _M_impl(std::move(__x._M_get_Tp_allocator()))\n      { this->_M_impl._M_swap_data(__x._M_impl); }\n\n      _Vector_base(_Vector_base&& __x, const allocat'
[#] parse_declaration, is_constructor=True, meet line: '_Vector_base(_Vector_base&& __x, const allocator_type& __a)\n      : _M_impl(__a)\n      {\n if (__x.get_allocator() == __a)\n   this->_M_impl._M_swap_data(__x._M_impl);\n else\n   {\n     size_t __n = __x._'
[#] parse_declaration, is_constructor=True, meet line: '_Vector_base() noexcept\n      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage\n        - this->_M_impl._M_start); }\n\n    public:\n      _Vector_impl _M_impl;\n\n      pointer\n     '
[#] parse_declaration, is_constructor=False, meet line: '_Vector_impl _M_impl;\n\n      pointer\n      _M_allocate(size_t __n)\n      {\n typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;\n return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();\n      }\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'pointer\n      _M_allocate(size_t __n)\n      {\n typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;\n return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();\n      }\n\n      void\n      _M_deallocat'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_deallocate(pointer __p, size_t __n)\n      {\n typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;\n if (__p)\n   _Tr::deallocate(_M_impl, __p, __n);\n      }\n\n    private:\n      void\n    '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_create_storage(size_t __n)\n      {\n this->_M_impl._M_start = this->_M_allocate(__n);\n this->_M_impl._M_finish = this->_M_impl._M_start;\n this->_M_impl._M_end_of_storage = this->_M_impl._'
[#] parse_declaration, is_constructor=True, meet line: 'vector()\n\n      noexcept(is_nothrow_default_constructible<_Alloc>::value)\n\n      : _Base() { }\n\n\n\n\n\n      explicit\n      vector(const allocator_type& __a) noexcept\n      : _Base(__a) { }\n# 282 "/usr/i'
[#] parse_declaration, is_constructor=True, meet line: 'vector(const allocator_type& __a) noexcept\n      : _Base(__a) { }\n# 282 "/usr/include/c++/7/bits/stl_vector.h" 3\n      explicit\n      vector(size_type __n, const allocator_type& __a = allocator_type()'
[#] parse_declaration, is_constructor=True, meet line: 'vector(size_type __n, const allocator_type& __a = allocator_type())\n      : _Base(__n, __a)\n      { _M_default_initialize(__n); }\n# 295 "/usr/include/c++/7/bits/stl_vector.h" 3\n      vector(size_type '
[#] parse_declaration, is_constructor=True, meet line: 'vector(size_type __n, const value_type& __value,\n      const allocator_type& __a = allocator_type())\n      : _Base(__n, __a)\n      { _M_fill_initialize(__n, __value); }\n# 326 "/usr/include/c++/7/bits/'
[#] parse_declaration, is_constructor=True, meet line: 'vector(const vector& __x)\n      : _Base(__x.size(),\n _Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()))\n      {\n this->_M_impl._M_finish =\n   std::__uninitialized_copy_a(__x.begin(), __x.end'
[#] parse_declaration, is_constructor=True, meet line: 'vector(vector&& __x) noexcept\n      : _Base(std::move(__x)) { }\n\n\n      vector(const vector& __x, const allocator_type& __a)\n      : _Base(__x.size(), __a)\n      {\n this->_M_impl._M_finish =\n   std::_'
[#] parse_declaration, is_constructor=True, meet line: 'vector(const vector& __x, const allocator_type& __a)\n      : _Base(__x.size(), __a)\n      {\n this->_M_impl._M_finish =\n   std::__uninitialized_copy_a(__x.begin(), __x.end(),\n          this->_M_impl._M'
[#] parse_declaration, is_constructor=True, meet line: 'vector(vector&& __rv, const allocator_type& __m)\n      noexcept(_Alloc_traits::_S_always_equal())\n      : _Base(std::move(__rv), __m)\n      {\n if (__rv.get_allocator() != __m)\n   {\n     this->_M_impl.'
[#] parse_declaration, is_constructor=True, meet line: 'vector(initializer_list<value_type> __l,\n      const allocator_type& __a = allocator_type())\n      : _Base(__a)\n      {\n _M_range_initialize(__l.begin(), __l.end(),\n       random_access_iterator_tag()'
[#] parse_declaration, is_constructor=True, meet line: 'vector(_InputIterator __first, _InputIterator __last,\n        const allocator_type& __a = allocator_type())\n : _Base(__a)\n { _M_initialize_dispatch(__first, __last, __false_type()); }\n# 433 "/usr/incl'
[#] parse_declaration, is_constructor=True, meet line: 'vector() noexcept\n      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,\n        _M_get_Tp_allocator()); }\n# 446 "/usr/include/c++/7/bits/stl_vector.h" 3\n      vector&\n      operator=('
[#] parse_declaration, is_constructor=True, meet line: 'vector&\n      operator=(const vector& __x);\n# 460 "/usr/include/c++/7/bits/stl_vector.h" 3\n      vector&\n      operator=(vector&& __x) noexcept(_Alloc_traits::_S_nothrow_move())\n      {\n constexpr boo'
[#] parse_declaration, is_constructor=True, meet line: 'vector&\n      operator=(vector&& __x) noexcept(_Alloc_traits::_S_nothrow_move())\n      {\n constexpr bool __move_storage =\n   _Alloc_traits::_S_propagate_on_move_assign()\n   || _Alloc_traits::_S_always'
[#] parse_declaration, is_constructor=True, meet line: 'vector&\n      operator=(initializer_list<value_type> __l)\n      {\n this->_M_assign_aux(__l.begin(), __l.end(),\n       random_access_iterator_tag());\n return *this;\n      }\n# 500 "/usr/include/c++/7/bi'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      assign(size_type __n, const value_type& __val)\n      { _M_fill_assign(__n, __val); }\n# 517 "/usr/include/c++/7/bits/stl_vector.h" 3\n      template<typename _InputIterator,\n        typename '
[#] parse_declaration, is_constructor=False, meet line: 'void\n assign(_InputIterator __first, _InputIterator __last)\n { _M_assign_dispatch(__first, __last, __false_type()); }\n# 545 "/usr/include/c++/7/bits/stl_vector.h" 3\n      void\n      assign(initializer'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      assign(initializer_list<value_type> __l)\n      {\n this->_M_assign_aux(__l.begin(), __l.end(),\n       random_access_iterator_tag());\n      }\n\n\n\n      using _Base::get_allocator;\n\n\n\n\n\n\n\n     '
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      begin() noexcept\n      { return iterator(this->_M_impl._M_start); }\n\n\n\n\n\n\n      const_iterator\n      begin() const noexcept\n      { return const_iterator(this->_M_impl._M_start); }\n\n\n\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'const_iterator\n      begin() const noexcept\n      { return const_iterator(this->_M_impl._M_start); }\n\n\n\n\n\n\n      iterator\n      end() noexcept\n      { return iterator(this->_M_impl._M_finish); }\n\n\n\n\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      end() noexcept\n      { return iterator(this->_M_impl._M_finish); }\n\n\n\n\n\n\n      const_iterator\n      end() const noexcept\n      { return const_iterator(this->_M_impl._M_finish); }\n\n\n\n\n\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'const_iterator\n      end() const noexcept\n      { return const_iterator(this->_M_impl._M_finish); }\n\n\n\n\n\n\n      reverse_iterator\n      rbegin() noexcept\n      { return reverse_iterator(end()); }\n\n\n\n\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'reverse_iterator\n      rbegin() noexcept\n      { return reverse_iterator(end()); }\n\n\n\n\n\n\n      const_reverse_iterator\n      rbegin() const noexcept\n      { return const_reverse_iterator(end()); }\n\n\n\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'const_reverse_iterator\n      rbegin() const noexcept\n      { return const_reverse_iterator(end()); }\n\n\n\n\n\n\n      reverse_iterator\n      rend() noexcept\n      { return reverse_iterator(begin()); }\n\n\n\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'reverse_iterator\n      rend() noexcept\n      { return reverse_iterator(begin()); }\n\n\n\n\n\n\n      const_reverse_iterator\n      rend() const noexcept\n      { return const_reverse_iterator(begin()); }\n\n\n\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'const_reverse_iterator\n      rend() const noexcept\n      { return const_reverse_iterator(begin()); }\n\n\n\n\n\n\n\n      const_iterator\n      cbegin() const noexcept\n      { return const_iterator(this->_M_im'
[#] parse_declaration, is_constructor=False, meet line: 'const_iterator\n      cbegin() const noexcept\n      { return const_iterator(this->_M_impl._M_start); }\n\n\n\n\n\n\n      const_iterator\n      cend() const noexcept\n      { return const_iterator(this->_M_impl'
[#] parse_declaration, is_constructor=False, meet line: 'const_iterator\n      cend() const noexcept\n      { return const_iterator(this->_M_impl._M_finish); }\n\n\n\n\n\n\n      const_reverse_iterator\n      crbegin() const noexcept\n      { return const_reverse_iter'
[#] parse_declaration, is_constructor=False, meet line: 'const_reverse_iterator\n      crbegin() const noexcept\n      { return const_reverse_iterator(end()); }\n\n\n\n\n\n\n      const_reverse_iterator\n      crend() const noexcept\n      { return const_reverse_itera'
[#] parse_declaration, is_constructor=False, meet line: 'const_reverse_iterator\n      crend() const noexcept\n      { return const_reverse_iterator(begin()); }\n\n\n\n\n      size_type\n      size() const noexcept\n      { return size_type(this->_M_impl._M_finish -'
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      size() const noexcept\n      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }\n\n\n      size_type\n      max_size() const noexcept\n      { return _Alloc_traits::max_'
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      max_size() const noexcept\n      { return _Alloc_traits::max_size(_M_get_Tp_allocator()); }\n# 688 "/usr/include/c++/7/bits/stl_vector.h" 3\n      void\n      resize(size_type __new_size)\n'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      resize(size_type __new_size)\n      {\n if (__new_size > size())\n   _M_default_append(__new_size - size());\n else if (__new_size < size())\n   _M_erase_at_end(this->_M_impl._M_start + __new_si'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      resize(size_type __new_size, const value_type& __x)\n      {\n if (__new_size > size())\n   _M_fill_insert(end(), __new_size - size(), __x);\n else if (__new_size < size())\n   _M_erase_at_end(t'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      shrink_to_fit()\n      { _M_shrink_to_fit(); }\n\n\n\n\n\n\n      size_type\n      capacity() const noexcept\n      { return size_type(this->_M_impl._M_end_of_storage\n    - this->_M_impl._M_start); }'
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      capacity() const noexcept\n      { return size_type(this->_M_impl._M_end_of_storage\n    - this->_M_impl._M_start); }\n\n\n\n\n\n      bool\n      empty() const noexcept\n      { return begin() '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      empty() const noexcept\n      { return begin() == end(); }\n# 779 "/usr/include/c++/7/bits/stl_vector.h" 3\n      void\n      reserve(size_type __n);\n# 794 "/usr/include/c++/7/bits/stl_vector.h'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      reserve(size_type __n);\n# 794 "/usr/include/c++/7/bits/stl_vector.h" 3\n      reference\n      operator[](size_type __n) noexcept\n      {\n ;\n return *(this->_M_impl._M_start + __n);\n      }\n#'
[#] parse_declaration, is_constructor=False, meet line: 'reference\n      operator[](size_type __n) noexcept\n      {\n ;\n return *(this->_M_impl._M_start + __n);\n      }\n# 812 "/usr/include/c++/7/bits/stl_vector.h" 3\n      const_reference\n      operator[](siz'
[#] parse_declaration, is_constructor=False, meet line: 'const_reference\n      operator[](size_type __n) const noexcept\n      {\n ;\n return *(this->_M_impl._M_start + __n);\n      }\n\n    protected:\n\n      void\n      _M_range_check(size_type __n) const\n      {'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_range_check(size_type __n) const\n      {\n if (__n >= this->size())\n   __throw_out_of_range_fmt(("vector::_M_range_check: __n " "(which is %zu) >= this->size() " "(which is %zu)")\n\n      '
[#] parse_declaration, is_constructor=False, meet line: 'reference\n      at(size_type __n)\n      {\n _M_range_check(__n);\n return (*this)[__n];\n      }\n# 861 "/usr/include/c++/7/bits/stl_vector.h" 3\n      const_reference\n      at(size_type __n) const\n      {'
[#] parse_declaration, is_constructor=False, meet line: 'const_reference\n      at(size_type __n) const\n      {\n _M_range_check(__n);\n return (*this)[__n];\n      }\n\n\n\n\n\n      reference\n      front() noexcept\n      {\n ;\n return *begin();\n      }\n\n\n\n\n\n      co'
[#] parse_declaration, is_constructor=False, meet line: 'reference\n      front() noexcept\n      {\n ;\n return *begin();\n      }\n\n\n\n\n\n      const_reference\n      front() const noexcept\n      {\n ;\n return *begin();\n      }\n\n\n\n\n\n      reference\n      back() noe'
[#] parse_declaration, is_constructor=False, meet line: 'const_reference\n      front() const noexcept\n      {\n ;\n return *begin();\n      }\n\n\n\n\n\n      reference\n      back() noexcept\n      {\n ;\n return *(end() - 1);\n      }\n\n\n\n\n\n      const_reference\n      b'
[#] parse_declaration, is_constructor=False, meet line: 'reference\n      back() noexcept\n      {\n ;\n return *(end() - 1);\n      }\n\n\n\n\n\n      const_reference\n      back() const noexcept\n      {\n ;\n return *(end() - 1);\n      }\n# 919 "/usr/include/c++/7/bits/'
[#] parse_declaration, is_constructor=False, meet line: 'const_reference\n      back() const noexcept\n      {\n ;\n return *(end() - 1);\n      }\n# 919 "/usr/include/c++/7/bits/stl_vector.h" 3\n      _Tp*\n      data() noexcept\n      { return _M_data_ptr(this->_M'
[#] parse_declaration, is_constructor=False, meet line: '_Tp*\n      data() noexcept\n      { return _M_data_ptr(this->_M_impl._M_start); }\n\n      const _Tp*\n      data() const noexcept\n      { return _M_data_ptr(this->_M_impl._M_start); }\n# 938 "/usr/include'
[#] parse_declaration, is_constructor=False, meet line: '_Tp*\n      data() const noexcept\n      { return _M_data_ptr(this->_M_impl._M_start); }\n# 938 "/usr/include/c++/7/bits/stl_vector.h" 3\n      void\n      push_back(const value_type& __x)\n      {\n if (thi'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      push_back(const value_type& __x)\n      {\n if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)\n   {\n     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,\n        '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      push_back(value_type&& __x)\n      { emplace_back(std::move(__x)); }\n\n      template<typename... _Args>\n\n\n\n void\n\n emplace_back(_Args&&... __args);\n# 974 "/usr/include/c++/7/bits/stl_vector.'
[#] parse_declaration, is_constructor=False, meet line: 'void\n\n emplace_back(_Args&&... __args);\n# 974 "/usr/include/c++/7/bits/stl_vector.h" 3\n      void\n      pop_back() noexcept\n      {\n ;\n --this->_M_impl._M_finish;\n _Alloc_traits::destroy(this->_M_impl'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      pop_back() noexcept\n      {\n ;\n --this->_M_impl._M_finish;\n _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);\n      }\n# 995 "/usr/include/c++/7/bits/stl_vector.h" 3\n      temp'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n emplace(const_iterator __position, _Args&&... __args)\n { return _M_emplace_aux(__position, std::forward<_Args>(__args)...); }\n# 1011 "/usr/include/c++/7/bits/stl_vector.h" 3\n      iterator\n '
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      insert(const_iterator __position, const value_type& __x);\n# 1041 "/usr/include/c++/7/bits/stl_vector.h" 3\n      iterator\n      insert(const_iterator __position, value_type&& __x)\n      '
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      insert(const_iterator __position, value_type&& __x)\n      { return _M_insert_rval(__position, std::move(__x)); }\n# 1058 "/usr/include/c++/7/bits/stl_vector.h" 3\n      iterator\n      ins'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      insert(const_iterator __position, initializer_list<value_type> __l)\n      {\n auto __offset = __position - cbegin();\n _M_range_insert(begin() + __offset, __l.begin(), __l.end(),\n   std::'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      insert(const_iterator __position, size_type __n, const value_type& __x)\n      {\n difference_type __offset = __position - cbegin();\n _M_fill_insert(begin() + __offset, __n, __x);\n return'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n insert(const_iterator __position, _InputIterator __first,\n        _InputIterator __last)\n {\n   difference_type __offset = __position - cbegin();\n   _M_insert_dispatch(begin() + __offset,\n   '
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n\n      erase(const_iterator __position)\n      { return _M_erase(begin() + (__position - cbegin())); }\n# 1204 "/usr/include/c++/7/bits/stl_vector.h" 3\n      iterator\n\n      erase(const_iterato'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n\n      erase(const_iterator __first, const_iterator __last)\n      {\n const auto __beg = begin();\n const auto __cbeg = cbegin();\n return _M_erase(__beg + (__first - __cbeg), __beg + (__last - '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      swap(vector& __x) noexcept\n      {\n\n\n                                                          ;\n\n this->_M_impl._M_swap_data(__x._M_impl);\n _Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      clear() noexcept\n      { _M_erase_at_end(this->_M_impl._M_start); }\n\n    protected:\n\n\n\n\n      template<typename _ForwardIterator>\n pointer\n _M_allocate_and_copy(size_type __n,\n        _Forw'
[#] parse_declaration, is_constructor=False, meet line: 'pointer\n _M_allocate_and_copy(size_type __n,\n        _ForwardIterator __first, _ForwardIterator __last)\n {\n   pointer __result = this->_M_allocate(__n);\n   try\n     {\n       std::__uninitialized_copy_'
[#] parse_declaration, is_constructor=False, meet line: 'void\n _M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)\n {\n   this->_M_impl._M_start = _M_allocate(static_cast<size_type>(__n));\n   this->_M_impl._M_end_of_storage =\n     this->_M_im'
[#] parse_declaration, is_constructor=False, meet line: 'void\n _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,\n          __false_type)\n {\n   typedef typename std::iterator_traits<_InputIterator>::\n     iterator_category _IterCategory;\n'
[#] parse_declaration, is_constructor=False, meet line: 'void\n _M_range_initialize(_InputIterator __first, _InputIterator __last,\n       std::input_iterator_tag)\n {\n   try {\n     for (; __first != __last; ++__first)\n\n       emplace_back(*__first);\n\n\n\n   } c'
[#] parse_declaration, is_constructor=False, meet line: 'void\n _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,\n       std::forward_iterator_tag)\n {\n   const size_type __n = std::distance(__first, __last);\n   this->_M_impl._M_start = t'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_fill_initialize(size_type __n, const value_type& __value)\n      {\n this->_M_impl._M_finish =\n   std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,\n     _M_get_Tp_allocat'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_default_initialize(size_type __n)\n      {\n this->_M_impl._M_finish =\n   std::__uninitialized_default_n_a(this->_M_impl._M_start, __n,\n        _M_get_Tp_allocator());\n      }\n# 1364 "/usr'
[#] parse_declaration, is_constructor=False, meet line: 'void\n _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)\n { _M_fill_assign(__n, __val); }\n\n\n      template<typename _InputIterator>\n void\n _M_assign_dispatch(_InputIterator __first, _InputI'
[#] parse_declaration, is_constructor=False, meet line: 'void\n _M_assign_dispatch(_InputIterator __first, _InputIterator __last,\n      __false_type)\n { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }\n\n\n      template<typename _InputIter'
[#] parse_declaration, is_constructor=False, meet line: 'void\n _M_assign_aux(_InputIterator __first, _InputIterator __last,\n        std::input_iterator_tag);\n\n\n      template<typename _ForwardIterator>\n void\n _M_assign_aux(_ForwardIterator __first, _Forward'
[#] parse_declaration, is_constructor=False, meet line: 'void\n _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,\n        std::forward_iterator_tag);\n\n\n\n      void\n      _M_fill_assign(size_type __n, const value_type& __val);\n\n\n\n\n\n\n\n      temp'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_fill_assign(size_type __n, const value_type& __val);\n\n\n\n\n\n\n\n      template<typename _Integer>\n void\n _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,\n      __true_type)\n '
[#] parse_declaration, is_constructor=False, meet line: 'void\n _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,\n      __true_type)\n { _M_fill_insert(__pos, __n, __val); }\n\n\n      template<typename _InputIterator>\n void\n _M_insert_dispatch(it'
[#] parse_declaration, is_constructor=False, meet line: 'void\n _M_insert_dispatch(iterator __pos, _InputIterator __first,\n      _InputIterator __last, __false_type)\n {\n   _M_range_insert(__pos, __first, __last,\n     std::__iterator_category(__first));\n }\n\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'void\n _M_range_insert(iterator __pos, _InputIterator __first,\n   _InputIterator __last, std::input_iterator_tag);\n\n\n      template<typename _ForwardIterator>\n void\n _M_range_insert(iterator __pos, _Fo'
[#] parse_declaration, is_constructor=False, meet line: 'void\n _M_range_insert(iterator __pos, _ForwardIterator __first,\n   _ForwardIterator __last, std::forward_iterator_tag);\n\n\n\n      void\n      _M_fill_insert(iterator __pos, size_type __n, const value_ty'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);\n\n\n\n      void\n      _M_default_append(size_type __n);\n\n      bool\n      _M_shrink_to_fit();\n# 1451 "/usr/include/c++/7/'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_default_append(size_type __n);\n\n      bool\n      _M_shrink_to_fit();\n# 1451 "/usr/include/c++/7/bits/stl_vector.h" 3\n      struct _Temporary_value\n      {\n template<typename... _Args>\n  '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      _M_shrink_to_fit();\n# 1451 "/usr/include/c++/7/bits/stl_vector.h" 3\n      struct _Temporary_value\n      {\n template<typename... _Args>\n   explicit\n   _Temporary_value(vector* __vec, _Args&&'
[#] parse_declaration, is_constructor=True, meet line: '_Temporary_value(vector* __vec, _Args&&... __args) : _M_this(__vec)\n   {\n     _Alloc_traits::construct(_M_this->_M_impl, _M_ptr(),\n         std::forward<_Args>(__args)...);\n   }\n\n ~_Temporary_value()\n'
[#] parse_declaration, is_constructor=True, meet line: '_Temporary_value()\n { _Alloc_traits::destroy(_M_this->_M_impl, _M_ptr()); }\n\n value_type&\n _M_val() { return *reinterpret_cast<_Tp*>(&__buf); }\n\n      private:\n pointer\n _M_ptr() { return pointer_trai'
[#] parse_declaration, is_constructor=False, meet line: 'value_type&\n _M_val() { return *reinterpret_cast<_Tp*>(&__buf); }\n\n      private:\n pointer\n _M_ptr() { return pointer_traits<pointer>::pointer_to(_M_val()); }\n\n vector* _M_this;\n typename aligned_stor'
[#] parse_declaration, is_constructor=False, meet line: 'pointer\n _M_ptr() { return pointer_traits<pointer>::pointer_to(_M_val()); }\n\n vector* _M_this;\n typename aligned_storage<sizeof(_Tp), alignof(_Tp)>::type __buf;\n      };\n\n\n\n      template<typename _Ar'
[#] parse_declaration, is_constructor=False, meet line: 'vector* _M_this;\n typename aligned_storage<sizeof(_Tp), alignof(_Tp)>::type __buf;\n      };\n\n\n\n      template<typename _Arg>\n void\n _M_insert_aux(iterator __position, _Arg&& __arg);\n\n      template<ty'
[#] parse_declaration, is_constructor=False, meet line: 'aligned_storage<sizeof(_Tp), alignof(_Tp)>::type __buf;\n      };\n\n\n\n      template<typename _Arg>\n void\n _M_insert_aux(iterator __position, _Arg&& __arg);\n\n      template<typename... _Args>\n void\n _M_'
[#] parse_declaration, is_constructor=False, meet line: 'void\n _M_insert_aux(iterator __position, _Arg&& __arg);\n\n      template<typename... _Args>\n void\n _M_realloc_insert(iterator __position, _Args&&... __args);\n\n\n      iterator\n      _M_insert_rval(const'
[#] parse_declaration, is_constructor=False, meet line: 'void\n _M_realloc_insert(iterator __position, _Args&&... __args);\n\n\n      iterator\n      _M_insert_rval(const_iterator __position, value_type&& __v);\n\n\n      template<typename... _Args>\n iterator\n _M_e'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      _M_insert_rval(const_iterator __position, value_type&& __v);\n\n\n      template<typename... _Args>\n iterator\n _M_emplace_aux(const_iterator __position, _Args&&... __args);\n\n\n      iterato'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n _M_emplace_aux(const_iterator __position, _Args&&... __args);\n\n\n      iterator\n      _M_emplace_aux(const_iterator __position, value_type&& __v)\n      { return _M_insert_rval(__position, std'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      _M_emplace_aux(const_iterator __position, value_type&& __v)\n      { return _M_insert_rval(__position, std::move(__v)); }\n\n\n\n      size_type\n      _M_check_len(size_type __n, const char*'
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      _M_check_len(size_type __n, const char* __s) const\n      {\n if (max_size() - size() < __n)\n   __throw_length_error((__s));\n\n const size_type __len = size() + std::max(size(), __n);\n re'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_erase_at_end(pointer __pos) noexcept\n      {\n std::_Destroy(__pos, this->_M_impl._M_finish, _M_get_Tp_allocator());\n this->_M_impl._M_finish = __pos;\n      }\n\n      iterator\n      _M_era'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      _M_erase(iterator __position);\n\n      iterator\n      _M_erase(iterator __first, iterator __last);\n\n\n    private:\n\n\n\n      void\n      _M_move_assign(vector&& __x, std::true_type) noexcep'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      _M_erase(iterator __first, iterator __last);\n\n\n    private:\n\n\n\n      void\n      _M_move_assign(vector&& __x, std::true_type) noexcept\n      {\n vector __tmp(get_allocator());\n this->_M_i'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_move_assign(vector&& __x, std::true_type) noexcept\n      {\n vector __tmp(get_allocator());\n this->_M_impl._M_swap_data(__tmp._M_impl);\n this->_M_impl._M_swap_data(__x._M_impl);\n std::__a'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_move_assign(vector&& __x, std::false_type)\n      {\n if (__x._M_get_Tp_allocator() == this->_M_get_Tp_allocator())\n   _M_move_assign(std::move(__x), std::true_type());\n else\n   {\n\n\n     t'
[#] parse_declaration, is_constructor=False, meet line: '_Up*\n _M_data_ptr(_Up* __ptr) const noexcept\n { return __ptr; }\n\n\n      template<typename _Ptr>\n typename std::pointer_traits<_Ptr>::element_type*\n _M_data_ptr(_Ptr __ptr) const\n { return empty() ? nu'
[#] parse_declaration, is_constructor=False, meet line: 'std::pointer_traits<_Ptr>::element_type*\n _M_data_ptr(_Ptr __ptr) const\n { return empty() ? nullptr : std::__addressof(*__ptr); }\n# 1586 "/usr/include/c++/7/bits/stl_vector.h" 3\n    };\n# 1599 "/usr/in'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n    { return (__x.size() == __y.size()\n       && std::equal(__x.begin(), __x.end(), __y.begin())); }\n# 1616 "/usr/in'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n    { return std::lexicographical_compare(__x.begin(), __x.end(),\n       __y.begin(), __y.end()); }\n\n\n  template<type'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n    { return !(__x == __y); }\n\n\n  template<typename _Tp, typename _Alloc>\n    inline bool\n    operator>(const vector'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n    { return __y < __x; }\n\n\n  template<typename _Tp, typename _Alloc>\n    inline bool\n    operator<=(const vector<_Tp'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n    { return !(__y < __x); }\n\n\n  template<typename _Tp, typename _Alloc>\n    inline bool\n    operator>=(const vector'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n    { return !(__x < __y); }\n\n\n  template<typename _Tp, typename _Alloc>\n    inline void\n    swap(vector<_Tp, _Alloc'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)\n    noexcept(noexcept(__x.swap(__y)))\n    { __x.swap(__y); }\n\n\n}\n# 65 "/usr/include/c++/7/vector" 2 3\n# 1 "/usr/include/c++/7/bits/stl'
[#] parse_declaration, is_constructor=False, meet line: '_Bit_type * _M_p;\n    _Bit_type _M_mask;\n\n    _Bit_reference(_Bit_type * __x, _Bit_type __y)\n    : _M_p(__x), _M_mask(__y) { }\n\n    _Bit_reference() noexcept : _M_p(0), _M_mask(0) { }\n\n    operator bo'
[#] parse_declaration, is_constructor=False, meet line: '_Bit_type _M_mask;\n\n    _Bit_reference(_Bit_type * __x, _Bit_type __y)\n    : _M_p(__x), _M_mask(__y) { }\n\n    _Bit_reference() noexcept : _M_p(0), _M_mask(0) { }\n\n    operator bool() const noexcept\n  '
[#] parse_declaration, is_constructor=True, meet line: '_Bit_reference(_Bit_type * __x, _Bit_type __y)\n    : _M_p(__x), _M_mask(__y) { }\n\n    _Bit_reference() noexcept : _M_p(0), _M_mask(0) { }\n\n    operator bool() const noexcept\n    { return !!(*_M_p & _M'
[#] parse_declaration, is_constructor=True, meet line: '_Bit_reference() noexcept : _M_p(0), _M_mask(0) { }\n\n    operator bool() const noexcept\n    { return !!(*_M_p & _M_mask); }\n\n    _Bit_reference&\n    operator=(bool __x) noexcept\n    {\n      if (__x)\n '
[#] parse_declaration, is_constructor=False, meet line: 'operator bool() const noexcept\n    { return !!(*_M_p & _M_mask); }\n\n    _Bit_reference&\n    operator=(bool __x) noexcept\n    {\n      if (__x)\n *_M_p |= _M_mask;\n      else\n *_M_p &= ~_M_mask;\n      re'
[#] parse_declaration, is_constructor=True, meet line: '_Bit_reference&\n    operator=(bool __x) noexcept\n    {\n      if (__x)\n *_M_p |= _M_mask;\n      else\n *_M_p &= ~_M_mask;\n      return *this;\n    }\n\n    _Bit_reference&\n    operator=(const _Bit_referenc'
[#] parse_declaration, is_constructor=True, meet line: '_Bit_reference&\n    operator=(const _Bit_reference& __x) noexcept\n    { return *this = bool(__x); }\n\n    bool\n    operator==(const _Bit_reference& __x) const\n    { return bool(*this) == bool(__x); }\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator==(const _Bit_reference& __x) const\n    { return bool(*this) == bool(__x); }\n\n    bool\n    operator<(const _Bit_reference& __x) const\n    { return !bool(*this) && bool(__x); }\n\n    vo'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<(const _Bit_reference& __x) const\n    { return !bool(*this) && bool(__x); }\n\n    void\n    flip() noexcept\n    { *_M_p ^= _M_mask; }\n  };\n\n\n  inline void\n  swap(_Bit_reference __x, _B'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    flip() noexcept\n    { *_M_p ^= _M_mask; }\n  };\n\n\n  inline void\n  swap(_Bit_reference __x, _Bit_reference __y) noexcept\n  {\n    bool __tmp = __x;\n    __x = __y;\n    __y = __tmp;\n  }\n\n  inline '
[#] parse_declaration, is_constructor=False, meet line: 'void\n  swap(_Bit_reference __x, _Bit_reference __y) noexcept\n  {\n    bool __tmp = __x;\n    __x = __y;\n    __y = __tmp;\n  }\n\n  inline void\n  swap(_Bit_reference __x, bool& __y) noexcept\n  {\n    bool __'
[#] parse_declaration, is_constructor=False, meet line: 'void\n  swap(_Bit_reference __x, bool& __y) noexcept\n  {\n    bool __tmp = __x;\n    __x = __y;\n    __y = __tmp;\n  }\n\n  inline void\n  swap(bool& __x, _Bit_reference __y) noexcept\n  {\n    bool __tmp = __x'
[#] parse_declaration, is_constructor=False, meet line: 'void\n  swap(bool& __x, _Bit_reference __y) noexcept\n  {\n    bool __tmp = __x;\n    __x = __y;\n    __y = __tmp;\n  }\n\n\n  struct _Bit_iterator_base\n  : public std::iterator<std::random_access_iterator_tag'
[#] parse_declaration, is_constructor=False, meet line: '_Bit_type * _M_p;\n    unsigned int _M_offset;\n\n    _Bit_iterator_base(_Bit_type * __x, unsigned int __y)\n    : _M_p(__x), _M_offset(__y) { }\n\n    void\n    _M_bump_up()\n    {\n      if (_M_offset++ == i'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned int _M_offset;\n\n    _Bit_iterator_base(_Bit_type * __x, unsigned int __y)\n    : _M_p(__x), _M_offset(__y) { }\n\n    void\n    _M_bump_up()\n    {\n      if (_M_offset++ == int(_S_word_bit) - 1)\n '
[#] parse_declaration, is_constructor=True, meet line: '_Bit_iterator_base(_Bit_type * __x, unsigned int __y)\n    : _M_p(__x), _M_offset(__y) { }\n\n    void\n    _M_bump_up()\n    {\n      if (_M_offset++ == int(_S_word_bit) - 1)\n {\n   _M_offset = 0;\n   ++_M_p'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _M_bump_up()\n    {\n      if (_M_offset++ == int(_S_word_bit) - 1)\n {\n   _M_offset = 0;\n   ++_M_p;\n }\n    }\n\n    void\n    _M_bump_down()\n    {\n      if (_M_offset-- == 0)\n {\n   _M_offset = int'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _M_bump_down()\n    {\n      if (_M_offset-- == 0)\n {\n   _M_offset = int(_S_word_bit) - 1;\n   --_M_p;\n }\n    }\n\n    void\n    _M_incr(ptrdiff_t __i)\n    {\n      difference_type __n = __i + _M_of'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _M_incr(ptrdiff_t __i)\n    {\n      difference_type __n = __i + _M_offset;\n      _M_p += __n / int(_S_word_bit);\n      __n = __n % int(_S_word_bit);\n      if (__n < 0)\n {\n   __n += int(_S_word'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator==(const _Bit_iterator_base& __i) const\n    { return _M_p == __i._M_p && _M_offset == __i._M_offset; }\n\n    bool\n    operator<(const _Bit_iterator_base& __i) const\n    {\n      return '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<(const _Bit_iterator_base& __i) const\n    {\n      return _M_p < __i._M_p\n      || (_M_p == __i._M_p && _M_offset < __i._M_offset);\n    }\n\n    bool\n    operator!=(const _Bit_iterator_'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator!=(const _Bit_iterator_base& __i) const\n    { return !(*this == __i); }\n\n    bool\n    operator>(const _Bit_iterator_base& __i) const\n    { return __i < *this; }\n\n    bool\n    operator'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>(const _Bit_iterator_base& __i) const\n    { return __i < *this; }\n\n    bool\n    operator<=(const _Bit_iterator_base& __i) const\n    { return !(__i < *this); }\n\n    bool\n    operator>'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<=(const _Bit_iterator_base& __i) const\n    { return !(__i < *this); }\n\n    bool\n    operator>=(const _Bit_iterator_base& __i) const\n    { return !(*this < __i); }\n  };\n\n  inline ptrd'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>=(const _Bit_iterator_base& __i) const\n    { return !(*this < __i); }\n  };\n\n  inline ptrdiff_t\n  operator-(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)\n  {\n    retur'
[#] parse_declaration, is_constructor=False, meet line: 'ptrdiff_t\n  operator-(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)\n  {\n    return (int(_S_word_bit) * (__x._M_p - __y._M_p)\n     + __x._M_offset - __y._M_offset);\n  }\n\n  struct _Bit_i'
[#] parse_declaration, is_constructor=True, meet line: '_Bit_iterator() : _Bit_iterator_base(0, 0) { }\n\n    _Bit_iterator(_Bit_type * __x, unsigned int __y)\n    : _Bit_iterator_base(__x, __y) { }\n\n    iterator\n    _M_const_cast() const\n    { return *this; '
[#] parse_declaration, is_constructor=True, meet line: '_Bit_iterator(_Bit_type * __x, unsigned int __y)\n    : _Bit_iterator_base(__x, __y) { }\n\n    iterator\n    _M_const_cast() const\n    { return *this; }\n\n    reference\n    operator*() const\n    { return '
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n    _M_const_cast() const\n    { return *this; }\n\n    reference\n    operator*() const\n    { return reference(_M_p, 1UL << _M_offset); }\n\n    iterator&\n    operator++()\n    {\n      _M_bump_up()'
[#] parse_declaration, is_constructor=False, meet line: 'reference\n    operator*() const\n    { return reference(_M_p, 1UL << _M_offset); }\n\n    iterator&\n    operator++()\n    {\n      _M_bump_up();\n      return *this;\n    }\n\n    iterator\n    operator++(int)\n'
[#] parse_declaration, is_constructor=False, meet line: 'iterator&\n    operator++()\n    {\n      _M_bump_up();\n      return *this;\n    }\n\n    iterator\n    operator++(int)\n    {\n      iterator __tmp = *this;\n      _M_bump_up();\n      return __tmp;\n    }\n\n    '
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n    operator++(int)\n    {\n      iterator __tmp = *this;\n      _M_bump_up();\n      return __tmp;\n    }\n\n    iterator&\n    operator--()\n    {\n      _M_bump_down();\n      return *this;\n    }\n\n  '
[#] parse_declaration, is_constructor=False, meet line: 'iterator&\n    operator--()\n    {\n      _M_bump_down();\n      return *this;\n    }\n\n    iterator\n    operator--(int)\n    {\n      iterator __tmp = *this;\n      _M_bump_down();\n      return __tmp;\n    }\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n    operator--(int)\n    {\n      iterator __tmp = *this;\n      _M_bump_down();\n      return __tmp;\n    }\n\n    iterator&\n    operator+=(difference_type __i)\n    {\n      _M_incr(__i);\n      retu'
[#] parse_declaration, is_constructor=False, meet line: 'iterator&\n    operator+=(difference_type __i)\n    {\n      _M_incr(__i);\n      return *this;\n    }\n\n    iterator&\n    operator-=(difference_type __i)\n    {\n      *this += -__i;\n      return *this;\n    '
[#] parse_declaration, is_constructor=False, meet line: 'iterator&\n    operator-=(difference_type __i)\n    {\n      *this += -__i;\n      return *this;\n    }\n\n    iterator\n    operator+(difference_type __i) const\n    {\n      iterator __tmp = *this;\n      retu'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n    operator+(difference_type __i) const\n    {\n      iterator __tmp = *this;\n      return __tmp += __i;\n    }\n\n    iterator\n    operator-(difference_type __i) const\n    {\n      iterator __tmp'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n    operator-(difference_type __i) const\n    {\n      iterator __tmp = *this;\n      return __tmp -= __i;\n    }\n\n    reference\n    operator[](difference_type __i) const\n    { return *(*this + _'
[#] parse_declaration, is_constructor=False, meet line: 'reference\n    operator[](difference_type __i) const\n    { return *(*this + __i); }\n  };\n\n  inline _Bit_iterator\n  operator+(ptrdiff_t __n, const _Bit_iterator& __x)\n  { return __x + __n; }\n\n  struct _'
[#] parse_declaration, is_constructor=False, meet line: '_Bit_iterator\n  operator+(ptrdiff_t __n, const _Bit_iterator& __x)\n  { return __x + __n; }\n\n  struct _Bit_const_iterator : public _Bit_iterator_base\n  {\n    typedef bool reference;\n    typedef bool co'
[#] parse_declaration, is_constructor=True, meet line: '_Bit_const_iterator() : _Bit_iterator_base(0, 0) { }\n\n    _Bit_const_iterator(_Bit_type * __x, unsigned int __y)\n    : _Bit_iterator_base(__x, __y) { }\n\n    _Bit_const_iterator(const _Bit_iterator& __'
[#] parse_declaration, is_constructor=True, meet line: '_Bit_const_iterator(_Bit_type * __x, unsigned int __y)\n    : _Bit_iterator_base(__x, __y) { }\n\n    _Bit_const_iterator(const _Bit_iterator& __x)\n    : _Bit_iterator_base(__x._M_p, __x._M_offset) { }\n\n'
[#] parse_declaration, is_constructor=True, meet line: '_Bit_const_iterator(const _Bit_iterator& __x)\n    : _Bit_iterator_base(__x._M_p, __x._M_offset) { }\n\n    _Bit_iterator\n    _M_const_cast() const\n    { return _Bit_iterator(_M_p, _M_offset); }\n\n    con'
[#] parse_declaration, is_constructor=False, meet line: '_Bit_iterator\n    _M_const_cast() const\n    { return _Bit_iterator(_M_p, _M_offset); }\n\n    const_reference\n    operator*() const\n    { return _Bit_reference(_M_p, 1UL << _M_offset); }\n\n    const_iter'
[#] parse_declaration, is_constructor=False, meet line: 'const_reference\n    operator*() const\n    { return _Bit_reference(_M_p, 1UL << _M_offset); }\n\n    const_iterator&\n    operator++()\n    {\n      _M_bump_up();\n      return *this;\n    }\n\n    const_iterat'
[#] parse_declaration, is_constructor=False, meet line: 'const_iterator&\n    operator++()\n    {\n      _M_bump_up();\n      return *this;\n    }\n\n    const_iterator\n    operator++(int)\n    {\n      const_iterator __tmp = *this;\n      _M_bump_up();\n      return '
[#] parse_declaration, is_constructor=False, meet line: 'const_iterator\n    operator++(int)\n    {\n      const_iterator __tmp = *this;\n      _M_bump_up();\n      return __tmp;\n    }\n\n    const_iterator&\n    operator--()\n    {\n      _M_bump_down();\n      retur'
[#] parse_declaration, is_constructor=False, meet line: 'const_iterator&\n    operator--()\n    {\n      _M_bump_down();\n      return *this;\n    }\n\n    const_iterator\n    operator--(int)\n    {\n      const_iterator __tmp = *this;\n      _M_bump_down();\n      ret'
[#] parse_declaration, is_constructor=False, meet line: 'const_iterator\n    operator--(int)\n    {\n      const_iterator __tmp = *this;\n      _M_bump_down();\n      return __tmp;\n    }\n\n    const_iterator&\n    operator+=(difference_type __i)\n    {\n      _M_inc'
[#] parse_declaration, is_constructor=False, meet line: 'const_iterator&\n    operator+=(difference_type __i)\n    {\n      _M_incr(__i);\n      return *this;\n    }\n\n    const_iterator&\n    operator-=(difference_type __i)\n    {\n      *this += -__i;\n      return'
[#] parse_declaration, is_constructor=False, meet line: 'const_iterator&\n    operator-=(difference_type __i)\n    {\n      *this += -__i;\n      return *this;\n    }\n\n    const_iterator\n    operator+(difference_type __i) const\n    {\n      const_iterator __tmp ='
[#] parse_declaration, is_constructor=False, meet line: 'const_iterator\n    operator+(difference_type __i) const\n    {\n      const_iterator __tmp = *this;\n      return __tmp += __i;\n    }\n\n    const_iterator\n    operator-(difference_type __i) const\n    {\n  '
[#] parse_declaration, is_constructor=False, meet line: 'const_iterator\n    operator-(difference_type __i) const\n    {\n      const_iterator __tmp = *this;\n      return __tmp -= __i;\n    }\n\n    const_reference\n    operator[](difference_type __i) const\n    { '
[#] parse_declaration, is_constructor=False, meet line: 'const_reference\n    operator[](difference_type __i) const\n    { return *(*this + __i); }\n  };\n\n  inline _Bit_const_iterator\n  operator+(ptrdiff_t __n, const _Bit_const_iterator& __x)\n  { return __x + '
[#] parse_declaration, is_constructor=False, meet line: '_Bit_const_iterator\n  operator+(ptrdiff_t __n, const _Bit_const_iterator& __x)\n  { return __x + __n; }\n\n  inline void\n  __fill_bvector(_Bit_iterator __first, _Bit_iterator __last, bool __x)\n  {\n    fo'
[#] parse_declaration, is_constructor=False, meet line: 'void\n  __fill_bvector(_Bit_iterator __first, _Bit_iterator __last, bool __x)\n  {\n    for (; __first != __last; ++__first)\n      *__first = __x;\n  }\n\n  inline void\n  fill(_Bit_iterator __first, _Bit_it'
[#] parse_declaration, is_constructor=False, meet line: 'void\n  fill(_Bit_iterator __first, _Bit_iterator __last, const bool& __x)\n  {\n    if (__first._M_p != __last._M_p)\n      {\n std::fill(__first._M_p + 1, __last._M_p, __x ? ~0 : 0);\n __fill_bvector(__fi'
[#] parse_declaration, is_constructor=False, meet line: '_Bit_iterator _M_start;\n _Bit_iterator _M_finish;\n _Bit_pointer _M_end_of_storage;\n\n _Bvector_impl()\n : _Bit_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage()\n { }\n\n _Bvector_impl(const _Bit_'
[#] parse_declaration, is_constructor=False, meet line: '_Bit_iterator _M_finish;\n _Bit_pointer _M_end_of_storage;\n\n _Bvector_impl()\n : _Bit_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage()\n { }\n\n _Bvector_impl(const _Bit_alloc_type& __a)\n : _Bit_'
[#] parse_declaration, is_constructor=False, meet line: '_Bit_pointer _M_end_of_storage;\n\n _Bvector_impl()\n : _Bit_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage()\n { }\n\n _Bvector_impl(const _Bit_alloc_type& __a)\n : _Bit_alloc_type(__a), _M_start('
[#] parse_declaration, is_constructor=True, meet line: '_Bvector_impl()\n : _Bit_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage()\n { }\n\n _Bvector_impl(const _Bit_alloc_type& __a)\n : _Bit_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage('
[#] parse_declaration, is_constructor=True, meet line: '_Bvector_impl(const _Bit_alloc_type& __a)\n : _Bit_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage()\n { }\n\n\n _Bvector_impl(_Bit_alloc_type&& __a)\n : _Bit_alloc_type(std::move(__a)), _M_star'
[#] parse_declaration, is_constructor=True, meet line: '_Bvector_impl(_Bit_alloc_type&& __a)\n : _Bit_alloc_type(std::move(__a)), _M_start(), _M_finish(),\n   _M_end_of_storage()\n { }\n\n\n _Bit_type*\n _M_end_addr() const noexcept\n {\n   if (_M_end_of_storage)\n '
[#] parse_declaration, is_constructor=False, meet line: '_Bit_type*\n _M_end_addr() const noexcept\n {\n   if (_M_end_of_storage)\n     return std::__addressof(_M_end_of_storage[-1]) + 1;\n   return 0;\n }\n      };\n\n    public:\n      typedef _Alloc allocator_type'
[#] parse_declaration, is_constructor=False, meet line: '_Bit_alloc_type&\n      _M_get_Bit_allocator() noexcept\n      { return *static_cast<_Bit_alloc_type*>(&this->_M_impl); }\n\n      const _Bit_alloc_type&\n      _M_get_Bit_allocator() const noexcept\n      '
[#] parse_declaration, is_constructor=False, meet line: '_Bit_alloc_type&\n      _M_get_Bit_allocator() const noexcept\n      { return *static_cast<const _Bit_alloc_type*>(&this->_M_impl); }\n\n      allocator_type\n      get_allocator() const noexcept\n      { r'
[#] parse_declaration, is_constructor=False, meet line: 'allocator_type\n      get_allocator() const noexcept\n      { return allocator_type(_M_get_Bit_allocator()); }\n\n      _Bvector_base()\n      : _M_impl() { }\n\n      _Bvector_base(const allocator_type& __a'
[#] parse_declaration, is_constructor=True, meet line: '_Bvector_base()\n      : _M_impl() { }\n\n      _Bvector_base(const allocator_type& __a)\n      : _M_impl(__a) { }\n\n\n      _Bvector_base(_Bvector_base&& __x) noexcept\n      : _M_impl(std::move(__x._M_get_'
[#] parse_declaration, is_constructor=True, meet line: '_Bvector_base(const allocator_type& __a)\n      : _M_impl(__a) { }\n\n\n      _Bvector_base(_Bvector_base&& __x) noexcept\n      : _M_impl(std::move(__x._M_get_Bit_allocator()))\n      {\n this->_M_impl._M_s'
[#] parse_declaration, is_constructor=True, meet line: '_Bvector_base(_Bvector_base&& __x) noexcept\n      : _M_impl(std::move(__x._M_get_Bit_allocator()))\n      {\n this->_M_impl._M_start = __x._M_impl._M_start;\n this->_M_impl._M_finish = __x._M_impl._M_fin'
[#] parse_declaration, is_constructor=True, meet line: '_Bvector_base()\n      { this->_M_deallocate(); }\n\n    protected:\n      _Bvector_impl _M_impl;\n\n      _Bit_pointer\n      _M_allocate(size_t __n)\n      { return _Bit_alloc_traits::allocate(_M_impl, _S_n'
[#] parse_declaration, is_constructor=False, meet line: '_Bvector_impl _M_impl;\n\n      _Bit_pointer\n      _M_allocate(size_t __n)\n      { return _Bit_alloc_traits::allocate(_M_impl, _S_nword(__n)); }\n\n      void\n      _M_deallocate()\n      {\n if (_M_impl._M'
[#] parse_declaration, is_constructor=False, meet line: '_Bit_pointer\n      _M_allocate(size_t __n)\n      { return _Bit_alloc_traits::allocate(_M_impl, _S_nword(__n)); }\n\n      void\n      _M_deallocate()\n      {\n if (_M_impl._M_start._M_p)\n   {\n     const s'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_deallocate()\n      {\n if (_M_impl._M_start._M_p)\n   {\n     const size_t __n = _M_impl._M_end_addr() - _M_impl._M_start._M_p;\n     _Bit_alloc_traits::deallocate(_M_impl,\n       _M_impl._M'
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n      _S_nword(size_t __n)\n      { return (__n + int(_S_word_bit) - 1) / int(_S_word_bit); }\n    };\n\n\n}\n\n\n\n\nnamespace std __attribute__ ((__visibility__ ("default")))\n{\n\n# 542 "/usr/include/c++'
[#] parse_declaration, is_constructor=False, meet line: 'allocator_type get_allocator() const\n    { return _Base::get_allocator(); }\n\n  protected:\n    using _Base::_M_allocate;\n    using _Base::_M_deallocate;\n    using _Base::_S_nword;\n    using _Base::_M_g'
[#] parse_declaration, is_constructor=True, meet line: 'vector()\n\n      noexcept(is_nothrow_default_constructible<allocator_type>::value)\n\n    : _Base() { }\n\n    explicit\n    vector(const allocator_type& __a)\n    : _Base(__a) { }\n\n\n    explicit\n    vector('
[#] parse_declaration, is_constructor=True, meet line: 'vector(const allocator_type& __a)\n    : _Base(__a) { }\n\n\n    explicit\n    vector(size_type __n, const allocator_type& __a = allocator_type())\n    : vector(__n, false, __a)\n    { }\n\n    vector(size_typ'
[#] parse_declaration, is_constructor=True, meet line: 'vector(size_type __n, const allocator_type& __a = allocator_type())\n    : vector(__n, false, __a)\n    { }\n\n    vector(size_type __n, const bool& __value,\n    const allocator_type& __a = allocator_type'
[#] parse_declaration, is_constructor=True, meet line: 'vector(size_type __n, const bool& __value,\n    const allocator_type& __a = allocator_type())\n    : _Base(__a)\n    {\n      _M_initialize(__n);\n      std::fill(this->_M_impl._M_start._M_p, this->_M_impl'
[#] parse_declaration, is_constructor=True, meet line: 'vector(const vector& __x)\n    : _Base(_Bit_alloc_traits::_S_select_on_copy(__x._M_get_Bit_allocator()))\n    {\n      _M_initialize(__x.size());\n      _M_copy_aligned(__x.begin(), __x.end(), this->_M_im'
[#] parse_declaration, is_constructor=True, meet line: 'vector(vector&& __x) noexcept\n    : _Base(std::move(__x)) { }\n\n    vector(vector&& __x, const allocator_type& __a)\n    noexcept(_Bit_alloc_traits::_S_always_equal())\n    : _Base(__a)\n    {\n      if (_'
[#] parse_declaration, is_constructor=True, meet line: 'vector(vector&& __x, const allocator_type& __a)\n    noexcept(_Bit_alloc_traits::_S_always_equal())\n    : _Base(__a)\n    {\n      if (__x.get_allocator() == __a)\n {\n   this->_M_impl._M_start = __x._M_im'
[#] parse_declaration, is_constructor=True, meet line: 'vector(const vector& __x, const allocator_type& __a)\n    : _Base(__a)\n    {\n      _M_initialize(__x.size());\n      _M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);\n    }\n\n    vector(in'
[#] parse_declaration, is_constructor=True, meet line: 'vector(initializer_list<bool> __l,\n    const allocator_type& __a = allocator_type())\n    : _Base(__a)\n    {\n      _M_initialize_range(__l.begin(), __l.end(),\n     random_access_iterator_tag());\n    }\n'
[#] parse_declaration, is_constructor=True, meet line: 'vector(_InputIterator __first, _InputIterator __last,\n      const allocator_type& __a = allocator_type())\n      : _Base(__a)\n      { _M_initialize_dispatch(__first, __last, __false_type()); }\n# 679 "/'
[#] parse_declaration, is_constructor=True, meet line: 'vector() noexcept { }\n\n    vector&\n    operator=(const vector& __x)\n    {\n      if (&__x == this)\n return *this;\n\n      if (_Bit_alloc_traits::_S_propagate_on_copy_assign())\n {\n   if (this->_M_get_Bit'
[#] parse_declaration, is_constructor=True, meet line: 'vector&\n    operator=(const vector& __x)\n    {\n      if (&__x == this)\n return *this;\n\n      if (_Bit_alloc_traits::_S_propagate_on_copy_assign())\n {\n   if (this->_M_get_Bit_allocator() != __x._M_get_'
[#] parse_declaration, is_constructor=True, meet line: 'vector&\n    operator=(vector&& __x) noexcept(_Bit_alloc_traits::_S_nothrow_move())\n    {\n      if (_Bit_alloc_traits::_S_propagate_on_move_assign()\n   || this->_M_get_Bit_allocator() == __x._M_get_Bit'
[#] parse_declaration, is_constructor=True, meet line: 'vector&\n    operator=(initializer_list<bool> __l)\n    {\n      this->assign (__l.begin(), __l.end());\n      return *this;\n    }\n\n\n\n\n\n\n    void\n    assign(size_type __n, const bool& __x)\n    { _M_fill_a'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    assign(size_type __n, const bool& __x)\n    { _M_fill_assign(__n, __x); }\n\n\n    template<typename _InputIterator,\n      typename = std::_RequireInputIter<_InputIterator>>\n      void\n      assi'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      assign(_InputIterator __first, _InputIterator __last)\n      { _M_assign_dispatch(__first, __last, __false_type()); }\n# 775 "/usr/include/c++/7/bits/stl_bvector.h" 3\n    void\n    assign(init'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    assign(initializer_list<bool> __l)\n    { this->assign(__l.begin(), __l.end()); }\n\n\n    iterator\n    begin() noexcept\n    { return this->_M_impl._M_start; }\n\n    const_iterator\n    begin() con'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n    begin() noexcept\n    { return this->_M_impl._M_start; }\n\n    const_iterator\n    begin() const noexcept\n    { return this->_M_impl._M_start; }\n\n    iterator\n    end() noexcept\n    { return'
[#] parse_declaration, is_constructor=False, meet line: 'const_iterator\n    begin() const noexcept\n    { return this->_M_impl._M_start; }\n\n    iterator\n    end() noexcept\n    { return this->_M_impl._M_finish; }\n\n    const_iterator\n    end() const noexcept\n '
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n    end() noexcept\n    { return this->_M_impl._M_finish; }\n\n    const_iterator\n    end() const noexcept\n    { return this->_M_impl._M_finish; }\n\n    reverse_iterator\n    rbegin() noexcept\n   '
[#] parse_declaration, is_constructor=False, meet line: 'const_iterator\n    end() const noexcept\n    { return this->_M_impl._M_finish; }\n\n    reverse_iterator\n    rbegin() noexcept\n    { return reverse_iterator(end()); }\n\n    const_reverse_iterator\n    rbeg'
[#] parse_declaration, is_constructor=False, meet line: 'reverse_iterator\n    rbegin() noexcept\n    { return reverse_iterator(end()); }\n\n    const_reverse_iterator\n    rbegin() const noexcept\n    { return const_reverse_iterator(end()); }\n\n    reverse_iterat'
[#] parse_declaration, is_constructor=False, meet line: 'const_reverse_iterator\n    rbegin() const noexcept\n    { return const_reverse_iterator(end()); }\n\n    reverse_iterator\n    rend() noexcept\n    { return reverse_iterator(begin()); }\n\n    const_reverse_'
[#] parse_declaration, is_constructor=False, meet line: 'reverse_iterator\n    rend() noexcept\n    { return reverse_iterator(begin()); }\n\n    const_reverse_iterator\n    rend() const noexcept\n    { return const_reverse_iterator(begin()); }\n\n\n    const_iterato'
[#] parse_declaration, is_constructor=False, meet line: 'const_reverse_iterator\n    rend() const noexcept\n    { return const_reverse_iterator(begin()); }\n\n\n    const_iterator\n    cbegin() const noexcept\n    { return this->_M_impl._M_start; }\n\n    const_iter'
[#] parse_declaration, is_constructor=False, meet line: 'const_iterator\n    cbegin() const noexcept\n    { return this->_M_impl._M_start; }\n\n    const_iterator\n    cend() const noexcept\n    { return this->_M_impl._M_finish; }\n\n    const_reverse_iterator\n    '
[#] parse_declaration, is_constructor=False, meet line: 'const_iterator\n    cend() const noexcept\n    { return this->_M_impl._M_finish; }\n\n    const_reverse_iterator\n    crbegin() const noexcept\n    { return const_reverse_iterator(end()); }\n\n    const_rever'
[#] parse_declaration, is_constructor=False, meet line: 'const_reverse_iterator\n    crbegin() const noexcept\n    { return const_reverse_iterator(end()); }\n\n    const_reverse_iterator\n    crend() const noexcept\n    { return const_reverse_iterator(begin()); }'
[#] parse_declaration, is_constructor=False, meet line: 'const_reverse_iterator\n    crend() const noexcept\n    { return const_reverse_iterator(begin()); }\n\n\n    size_type\n    size() const noexcept\n    { return size_type(end() - begin()); }\n\n    size_type\n  '
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n    size() const noexcept\n    { return size_type(end() - begin()); }\n\n    size_type\n    max_size() const noexcept\n    {\n      const size_type __isize =\n __gnu_cxx::__numeric_traits<differenc'
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n    max_size() const noexcept\n    {\n      const size_type __isize =\n __gnu_cxx::__numeric_traits<difference_type>::__max\n - int(_S_word_bit) + 1;\n      const size_type __asize\n = _Bit_alloc_'
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n    capacity() const noexcept\n    { return size_type(const_iterator(this->_M_impl._M_end_addr(), 0)\n         - begin()); }\n\n    bool\n    empty() const noexcept\n    { return begin() == end();'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    empty() const noexcept\n    { return begin() == end(); }\n\n    reference\n    operator[](size_type __n)\n    {\n      return *iterator(this->_M_impl._M_start._M_p\n         + __n / int(_S_word_bit)'
[#] parse_declaration, is_constructor=False, meet line: 'reference\n    operator[](size_type __n)\n    {\n      return *iterator(this->_M_impl._M_start._M_p\n         + __n / int(_S_word_bit), __n % int(_S_word_bit));\n    }\n\n    const_reference\n    operator[](s'
[#] parse_declaration, is_constructor=False, meet line: 'const_reference\n    operator[](size_type __n) const\n    {\n      return *const_iterator(this->_M_impl._M_start._M_p\n        + __n / int(_S_word_bit), __n % int(_S_word_bit));\n    }\n\n  protected:\n    vo'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _M_range_check(size_type __n) const\n    {\n      if (__n >= this->size())\n __throw_out_of_range_fmt(("vector<bool>::_M_range_check: __n " "(which is %zu) >= this->size() " "(which is %zu)")\n\n '
[#] parse_declaration, is_constructor=False, meet line: 'reference\n    at(size_type __n)\n    { _M_range_check(__n); return (*this)[__n]; }\n\n    const_reference\n    at(size_type __n) const\n    { _M_range_check(__n); return (*this)[__n]; }\n\n    void\n    reser'
[#] parse_declaration, is_constructor=False, meet line: 'const_reference\n    at(size_type __n) const\n    { _M_range_check(__n); return (*this)[__n]; }\n\n    void\n    reserve(size_type __n)\n    {\n      if (__n > max_size())\n __throw_length_error(("vector::res'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    reserve(size_type __n)\n    {\n      if (__n > max_size())\n __throw_length_error(("vector::reserve"));\n      if (capacity() < __n)\n _M_reallocate(__n);\n    }\n\n    reference\n    front()\n    { re'
[#] parse_declaration, is_constructor=False, meet line: 'reference\n    front()\n    { return *begin(); }\n\n    const_reference\n    front() const\n    { return *begin(); }\n\n    reference\n    back()\n    { return *(end() - 1); }\n\n    const_reference\n    back() co'
[#] parse_declaration, is_constructor=False, meet line: 'const_reference\n    front() const\n    { return *begin(); }\n\n    reference\n    back()\n    { return *(end() - 1); }\n\n    const_reference\n    back() const\n    { return *(end() - 1); }\n\n\n\n\n\n\n    void\n    '
[#] parse_declaration, is_constructor=False, meet line: 'reference\n    back()\n    { return *(end() - 1); }\n\n    const_reference\n    back() const\n    { return *(end() - 1); }\n\n\n\n\n\n\n    void\n    data() noexcept { }\n\n    void\n    push_back(bool __x)\n    {\n    '
[#] parse_declaration, is_constructor=False, meet line: 'const_reference\n    back() const\n    { return *(end() - 1); }\n\n\n\n\n\n\n    void\n    data() noexcept { }\n\n    void\n    push_back(bool __x)\n    {\n      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    data() noexcept { }\n\n    void\n    push_back(bool __x)\n    {\n      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr())\n        *this->_M_impl._M_finish++ = __x;\n      else\n       '
[#] parse_declaration, is_constructor=False, meet line: 'void\n    push_back(bool __x)\n    {\n      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr())\n        *this->_M_impl._M_finish++ = __x;\n      else\n        _M_insert_aux(end(), __x);\n    }\n'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    swap(vector& __x) noexcept\n    {\n      std::swap(this->_M_impl._M_start, __x._M_impl._M_start);\n      std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);\n      std::swap(this->_M_impl.'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    swap(reference __x, reference __y) noexcept\n    {\n      bool __tmp = __x;\n      __x = __y;\n      __y = __tmp;\n    }\n\n    iterator\n\n    insert(const_iterator __position, const bool& __x = bool'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n\n    insert(const_iterator __position, const bool& __x = bool())\n\n\n\n    {\n      const difference_type __n = __position - begin();\n      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_en'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      insert(const_iterator __position,\n      _InputIterator __first, _InputIterator __last)\n      {\n difference_type __offset = __position - cbegin();\n _M_insert_dispatch(__position._M_const'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n    insert(const_iterator __position, size_type __n, const bool& __x)\n    {\n      difference_type __offset = __position - cbegin();\n      _M_fill_insert(__position._M_const_cast(), __n, __x);'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n    insert(const_iterator __p, initializer_list<bool> __l)\n    { return this->insert(__p, __l.begin(), __l.end()); }\n\n\n    void\n    pop_back()\n    { --this->_M_impl._M_finish; }\n\n    iterator'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    pop_back()\n    { --this->_M_impl._M_finish; }\n\n    iterator\n\n    erase(const_iterator __position)\n\n\n\n    { return _M_erase(__position._M_const_cast()); }\n\n    iterator\n\n    erase(const_iterat'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n\n    erase(const_iterator __position)\n\n\n\n    { return _M_erase(__position._M_const_cast()); }\n\n    iterator\n\n    erase(const_iterator __first, const_iterator __last)\n\n\n\n    { return _M_erase('
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n\n    erase(const_iterator __first, const_iterator __last)\n\n\n\n    { return _M_erase(__first._M_const_cast(), __last._M_const_cast()); }\n\n    void\n    resize(size_type __new_size, bool __x = bo'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    resize(size_type __new_size, bool __x = bool())\n    {\n      if (__new_size < size())\n        _M_erase_at_end(begin() + difference_type(__new_size));\n      else\n        insert(end(), __new_siz'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    shrink_to_fit()\n    { _M_shrink_to_fit(); }\n\n\n    void\n    flip() noexcept\n    {\n      _Bit_type * const __end = this->_M_impl._M_end_addr();\n      for (_Bit_type * __p = this->_M_impl._M_sta'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    flip() noexcept\n    {\n      _Bit_type * const __end = this->_M_impl._M_end_addr();\n      for (_Bit_type * __p = this->_M_impl._M_start._M_p; __p != __end; ++__p)\n        *__p = ~*__p;\n    }\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    clear() noexcept\n    { _M_erase_at_end(begin()); }\n\n\n    template<typename... _Args>\n\n\n\n      void\n\n      emplace_back(_Args&&... __args)\n      {\n push_back(bool(__args...));\n\n\n\n      }\n\n    '
[#] parse_declaration, is_constructor=False, meet line: 'void\n\n      emplace_back(_Args&&... __args)\n      {\n push_back(bool(__args...));\n\n\n\n      }\n\n    template<typename... _Args>\n      iterator\n      emplace(const_iterator __pos, _Args&&... __args)\n     '
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      emplace(const_iterator __pos, _Args&&... __args)\n      { return insert(__pos, bool(__args...)); }\n\n\n  protected:\n\n    iterator\n    _M_copy_aligned(const_iterator __first, const_iterator'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n    _M_copy_aligned(const_iterator __first, const_iterator __last,\n      iterator __result)\n    {\n      _Bit_type* __q = std::copy(__first._M_p, __last._M_p, __result._M_p);\n      return std:'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _M_initialize(size_type __n)\n    {\n      if (__n)\n {\n   _Bit_pointer __q = this->_M_allocate(__n);\n   this->_M_impl._M_end_of_storage = __q + _S_nword(__n);\n   this->_M_impl._M_start = iterat'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _M_reallocate(size_type __n);\n\n\n    bool\n    _M_shrink_to_fit();\n\n\n\n\n\n\n    template<typename _Integer>\n      void\n      _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)\n      {'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    _M_shrink_to_fit();\n\n\n\n\n\n\n    template<typename _Integer>\n      void\n      _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)\n      {\n _M_initialize(static_cast<size_type>(__n));'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)\n      {\n _M_initialize(static_cast<size_type>(__n));\n std::fill(this->_M_impl._M_start._M_p,\n    this->_M_impl._M_end_addr(),'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,\n        __false_type)\n      { _M_initialize_range(__first, __last,\n       std::__iterator_category(__first)); }\n\n    te'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_initialize_range(_InputIterator __first, _InputIterator __last,\n     std::input_iterator_tag)\n      {\n for (; __first != __last; ++__first)\n   push_back(*__first);\n      }\n\n    template<'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,\n     std::forward_iterator_tag)\n      {\n const size_type __n = std::distance(__first, __last);\n _M_initialize(__n);\n s'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)\n      { _M_fill_assign(__n, __val); }\n\n    template<class _InputIterator>\n      void\n      _M_assign_dispatch(_InputIterator __'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_assign_dispatch(_InputIterator __first, _InputIterator __last,\n    __false_type)\n      { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }\n\n    void\n    _M_fill_assign'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _M_fill_assign(size_t __n, bool __x)\n    {\n      if (__n > size())\n {\n   std::fill(this->_M_impl._M_start._M_p,\n      this->_M_impl._M_end_addr(), __x ? ~0 : 0);\n   insert(end(), __n - size()'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_assign_aux(_InputIterator __first, _InputIterator __last,\n      std::input_iterator_tag)\n      {\n iterator __cur = begin();\n for (; __first != __last && __cur != end(); ++__cur, ++__firs'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,\n      std::forward_iterator_tag)\n      {\n const size_type __len = std::distance(__first, __last);\n if (__len < size())\n   _M'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,\n    __true_type)\n      { _M_fill_insert(__pos, __n, __x); }\n\n    template<typename _InputIterator>\n      void\n      _M_insert_'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_insert_dispatch(iterator __pos,\n    _InputIterator __first, _InputIterator __last,\n    __false_type)\n      { _M_insert_range(__pos, __first, __last,\n   std::__iterator_category(__first))'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _M_fill_insert(iterator __position, size_type __n, bool __x);\n\n    template<typename _InputIterator>\n      void\n      _M_insert_range(iterator __pos, _InputIterator __first,\n        _InputIte'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_insert_range(iterator __pos, _InputIterator __first,\n        _InputIterator __last, std::input_iterator_tag)\n      {\n for (; __first != __last; ++__first)\n   {\n     __pos = insert(__pos,'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_insert_range(iterator __position, _ForwardIterator __first,\n        _ForwardIterator __last, std::forward_iterator_tag);\n\n    void\n    _M_insert_aux(iterator __position, bool __x);\n\n    '
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _M_insert_aux(iterator __position, bool __x);\n\n    size_type\n    _M_check_len(size_type __n, const char* __s) const\n    {\n      if (max_size() - size() < __n)\n __throw_length_error((__s));\n\n '
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n    _M_check_len(size_type __n, const char* __s) const\n    {\n      if (max_size() - size() < __n)\n __throw_length_error((__s));\n\n      const size_type __len = size() + std::max(size(), __n);'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _M_erase_at_end(iterator __pos)\n    { this->_M_impl._M_finish = __pos; }\n\n    iterator\n    _M_erase(iterator __pos);\n\n    iterator\n    _M_erase(iterator __first, iterator __last);\n  };\n\n\n}\n\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n    _M_erase(iterator __pos);\n\n    iterator\n    _M_erase(iterator __first, iterator __last);\n  };\n\n\n}\n\n\n\n\n\nnamespace std __attribute__ ((__visibility__ ("default")))\n{\n\n\n\n\n  template<typename'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n    _M_erase(iterator __first, iterator __last);\n  };\n\n\n}\n\n\n\n\n\nnamespace std __attribute__ ((__visibility__ ("default")))\n{\n\n\n\n\n  template<typename _Alloc>\n    struct hash<std::vector<bool, _'
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n      operator()(const std::vector<bool, _Alloc>&) const noexcept;\n    };\n\n\n}\n# 66 "/usr/include/c++/7/vector" 2 3\n\n\n\n# 1 "/usr/include/c++/7/bits/vector.tcc" 1 3\n# 59 "/usr/include/c++/7/bits/'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    vector<_Tp, _Alloc>::\n    reserve(size_type __n)\n    {\n      if (__n > this->max_size())\n __throw_length_error(("vector::reserve"));\n      if (this->capacity() < __n)\n {\n   const size_type __'
[#] parse_declaration, is_constructor=False, meet line: 'void\n\n      vector<_Tp, _Alloc>::\n      emplace_back(_Args&&... __args)\n      {\n if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)\n   {\n     _Alloc_traits::construct(this->_M_impl, this-'
[#] parse_declaration, is_constructor=False, meet line: 'vector<_Tp, _Alloc>::iterator\n    vector<_Tp, _Alloc>::\n\n    insert(const_iterator __position, const value_type& __x)\n\n\n\n    {\n      const size_type __n = __position - begin();\n      if (this->_M_impl'
[#] parse_declaration, is_constructor=False, meet line: 'vector<_Tp, _Alloc>::iterator\n    vector<_Tp, _Alloc>::\n    _M_erase(iterator __position)\n    {\n      if (__position + 1 != end())\n std::move(__position + 1, end(), __position);\n      --this->_M_impl.'
[#] parse_declaration, is_constructor=False, meet line: 'vector<_Tp, _Alloc>::iterator\n    vector<_Tp, _Alloc>::\n    _M_erase(iterator __first, iterator __last)\n    {\n      if (__first != __last)\n {\n   if (__last != end())\n     std::move(__last, end(), __fi'
[#] parse_declaration, is_constructor=False, meet line: 'vector<_Tp, _Alloc>&\n    vector<_Tp, _Alloc>::\n    operator=(const vector<_Tp, _Alloc>& __x)\n    {\n      if (&__x != this)\n {\n\n   if (_Alloc_traits::_S_propagate_on_copy_assign())\n     {\n       if (!_'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    vector<_Tp, _Alloc>::\n    _M_fill_assign(size_t __n, const value_type& __val)\n    {\n      if (__n > capacity())\n {\n   vector __tmp(__n, __val, _M_get_Tp_allocator());\n   __tmp._M_impl._M_swap'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      vector<_Tp, _Alloc>::\n      _M_assign_aux(_InputIterator __first, _InputIterator __last,\n      std::input_iterator_tag)\n      {\n pointer __cur(this->_M_impl._M_start);\n for (; __first != __'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      vector<_Tp, _Alloc>::\n      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,\n      std::forward_iterator_tag)\n      {\n const size_type __len = std::distance(__first, __last)'
[#] parse_declaration, is_constructor=False, meet line: 'auto\n    vector<_Tp, _Alloc>::\n    _M_insert_rval(const_iterator __position, value_type&& __v) -> iterator\n    {\n      const auto __n = __position - cbegin();\n      if (this->_M_impl._M_finish != this'
[#] parse_declaration, is_constructor=False, meet line: 'auto\n      vector<_Tp, _Alloc>::\n      _M_emplace_aux(const_iterator __position, _Args&&... __args)\n      -> iterator\n      {\n const auto __n = __position - cbegin();\n if (this->_M_impl._M_finish != t'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      vector<_Tp, _Alloc>::\n      _M_insert_aux(iterator __position, _Arg&& __arg)\n\n\n\n\n\n\n    {\n      _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,\n          std::move(*(this->_'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      vector<_Tp, _Alloc>::\n      _M_realloc_insert(iterator __position, _Args&&... __args)\n\n\n\n\n\n\n    {\n      const size_type __len =\n _M_check_len(size_type(1), "vector::_M_realloc_insert");\n   '
[#] parse_declaration, is_constructor=False, meet line: 'void\n    vector<_Tp, _Alloc>::\n    _M_fill_insert(iterator __position, size_type __n, const value_type& __x)\n    {\n      if (__n != 0)\n {\n   if (size_type(this->_M_impl._M_end_of_storage\n   - this->_M'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    vector<_Tp, _Alloc>::\n    _M_default_append(size_type __n)\n    {\n      if (__n != 0)\n {\n   if (size_type(this->_M_impl._M_end_of_storage\n   - this->_M_impl._M_finish) >= __n)\n     {\n       th'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    vector<_Tp, _Alloc>::\n    _M_shrink_to_fit()\n    {\n      if (capacity() == size())\n return false;\n      return std::__shrink_to_fit_aux<vector>::_S_do_it(*this);\n    }\n\n\n  template<typename _'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      vector<_Tp, _Alloc>::\n      _M_range_insert(iterator __pos, _InputIterator __first,\n        _InputIterator __last, std::input_iterator_tag)\n      {\n for (; __first != __last; ++__first)\n   '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      vector<_Tp, _Alloc>::\n      _M_range_insert(iterator __position, _ForwardIterator __first,\n        _ForwardIterator __last, std::forward_iterator_tag)\n      {\n if (__first != __last)\n   {\n '
[#] parse_declaration, is_constructor=False, meet line: 'void\n    vector<bool, _Alloc>::\n    _M_reallocate(size_type __n)\n    {\n      _Bit_pointer __q = this->_M_allocate(__n);\n      iterator __start(std::__addressof(*__q), 0);\n      iterator __finish(_M_co'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    vector<bool, _Alloc>::\n    _M_fill_insert(iterator __position, size_type __n, bool __x)\n    {\n      if (__n == 0)\n return;\n      if (capacity() - size() >= __n)\n {\n   std::copy_backward(__pos'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      vector<bool, _Alloc>::\n      _M_insert_range(iterator __position, _ForwardIterator __first,\n        _ForwardIterator __last, std::forward_iterator_tag)\n      {\n if (__first != __last)\n   {\n'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    vector<bool, _Alloc>::\n    _M_insert_aux(iterator __position, bool __x)\n    {\n      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr())\n {\n   std::copy_backward(__position, this-'
[#] parse_declaration, is_constructor=False, meet line: 'vector<bool, _Alloc>::iterator\n    vector<bool, _Alloc>::\n    _M_erase(iterator __position)\n    {\n      if (__position + 1 != end())\n        std::copy(__position + 1, end(), __position);\n      --this-'
[#] parse_declaration, is_constructor=False, meet line: 'vector<bool, _Alloc>::iterator\n    vector<bool, _Alloc>::\n    _M_erase(iterator __first, iterator __last)\n    {\n      if (__first != __last)\n _M_erase_at_end(std::copy(__last, end(), __first));\n      '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    vector<bool, _Alloc>::\n    _M_shrink_to_fit()\n    {\n      if (capacity() - size() < int(_S_word_bit))\n return false;\n      try\n {\n   _M_reallocate(size());\n   return true;\n }\n      catch(...)'
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n    hash<std::vector<bool, _Alloc>>::\n    operator()(const std::vector<bool, _Alloc>& __b) const noexcept\n    {\n      size_t __hash = 0;\n      using std::_S_word_bit;\n      using std::_Bit_type'
[#] parse_declaration, is_constructor=False, meet line: '_Rb_tree_color _M_color;\n    _Base_ptr _M_parent;\n    _Base_ptr _M_left;\n    _Base_ptr _M_right;\n\n    static _Base_ptr\n    _S_minimum(_Base_ptr __x) noexcept\n    {\n      while (__x->_M_left != 0) __x '
[#] parse_declaration, is_constructor=False, meet line: '_Base_ptr _M_parent;\n    _Base_ptr _M_left;\n    _Base_ptr _M_right;\n\n    static _Base_ptr\n    _S_minimum(_Base_ptr __x) noexcept\n    {\n      while (__x->_M_left != 0) __x = __x->_M_left;\n      return '
[#] parse_declaration, is_constructor=False, meet line: '_Base_ptr _M_left;\n    _Base_ptr _M_right;\n\n    static _Base_ptr\n    _S_minimum(_Base_ptr __x) noexcept\n    {\n      while (__x->_M_left != 0) __x = __x->_M_left;\n      return __x;\n    }\n\n    static _C'
[#] parse_declaration, is_constructor=False, meet line: '_Base_ptr _M_right;\n\n    static _Base_ptr\n    _S_minimum(_Base_ptr __x) noexcept\n    {\n      while (__x->_M_left != 0) __x = __x->_M_left;\n      return __x;\n    }\n\n    static _Const_Base_ptr\n    _S_mi'
[#] parse_declaration, is_constructor=False, meet line: '_Base_ptr\n    _S_minimum(_Base_ptr __x) noexcept\n    {\n      while (__x->_M_left != 0) __x = __x->_M_left;\n      return __x;\n    }\n\n    static _Const_Base_ptr\n    _S_minimum(_Const_Base_ptr __x) noexc'
[#] parse_declaration, is_constructor=False, meet line: '_Const_Base_ptr\n    _S_minimum(_Const_Base_ptr __x) noexcept\n    {\n      while (__x->_M_left != 0) __x = __x->_M_left;\n      return __x;\n    }\n\n    static _Base_ptr\n    _S_maximum(_Base_ptr __x) noexc'
[#] parse_declaration, is_constructor=False, meet line: '_Base_ptr\n    _S_maximum(_Base_ptr __x) noexcept\n    {\n      while (__x->_M_right != 0) __x = __x->_M_right;\n      return __x;\n    }\n\n    static _Const_Base_ptr\n    _S_maximum(_Const_Base_ptr __x) noe'
[#] parse_declaration, is_constructor=False, meet line: '_Const_Base_ptr\n    _S_maximum(_Const_Base_ptr __x) noexcept\n    {\n      while (__x->_M_right != 0) __x = __x->_M_right;\n      return __x;\n    }\n  };\n\n\n  template<typename _Key_compare>\n    struct _Rb'
[#] parse_declaration, is_constructor=False, meet line: '_Key_compare _M_key_compare;\n\n      _Rb_tree_key_compare()\n      noexcept(is_nothrow_default_constructible<_Key_compare>::value)\n\n      : _M_key_compare()\n      { }\n\n      _Rb_tree_key_compare(const _'
[#] parse_declaration, is_constructor=True, meet line: '_Rb_tree_key_compare()\n      noexcept(is_nothrow_default_constructible<_Key_compare>::value)\n\n      : _M_key_compare()\n      { }\n\n      _Rb_tree_key_compare(const _Key_compare& __comp)\n      : _M_key_'
[#] parse_declaration, is_constructor=True, meet line: '_Rb_tree_key_compare(const _Key_compare& __comp)\n      : _M_key_compare(__comp)\n      { }\n\n\n\n      _Rb_tree_key_compare(const _Rb_tree_key_compare&) = default;\n\n      _Rb_tree_key_compare(_Rb_tree_key'
[#] parse_declaration, is_constructor=True, meet line: '_Rb_tree_key_compare(const _Rb_tree_key_compare&) = default;\n\n      _Rb_tree_key_compare(_Rb_tree_key_compare&& __x)\n noexcept(is_nothrow_copy_constructible<_Key_compare>::value)\n      : _M_key_compar'
[#] parse_declaration, is_constructor=True, meet line: '_Rb_tree_key_compare(_Rb_tree_key_compare&& __x)\n noexcept(is_nothrow_copy_constructible<_Key_compare>::value)\n      : _M_key_compare(__x._M_key_compare)\n      { }\n\n    };\n\n\n  struct _Rb_tree_header\n '
[#] parse_declaration, is_constructor=False, meet line: '_Rb_tree_node_base _M_header;\n    size_t _M_node_count;\n\n    _Rb_tree_header() noexcept\n    {\n      _M_header._M_color = _S_red;\n      _M_reset();\n    }\n\n\n    _Rb_tree_header(_Rb_tree_header&& __x) no'
[#] parse_declaration, is_constructor=False, meet line: 'size_t _M_node_count;\n\n    _Rb_tree_header() noexcept\n    {\n      _M_header._M_color = _S_red;\n      _M_reset();\n    }\n\n\n    _Rb_tree_header(_Rb_tree_header&& __x) noexcept\n    {\n      if (__x._M_head'
[#] parse_declaration, is_constructor=True, meet line: '_Rb_tree_header() noexcept\n    {\n      _M_header._M_color = _S_red;\n      _M_reset();\n    }\n\n\n    _Rb_tree_header(_Rb_tree_header&& __x) noexcept\n    {\n      if (__x._M_header._M_parent != nullptr)\n _'
[#] parse_declaration, is_constructor=True, meet line: '_Rb_tree_header(_Rb_tree_header&& __x) noexcept\n    {\n      if (__x._M_header._M_parent != nullptr)\n _M_move_data(__x);\n      else\n {\n   _M_header._M_color = _S_red;\n   _M_reset();\n }\n    }\n\n\n    void'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _M_move_data(_Rb_tree_header& __from)\n    {\n      _M_header._M_color = __from._M_header._M_color;\n      _M_header._M_parent = __from._M_header._M_parent;\n      _M_header._M_left = __from._M_h'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _M_reset()\n    {\n      _M_header._M_parent = 0;\n      _M_header._M_left = &_M_header;\n      _M_header._M_right = &_M_header;\n      _M_node_count = 0;\n    }\n  };\n\n  template<typename _Val>\n   '
[#] parse_declaration, is_constructor=False, meet line: '__gnu_cxx::__aligned_membuf<_Val> _M_storage;\n\n      _Val*\n      _M_valptr()\n      { return _M_storage._M_ptr(); }\n\n      const _Val*\n      _M_valptr() const\n      { return _M_storage._M_ptr(); }\n\n   '
[#] parse_declaration, is_constructor=False, meet line: '_Val*\n      _M_valptr()\n      { return _M_storage._M_ptr(); }\n\n      const _Val*\n      _M_valptr() const\n      { return _M_storage._M_ptr(); }\n\n    };\n\n  __attribute__ ((__pure__)) _Rb_tree_node_base*'
[#] parse_declaration, is_constructor=False, meet line: '_Val*\n      _M_valptr() const\n      { return _M_storage._M_ptr(); }\n\n    };\n\n  __attribute__ ((__pure__)) _Rb_tree_node_base*\n  _Rb_tree_increment(_Rb_tree_node_base* __x) throw ();\n\n  __attribute__ ('
[#] parse_declaration, is_constructor=False, meet line: '__attribute__ ((__pure__)) _Rb_tree_node_base*\n  _Rb_tree_increment(_Rb_tree_node_base* __x) throw ();\n\n  __attribute__ ((__pure__)) const _Rb_tree_node_base*\n  _Rb_tree_increment(const _Rb_tree_node_'
[#] parse_declaration, is_constructor=False, meet line: '__attribute__ ((__pure__)) const _Rb_tree_node_base*\n  _Rb_tree_increment(const _Rb_tree_node_base* __x) throw ();\n\n  __attribute__ ((__pure__)) _Rb_tree_node_base*\n  _Rb_tree_decrement(_Rb_tree_node_'
[#] parse_declaration, is_constructor=False, meet line: '__attribute__ ((__pure__)) _Rb_tree_node_base*\n  _Rb_tree_decrement(_Rb_tree_node_base* __x) throw ();\n\n  __attribute__ ((__pure__)) const _Rb_tree_node_base*\n  _Rb_tree_decrement(const _Rb_tree_node_'
[#] parse_declaration, is_constructor=False, meet line: '__attribute__ ((__pure__)) const _Rb_tree_node_base*\n  _Rb_tree_decrement(const _Rb_tree_node_base* __x) throw ();\n\n  template<typename _Tp>\n    struct _Rb_tree_iterator\n    {\n      typedef _Tp value_'
[#] parse_declaration, is_constructor=True, meet line: '_Rb_tree_iterator() noexcept\n      : _M_node() { }\n\n      explicit\n      _Rb_tree_iterator(_Base_ptr __x) noexcept\n      : _M_node(__x) { }\n\n      reference\n      operator*() const noexcept\n      { re'
[#] parse_declaration, is_constructor=True, meet line: '_Rb_tree_iterator(_Base_ptr __x) noexcept\n      : _M_node(__x) { }\n\n      reference\n      operator*() const noexcept\n      { return *static_cast<_Link_type>(_M_node)->_M_valptr(); }\n\n      pointer\n   '
[#] parse_declaration, is_constructor=False, meet line: 'reference\n      operator*() const noexcept\n      { return *static_cast<_Link_type>(_M_node)->_M_valptr(); }\n\n      pointer\n      operator->() const noexcept\n      { return static_cast<_Link_type> (_M_'
[#] parse_declaration, is_constructor=False, meet line: 'pointer\n      operator->() const noexcept\n      { return static_cast<_Link_type> (_M_node)->_M_valptr(); }\n\n      _Self&\n      operator++() noexcept\n      {\n _M_node = _Rb_tree_increment(_M_node);\n re'
[#] parse_declaration, is_constructor=False, meet line: '_Self&\n      operator++() noexcept\n      {\n _M_node = _Rb_tree_increment(_M_node);\n return *this;\n      }\n\n      _Self\n      operator++(int) noexcept\n      {\n _Self __tmp = *this;\n _M_node = _Rb_tree_'
[#] parse_declaration, is_constructor=False, meet line: '_Self\n      operator++(int) noexcept\n      {\n _Self __tmp = *this;\n _M_node = _Rb_tree_increment(_M_node);\n return __tmp;\n      }\n\n      _Self&\n      operator--() noexcept\n      {\n _M_node = _Rb_tree_'
[#] parse_declaration, is_constructor=False, meet line: '_Self&\n      operator--() noexcept\n      {\n _M_node = _Rb_tree_decrement(_M_node);\n return *this;\n      }\n\n      _Self\n      operator--(int) noexcept\n      {\n _Self __tmp = *this;\n _M_node = _Rb_tree_'
[#] parse_declaration, is_constructor=False, meet line: '_Self\n      operator--(int) noexcept\n      {\n _Self __tmp = *this;\n _M_node = _Rb_tree_decrement(_M_node);\n return __tmp;\n      }\n\n      bool\n      operator==(const _Self& __x) const noexcept\n      { '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      operator==(const _Self& __x) const noexcept\n      { return _M_node == __x._M_node; }\n\n      bool\n      operator!=(const _Self& __x) const noexcept\n      { return _M_node != __x._M_node; }\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      operator!=(const _Self& __x) const noexcept\n      { return _M_node != __x._M_node; }\n\n      _Base_ptr _M_node;\n  };\n\n  template<typename _Tp>\n    struct _Rb_tree_const_iterator\n    {\n      '
[#] parse_declaration, is_constructor=False, meet line: '_Base_ptr _M_node;\n  };\n\n  template<typename _Tp>\n    struct _Rb_tree_const_iterator\n    {\n      typedef _Tp value_type;\n      typedef const _Tp& reference;\n      typedef const _Tp* pointer;\n\n      ty'
[#] parse_declaration, is_constructor=True, meet line: '_Rb_tree_const_iterator() noexcept\n      : _M_node() { }\n\n      explicit\n      _Rb_tree_const_iterator(_Base_ptr __x) noexcept\n      : _M_node(__x) { }\n\n      _Rb_tree_const_iterator(const iterator& _'
[#] parse_declaration, is_constructor=True, meet line: '_Rb_tree_const_iterator(_Base_ptr __x) noexcept\n      : _M_node(__x) { }\n\n      _Rb_tree_const_iterator(const iterator& __it) noexcept\n      : _M_node(__it._M_node) { }\n\n      iterator\n      _M_const_'
[#] parse_declaration, is_constructor=True, meet line: '_Rb_tree_const_iterator(const iterator& __it) noexcept\n      : _M_node(__it._M_node) { }\n\n      iterator\n      _M_const_cast() const noexcept\n      { return iterator(const_cast<typename iterator::_Bas'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      _M_const_cast() const noexcept\n      { return iterator(const_cast<typename iterator::_Base_ptr>(_M_node)); }\n\n      reference\n      operator*() const noexcept\n      { return *static_cas'
[#] parse_declaration, is_constructor=False, meet line: 'reference\n      operator*() const noexcept\n      { return *static_cast<_Link_type>(_M_node)->_M_valptr(); }\n\n      pointer\n      operator->() const noexcept\n      { return static_cast<_Link_type>(_M_n'
[#] parse_declaration, is_constructor=False, meet line: 'pointer\n      operator->() const noexcept\n      { return static_cast<_Link_type>(_M_node)->_M_valptr(); }\n\n      _Self&\n      operator++() noexcept\n      {\n _M_node = _Rb_tree_increment(_M_node);\n ret'
[#] parse_declaration, is_constructor=False, meet line: '_Self&\n      operator++() noexcept\n      {\n _M_node = _Rb_tree_increment(_M_node);\n return *this;\n      }\n\n      _Self\n      operator++(int) noexcept\n      {\n _Self __tmp = *this;\n _M_node = _Rb_tree_'
[#] parse_declaration, is_constructor=False, meet line: '_Self\n      operator++(int) noexcept\n      {\n _Self __tmp = *this;\n _M_node = _Rb_tree_increment(_M_node);\n return __tmp;\n      }\n\n      _Self&\n      operator--() noexcept\n      {\n _M_node = _Rb_tree_'
[#] parse_declaration, is_constructor=False, meet line: '_Self&\n      operator--() noexcept\n      {\n _M_node = _Rb_tree_decrement(_M_node);\n return *this;\n      }\n\n      _Self\n      operator--(int) noexcept\n      {\n _Self __tmp = *this;\n _M_node = _Rb_tree_'
[#] parse_declaration, is_constructor=False, meet line: '_Self\n      operator--(int) noexcept\n      {\n _Self __tmp = *this;\n _M_node = _Rb_tree_decrement(_M_node);\n return __tmp;\n      }\n\n      bool\n      operator==(const _Self& __x) const noexcept\n      { '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      operator==(const _Self& __x) const noexcept\n      { return _M_node == __x._M_node; }\n\n      bool\n      operator!=(const _Self& __x) const noexcept\n      { return _M_node != __x._M_node; }\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      operator!=(const _Self& __x) const noexcept\n      { return _M_node != __x._M_node; }\n\n      _Base_ptr _M_node;\n    };\n\n  template<typename _Val>\n    inline bool\n    operator==(const _Rb_tre'
[#] parse_declaration, is_constructor=False, meet line: '_Base_ptr _M_node;\n    };\n\n  template<typename _Val>\n    inline bool\n    operator==(const _Rb_tree_iterator<_Val>& __x,\n               const _Rb_tree_const_iterator<_Val>& __y) noexcept\n    { return _'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator==(const _Rb_tree_iterator<_Val>& __x,\n               const _Rb_tree_const_iterator<_Val>& __y) noexcept\n    { return __x._M_node == __y._M_node; }\n\n  template<typename _Val>\n    inli'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator!=(const _Rb_tree_iterator<_Val>& __x,\n               const _Rb_tree_const_iterator<_Val>& __y) noexcept\n    { return __x._M_node != __y._M_node; }\n\n  void\n  _Rb_tree_insert_and_rebal'
[#] parse_declaration, is_constructor=False, meet line: 'void\n  _Rb_tree_insert_and_rebalance(const bool __insert_left,\n                                _Rb_tree_node_base* __x,\n                                _Rb_tree_node_base* __p,\n                       '
[#] parse_declaration, is_constructor=False, meet line: '_Rb_tree_node_base*\n  _Rb_tree_rebalance_for_erase(_Rb_tree_node_base* const __z,\n          _Rb_tree_node_base& __header) throw ();\n\n\n  template<typename _Cmp, typename _SfinaeType, typename = __void_'
[#] parse_declaration, is_constructor=True, meet line: '_Reuse_or_alloc_node(_Rb_tree& __t)\n   : _M_root(__t._M_root()), _M_nodes(__t._M_rightmost()), _M_t(__t)\n {\n   if (_M_root)\n     {\n       _M_root->_M_parent = 0;\n\n       if (_M_nodes->_M_left)\n  _M_no'
[#] parse_declaration, is_constructor=True, meet line: '_Reuse_or_alloc_node(const _Reuse_or_alloc_node&) = delete;\n\n\n ~_Reuse_or_alloc_node()\n { _M_t._M_erase(static_cast<_Link_type>(_M_root)); }\n\n template<typename _Arg>\n   _Link_type\n\n\n\n   operator()(_A'
[#] parse_declaration, is_constructor=True, meet line: '_Reuse_or_alloc_node()\n { _M_t._M_erase(static_cast<_Link_type>(_M_root)); }\n\n template<typename _Arg>\n   _Link_type\n\n\n\n   operator()(_Arg&& __arg)\n\n   {\n     _Link_type __node = static_cast<_Link_typ'
[#] parse_declaration, is_constructor=False, meet line: '_Link_type\n\n\n\n   operator()(_Arg&& __arg)\n\n   {\n     _Link_type __node = static_cast<_Link_type>(_M_extract());\n     if (__node)\n       {\n  _M_t._M_destroy_node(__node);\n  _M_t._M_construct_node(__nod'
[#] parse_declaration, is_constructor=False, meet line: '_Base_ptr\n _M_extract()\n {\n   if (!_M_nodes)\n     return _M_nodes;\n\n   _Base_ptr __node = _M_nodes;\n   _M_nodes = _M_nodes->_M_parent;\n   if (_M_nodes)\n     {\n       if (_M_nodes->_M_right == __node)\n'
[#] parse_declaration, is_constructor=False, meet line: '_Base_ptr _M_root;\n _Base_ptr _M_nodes;\n _Rb_tree& _M_t;\n      };\n\n\n\n      struct _Alloc_node\n      {\n _Alloc_node(_Rb_tree& __t)\n   : _M_t(__t) { }\n\n template<typename _Arg>\n   _Link_type\n\n\n\n   opera'
[#] parse_declaration, is_constructor=False, meet line: '_Base_ptr _M_nodes;\n _Rb_tree& _M_t;\n      };\n\n\n\n      struct _Alloc_node\n      {\n _Alloc_node(_Rb_tree& __t)\n   : _M_t(__t) { }\n\n template<typename _Arg>\n   _Link_type\n\n\n\n   operator()(_Arg&& __arg) '
[#] parse_declaration, is_constructor=False, meet line: '_Rb_tree& _M_t;\n      };\n\n\n\n      struct _Alloc_node\n      {\n _Alloc_node(_Rb_tree& __t)\n   : _M_t(__t) { }\n\n template<typename _Arg>\n   _Link_type\n\n\n\n   operator()(_Arg&& __arg) const\n\n   { return _M'
[#] parse_declaration, is_constructor=True, meet line: '_Alloc_node(_Rb_tree& __t)\n   : _M_t(__t) { }\n\n template<typename _Arg>\n   _Link_type\n\n\n\n   operator()(_Arg&& __arg) const\n\n   { return _M_t._M_create_node(std::forward<_Arg>(__arg)); }\n\n      private'
[#] parse_declaration, is_constructor=False, meet line: '_Link_type\n\n\n\n   operator()(_Arg&& __arg) const\n\n   { return _M_t._M_create_node(std::forward<_Arg>(__arg)); }\n\n      private:\n _Rb_tree& _M_t;\n      };\n\n    public:\n      typedef _Key key_type;\n     '
[#] parse_declaration, is_constructor=False, meet line: '_Rb_tree& _M_t;\n      };\n\n    public:\n      typedef _Key key_type;\n      typedef _Val value_type;\n      typedef value_type* pointer;\n      typedef const value_type* const_pointer;\n      typedef value_'
[#] parse_declaration, is_constructor=False, meet line: '_Node_allocator&\n      _M_get_Node_allocator() noexcept\n      { return *static_cast<_Node_allocator*>(&this->_M_impl); }\n\n      const _Node_allocator&\n      _M_get_Node_allocator() const noexcept\n    '
[#] parse_declaration, is_constructor=False, meet line: '_Node_allocator&\n      _M_get_Node_allocator() const noexcept\n      { return *static_cast<const _Node_allocator*>(&this->_M_impl); }\n\n      allocator_type\n      get_allocator() const noexcept\n      { '
[#] parse_declaration, is_constructor=False, meet line: 'allocator_type\n      get_allocator() const noexcept\n      { return allocator_type(_M_get_Node_allocator()); }\n\n    protected:\n      _Link_type\n      _M_get_node()\n      { return _Alloc_traits::allocat'
[#] parse_declaration, is_constructor=False, meet line: '_Link_type\n      _M_get_node()\n      { return _Alloc_traits::allocate(_M_get_Node_allocator(), 1); }\n\n      void\n      _M_put_node(_Link_type __p) noexcept\n      { _Alloc_traits::deallocate(_M_get_Nod'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_put_node(_Link_type __p) noexcept\n      { _Alloc_traits::deallocate(_M_get_Node_allocator(), __p, 1); }\n# 619 "/usr/include/c++/7/bits/stl_tree.h" 3\n      template<typename... _Args>\n vo'
[#] parse_declaration, is_constructor=False, meet line: 'void\n _M_construct_node(_Link_type __node, _Args&&... __args)\n {\n   try\n     {\n       ::new(__node) _Rb_tree_node<_Val>;\n       _Alloc_traits::construct(_M_get_Node_allocator(),\n           __node->_M_'
[#] parse_declaration, is_constructor=False, meet line: '_Link_type\n        _M_create_node(_Args&&... __args)\n {\n   _Link_type __tmp = _M_get_node();\n   _M_construct_node(__tmp, std::forward<_Args>(__args)...);\n   return __tmp;\n }\n\n      void\n      _M_destr'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_destroy_node(_Link_type __p) noexcept\n      {\n _Alloc_traits::destroy(_M_get_Node_allocator(), __p->_M_valptr());\n __p->~_Rb_tree_node<_Val>();\n      }\n\n\n      void\n      _M_drop_node(_L'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_drop_node(_Link_type __p) noexcept\n      {\n _M_destroy_node(__p);\n _M_put_node(__p);\n      }\n\n      template<typename _NodeGen>\n _Link_type\n _M_clone_node(_Const_Link_type __x, _NodeGen&'
[#] parse_declaration, is_constructor=False, meet line: '_Link_type\n _M_clone_node(_Const_Link_type __x, _NodeGen& __node_gen)\n {\n   _Link_type __tmp = __node_gen(*__x->_M_valptr());\n   __tmp->_M_color = __x->_M_color;\n   __tmp->_M_left = 0;\n   __tmp->_M_ri'
[#] parse_declaration, is_constructor=True, meet line: '_Rb_tree_impl() = default;\n   _Rb_tree_impl(_Rb_tree_impl&&) = default;\n\n\n   _Rb_tree_impl(const _Rb_tree_impl& __x)\n   : _Node_allocator(_Alloc_traits::_S_select_on_copy(__x))\n   , _Base_key_compare('
[#] parse_declaration, is_constructor=True, meet line: '_Rb_tree_impl(_Rb_tree_impl&&) = default;\n\n\n   _Rb_tree_impl(const _Rb_tree_impl& __x)\n   : _Node_allocator(_Alloc_traits::_S_select_on_copy(__x))\n   , _Base_key_compare(__x._M_key_compare)\n   { }\n\n\n\n'
[#] parse_declaration, is_constructor=True, meet line: '_Rb_tree_impl(const _Rb_tree_impl& __x)\n   : _Node_allocator(_Alloc_traits::_S_select_on_copy(__x))\n   , _Base_key_compare(__x._M_key_compare)\n   { }\n\n\n\n\n\n\n   _Rb_tree_impl(const _Key_compare& __comp,'
[#] parse_declaration, is_constructor=True, meet line: '_Rb_tree_impl(const _Key_compare& __comp, _Node_allocator&& __a)\n   : _Node_allocator(std::move(__a)), _Base_key_compare(__comp)\n   { }\n\n };\n\n      _Rb_tree_impl<_Compare> _M_impl;\n\n    protected:\n   '
[#] parse_declaration, is_constructor=False, meet line: '_Rb_tree_impl<_Compare> _M_impl;\n\n    protected:\n      _Base_ptr&\n      _M_root() noexcept\n      { return this->_M_impl._M_header._M_parent; }\n\n      _Const_Base_ptr\n      _M_root() const noexcept\n   '
[#] parse_declaration, is_constructor=False, meet line: '_Base_ptr&\n      _M_root() noexcept\n      { return this->_M_impl._M_header._M_parent; }\n\n      _Const_Base_ptr\n      _M_root() const noexcept\n      { return this->_M_impl._M_header._M_parent; }\n\n     '
[#] parse_declaration, is_constructor=False, meet line: '_Const_Base_ptr\n      _M_root() const noexcept\n      { return this->_M_impl._M_header._M_parent; }\n\n      _Base_ptr&\n      _M_leftmost() noexcept\n      { return this->_M_impl._M_header._M_left; }\n\n   '
[#] parse_declaration, is_constructor=False, meet line: '_Base_ptr&\n      _M_leftmost() noexcept\n      { return this->_M_impl._M_header._M_left; }\n\n      _Const_Base_ptr\n      _M_leftmost() const noexcept\n      { return this->_M_impl._M_header._M_left; }\n\n '
[#] parse_declaration, is_constructor=False, meet line: '_Const_Base_ptr\n      _M_leftmost() const noexcept\n      { return this->_M_impl._M_header._M_left; }\n\n      _Base_ptr&\n      _M_rightmost() noexcept\n      { return this->_M_impl._M_header._M_right; }\n'
[#] parse_declaration, is_constructor=False, meet line: '_Base_ptr&\n      _M_rightmost() noexcept\n      { return this->_M_impl._M_header._M_right; }\n\n      _Const_Base_ptr\n      _M_rightmost() const noexcept\n      { return this->_M_impl._M_header._M_right; '
[#] parse_declaration, is_constructor=False, meet line: '_Const_Base_ptr\n      _M_rightmost() const noexcept\n      { return this->_M_impl._M_header._M_right; }\n\n      _Link_type\n      _M_begin() noexcept\n      { return static_cast<_Link_type>(this->_M_impl.'
[#] parse_declaration, is_constructor=False, meet line: '_Link_type\n      _M_begin() noexcept\n      { return static_cast<_Link_type>(this->_M_impl._M_header._M_parent); }\n\n      _Const_Link_type\n      _M_begin() const noexcept\n      {\n return static_cast<_C'
[#] parse_declaration, is_constructor=False, meet line: '_Const_Link_type\n      _M_begin() const noexcept\n      {\n return static_cast<_Const_Link_type>\n   (this->_M_impl._M_header._M_parent);\n      }\n\n      _Base_ptr\n      _M_end() noexcept\n      { return &'
[#] parse_declaration, is_constructor=False, meet line: '_Base_ptr\n      _M_end() noexcept\n      { return &this->_M_impl._M_header; }\n\n      _Const_Base_ptr\n      _M_end() const noexcept\n      { return &this->_M_impl._M_header; }\n\n      static const_referen'
[#] parse_declaration, is_constructor=False, meet line: '_Const_Base_ptr\n      _M_end() const noexcept\n      { return &this->_M_impl._M_header; }\n\n      static const_reference\n      _S_value(_Const_Link_type __x)\n      { return *__x->_M_valptr(); }\n\n      s'
[#] parse_declaration, is_constructor=False, meet line: 'const_reference\n      _S_value(_Const_Link_type __x)\n      { return *__x->_M_valptr(); }\n\n      static const _Key&\n      _S_key(_Const_Link_type __x)\n      { return _KeyOfValue()(_S_value(__x)); }\n\n  '
[#] parse_declaration, is_constructor=False, meet line: '_Key&\n      _S_key(_Const_Link_type __x)\n      { return _KeyOfValue()(_S_value(__x)); }\n\n      static _Link_type\n      _S_left(_Base_ptr __x) noexcept\n      { return static_cast<_Link_type>(__x->_M_le'
[#] parse_declaration, is_constructor=False, meet line: '_Link_type\n      _S_left(_Base_ptr __x) noexcept\n      { return static_cast<_Link_type>(__x->_M_left); }\n\n      static _Const_Link_type\n      _S_left(_Const_Base_ptr __x) noexcept\n      { return stati'
[#] parse_declaration, is_constructor=False, meet line: '_Const_Link_type\n      _S_left(_Const_Base_ptr __x) noexcept\n      { return static_cast<_Const_Link_type>(__x->_M_left); }\n\n      static _Link_type\n      _S_right(_Base_ptr __x) noexcept\n      { retur'
[#] parse_declaration, is_constructor=False, meet line: '_Link_type\n      _S_right(_Base_ptr __x) noexcept\n      { return static_cast<_Link_type>(__x->_M_right); }\n\n      static _Const_Link_type\n      _S_right(_Const_Base_ptr __x) noexcept\n      { return st'
[#] parse_declaration, is_constructor=False, meet line: '_Const_Link_type\n      _S_right(_Const_Base_ptr __x) noexcept\n      { return static_cast<_Const_Link_type>(__x->_M_right); }\n\n      static const_reference\n      _S_value(_Const_Base_ptr __x)\n      { r'
[#] parse_declaration, is_constructor=False, meet line: 'const_reference\n      _S_value(_Const_Base_ptr __x)\n      { return *static_cast<_Const_Link_type>(__x)->_M_valptr(); }\n\n      static const _Key&\n      _S_key(_Const_Base_ptr __x)\n      { return _KeyOf'
[#] parse_declaration, is_constructor=False, meet line: '_Key&\n      _S_key(_Const_Base_ptr __x)\n      { return _KeyOfValue()(_S_value(__x)); }\n\n      static _Base_ptr\n      _S_minimum(_Base_ptr __x) noexcept\n      { return _Rb_tree_node_base::_S_minimum(__'
[#] parse_declaration, is_constructor=False, meet line: '_Base_ptr\n      _S_minimum(_Base_ptr __x) noexcept\n      { return _Rb_tree_node_base::_S_minimum(__x); }\n\n      static _Const_Base_ptr\n      _S_minimum(_Const_Base_ptr __x) noexcept\n      { return _Rb'
[#] parse_declaration, is_constructor=False, meet line: '_Const_Base_ptr\n      _S_minimum(_Const_Base_ptr __x) noexcept\n      { return _Rb_tree_node_base::_S_minimum(__x); }\n\n      static _Base_ptr\n      _S_maximum(_Base_ptr __x) noexcept\n      { return _Rb'
[#] parse_declaration, is_constructor=False, meet line: '_Base_ptr\n      _S_maximum(_Base_ptr __x) noexcept\n      { return _Rb_tree_node_base::_S_maximum(__x); }\n\n      static _Const_Base_ptr\n      _S_maximum(_Const_Base_ptr __x) noexcept\n      { return _Rb'
[#] parse_declaration, is_constructor=False, meet line: '_Const_Base_ptr\n      _S_maximum(_Const_Base_ptr __x) noexcept\n      { return _Rb_tree_node_base::_S_maximum(__x); }\n\n    public:\n      typedef _Rb_tree_iterator<value_type> iterator;\n      typedef _R'
[#] parse_declaration, is_constructor=False, meet line: 'pair<_Base_ptr, _Base_ptr>\n      _M_get_insert_unique_pos(const key_type& __k);\n\n      pair<_Base_ptr, _Base_ptr>\n      _M_get_insert_equal_pos(const key_type& __k);\n\n      pair<_Base_ptr, _Base_ptr>\n'
[#] parse_declaration, is_constructor=False, meet line: 'pair<_Base_ptr, _Base_ptr>\n      _M_get_insert_equal_pos(const key_type& __k);\n\n      pair<_Base_ptr, _Base_ptr>\n      _M_get_insert_hint_unique_pos(const_iterator __pos,\n        const key_type& __k);'
[#] parse_declaration, is_constructor=False, meet line: 'pair<_Base_ptr, _Base_ptr>\n      _M_get_insert_hint_unique_pos(const_iterator __pos,\n        const key_type& __k);\n\n      pair<_Base_ptr, _Base_ptr>\n      _M_get_insert_hint_equal_pos(const_iterator _'
[#] parse_declaration, is_constructor=False, meet line: 'pair<_Base_ptr, _Base_ptr>\n      _M_get_insert_hint_equal_pos(const_iterator __pos,\n       const key_type& __k);\n\n    private:\n\n      template<typename _Arg, typename _NodeGen>\n        iterator\n _M_in'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n _M_insert_(_Base_ptr __x, _Base_ptr __y, _Arg&& __v, _NodeGen&);\n\n      iterator\n      _M_insert_node(_Base_ptr __x, _Base_ptr __y, _Link_type __z);\n\n      template<typename _Arg>\n        it'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      _M_insert_node(_Base_ptr __x, _Base_ptr __y, _Link_type __z);\n\n      template<typename _Arg>\n        iterator\n        _M_insert_lower(_Base_ptr __y, _Arg&& __v);\n\n      template<typenam'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n        _M_insert_lower(_Base_ptr __y, _Arg&& __v);\n\n      template<typename _Arg>\n        iterator\n        _M_insert_equal_lower(_Arg&& __x);\n\n      iterator\n      _M_insert_lower_node(_Base'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n        _M_insert_equal_lower(_Arg&& __x);\n\n      iterator\n      _M_insert_lower_node(_Base_ptr __p, _Link_type __z);\n\n      iterator\n      _M_insert_equal_lower_node(_Link_type __z);\n# 867 "'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      _M_insert_lower_node(_Base_ptr __p, _Link_type __z);\n\n      iterator\n      _M_insert_equal_lower_node(_Link_type __z);\n# 867 "/usr/include/c++/7/bits/stl_tree.h" 3\n      template<typena'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      _M_insert_equal_lower_node(_Link_type __z);\n# 867 "/usr/include/c++/7/bits/stl_tree.h" 3\n      template<typename _NodeGen>\n _Link_type\n _M_copy(_Const_Link_type __x, _Base_ptr __p, _Nod'
[#] parse_declaration, is_constructor=False, meet line: '_Link_type\n _M_copy(_Const_Link_type __x, _Base_ptr __p, _NodeGen&);\n\n      template<typename _NodeGen>\n _Link_type\n _M_copy(const _Rb_tree& __x, _NodeGen& __gen)\n {\n   _Link_type __root = _M_copy(__x'
[#] parse_declaration, is_constructor=False, meet line: '_Link_type\n _M_copy(const _Rb_tree& __x, _NodeGen& __gen)\n {\n   _Link_type __root = _M_copy(__x._M_begin(), _M_end(), __gen);\n   _M_leftmost() = _S_minimum(__root);\n   _M_rightmost() = _S_maximum(__ro'
[#] parse_declaration, is_constructor=False, meet line: '_Link_type\n      _M_copy(const _Rb_tree& __x)\n      {\n _Alloc_node __an(*this);\n return _M_copy(__x, __an);\n      }\n\n      void\n      _M_erase(_Link_type __x);\n\n      iterator\n      _M_lower_bound(_Li'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_erase(_Link_type __x);\n\n      iterator\n      _M_lower_bound(_Link_type __x, _Base_ptr __y,\n       const _Key& __k);\n\n      const_iterator\n      _M_lower_bound(_Const_Link_type __x, _Cons'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      _M_lower_bound(_Link_type __x, _Base_ptr __y,\n       const _Key& __k);\n\n      const_iterator\n      _M_lower_bound(_Const_Link_type __x, _Const_Base_ptr __y,\n       const _Key& __k) cons'
[#] parse_declaration, is_constructor=False, meet line: 'const_iterator\n      _M_lower_bound(_Const_Link_type __x, _Const_Base_ptr __y,\n       const _Key& __k) const;\n\n      iterator\n      _M_upper_bound(_Link_type __x, _Base_ptr __y,\n       const _Key& __k'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      _M_upper_bound(_Link_type __x, _Base_ptr __y,\n       const _Key& __k);\n\n      const_iterator\n      _M_upper_bound(_Const_Link_type __x, _Const_Base_ptr __y,\n       const _Key& __k) cons'
[#] parse_declaration, is_constructor=False, meet line: 'const_iterator\n      _M_upper_bound(_Const_Link_type __x, _Const_Base_ptr __y,\n       const _Key& __k) const;\n\n    public:\n\n\n\n\n      _Rb_tree() = default;\n\n\n      _Rb_tree(const _Compare& __comp,\n    '
[#] parse_declaration, is_constructor=True, meet line: '_Rb_tree() = default;\n\n\n      _Rb_tree(const _Compare& __comp,\n        const allocator_type& __a = allocator_type())\n      : _M_impl(__comp, _Node_allocator(__a)) { }\n\n      _Rb_tree(const _Rb_tree& _'
[#] parse_declaration, is_constructor=True, meet line: '_Rb_tree(const _Compare& __comp,\n        const allocator_type& __a = allocator_type())\n      : _M_impl(__comp, _Node_allocator(__a)) { }\n\n      _Rb_tree(const _Rb_tree& __x)\n      : _M_impl(__x._M_imp'
[#] parse_declaration, is_constructor=True, meet line: '_Rb_tree(const _Rb_tree& __x)\n      : _M_impl(__x._M_impl)\n      {\n if (__x._M_root() != 0)\n   _M_root() = _M_copy(__x);\n      }\n\n\n      _Rb_tree(const allocator_type& __a)\n      : _M_impl(_Compare(),'
[#] parse_declaration, is_constructor=True, meet line: '_Rb_tree(const allocator_type& __a)\n      : _M_impl(_Compare(), _Node_allocator(__a))\n      { }\n\n      _Rb_tree(const _Rb_tree& __x, const allocator_type& __a)\n      : _M_impl(__x._M_impl._M_key_compa'
[#] parse_declaration, is_constructor=True, meet line: '_Rb_tree(const _Rb_tree& __x, const allocator_type& __a)\n      : _M_impl(__x._M_impl._M_key_compare, _Node_allocator(__a))\n      {\n if (__x._M_root() != nullptr)\n   _M_root() = _M_copy(__x);\n      }\n\n'
[#] parse_declaration, is_constructor=True, meet line: '_Rb_tree(_Rb_tree&&) = default;\n\n      _Rb_tree(_Rb_tree&& __x, const allocator_type& __a)\n      : _Rb_tree(std::move(__x), _Node_allocator(__a))\n      { }\n\n      _Rb_tree(_Rb_tree&& __x, _Node_alloca'
[#] parse_declaration, is_constructor=True, meet line: '_Rb_tree(_Rb_tree&& __x, const allocator_type& __a)\n      : _Rb_tree(std::move(__x), _Node_allocator(__a))\n      { }\n\n      _Rb_tree(_Rb_tree&& __x, _Node_allocator&& __a);\n\n\n      ~_Rb_tree() noexcep'
[#] parse_declaration, is_constructor=True, meet line: '_Rb_tree(_Rb_tree&& __x, _Node_allocator&& __a);\n\n\n      ~_Rb_tree() noexcept\n      { _M_erase(_M_begin()); }\n\n      _Rb_tree&\n      operator=(const _Rb_tree& __x);\n\n\n      _Compare\n      key_comp() c'
[#] parse_declaration, is_constructor=True, meet line: '_Rb_tree() noexcept\n      { _M_erase(_M_begin()); }\n\n      _Rb_tree&\n      operator=(const _Rb_tree& __x);\n\n\n      _Compare\n      key_comp() const\n      { return _M_impl._M_key_compare; }\n\n      itera'
[#] parse_declaration, is_constructor=True, meet line: '_Rb_tree&\n      operator=(const _Rb_tree& __x);\n\n\n      _Compare\n      key_comp() const\n      { return _M_impl._M_key_compare; }\n\n      iterator\n      begin() noexcept\n      { return iterator(this->_M'
[#] parse_declaration, is_constructor=False, meet line: '_Compare\n      key_comp() const\n      { return _M_impl._M_key_compare; }\n\n      iterator\n      begin() noexcept\n      { return iterator(this->_M_impl._M_header._M_left); }\n\n      const_iterator\n      '
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      begin() noexcept\n      { return iterator(this->_M_impl._M_header._M_left); }\n\n      const_iterator\n      begin() const noexcept\n      { return const_iterator(this->_M_impl._M_header._M_'
[#] parse_declaration, is_constructor=False, meet line: 'const_iterator\n      begin() const noexcept\n      { return const_iterator(this->_M_impl._M_header._M_left); }\n\n      iterator\n      end() noexcept\n      { return iterator(&this->_M_impl._M_header); }\n'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      end() noexcept\n      { return iterator(&this->_M_impl._M_header); }\n\n      const_iterator\n      end() const noexcept\n      { return const_iterator(&this->_M_impl._M_header); }\n\n      re'
[#] parse_declaration, is_constructor=False, meet line: 'const_iterator\n      end() const noexcept\n      { return const_iterator(&this->_M_impl._M_header); }\n\n      reverse_iterator\n      rbegin() noexcept\n      { return reverse_iterator(end()); }\n\n      co'
[#] parse_declaration, is_constructor=False, meet line: 'reverse_iterator\n      rbegin() noexcept\n      { return reverse_iterator(end()); }\n\n      const_reverse_iterator\n      rbegin() const noexcept\n      { return const_reverse_iterator(end()); }\n\n      re'
[#] parse_declaration, is_constructor=False, meet line: 'const_reverse_iterator\n      rbegin() const noexcept\n      { return const_reverse_iterator(end()); }\n\n      reverse_iterator\n      rend() noexcept\n      { return reverse_iterator(begin()); }\n\n      co'
[#] parse_declaration, is_constructor=False, meet line: 'reverse_iterator\n      rend() noexcept\n      { return reverse_iterator(begin()); }\n\n      const_reverse_iterator\n      rend() const noexcept\n      { return const_reverse_iterator(begin()); }\n\n      bo'
[#] parse_declaration, is_constructor=False, meet line: 'const_reverse_iterator\n      rend() const noexcept\n      { return const_reverse_iterator(begin()); }\n\n      bool\n      empty() const noexcept\n      { return _M_impl._M_node_count == 0; }\n\n      size_t'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      empty() const noexcept\n      { return _M_impl._M_node_count == 0; }\n\n      size_type\n      size() const noexcept\n      { return _M_impl._M_node_count; }\n\n      size_type\n      max_size() co'
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      size() const noexcept\n      { return _M_impl._M_node_count; }\n\n      size_type\n      max_size() const noexcept\n      { return _Alloc_traits::max_size(_M_get_Node_allocator()); }\n\n     '
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      max_size() const noexcept\n      { return _Alloc_traits::max_size(_M_get_Node_allocator()); }\n\n      void\n      swap(_Rb_tree& __t)\n      noexcept(__is_nothrow_swappable<_Compare>::valu'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      swap(_Rb_tree& __t)\n      noexcept(__is_nothrow_swappable<_Compare>::value);\n\n\n\n      template<typename _Arg>\n        pair<iterator, bool>\n        _M_insert_unique(_Arg&& __x);\n\n      templ'
[#] parse_declaration, is_constructor=False, meet line: 'pair<iterator, bool>\n        _M_insert_unique(_Arg&& __x);\n\n      template<typename _Arg>\n        iterator\n        _M_insert_equal(_Arg&& __x);\n\n      template<typename _Arg, typename _NodeGen>\n      '
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n        _M_insert_equal(_Arg&& __x);\n\n      template<typename _Arg, typename _NodeGen>\n        iterator\n _M_insert_unique_(const_iterator __pos, _Arg&& __x, _NodeGen&);\n\n      template<typena'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n _M_insert_unique_(const_iterator __pos, _Arg&& __x, _NodeGen&);\n\n      template<typename _Arg>\n iterator\n _M_insert_unique_(const_iterator __pos, _Arg&& __x)\n {\n   _Alloc_node __an(*this);\n '
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n _M_insert_unique_(const_iterator __pos, _Arg&& __x)\n {\n   _Alloc_node __an(*this);\n   return _M_insert_unique_(__pos, std::forward<_Arg>(__x), __an);\n }\n\n      template<typename _Arg, typena'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n _M_insert_equal_(const_iterator __pos, _Arg&& __x, _NodeGen&);\n\n      template<typename _Arg>\n iterator\n _M_insert_equal_(const_iterator __pos, _Arg&& __x)\n {\n   _Alloc_node __an(*this);\n   '
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n _M_insert_equal_(const_iterator __pos, _Arg&& __x)\n {\n   _Alloc_node __an(*this);\n   return _M_insert_equal_(__pos, std::forward<_Arg>(__x), __an);\n }\n\n      template<typename... _Args>\n pai'
[#] parse_declaration, is_constructor=False, meet line: 'pair<iterator, bool>\n _M_emplace_unique(_Args&&... __args);\n\n      template<typename... _Args>\n iterator\n _M_emplace_equal(_Args&&... __args);\n\n      template<typename... _Args>\n iterator\n _M_emplace_'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n _M_emplace_equal(_Args&&... __args);\n\n      template<typename... _Args>\n iterator\n _M_emplace_hint_unique(const_iterator __pos, _Args&&... __args);\n\n      template<typename... _Args>\n iterat'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n _M_emplace_hint_unique(const_iterator __pos, _Args&&... __args);\n\n      template<typename... _Args>\n iterator\n _M_emplace_hint_equal(const_iterator __pos, _Args&&... __args);\n# 1087 "/usr/in'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n _M_emplace_hint_equal(const_iterator __pos, _Args&&... __args);\n# 1087 "/usr/include/c++/7/bits/stl_tree.h" 3\n      template<typename _InputIterator>\n        void\n        _M_insert_unique(_I'
[#] parse_declaration, is_constructor=False, meet line: 'void\n        _M_insert_unique(_InputIterator __first, _InputIterator __last);\n\n      template<typename _InputIterator>\n        void\n        _M_insert_equal(_InputIterator __first, _InputIterator __las'
[#] parse_declaration, is_constructor=False, meet line: 'void\n        _M_insert_equal(_InputIterator __first, _InputIterator __last);\n\n    private:\n      void\n      _M_erase_aux(const_iterator __position);\n\n      void\n      _M_erase_aux(const_iterator __fir'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_erase_aux(const_iterator __position);\n\n      void\n      _M_erase_aux(const_iterator __first, const_iterator __last);\n\n    public:\n\n\n\n      __attribute ((__abi_tag__ ("cxx11")))\n      ite'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_erase_aux(const_iterator __first, const_iterator __last);\n\n    public:\n\n\n\n      __attribute ((__abi_tag__ ("cxx11")))\n      iterator\n      erase(const_iterator __position)\n      {\n ;\n co'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      erase(const_iterator __position)\n      {\n ;\n const_iterator __result = __position;\n ++__result;\n _M_erase_aux(__position);\n return __result._M_const_cast();\n      }\n\n\n      __attribute '
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      erase(iterator __position)\n      {\n ;\n iterator __result = __position;\n ++__result;\n _M_erase_aux(__position);\n return __result;\n      }\n# 1143 "/usr/include/c++/7/bits/stl_tree.h" 3\n  '
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      erase(const key_type& __x);\n\n\n\n\n      __attribute ((__abi_tag__ ("cxx11")))\n      iterator\n      erase(const_iterator __first, const_iterator __last)\n      {\n _M_erase_aux(__first, __l'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      erase(const_iterator __first, const_iterator __last)\n      {\n _M_erase_aux(__first, __last);\n return __last._M_const_cast();\n      }\n# 1165 "/usr/include/c++/7/bits/stl_tree.h" 3\n      '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      erase(const key_type* __first, const key_type* __last);\n\n      void\n      clear() noexcept\n      {\n        _M_erase(_M_begin());\n _M_impl._M_reset();\n      }\n\n\n      iterator\n      find(con'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      clear() noexcept\n      {\n        _M_erase(_M_begin());\n _M_impl._M_reset();\n      }\n\n\n      iterator\n      find(const key_type& __k);\n\n      const_iterator\n      find(const key_type& __k) c'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      find(const key_type& __k);\n\n      const_iterator\n      find(const key_type& __k) const;\n\n      size_type\n      count(const key_type& __k) const;\n\n      iterator\n      lower_bound(const '
[#] parse_declaration, is_constructor=False, meet line: 'const_iterator\n      find(const key_type& __k) const;\n\n      size_type\n      count(const key_type& __k) const;\n\n      iterator\n      lower_bound(const key_type& __k)\n      { return _M_lower_bound(_M_b'
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      count(const key_type& __k) const;\n\n      iterator\n      lower_bound(const key_type& __k)\n      { return _M_lower_bound(_M_begin(), _M_end(), __k); }\n\n      const_iterator\n      lower_b'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      lower_bound(const key_type& __k)\n      { return _M_lower_bound(_M_begin(), _M_end(), __k); }\n\n      const_iterator\n      lower_bound(const key_type& __k) const\n      { return _M_lower_b'
[#] parse_declaration, is_constructor=False, meet line: 'const_iterator\n      lower_bound(const key_type& __k) const\n      { return _M_lower_bound(_M_begin(), _M_end(), __k); }\n\n      iterator\n      upper_bound(const key_type& __k)\n      { return _M_upper_b'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      upper_bound(const key_type& __k)\n      { return _M_upper_bound(_M_begin(), _M_end(), __k); }\n\n      const_iterator\n      upper_bound(const key_type& __k) const\n      { return _M_upper_b'
[#] parse_declaration, is_constructor=False, meet line: 'const_iterator\n      upper_bound(const key_type& __k) const\n      { return _M_upper_bound(_M_begin(), _M_end(), __k); }\n\n      pair<iterator, iterator>\n      equal_range(const key_type& __k);\n\n      p'
[#] parse_declaration, is_constructor=False, meet line: 'pair<iterator, iterator>\n      equal_range(const key_type& __k);\n\n      pair<const_iterator, const_iterator>\n      equal_range(const key_type& __k) const;\n\n\n      template<typename _Kt,\n        typena'
[#] parse_declaration, is_constructor=False, meet line: 'pair<const_iterator, const_iterator>\n      equal_range(const key_type& __k) const;\n\n\n      template<typename _Kt,\n        typename _Req =\n   typename __has_is_transparent<_Compare, _Kt>::type>\n iterat'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n _M_find_tr(const _Kt& __k)\n {\n   const _Rb_tree* __const_this = this;\n   return __const_this->_M_find_tr(__k)._M_const_cast();\n }\n\n      template<typename _Kt,\n        typename _Req =\n   typ'
[#] parse_declaration, is_constructor=False, meet line: 'const_iterator\n _M_find_tr(const _Kt& __k) const\n {\n   auto __j = _M_lower_bound_tr(__k);\n   if (__j != end() && _M_impl._M_key_compare(__k, _S_key(__j._M_node)))\n     __j = end();\n   return __j;\n }\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n _M_count_tr(const _Kt& __k) const\n {\n   auto __p = _M_equal_range_tr(__k);\n   return std::distance(__p.first, __p.second);\n }\n\n      template<typename _Kt,\n        typename _Req =\n   typena'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n _M_lower_bound_tr(const _Kt& __k)\n {\n   const _Rb_tree* __const_this = this;\n   return __const_this->_M_lower_bound_tr(__k)._M_const_cast();\n }\n\n      template<typename _Kt,\n        typename'
[#] parse_declaration, is_constructor=False, meet line: 'const_iterator\n _M_lower_bound_tr(const _Kt& __k) const\n {\n   auto __x = _M_begin();\n   auto __y = _M_end();\n   while (__x != 0)\n     if (!_M_impl._M_key_compare(_S_key(__x), __k))\n       {\n  __y = __'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n _M_upper_bound_tr(const _Kt& __k)\n {\n   const _Rb_tree* __const_this = this;\n   return __const_this->_M_upper_bound_tr(__k)._M_const_cast();\n }\n\n      template<typename _Kt,\n        typename'
[#] parse_declaration, is_constructor=False, meet line: 'const_iterator\n _M_upper_bound_tr(const _Kt& __k) const\n {\n   auto __x = _M_begin();\n   auto __y = _M_end();\n   while (__x != 0)\n     if (_M_impl._M_key_compare(__k, _S_key(__x)))\n       {\n  __y = __x'
[#] parse_declaration, is_constructor=False, meet line: 'pair<iterator, iterator>\n _M_equal_range_tr(const _Kt& __k)\n {\n   const _Rb_tree* __const_this = this;\n   auto __ret = __const_this->_M_equal_range_tr(__k);\n   return { __ret.first._M_const_cast(), __'
[#] parse_declaration, is_constructor=False, meet line: 'pair<const_iterator, const_iterator>\n _M_equal_range_tr(const _Kt& __k) const\n {\n   auto __low = _M_lower_bound_tr(__k);\n   auto __high = __low;\n   auto& __cmp = _M_impl._M_key_compare;\n   while (__hi'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      __rb_verify() const;\n\n\n      _Rb_tree&\n      operator=(_Rb_tree&&)\n      noexcept(_Alloc_traits::_S_nothrow_move()\n        && is_nothrow_move_assignable<_Compare>::value);\n\n      template<t'
[#] parse_declaration, is_constructor=True, meet line: '_Rb_tree&\n      operator=(_Rb_tree&&)\n      noexcept(_Alloc_traits::_S_nothrow_move()\n        && is_nothrow_move_assignable<_Compare>::value);\n\n      template<typename _Iterator>\n void\n _M_assign_uniq'
[#] parse_declaration, is_constructor=False, meet line: 'void\n _M_assign_unique(_Iterator, _Iterator);\n\n      template<typename _Iterator>\n void\n _M_assign_equal(_Iterator, _Iterator);\n\n    private:\n\n      void\n      _M_move_data(_Rb_tree& __x, std::true_ty'
[#] parse_declaration, is_constructor=False, meet line: 'void\n _M_assign_equal(_Iterator, _Iterator);\n\n    private:\n\n      void\n      _M_move_data(_Rb_tree& __x, std::true_type)\n      { _M_impl._M_move_data(__x._M_impl); }\n\n\n\n      void\n      _M_move_data(_'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_move_data(_Rb_tree& __x, std::true_type)\n      { _M_impl._M_move_data(__x._M_impl); }\n\n\n\n      void\n      _M_move_data(_Rb_tree&, std::false_type);\n\n\n      void\n      _M_move_assign(_Rb_'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_move_data(_Rb_tree&, std::false_type);\n\n\n      void\n      _M_move_assign(_Rb_tree&, std::true_type);\n\n\n\n      void\n      _M_move_assign(_Rb_tree&, std::false_type);\n# 1528 "/usr/include/'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_move_assign(_Rb_tree&, std::true_type);\n\n\n\n      void\n      _M_move_assign(_Rb_tree&, std::false_type);\n# 1528 "/usr/include/c++/7/bits/stl_tree.h" 3\n    };\n\n  template<typename _Key, ty'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_move_assign(_Rb_tree&, std::false_type);\n# 1528 "/usr/include/c++/7/bits/stl_tree.h" 3\n    };\n\n  template<typename _Key, typename _Val, typename _KeyOfValue,\n           typename _Compare'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator==(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,\n        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)\n    {\n      return __x.size() == __y.size()\n'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,\n       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)\n    {\n      return std::lexicographical_compar'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator!=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,\n        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)\n    { return !(__x == __y); }\n\n  template<ty'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,\n       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)\n    { return __y < __x; }\n\n  template<typename'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,\n        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)\n    { return !(__y < __x); }\n\n  template<typ'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,\n        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)\n    { return !(__x < __y); }\n\n  template<typ'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,\n  _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)\n    { __x.swap(__y); }\n\n\n  template<typename _Key, typename _Val, ty'
[#] parse_declaration, is_constructor=False, meet line: '_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n    _Rb_tree(_Rb_tree&& __x, _Node_allocator&& __a)\n    : _M_impl(__x._M_impl._M_key_compare, std::move(__a))\n    {\n      using __eq = typename _A'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n    _M_move_data(_Rb_tree& __x, std::false_type)\n    {\n      if (_M_get_Node_allocator() == __x._M_get_Node_allocator())\n _M_move_data(__'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n    _M_move_assign(_Rb_tree& __x, true_type)\n    {\n      clear();\n      if (__x._M_root() != nullptr)\n _M_move_data(__x, std::true_type()'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n    _M_move_assign(_Rb_tree& __x, false_type)\n    {\n      if (_M_get_Node_allocator() == __x._M_get_Node_allocator())\n return _M_move_ass'
[#] parse_declaration, is_constructor=False, meet line: '_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&\n    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n    operator=(_Rb_tree&& __x)\n    noexcept(_Alloc_traits::_S_nothrow_move()\n      && is_n'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n      _M_assign_unique(_Iterator __first, _Iterator __last)\n      {\n _Reuse_or_alloc_node __roan(*this);\n _M_impl._M_reset();\n for (; _'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n      _M_assign_equal(_Iterator __first, _Iterator __last)\n      {\n _Reuse_or_alloc_node __roan(*this);\n _M_impl._M_reset();\n for (; __'
[#] parse_declaration, is_constructor=False, meet line: '_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&\n    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n    operator=(const _Rb_tree& __x)\n    {\n      if (this != &__x)\n {\n\n\n   if (_Alloc_trait'
[#] parse_declaration, is_constructor=False, meet line: '_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n      _M_insert_(_Base_ptr __x, _Base_ptr __p,\n\n   _Arg&& __v,\n\n\n\n   _NodeGen&'
[#] parse_declaration, is_constructor=False, meet line: '_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n\n    _M_insert_lower(_Base_ptr __p, _Arg&& __v)\n\n\n\n    {\n      bool __insert_lef'
[#] parse_declaration, is_constructor=False, meet line: '_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n\n    _M_insert_equal_lower(_Arg&& __v)\n\n\n\n    {\n      _Link_type __x = _M_begin('
[#] parse_declaration, is_constructor=False, meet line: '_Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type\n      _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::\n      _M_copy(_Const_Link_type __x, _Base_ptr __p, _NodeGen& __node_gen)\n      {\n\n _Link_t'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n    _M_erase(_Link_type __x)\n    {\n\n      while (__x != 0)\n {\n   _M_erase(_S_right(__x));\n   _Link_type __y = _S_left(__x);\n   _M_drop_no'
[#] parse_declaration, is_constructor=False, meet line: '_Rb_tree<_Key, _Val, _KeyOfValue,\n        _Compare, _Alloc>::iterator\n    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n    _M_lower_bound(_Link_type __x, _Base_ptr __y,\n     const _Key& __k)\n'
[#] parse_declaration, is_constructor=False, meet line: '_Rb_tree<_Key, _Val, _KeyOfValue,\n        _Compare, _Alloc>::const_iterator\n    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n    _M_lower_bound(_Const_Link_type __x, _Const_Base_ptr __y,\n    '
[#] parse_declaration, is_constructor=False, meet line: '_Rb_tree<_Key, _Val, _KeyOfValue,\n        _Compare, _Alloc>::iterator\n    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n    _M_upper_bound(_Link_type __x, _Base_ptr __y,\n     const _Key& __k)\n'
[#] parse_declaration, is_constructor=False, meet line: '_Rb_tree<_Key, _Val, _KeyOfValue,\n        _Compare, _Alloc>::const_iterator\n    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n    _M_upper_bound(_Const_Link_type __x, _Const_Base_ptr __y,\n    '
[#] parse_declaration, is_constructor=False, meet line: 'pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,\n      _Compare, _Alloc>::iterator,\n  typename _Rb_tree<_Key, _Val, _KeyOfValue,\n      _Compare, _Alloc>::iterator>\n    _Rb_tree<_Key, _Val, _KeyOfValue,'
[#] parse_declaration, is_constructor=False, meet line: 'pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,\n      _Compare, _Alloc>::const_iterator,\n  typename _Rb_tree<_Key, _Val, _KeyOfValue,\n      _Compare, _Alloc>::const_iterator>\n    _Rb_tree<_Key, _Val, '
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n    swap(_Rb_tree& __t)\n    noexcept(__is_nothrow_swappable<_Compare>::value)\n    {\n      if (_M_root() == 0)\n {\n   if (__t._M_root() != '
[#] parse_declaration, is_constructor=False, meet line: 'pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,\n      _Compare, _Alloc>::_Base_ptr,\n  typename _Rb_tree<_Key, _Val, _KeyOfValue,\n      _Compare, _Alloc>::_Base_ptr>\n    _Rb_tree<_Key, _Val, _KeyOfValu'
[#] parse_declaration, is_constructor=False, meet line: 'pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,\n      _Compare, _Alloc>::_Base_ptr,\n  typename _Rb_tree<_Key, _Val, _KeyOfValue,\n      _Compare, _Alloc>::_Base_ptr>\n    _Rb_tree<_Key, _Val, _KeyOfValu'
[#] parse_declaration, is_constructor=False, meet line: 'pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,\n      _Compare, _Alloc>::iterator, bool>\n    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n\n    _M_insert_unique(_Arg&& __v)\n\n\n\n    {\n      type'
[#] parse_declaration, is_constructor=False, meet line: '_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n\n    _M_insert_equal(_Arg&& __v)\n\n\n\n    {\n      pair<_Base_ptr, _Base_ptr> __res'
[#] parse_declaration, is_constructor=False, meet line: 'pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,\n      _Compare, _Alloc>::_Base_ptr,\n         typename _Rb_tree<_Key, _Val, _KeyOfValue,\n      _Compare, _Alloc>::_Base_ptr>\n    _Rb_tree<_Key, _Val, _Ke'
[#] parse_declaration, is_constructor=False, meet line: '_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n      _M_insert_unique_(const_iterator __position,\n\n   _Arg&& __v,\n\n\n\n   _Node'
[#] parse_declaration, is_constructor=False, meet line: 'pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,\n      _Compare, _Alloc>::_Base_ptr,\n         typename _Rb_tree<_Key, _Val, _KeyOfValue,\n      _Compare, _Alloc>::_Base_ptr>\n    _Rb_tree<_Key, _Val, _Ke'
[#] parse_declaration, is_constructor=False, meet line: '_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n      _M_insert_equal_(const_iterator __position,\n\n         _Arg&& __v,\n\n\n\n   '
[#] parse_declaration, is_constructor=False, meet line: '_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n    _M_insert_node(_Base_ptr __x, _Base_ptr __p, _Link_type __z)\n    {\n      boo'
[#] parse_declaration, is_constructor=False, meet line: '_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n    _M_insert_lower_node(_Base_ptr __p, _Link_type __z)\n    {\n      bool __inser'
[#] parse_declaration, is_constructor=False, meet line: '_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n    _M_insert_equal_lower_node(_Link_type __z)\n    {\n      _Link_type __x = _M_b'
[#] parse_declaration, is_constructor=False, meet line: 'pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,\n        _Compare, _Alloc>::iterator, bool>\n      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n      _M_emplace_unique(_Args&&... __args)\n      '
[#] parse_declaration, is_constructor=False, meet line: '_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n      _M_emplace_equal(_Args&&... __args)\n      {\n _Link_type __z = _M_create_'
[#] parse_declaration, is_constructor=False, meet line: '_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n      _M_emplace_hint_unique(const_iterator __pos, _Args&&... __args)\n      {\n'
[#] parse_declaration, is_constructor=False, meet line: '_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n      _M_emplace_hint_equal(const_iterator __pos, _Args&&... __args)\n      {\n '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::\n      _M_insert_unique(_II __first, _II __last)\n      {\n _Alloc_node __an(*this);\n for (; __first != __last; ++__first)\n   _M_insert_unique_(end()'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::\n      _M_insert_equal(_II __first, _II __last)\n      {\n _Alloc_node __an(*this);\n for (; __first != __last; ++__first)\n   _M_insert_equal_(end(), '
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n    _M_erase_aux(const_iterator __position)\n    {\n      _Link_type __y =\n static_cast<_Link_type>(_Rb_tree_rebalance_for_erase\n    (const'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n    _M_erase_aux(const_iterator __first, const_iterator __last)\n    {\n      if (__first == begin() && __last == end())\n clear();\n      el'
[#] parse_declaration, is_constructor=False, meet line: '_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type\n    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n    erase(const _Key& __x)\n    {\n      pair<iterator, iterator> __p = equal_ran'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n    erase(const _Key* __first, const _Key* __last)\n    {\n      while (__first != __last)\n erase(*__first++);\n    }\n\n  template<typename _'
[#] parse_declaration, is_constructor=False, meet line: '_Rb_tree<_Key, _Val, _KeyOfValue,\n        _Compare, _Alloc>::iterator\n    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n    find(const _Key& __k)\n    {\n      iterator __j = _M_lower_bound(_M_b'
[#] parse_declaration, is_constructor=False, meet line: '_Rb_tree<_Key, _Val, _KeyOfValue,\n        _Compare, _Alloc>::const_iterator\n    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n    find(const _Key& __k) const\n    {\n      const_iterator __j = _'
[#] parse_declaration, is_constructor=False, meet line: '_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type\n    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n    count(const _Key& __k) const\n    {\n      pair<const_iterator, const_iterato'
[#] parse_declaration, is_constructor=False, meet line: '__attribute__ ((__pure__)) unsigned int\n  _Rb_tree_black_count(const _Rb_tree_node_base* __node,\n                       const _Rb_tree_node_base* __root) throw ();\n\n  template<typename _Key, typename '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::__rb_verify() const\n    {\n      if (_M_impl._M_node_count == 0 || begin() == end())\n return _M_impl._M_node_count == 0 && begin() == end()\n   '
[#] parse_declaration, is_constructor=False, meet line: '_Compare comp;\n\n value_compare(_Compare __c)\n : comp(__c) { }\n\n      public:\n bool operator()(const value_type& __x, const value_type& __y) const\n { return comp(__x.first, __y.first); }\n      };\n\n    '
[#] parse_declaration, is_constructor=True, meet line: 'value_compare(_Compare __c)\n : comp(__c) { }\n\n      public:\n bool operator()(const value_type& __x, const value_type& __y) const\n { return comp(__x.first, __y.first); }\n      };\n\n    private:\n\n      t'
[#] parse_declaration, is_constructor=False, meet line: 'bool operator()(const value_type& __x, const value_type& __y) const\n { return comp(__x.first, __y.first); }\n      };\n\n    private:\n\n      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template\n '
[#] parse_declaration, is_constructor=False, meet line: '_Rep_type _M_t;\n\n      typedef __gnu_cxx::__alloc_traits<_Pair_alloc_type> _Alloc_traits;\n\n    public:\n\n\n      typedef typename _Alloc_traits::pointer pointer;\n      typedef typename _Alloc_traits::co'
[#] parse_declaration, is_constructor=True, meet line: 'map() = default;\n\n\n\n\n\n\n\n      explicit\n      map(const _Compare& __comp,\n   const allocator_type& __a = allocator_type())\n      : _M_t(__comp, _Pair_alloc_type(__a)) { }\n# 199 "/usr/include/c++/7/bits'
[#] parse_declaration, is_constructor=True, meet line: 'map(const _Compare& __comp,\n   const allocator_type& __a = allocator_type())\n      : _M_t(__comp, _Pair_alloc_type(__a)) { }\n# 199 "/usr/include/c++/7/bits/stl_map.h" 3\n      map(const map&) = default'
[#] parse_declaration, is_constructor=True, meet line: 'map(const map&) = default;\n\n\n\n\n\n\n\n      map(map&&) = default;\n# 220 "/usr/include/c++/7/bits/stl_map.h" 3\n      map(initializer_list<value_type> __l,\n   const _Compare& __comp = _Compare(),\n   const a'
[#] parse_declaration, is_constructor=True, meet line: 'map(map&&) = default;\n# 220 "/usr/include/c++/7/bits/stl_map.h" 3\n      map(initializer_list<value_type> __l,\n   const _Compare& __comp = _Compare(),\n   const allocator_type& __a = allocator_type())\n '
[#] parse_declaration, is_constructor=True, meet line: 'map(initializer_list<value_type> __l,\n   const _Compare& __comp = _Compare(),\n   const allocator_type& __a = allocator_type())\n      : _M_t(__comp, _Pair_alloc_type(__a))\n      { _M_t._M_insert_unique'
[#] parse_declaration, is_constructor=True, meet line: 'map(const allocator_type& __a)\n      : _M_t(_Compare(), _Pair_alloc_type(__a)) { }\n\n\n      map(const map& __m, const allocator_type& __a)\n      : _M_t(__m._M_t, _Pair_alloc_type(__a)) { }\n\n\n      map('
[#] parse_declaration, is_constructor=True, meet line: 'map(const map& __m, const allocator_type& __a)\n      : _M_t(__m._M_t, _Pair_alloc_type(__a)) { }\n\n\n      map(map&& __m, const allocator_type& __a)\n      noexcept(is_nothrow_copy_constructible<_Compare'
[#] parse_declaration, is_constructor=True, meet line: 'map(map&& __m, const allocator_type& __a)\n      noexcept(is_nothrow_copy_constructible<_Compare>::value\n        && _Alloc_traits::_S_always_equal())\n      : _M_t(std::move(__m._M_t), _Pair_alloc_type('
[#] parse_declaration, is_constructor=True, meet line: 'map(initializer_list<value_type> __l, const allocator_type& __a)\n      : _M_t(_Compare(), _Pair_alloc_type(__a))\n      { _M_t._M_insert_unique(__l.begin(), __l.end()); }\n\n\n      template<typename _Inp'
[#] parse_declaration, is_constructor=True, meet line: 'map(_InputIterator __first, _InputIterator __last,\n     const allocator_type& __a)\n : _M_t(_Compare(), _Pair_alloc_type(__a))\n { _M_t._M_insert_unique(__first, __last); }\n# 264 "/usr/include/c++/7/bit'
[#] parse_declaration, is_constructor=True, meet line: 'map(_InputIterator __first, _InputIterator __last)\n : _M_t()\n { _M_t._M_insert_unique(__first, __last); }\n# 281 "/usr/include/c++/7/bits/stl_map.h" 3\n      template<typename _InputIterator>\n map(_Inpu'
[#] parse_declaration, is_constructor=True, meet line: 'map(_InputIterator __first, _InputIterator __last,\n     const _Compare& __comp,\n     const allocator_type& __a = allocator_type())\n : _M_t(__comp, _Pair_alloc_type(__a))\n { _M_t._M_insert_unique(__fir'
[#] parse_declaration, is_constructor=True, meet line: 'map() = default;\n# 310 "/usr/include/c++/7/bits/stl_map.h" 3\n      map&\n      operator=(const map&) = default;\n\n\n      map&\n      operator=(map&&) = default;\n# 328 "/usr/include/c++/7/bits/stl_map.h" '
[#] parse_declaration, is_constructor=True, meet line: 'map&\n      operator=(const map&) = default;\n\n\n      map&\n      operator=(map&&) = default;\n# 328 "/usr/include/c++/7/bits/stl_map.h" 3\n      map&\n      operator=(initializer_list<value_type> __l)\n    '
[#] parse_declaration, is_constructor=True, meet line: 'map&\n      operator=(map&&) = default;\n# 328 "/usr/include/c++/7/bits/stl_map.h" 3\n      map&\n      operator=(initializer_list<value_type> __l)\n      {\n _M_t._M_assign_unique(__l.begin(), __l.end());\n'
[#] parse_declaration, is_constructor=True, meet line: 'map&\n      operator=(initializer_list<value_type> __l)\n      {\n _M_t._M_assign_unique(__l.begin(), __l.end());\n return *this;\n      }\n\n\n\n      allocator_type\n      get_allocator() const noexcept\n     '
[#] parse_declaration, is_constructor=False, meet line: 'allocator_type\n      get_allocator() const noexcept\n      { return allocator_type(_M_t.get_allocator()); }\n\n\n\n\n\n\n\n      iterator\n      begin() noexcept\n      { return _M_t.begin(); }\n\n\n\n\n\n\n      const'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      begin() noexcept\n      { return _M_t.begin(); }\n\n\n\n\n\n\n      const_iterator\n      begin() const noexcept\n      { return _M_t.begin(); }\n\n\n\n\n\n\n      iterator\n      end() noexcept\n      { '
[#] parse_declaration, is_constructor=False, meet line: 'const_iterator\n      begin() const noexcept\n      { return _M_t.begin(); }\n\n\n\n\n\n\n      iterator\n      end() noexcept\n      { return _M_t.end(); }\n\n\n\n\n\n\n      const_iterator\n      end() const noexcept\n'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      end() noexcept\n      { return _M_t.end(); }\n\n\n\n\n\n\n      const_iterator\n      end() const noexcept\n      { return _M_t.end(); }\n\n\n\n\n\n\n      reverse_iterator\n      rbegin() noexcept\n     '
[#] parse_declaration, is_constructor=False, meet line: 'const_iterator\n      end() const noexcept\n      { return _M_t.end(); }\n\n\n\n\n\n\n      reverse_iterator\n      rbegin() noexcept\n      { return _M_t.rbegin(); }\n\n\n\n\n\n\n      const_reverse_iterator\n      rbe'
[#] parse_declaration, is_constructor=False, meet line: 'reverse_iterator\n      rbegin() noexcept\n      { return _M_t.rbegin(); }\n\n\n\n\n\n\n      const_reverse_iterator\n      rbegin() const noexcept\n      { return _M_t.rbegin(); }\n\n\n\n\n\n\n      reverse_iterator\n '
[#] parse_declaration, is_constructor=False, meet line: 'const_reverse_iterator\n      rbegin() const noexcept\n      { return _M_t.rbegin(); }\n\n\n\n\n\n\n      reverse_iterator\n      rend() noexcept\n      { return _M_t.rend(); }\n\n\n\n\n\n\n      const_reverse_iterator'
[#] parse_declaration, is_constructor=False, meet line: 'reverse_iterator\n      rend() noexcept\n      { return _M_t.rend(); }\n\n\n\n\n\n\n      const_reverse_iterator\n      rend() const noexcept\n      { return _M_t.rend(); }\n\n\n\n\n\n\n\n      const_iterator\n      cbeg'
[#] parse_declaration, is_constructor=False, meet line: 'const_reverse_iterator\n      rend() const noexcept\n      { return _M_t.rend(); }\n\n\n\n\n\n\n\n      const_iterator\n      cbegin() const noexcept\n      { return _M_t.begin(); }\n\n\n\n\n\n\n      const_iterator\n   '
[#] parse_declaration, is_constructor=False, meet line: 'const_iterator\n      cbegin() const noexcept\n      { return _M_t.begin(); }\n\n\n\n\n\n\n      const_iterator\n      cend() const noexcept\n      { return _M_t.end(); }\n\n\n\n\n\n\n      const_reverse_iterator\n     '
[#] parse_declaration, is_constructor=False, meet line: 'const_iterator\n      cend() const noexcept\n      { return _M_t.end(); }\n\n\n\n\n\n\n      const_reverse_iterator\n      crbegin() const noexcept\n      { return _M_t.rbegin(); }\n\n\n\n\n\n\n      const_reverse_iter'
[#] parse_declaration, is_constructor=False, meet line: 'const_reverse_iterator\n      crbegin() const noexcept\n      { return _M_t.rbegin(); }\n\n\n\n\n\n\n      const_reverse_iterator\n      crend() const noexcept\n      { return _M_t.rend(); }\n\n\n\n\n\n\n      bool\n   '
[#] parse_declaration, is_constructor=False, meet line: 'const_reverse_iterator\n      crend() const noexcept\n      { return _M_t.rend(); }\n\n\n\n\n\n\n      bool\n      empty() const noexcept\n      { return _M_t.empty(); }\n\n\n      size_type\n      size() const noex'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      empty() const noexcept\n      { return _M_t.empty(); }\n\n\n      size_type\n      size() const noexcept\n      { return _M_t.size(); }\n\n\n      size_type\n      max_size() const noexcept\n      { r'
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      size() const noexcept\n      { return _M_t.size(); }\n\n\n      size_type\n      max_size() const noexcept\n      { return _M_t.max_size(); }\n# 483 "/usr/include/c++/7/bits/stl_map.h" 3\n    '
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      max_size() const noexcept\n      { return _M_t.max_size(); }\n# 483 "/usr/include/c++/7/bits/stl_map.h" 3\n      mapped_type&\n      operator[](const key_type& __k)\n      {\n\n\n\n iterator __'
[#] parse_declaration, is_constructor=False, meet line: 'mapped_type&\n      operator[](const key_type& __k)\n      {\n\n\n\n iterator __i = lower_bound(__k);\n\n if (__i == end() || key_comp()(__k, (*__i).first))\n\n   __i = _M_t._M_emplace_hint_unique(__i, std::pie'
[#] parse_declaration, is_constructor=False, meet line: 'mapped_type&\n      operator[](key_type&& __k)\n      {\n\n\n\n iterator __i = lower_bound(__k);\n\n if (__i == end() || key_comp()(__k, (*__i).first))\n   __i = _M_t._M_emplace_hint_unique(__i, std::piecewise'
[#] parse_declaration, is_constructor=False, meet line: 'mapped_type&\n      at(const key_type& __k)\n      {\n iterator __i = lower_bound(__k);\n if (__i == end() || key_comp()(__k, (*__i).first))\n   __throw_out_of_range(("map::at"));\n return (*__i).second;\n  '
[#] parse_declaration, is_constructor=False, meet line: 'mapped_type&\n      at(const key_type& __k) const\n      {\n const_iterator __i = lower_bound(__k);\n if (__i == end() || key_comp()(__k, (*__i).first))\n   __throw_out_of_range(("map::at"));\n return (*__i'
[#] parse_declaration, is_constructor=False, meet line: 'std::pair<iterator, bool>\n emplace(_Args&&... __args)\n { return _M_t._M_emplace_unique(std::forward<_Args>(__args)...); }\n# 596 "/usr/include/c++/7/bits/stl_map.h" 3\n      template<typename... _Args>\n'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n emplace_hint(const_iterator __pos, _Args&&... __args)\n {\n   return _M_t._M_emplace_hint_unique(__pos,\n          std::forward<_Args>(__args)...);\n }\n# 794 "/usr/include/c++/7/bits/stl_map.h" '
[#] parse_declaration, is_constructor=False, meet line: 'std::pair<iterator, bool>\n      insert(const value_type& __x)\n      { return _M_t._M_insert_unique(__x); }\n\n\n\n\n      std::pair<iterator, bool>\n      insert(value_type&& __x)\n      { return _M_t._M_ins'
[#] parse_declaration, is_constructor=False, meet line: 'std::pair<iterator, bool>\n      insert(value_type&& __x)\n      { return _M_t._M_insert_unique(std::move(__x)); }\n\n      template<typename _Pair>\n __enable_if_t<is_constructible<value_type, _Pair>::val'
[#] parse_declaration, is_constructor=False, meet line: '__enable_if_t<is_constructible<value_type, _Pair>::value,\n        pair<iterator, bool>>\n insert(_Pair&& __x)\n { return _M_t._M_emplace_unique(std::forward<_Pair>(__x)); }\n# 821 "/usr/include/c++/7/bit'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      insert(std::initializer_list<value_type> __list)\n      { insert(__list.begin(), __list.end()); }\n# 850 "/usr/include/c++/7/bits/stl_map.h" 3\n      iterator\n\n      insert(const_iterator __po'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n\n      insert(const_iterator __position, const value_type& __x)\n\n\n\n      { return _M_t._M_insert_unique_(__position, __x); }\n\n\n\n\n      iterator\n      insert(const_iterator __position, value_t'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      insert(const_iterator __position, value_type&& __x)\n      { return _M_t._M_insert_unique_(__position, std::move(__x)); }\n\n      template<typename _Pair>\n __enable_if_t<is_constructible<'
[#] parse_declaration, is_constructor=False, meet line: '__enable_if_t<is_constructible<value_type, _Pair>::value, iterator>\n insert(const_iterator __position, _Pair&& __x)\n {\n   return _M_t._M_emplace_hint_unique(__position,\n          std::forward<_Pair>(_'
[#] parse_declaration, is_constructor=False, meet line: 'void\n insert(_InputIterator __first, _InputIterator __last)\n { _M_t._M_insert_unique(__first, __last); }\n# 1023 "/usr/include/c++/7/bits/stl_map.h" 3\n      iterator\n      erase(const_iterator __positi'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      erase(const_iterator __position)\n      { return _M_t.erase(__position); }\n\n\n      __attribute ((__abi_tag__ ("cxx11")))\n      iterator\n      erase(iterator __position)\n      { return _M'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      erase(iterator __position)\n      { return _M_t.erase(__position); }\n# 1060 "/usr/include/c++/7/bits/stl_map.h" 3\n      size_type\n      erase(const key_type& __x)\n      { return _M_t.era'
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      erase(const key_type& __x)\n      { return _M_t.erase(__x); }\n# 1080 "/usr/include/c++/7/bits/stl_map.h" 3\n      iterator\n      erase(const_iterator __first, const_iterator __last)\n    '
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      erase(const_iterator __first, const_iterator __last)\n      { return _M_t.erase(__first, __last); }\n# 1114 "/usr/include/c++/7/bits/stl_map.h" 3\n      void\n      swap(map& __x)\n      noe'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      swap(map& __x)\n      noexcept(__is_nothrow_swappable<_Compare>::value)\n      { _M_t.swap(__x._M_t); }\n\n\n\n\n\n\n\n      void\n      clear() noexcept\n      { _M_t.clear(); }\n\n\n\n\n\n\n      key_compar'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      clear() noexcept\n      { _M_t.clear(); }\n\n\n\n\n\n\n      key_compare\n      key_comp() const\n      { return _M_t.key_comp(); }\n\n\n\n\n\n      value_compare\n      value_comp() const\n      { return va'
[#] parse_declaration, is_constructor=False, meet line: 'key_compare\n      key_comp() const\n      { return _M_t.key_comp(); }\n\n\n\n\n\n      value_compare\n      value_comp() const\n      { return value_compare(_M_t.key_comp()); }\n# 1161 "/usr/include/c++/7/bits/'
[#] parse_declaration, is_constructor=False, meet line: 'value_compare\n      value_comp() const\n      { return value_compare(_M_t.key_comp()); }\n# 1161 "/usr/include/c++/7/bits/stl_map.h" 3\n      iterator\n      find(const key_type& __x)\n      { return _M_t.'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      find(const key_type& __x)\n      { return _M_t.find(__x); }\n\n\n      template<typename _Kt>\n auto\n find(const _Kt& __x) -> decltype(_M_t._M_find_tr(__x))\n { return _M_t._M_find_tr(__x); }'
[#] parse_declaration, is_constructor=False, meet line: 'auto\n find(const _Kt& __x) -> decltype(_M_t._M_find_tr(__x))\n { return _M_t._M_find_tr(__x); }\n# 1186 "/usr/include/c++/7/bits/stl_map.h" 3\n      const_iterator\n      find(const key_type& __x) const\n '
[#] parse_declaration, is_constructor=False, meet line: 'const_iterator\n      find(const key_type& __x) const\n      { return _M_t.find(__x); }\n\n\n      template<typename _Kt>\n auto\n find(const _Kt& __x) const -> decltype(_M_t._M_find_tr(__x))\n { return _M_t.'
[#] parse_declaration, is_constructor=False, meet line: 'auto\n find(const _Kt& __x) const -> decltype(_M_t._M_find_tr(__x))\n { return _M_t._M_find_tr(__x); }\n# 1207 "/usr/include/c++/7/bits/stl_map.h" 3\n      size_type\n      count(const key_type& __x) const'
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      count(const key_type& __x) const\n      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }\n\n\n      template<typename _Kt>\n auto\n count(const _Kt& __x) const -> decltype(_M_t._M_count_tr(_'
[#] parse_declaration, is_constructor=False, meet line: 'auto\n count(const _Kt& __x) const -> decltype(_M_t._M_count_tr(__x))\n { return _M_t._M_count_tr(__x); }\n# 1231 "/usr/include/c++/7/bits/stl_map.h" 3\n      iterator\n      lower_bound(const key_type& __'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      lower_bound(const key_type& __x)\n      { return _M_t.lower_bound(__x); }\n\n\n      template<typename _Kt>\n auto\n lower_bound(const _Kt& __x)\n -> decltype(iterator(_M_t._M_lower_bound_tr(_'
[#] parse_declaration, is_constructor=False, meet line: 'auto\n lower_bound(const _Kt& __x)\n -> decltype(iterator(_M_t._M_lower_bound_tr(__x)))\n { return iterator(_M_t._M_lower_bound_tr(__x)); }\n# 1256 "/usr/include/c++/7/bits/stl_map.h" 3\n      const_iterat'
[#] parse_declaration, is_constructor=False, meet line: 'const_iterator\n      lower_bound(const key_type& __x) const\n      { return _M_t.lower_bound(__x); }\n\n\n      template<typename _Kt>\n auto\n lower_bound(const _Kt& __x) const\n -> decltype(const_iterator('
[#] parse_declaration, is_constructor=False, meet line: 'auto\n lower_bound(const _Kt& __x) const\n -> decltype(const_iterator(_M_t._M_lower_bound_tr(__x)))\n { return const_iterator(_M_t._M_lower_bound_tr(__x)); }\n# 1276 "/usr/include/c++/7/bits/stl_map.h" 3\n'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      upper_bound(const key_type& __x)\n      { return _M_t.upper_bound(__x); }\n\n\n      template<typename _Kt>\n auto\n upper_bound(const _Kt& __x)\n -> decltype(iterator(_M_t._M_upper_bound_tr(_'
[#] parse_declaration, is_constructor=False, meet line: 'auto\n upper_bound(const _Kt& __x)\n -> decltype(iterator(_M_t._M_upper_bound_tr(__x)))\n { return iterator(_M_t._M_upper_bound_tr(__x)); }\n# 1296 "/usr/include/c++/7/bits/stl_map.h" 3\n      const_iterat'
[#] parse_declaration, is_constructor=False, meet line: 'const_iterator\n      upper_bound(const key_type& __x) const\n      { return _M_t.upper_bound(__x); }\n\n\n      template<typename _Kt>\n auto\n upper_bound(const _Kt& __x) const\n -> decltype(const_iterator('
[#] parse_declaration, is_constructor=False, meet line: 'auto\n upper_bound(const _Kt& __x) const\n -> decltype(const_iterator(_M_t._M_upper_bound_tr(__x)))\n { return const_iterator(_M_t._M_upper_bound_tr(__x)); }\n# 1325 "/usr/include/c++/7/bits/stl_map.h" 3\n'
[#] parse_declaration, is_constructor=False, meet line: 'std::pair<iterator, iterator>\n      equal_range(const key_type& __x)\n      { return _M_t.equal_range(__x); }\n\n\n      template<typename _Kt>\n auto\n equal_range(const _Kt& __x)\n -> decltype(pair<iterato'
[#] parse_declaration, is_constructor=False, meet line: 'auto\n equal_range(const _Kt& __x)\n -> decltype(pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)))\n { return pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)); }\n# 1354 "/usr/include/c++/7/bits'
[#] parse_declaration, is_constructor=False, meet line: 'std::pair<const_iterator, const_iterator>\n      equal_range(const key_type& __x) const\n      { return _M_t.equal_range(__x); }\n\n\n      template<typename _Kt>\n auto\n equal_range(const _Kt& __x) const\n '
[#] parse_declaration, is_constructor=False, meet line: 'auto\n equal_range(const _Kt& __x) const\n -> decltype(pair<const_iterator, const_iterator>(\n       _M_t._M_equal_range_tr(__x)))\n {\n   return pair<const_iterator, const_iterator>(\n       _M_t._M_equal_'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n operator==(const map<_K1, _T1, _C1, _A1>&,\n     const map<_K1, _T1, _C1, _A1>&);\n\n      template<typename _K1, typename _T1, typename _C1, typename _A1>\n friend bool\n operator<(const map<_K1, _T'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n operator<(const map<_K1, _T1, _C1, _A1>&,\n    const map<_K1, _T1, _C1, _A1>&);\n    };\n# 1392 "/usr/include/c++/7/bits/stl_map.h" 3\n  template<typename _Key, typename _Tp, typename _Compare, type'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator==(const map<_Key, _Tp, _Compare, _Alloc>& __x,\n        const map<_Key, _Tp, _Compare, _Alloc>& __y)\n    { return __x._M_t == __y._M_t; }\n# 1409 "/usr/include/c++/7/bits/stl_map.h" 3\n'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<(const map<_Key, _Tp, _Compare, _Alloc>& __x,\n       const map<_Key, _Tp, _Compare, _Alloc>& __y)\n    { return __x._M_t < __y._M_t; }\n\n\n  template<typename _Key, typename _Tp, typena'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator!=(const map<_Key, _Tp, _Compare, _Alloc>& __x,\n        const map<_Key, _Tp, _Compare, _Alloc>& __y)\n    { return !(__x == __y); }\n\n\n  template<typename _Key, typename _Tp, typename _'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>(const map<_Key, _Tp, _Compare, _Alloc>& __x,\n       const map<_Key, _Tp, _Compare, _Alloc>& __y)\n    { return __y < __x; }\n\n\n  template<typename _Key, typename _Tp, typename _Compar'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<=(const map<_Key, _Tp, _Compare, _Alloc>& __x,\n        const map<_Key, _Tp, _Compare, _Alloc>& __y)\n    { return !(__y < __x); }\n\n\n  template<typename _Key, typename _Tp, typename _C'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>=(const map<_Key, _Tp, _Compare, _Alloc>& __x,\n        const map<_Key, _Tp, _Compare, _Alloc>& __y)\n    { return !(__x < __y); }\n\n\n  template<typename _Key, typename _Tp, typename _C'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    swap(map<_Key, _Tp, _Compare, _Alloc>& __x,\n  map<_Key, _Tp, _Compare, _Alloc>& __y)\n    noexcept(noexcept(__x.swap(__y)))\n    { __x.swap(__y); }\n\n\n# 1476 "/usr/include/c++/7/bits/stl_map.h" '
[#] parse_declaration, is_constructor=False, meet line: '_Compare comp;\n\n value_compare(_Compare __c)\n : comp(__c) { }\n\n      public:\n bool operator()(const value_type& __x, const value_type& __y) const\n { return comp(__x.first, __y.first); }\n      };\n\n    '
[#] parse_declaration, is_constructor=True, meet line: 'value_compare(_Compare __c)\n : comp(__c) { }\n\n      public:\n bool operator()(const value_type& __x, const value_type& __y) const\n { return comp(__x.first, __y.first); }\n      };\n\n    private:\n\n      t'
[#] parse_declaration, is_constructor=False, meet line: 'bool operator()(const value_type& __x, const value_type& __y) const\n { return comp(__x.first, __y.first); }\n      };\n\n    private:\n\n      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template\n '
[#] parse_declaration, is_constructor=False, meet line: '_Rep_type _M_t;\n\n      typedef __gnu_cxx::__alloc_traits<_Pair_alloc_type> _Alloc_traits;\n\n    public:\n\n\n      typedef typename _Alloc_traits::pointer pointer;\n      typedef typename _Alloc_traits::co'
[#] parse_declaration, is_constructor=True, meet line: 'multimap() = default;\n\n\n\n\n\n\n\n      explicit\n      multimap(const _Compare& __comp,\n        const allocator_type& __a = allocator_type())\n      : _M_t(__comp, _Pair_alloc_type(__a)) { }\n# 196 "/usr/inc'
[#] parse_declaration, is_constructor=True, meet line: 'multimap(const _Compare& __comp,\n        const allocator_type& __a = allocator_type())\n      : _M_t(__comp, _Pair_alloc_type(__a)) { }\n# 196 "/usr/include/c++/7/bits/stl_multimap.h" 3\n      multimap(c'
[#] parse_declaration, is_constructor=True, meet line: 'multimap(const multimap&) = default;\n# 205 "/usr/include/c++/7/bits/stl_multimap.h" 3\n      multimap(multimap&&) = default;\n# 217 "/usr/include/c++/7/bits/stl_multimap.h" 3\n      multimap(initializer_'
[#] parse_declaration, is_constructor=True, meet line: 'multimap(multimap&&) = default;\n# 217 "/usr/include/c++/7/bits/stl_multimap.h" 3\n      multimap(initializer_list<value_type> __l,\n        const _Compare& __comp = _Compare(),\n        const allocator_t'
[#] parse_declaration, is_constructor=True, meet line: 'multimap(initializer_list<value_type> __l,\n        const _Compare& __comp = _Compare(),\n        const allocator_type& __a = allocator_type())\n      : _M_t(__comp, _Pair_alloc_type(__a))\n      { _M_t._'
[#] parse_declaration, is_constructor=True, meet line: 'multimap(const allocator_type& __a)\n      : _M_t(_Compare(), _Pair_alloc_type(__a)) { }\n\n\n      multimap(const multimap& __m, const allocator_type& __a)\n      : _M_t(__m._M_t, _Pair_alloc_type(__a)) {'
[#] parse_declaration, is_constructor=True, meet line: 'multimap(const multimap& __m, const allocator_type& __a)\n      : _M_t(__m._M_t, _Pair_alloc_type(__a)) { }\n\n\n      multimap(multimap&& __m, const allocator_type& __a)\n      noexcept(is_nothrow_copy_co'
[#] parse_declaration, is_constructor=True, meet line: 'multimap(multimap&& __m, const allocator_type& __a)\n      noexcept(is_nothrow_copy_constructible<_Compare>::value\n        && _Alloc_traits::_S_always_equal())\n      : _M_t(std::move(__m._M_t), _Pair_a'
[#] parse_declaration, is_constructor=True, meet line: 'multimap(initializer_list<value_type> __l, const allocator_type& __a)\n      : _M_t(_Compare(), _Pair_alloc_type(__a))\n      { _M_t._M_insert_equal(__l.begin(), __l.end()); }\n\n\n      template<typename '
[#] parse_declaration, is_constructor=True, meet line: 'multimap(_InputIterator __first, _InputIterator __last,\n   const allocator_type& __a)\n : _M_t(_Compare(), _Pair_alloc_type(__a))\n { _M_t._M_insert_equal(__first, __last); }\n# 260 "/usr/include/c++/7/b'
[#] parse_declaration, is_constructor=True, meet line: 'multimap(_InputIterator __first, _InputIterator __last)\n : _M_t()\n { _M_t._M_insert_equal(__first, __last); }\n# 276 "/usr/include/c++/7/bits/stl_multimap.h" 3\n      template<typename _InputIterator>\n '
[#] parse_declaration, is_constructor=True, meet line: 'multimap(_InputIterator __first, _InputIterator __last,\n   const _Compare& __comp,\n   const allocator_type& __a = allocator_type())\n : _M_t(__comp, _Pair_alloc_type(__a))\n { _M_t._M_insert_equal(__fir'
[#] parse_declaration, is_constructor=True, meet line: 'multimap() = default;\n# 305 "/usr/include/c++/7/bits/stl_multimap.h" 3\n      multimap&\n      operator=(const multimap&) = default;\n\n\n      multimap&\n      operator=(multimap&&) = default;\n# 323 "/usr/'
[#] parse_declaration, is_constructor=True, meet line: 'multimap&\n      operator=(const multimap&) = default;\n\n\n      multimap&\n      operator=(multimap&&) = default;\n# 323 "/usr/include/c++/7/bits/stl_multimap.h" 3\n      multimap&\n      operator=(initiali'
[#] parse_declaration, is_constructor=True, meet line: 'multimap&\n      operator=(multimap&&) = default;\n# 323 "/usr/include/c++/7/bits/stl_multimap.h" 3\n      multimap&\n      operator=(initializer_list<value_type> __l)\n      {\n _M_t._M_assign_equal(__l.be'
[#] parse_declaration, is_constructor=True, meet line: 'multimap&\n      operator=(initializer_list<value_type> __l)\n      {\n _M_t._M_assign_equal(__l.begin(), __l.end());\n return *this;\n      }\n\n\n\n      allocator_type\n      get_allocator() const noexcept\n '
[#] parse_declaration, is_constructor=False, meet line: 'allocator_type\n      get_allocator() const noexcept\n      { return allocator_type(_M_t.get_allocator()); }\n\n\n\n\n\n\n\n      iterator\n      begin() noexcept\n      { return _M_t.begin(); }\n\n\n\n\n\n\n      const'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      begin() noexcept\n      { return _M_t.begin(); }\n\n\n\n\n\n\n      const_iterator\n      begin() const noexcept\n      { return _M_t.begin(); }\n\n\n\n\n\n\n      iterator\n      end() noexcept\n      { '
[#] parse_declaration, is_constructor=False, meet line: 'const_iterator\n      begin() const noexcept\n      { return _M_t.begin(); }\n\n\n\n\n\n\n      iterator\n      end() noexcept\n      { return _M_t.end(); }\n\n\n\n\n\n\n      const_iterator\n      end() const noexcept\n'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      end() noexcept\n      { return _M_t.end(); }\n\n\n\n\n\n\n      const_iterator\n      end() const noexcept\n      { return _M_t.end(); }\n\n\n\n\n\n\n      reverse_iterator\n      rbegin() noexcept\n     '
[#] parse_declaration, is_constructor=False, meet line: 'const_iterator\n      end() const noexcept\n      { return _M_t.end(); }\n\n\n\n\n\n\n      reverse_iterator\n      rbegin() noexcept\n      { return _M_t.rbegin(); }\n\n\n\n\n\n\n      const_reverse_iterator\n      rbe'
[#] parse_declaration, is_constructor=False, meet line: 'reverse_iterator\n      rbegin() noexcept\n      { return _M_t.rbegin(); }\n\n\n\n\n\n\n      const_reverse_iterator\n      rbegin() const noexcept\n      { return _M_t.rbegin(); }\n\n\n\n\n\n\n      reverse_iterator\n '
[#] parse_declaration, is_constructor=False, meet line: 'const_reverse_iterator\n      rbegin() const noexcept\n      { return _M_t.rbegin(); }\n\n\n\n\n\n\n      reverse_iterator\n      rend() noexcept\n      { return _M_t.rend(); }\n\n\n\n\n\n\n      const_reverse_iterator'
[#] parse_declaration, is_constructor=False, meet line: 'reverse_iterator\n      rend() noexcept\n      { return _M_t.rend(); }\n\n\n\n\n\n\n      const_reverse_iterator\n      rend() const noexcept\n      { return _M_t.rend(); }\n\n\n\n\n\n\n\n      const_iterator\n      cbeg'
[#] parse_declaration, is_constructor=False, meet line: 'const_reverse_iterator\n      rend() const noexcept\n      { return _M_t.rend(); }\n\n\n\n\n\n\n\n      const_iterator\n      cbegin() const noexcept\n      { return _M_t.begin(); }\n\n\n\n\n\n\n      const_iterator\n   '
[#] parse_declaration, is_constructor=False, meet line: 'const_iterator\n      cbegin() const noexcept\n      { return _M_t.begin(); }\n\n\n\n\n\n\n      const_iterator\n      cend() const noexcept\n      { return _M_t.end(); }\n\n\n\n\n\n\n      const_reverse_iterator\n     '
[#] parse_declaration, is_constructor=False, meet line: 'const_iterator\n      cend() const noexcept\n      { return _M_t.end(); }\n\n\n\n\n\n\n      const_reverse_iterator\n      crbegin() const noexcept\n      { return _M_t.rbegin(); }\n\n\n\n\n\n\n      const_reverse_iter'
[#] parse_declaration, is_constructor=False, meet line: 'const_reverse_iterator\n      crbegin() const noexcept\n      { return _M_t.rbegin(); }\n\n\n\n\n\n\n      const_reverse_iterator\n      crend() const noexcept\n      { return _M_t.rend(); }\n\n\n\n\n      bool\n     '
[#] parse_declaration, is_constructor=False, meet line: 'const_reverse_iterator\n      crend() const noexcept\n      { return _M_t.rend(); }\n\n\n\n\n      bool\n      empty() const noexcept\n      { return _M_t.empty(); }\n\n\n      size_type\n      size() const noexce'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      empty() const noexcept\n      { return _M_t.empty(); }\n\n\n      size_type\n      size() const noexcept\n      { return _M_t.size(); }\n\n\n      size_type\n      max_size() const noexcept\n      { r'
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      size() const noexcept\n      { return _M_t.size(); }\n\n\n      size_type\n      max_size() const noexcept\n      { return _M_t.max_size(); }\n# 481 "/usr/include/c++/7/bits/stl_multimap.h" 3'
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      max_size() const noexcept\n      { return _M_t.max_size(); }\n# 481 "/usr/include/c++/7/bits/stl_multimap.h" 3\n      template<typename... _Args>\n iterator\n emplace(_Args&&... __args)\n { '
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n emplace(_Args&&... __args)\n { return _M_t._M_emplace_equal(std::forward<_Args>(__args)...); }\n# 508 "/usr/include/c++/7/bits/stl_multimap.h" 3\n      template<typename... _Args>\n iterator\n em'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n emplace_hint(const_iterator __pos, _Args&&... __args)\n {\n   return _M_t._M_emplace_hint_equal(__pos,\n         std::forward<_Args>(__args)...);\n }\n# 530 "/usr/include/c++/7/bits/stl_multimap.'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      insert(const value_type& __x)\n      { return _M_t._M_insert_equal(__x); }\n\n\n\n\n      iterator\n      insert(value_type&& __x)\n      { return _M_t._M_insert_equal(std::move(__x)); }\n\n     '
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      insert(value_type&& __x)\n      { return _M_t._M_insert_equal(std::move(__x)); }\n\n      template<typename _Pair>\n __enable_if_t<is_constructible<value_type, _Pair>::value, iterator>\n ins'
[#] parse_declaration, is_constructor=False, meet line: '__enable_if_t<is_constructible<value_type, _Pair>::value, iterator>\n insert(_Pair&& __x)\n { return _M_t._M_emplace_equal(std::forward<_Pair>(__x)); }\n# 569 "/usr/include/c++/7/bits/stl_multimap.h" 3\n '
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n\n      insert(const_iterator __position, const value_type& __x)\n\n\n\n      { return _M_t._M_insert_equal_(__position, __x); }\n\n\n\n\n      iterator\n      insert(const_iterator __position, value_ty'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      insert(const_iterator __position, value_type&& __x)\n      { return _M_t._M_insert_equal_(__position, std::move(__x)); }\n\n      template<typename _Pair>\n __enable_if_t<is_constructible<v'
[#] parse_declaration, is_constructor=False, meet line: '__enable_if_t<is_constructible<value_type, _Pair&&>::value, iterator>\n insert(const_iterator __position, _Pair&& __x)\n {\n   return _M_t._M_emplace_hint_equal(__position,\n         std::forward<_Pair>(_'
[#] parse_declaration, is_constructor=False, meet line: 'void\n insert(_InputIterator __first, _InputIterator __last)\n { _M_t._M_insert_equal(__first, __last); }\n# 616 "/usr/include/c++/7/bits/stl_multimap.h" 3\n      void\n      insert(initializer_list<value_'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      insert(initializer_list<value_type> __l)\n      { this->insert(__l.begin(), __l.end()); }\n# 693 "/usr/include/c++/7/bits/stl_multimap.h" 3\n      iterator\n      erase(const_iterator __positio'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      erase(const_iterator __position)\n      { return _M_t.erase(__position); }\n\n\n      __attribute ((__abi_tag__ ("cxx11")))\n      iterator\n      erase(iterator __position)\n      { return _M'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      erase(iterator __position)\n      { return _M_t.erase(__position); }\n# 730 "/usr/include/c++/7/bits/stl_multimap.h" 3\n      size_type\n      erase(const key_type& __x)\n      { return _M_t'
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      erase(const key_type& __x)\n      { return _M_t.erase(__x); }\n# 751 "/usr/include/c++/7/bits/stl_multimap.h" 3\n      iterator\n      erase(const_iterator __first, const_iterator __last)\n'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      erase(const_iterator __first, const_iterator __last)\n      { return _M_t.erase(__first, __last); }\n# 788 "/usr/include/c++/7/bits/stl_multimap.h" 3\n      void\n      swap(multimap& __x)\n'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      swap(multimap& __x)\n      noexcept(__is_nothrow_swappable<_Compare>::value)\n      { _M_t.swap(__x._M_t); }\n\n\n\n\n\n\n\n      void\n      clear() noexcept\n      { _M_t.clear(); }\n\n\n\n\n\n\n      key_c'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      clear() noexcept\n      { _M_t.clear(); }\n\n\n\n\n\n\n      key_compare\n      key_comp() const\n      { return _M_t.key_comp(); }\n\n\n\n\n\n      value_compare\n      value_comp() const\n      { return va'
[#] parse_declaration, is_constructor=False, meet line: 'key_compare\n      key_comp() const\n      { return _M_t.key_comp(); }\n\n\n\n\n\n      value_compare\n      value_comp() const\n      { return value_compare(_M_t.key_comp()); }\n# 834 "/usr/include/c++/7/bits/s'
[#] parse_declaration, is_constructor=False, meet line: 'value_compare\n      value_comp() const\n      { return value_compare(_M_t.key_comp()); }\n# 834 "/usr/include/c++/7/bits/stl_multimap.h" 3\n      iterator\n      find(const key_type& __x)\n      { return _'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      find(const key_type& __x)\n      { return _M_t.find(__x); }\n\n\n      template<typename _Kt>\n auto\n find(const _Kt& __x) -> decltype(_M_t._M_find_tr(__x))\n { return _M_t._M_find_tr(__x); }'
[#] parse_declaration, is_constructor=False, meet line: 'auto\n find(const _Kt& __x) -> decltype(_M_t._M_find_tr(__x))\n { return _M_t._M_find_tr(__x); }\n# 858 "/usr/include/c++/7/bits/stl_multimap.h" 3\n      const_iterator\n      find(const key_type& __x) con'
[#] parse_declaration, is_constructor=False, meet line: 'const_iterator\n      find(const key_type& __x) const\n      { return _M_t.find(__x); }\n\n\n      template<typename _Kt>\n auto\n find(const _Kt& __x) const -> decltype(_M_t._M_find_tr(__x))\n { return _M_t.'
[#] parse_declaration, is_constructor=False, meet line: 'auto\n find(const _Kt& __x) const -> decltype(_M_t._M_find_tr(__x))\n { return _M_t._M_find_tr(__x); }\n# 876 "/usr/include/c++/7/bits/stl_multimap.h" 3\n      size_type\n      count(const key_type& __x) c'
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      count(const key_type& __x) const\n      { return _M_t.count(__x); }\n\n\n      template<typename _Kt>\n auto\n count(const _Kt& __x) const -> decltype(_M_t._M_count_tr(__x))\n { return _M_t._'
[#] parse_declaration, is_constructor=False, meet line: 'auto\n count(const _Kt& __x) const -> decltype(_M_t._M_count_tr(__x))\n { return _M_t._M_count_tr(__x); }\n# 900 "/usr/include/c++/7/bits/stl_multimap.h" 3\n      iterator\n      lower_bound(const key_type'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      lower_bound(const key_type& __x)\n      { return _M_t.lower_bound(__x); }\n\n\n      template<typename _Kt>\n auto\n lower_bound(const _Kt& __x)\n -> decltype(iterator(_M_t._M_lower_bound_tr(_'
[#] parse_declaration, is_constructor=False, meet line: 'auto\n lower_bound(const _Kt& __x)\n -> decltype(iterator(_M_t._M_lower_bound_tr(__x)))\n { return iterator(_M_t._M_lower_bound_tr(__x)); }\n# 925 "/usr/include/c++/7/bits/stl_multimap.h" 3\n      const_it'
[#] parse_declaration, is_constructor=False, meet line: 'const_iterator\n      lower_bound(const key_type& __x) const\n      { return _M_t.lower_bound(__x); }\n\n\n      template<typename _Kt>\n auto\n lower_bound(const _Kt& __x) const\n -> decltype(const_iterator('
[#] parse_declaration, is_constructor=False, meet line: 'auto\n lower_bound(const _Kt& __x) const\n -> decltype(const_iterator(_M_t._M_lower_bound_tr(__x)))\n { return const_iterator(_M_t._M_lower_bound_tr(__x)); }\n# 945 "/usr/include/c++/7/bits/stl_multimap.h'
[#] parse_declaration, is_constructor=False, meet line: 'iterator\n      upper_bound(const key_type& __x)\n      { return _M_t.upper_bound(__x); }\n\n\n      template<typename _Kt>\n auto\n upper_bound(const _Kt& __x)\n -> decltype(iterator(_M_t._M_upper_bound_tr(_'
[#] parse_declaration, is_constructor=False, meet line: 'auto\n upper_bound(const _Kt& __x)\n -> decltype(iterator(_M_t._M_upper_bound_tr(__x)))\n { return iterator(_M_t._M_upper_bound_tr(__x)); }\n# 965 "/usr/include/c++/7/bits/stl_multimap.h" 3\n      const_it'
[#] parse_declaration, is_constructor=False, meet line: 'const_iterator\n      upper_bound(const key_type& __x) const\n      { return _M_t.upper_bound(__x); }\n\n\n      template<typename _Kt>\n auto\n upper_bound(const _Kt& __x) const\n -> decltype(const_iterator('
[#] parse_declaration, is_constructor=False, meet line: 'auto\n upper_bound(const _Kt& __x) const\n -> decltype(const_iterator(_M_t._M_upper_bound_tr(__x)))\n { return const_iterator(_M_t._M_upper_bound_tr(__x)); }\n# 992 "/usr/include/c++/7/bits/stl_multimap.h'
[#] parse_declaration, is_constructor=False, meet line: 'std::pair<iterator, iterator>\n      equal_range(const key_type& __x)\n      { return _M_t.equal_range(__x); }\n\n\n      template<typename _Kt>\n auto\n equal_range(const _Kt& __x)\n -> decltype(pair<iterato'
[#] parse_declaration, is_constructor=False, meet line: 'auto\n equal_range(const _Kt& __x)\n -> decltype(pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)))\n { return pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)); }\n# 1019 "/usr/include/c++/7/bits'
[#] parse_declaration, is_constructor=False, meet line: 'std::pair<const_iterator, const_iterator>\n      equal_range(const key_type& __x) const\n      { return _M_t.equal_range(__x); }\n\n\n      template<typename _Kt>\n auto\n equal_range(const _Kt& __x) const\n '
[#] parse_declaration, is_constructor=False, meet line: 'auto\n equal_range(const _Kt& __x) const\n -> decltype(pair<const_iterator, const_iterator>(\n       _M_t._M_equal_range_tr(__x)))\n {\n   return pair<const_iterator, const_iterator>(\n       _M_t._M_equal_'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n operator==(const multimap<_K1, _T1, _C1, _A1>&,\n     const multimap<_K1, _T1, _C1, _A1>&);\n\n      template<typename _K1, typename _T1, typename _C1, typename _A1>\n friend bool\n operator<(const m'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n operator<(const multimap<_K1, _T1, _C1, _A1>&,\n    const multimap<_K1, _T1, _C1, _A1>&);\n  };\n# 1057 "/usr/include/c++/7/bits/stl_multimap.h" 3\n  template<typename _Key, typename _Tp, typename _'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator==(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n        const multimap<_Key, _Tp, _Compare, _Alloc>& __y)\n    { return __x._M_t == __y._M_t; }\n# 1074 "/usr/include/c++/7/bits/stl'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n       const multimap<_Key, _Tp, _Compare, _Alloc>& __y)\n    { return __x._M_t < __y._M_t; }\n\n\n  template<typename _Key, typename _'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator!=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n        const multimap<_Key, _Tp, _Compare, _Alloc>& __y)\n    { return !(__x == __y); }\n\n\n  template<typename _Key, typename _Tp, '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n       const multimap<_Key, _Tp, _Compare, _Alloc>& __y)\n    { return __y < __x; }\n\n\n  template<typename _Key, typename _Tp, typena'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n        const multimap<_Key, _Tp, _Compare, _Alloc>& __y)\n    { return !(__y < __x); }\n\n\n  template<typename _Key, typename _Tp, t'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n        const multimap<_Key, _Tp, _Compare, _Alloc>& __y)\n    { return !(__x < __y); }\n\n\n  template<typename _Key, typename _Tp, t'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    swap(multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n  multimap<_Key, _Tp, _Compare, _Alloc>& __y)\n    noexcept(noexcept(__x.swap(__y)))\n    { __x.swap(__y); }\n\n\n# 1141 "/usr/include/c++/7/bits/s'
[#] parse_declaration, is_constructor=False, meet line: 'void *memcpy (void *__restrict __dest, const void *__restrict __src,\n       size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));\n\n\nextern void *memmove (void *__dest, const void *__src, size_t _'
[#] parse_declaration, is_constructor=False, meet line: 'void *memmove (void *__dest, const void *__src, size_t __n)\n     throw () __attribute__ ((__nonnull__ (1, 2)));\n\n\n\n\n\nextern void *memccpy (void *__restrict __dest, const void *__restrict __src,\n      '
[#] parse_declaration, is_constructor=False, meet line: 'void *memccpy (void *__restrict __dest, const void *__restrict __src,\n        int __c, size_t __n)\n     throw () __attribute__ ((__nonnull__ (1, 2)));\n\n\n\n\nextern void *memset (void *__s, int __c, size'
[#] parse_declaration, is_constructor=False, meet line: 'void *memset (void *__s, int __c, size_t __n) throw () __attribute__ ((__nonnull__ (1)));\n\n\nextern int memcmp (const void *__s1, const void *__s2, size_t __n)\n     throw () __attribute__ ((__pure__)) '
[#] parse_declaration, is_constructor=False, meet line: 'int memcmp (const void *__s1, const void *__s2, size_t __n)\n     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));\n\n\n\nextern "C++"\n{\nextern void *memchr (void *__s, int __c, si'
[#] parse_declaration, is_constructor=False, meet line: 'void *memchr (void *__s, int __c, size_t __n)\n      throw () __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));\nextern const void *memchr (const void *__s, int __c, size_t '
[#] parse_declaration, is_constructor=False, meet line: 'const void *memchr (const void *__s, int __c, size_t __n)\n      throw () __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));\n# 88 "/usr/include/string.h" 3 4\n}\n# 98 "/usr/in'
[#] parse_declaration, is_constructor=False, meet line: ' void *rawmemchr (void *__s, int __c)\n     throw () __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));\nextern "C++" const void *rawmemchr (const void *__s, int __c)\n    '
[#] parse_declaration, is_constructor=False, meet line: ' const void *rawmemchr (const void *__s, int __c)\n     throw () __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));\n\n\n\n\n\n\n\nextern "C++" void *memrchr (void *__s, int __c,'
[#] parse_declaration, is_constructor=False, meet line: ' void *memrchr (void *__s, int __c, size_t __n)\n      throw () __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));\nextern "C++" const void *memrchr (const void *__s, int __'
[#] parse_declaration, is_constructor=False, meet line: ' const void *memrchr (const void *__s, int __c, size_t __n)\n      throw () __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));\n# 121 "/usr/include/string.h" 3 4\nextern char'
[#] parse_declaration, is_constructor=False, meet line: 'char *strcpy (char *__restrict __dest, const char *__restrict __src)\n     throw () __attribute__ ((__nonnull__ (1, 2)));\n\nextern char *strncpy (char *__restrict __dest,\n        const char *__restrict '
[#] parse_declaration, is_constructor=False, meet line: 'char *strncpy (char *__restrict __dest,\n        const char *__restrict __src, size_t __n)\n     throw () __attribute__ ((__nonnull__ (1, 2)));\n\n\nextern char *strcat (char *__restrict __dest, const char'
[#] parse_declaration, is_constructor=False, meet line: 'char *strcat (char *__restrict __dest, const char *__restrict __src)\n     throw () __attribute__ ((__nonnull__ (1, 2)));\n\nextern char *strncat (char *__restrict __dest, const char *__restrict __src,\n '
[#] parse_declaration, is_constructor=False, meet line: 'char *strncat (char *__restrict __dest, const char *__restrict __src,\n        size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));\n\n\nextern int strcmp (const char *__s1, const char *__s2)\n     t'
[#] parse_declaration, is_constructor=False, meet line: 'int strcmp (const char *__s1, const char *__s2)\n     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));\n\nextern int strncmp (const char *__s1, const char *__s2, size_t __n)\n    '
[#] parse_declaration, is_constructor=False, meet line: 'int strncmp (const char *__s1, const char *__s2, size_t __n)\n     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));\n\n\nextern int strcoll (const char *__s1, const char *__s2)\n  '
[#] parse_declaration, is_constructor=False, meet line: 'int strcoll (const char *__s1, const char *__s2)\n     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));\n\nextern size_t strxfrm (char *__restrict __dest,\n         const char *__'
[#] parse_declaration, is_constructor=False, meet line: 'size_t strxfrm (char *__restrict __dest,\n         const char *__restrict __src, size_t __n)\n     throw () __attribute__ ((__nonnull__ (2)));\n\n\n\n\n\n\nextern int strcoll_l (const char *__s1, const char *_'
[#] parse_declaration, is_constructor=False, meet line: 'int strcoll_l (const char *__s1, const char *__s2, locale_t __l)\n     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));\n\n\nextern size_t strxfrm_l (char *__dest, const char *'
[#] parse_declaration, is_constructor=False, meet line: 'size_t strxfrm_l (char *__dest, const char *__src, size_t __n,\n    locale_t __l) throw () __attribute__ ((__nonnull__ (2, 4)));\n\n\n\n\n\nextern char *strdup (const char *__s)\n     throw () __attribute__ ('
[#] parse_declaration, is_constructor=False, meet line: 'char *strdup (const char *__s)\n     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));\n\n\n\n\n\n\nextern char *strndup (const char *__string, size_t __n)\n     throw () __attribute__ ('
[#] parse_declaration, is_constructor=False, meet line: 'char *strndup (const char *__string, size_t __n)\n     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));\n# 203 "/usr/include/string.h" 3 4\nextern "C++"\n{\nextern char *strchr (cha'
[#] parse_declaration, is_constructor=False, meet line: 'char *strchr (char *__s, int __c)\n     throw () __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));\nextern const char *strchr (const char *__s, int __c)\n     throw () __asm '
[#] parse_declaration, is_constructor=False, meet line: 'const char *strchr (const char *__s, int __c)\n     throw () __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));\n# 223 "/usr/include/string.h" 3 4\n}\n\n\n\n\n\n\nextern "C++"\n{\nexte'
[#] parse_declaration, is_constructor=False, meet line: 'char *strrchr (char *__s, int __c)\n     throw () __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));\nextern const char *strrchr (const char *__s, int __c)\n     throw () __a'
[#] parse_declaration, is_constructor=False, meet line: 'const char *strrchr (const char *__s, int __c)\n     throw () __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));\n# 250 "/usr/include/string.h" 3 4\n}\n# 260 "/usr/include/str'
[#] parse_declaration, is_constructor=False, meet line: ' char *strchrnul (char *__s, int __c)\n     throw () __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));\nextern "C++" const char *strchrnul (const char *__s, int __c)\n    '
[#] parse_declaration, is_constructor=False, meet line: ' const char *strchrnul (const char *__s, int __c)\n     throw () __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));\n# 272 "/usr/include/string.h" 3 4\nextern size_t strcsp'
[#] parse_declaration, is_constructor=False, meet line: 'size_t strcspn (const char *__s, const char *__reject)\n     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));\n\n\nextern size_t strspn (const char *__s, const char *__accept)\n   '
[#] parse_declaration, is_constructor=False, meet line: 'size_t strspn (const char *__s, const char *__accept)\n     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));\n\n\nextern "C++"\n{\nextern char *strpbrk (char *__s, const char *__acc'
[#] parse_declaration, is_constructor=False, meet line: 'char *strpbrk (char *__s, const char *__accept)\n     throw () __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));\nextern const char *strpbrk (const char *__s, const char'
[#] parse_declaration, is_constructor=False, meet line: 'const char *strpbrk (const char *__s, const char *__accept)\n     throw () __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));\n# 300 "/usr/include/string.h" 3 4\n}\n\n\n\n\n\n\ne'
[#] parse_declaration, is_constructor=False, meet line: 'char *strstr (char *__haystack, const char *__needle)\n     throw () __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));\nextern const char *strstr (const char *__haystack,'
[#] parse_declaration, is_constructor=False, meet line: 'const char *strstr (const char *__haystack, const char *__needle)\n     throw () __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));\n# 327 "/usr/include/string.h" 3 4\n}\n\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'char *strtok (char *__restrict __s, const char *__restrict __delim)\n     throw () __attribute__ ((__nonnull__ (2)));\n\n\n\nextern char *__strtok_r (char *__restrict __s,\n    const char *__restrict __deli'
[#] parse_declaration, is_constructor=False, meet line: 'char *__strtok_r (char *__restrict __s,\n    const char *__restrict __delim,\n    char **__restrict __save_ptr)\n     throw () __attribute__ ((__nonnull__ (2, 3)));\n\nextern char *strtok_r (char *__restri'
[#] parse_declaration, is_constructor=False, meet line: 'char *strtok_r (char *__restrict __s, const char *__restrict __delim,\n         char **__restrict __save_ptr)\n     throw () __attribute__ ((__nonnull__ (2, 3)));\n\n\n\n\n\nextern "C++" char *strcasestr (cha'
[#] parse_declaration, is_constructor=False, meet line: ' char *strcasestr (char *__haystack, const char *__needle)\n     throw () __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));\nextern "C++" const char *strcasestr (cons'
[#] parse_declaration, is_constructor=False, meet line: ' const char *strcasestr (const char *__haystack,\n         const char *__needle)\n     throw () __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));\n# 368 "/usr/include/'
[#] parse_declaration, is_constructor=False, meet line: 'void *memmem (const void *__haystack, size_t __haystacklen,\n       const void *__needle, size_t __needlelen)\n     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));\n\n\n\nextern vo'
[#] parse_declaration, is_constructor=False, meet line: 'void *__mempcpy (void *__restrict __dest,\n   const void *__restrict __src, size_t __n)\n     throw () __attribute__ ((__nonnull__ (1, 2)));\nextern void *mempcpy (void *__restrict __dest,\n        const '
[#] parse_declaration, is_constructor=False, meet line: 'void *mempcpy (void *__restrict __dest,\n        const void *__restrict __src, size_t __n)\n     throw () __attribute__ ((__nonnull__ (1, 2)));\n\n\n\n\nextern size_t strlen (const char *__s)\n     throw () _'
[#] parse_declaration, is_constructor=False, meet line: 'size_t strlen (const char *__s)\n     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));\n\n\n\n\nextern size_t strnlen (const char *__string, size_t __maxlen)\n     throw () __attribute_'
[#] parse_declaration, is_constructor=False, meet line: 'size_t strnlen (const char *__string, size_t __maxlen)\n     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));\n\n\n\n\nextern char *strerror (int __errnum) throw ();\n# 420 "/usr/includ'
[#] parse_declaration, is_constructor=False, meet line: 'char *strerror (int __errnum) throw ();\n# 420 "/usr/include/string.h" 3 4\nextern char *strerror_r (int __errnum, char *__buf, size_t __buflen)\n     throw () __attribute__ ((__nonnull__ (2))) ;\n\n\n\n\n\nex'
[#] parse_declaration, is_constructor=False, meet line: 'char *strerror_r (int __errnum, char *__buf, size_t __buflen)\n     throw () __attribute__ ((__nonnull__ (2))) ;\n\n\n\n\n\nextern char *strerror_l (int __errnum, locale_t __l) throw ();\n\n\n\n# 1 "/usr/include'
[#] parse_declaration, is_constructor=False, meet line: 'char *strerror_l (int __errnum, locale_t __l) throw ();\n\n\n\n# 1 "/usr/include/strings.h" 1 3 4\n# 23 "/usr/include/strings.h" 3 4\n# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4\n# 24 "/usr/'
[#] parse_declaration, is_constructor=False, meet line: 'int bcmp (const void *__s1, const void *__s2, size_t __n)\n     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));\n\n\nextern void bcopy (const void *__src, void *__dest, size_t __'
[#] parse_declaration, is_constructor=False, meet line: 'void bcopy (const void *__src, void *__dest, size_t __n)\n  throw () __attribute__ ((__nonnull__ (1, 2)));\n\n\nextern void bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));\n\n\n\next'
[#] parse_declaration, is_constructor=False, meet line: 'void bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));\n\n\n\nextern "C++"\n{\nextern char *index (char *__s, int __c)\n     throw () __asm ("index") __attribute__ ((__pure__)) __attr'
[#] parse_declaration, is_constructor=False, meet line: 'char *index (char *__s, int __c)\n     throw () __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));\nextern const char *index (const char *__s, int __c)\n     throw () __asm ("i'
[#] parse_declaration, is_constructor=False, meet line: 'const char *index (const char *__s, int __c)\n     throw () __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));\n# 66 "/usr/include/strings.h" 3 4\n}\n\n\n\n\n\n\n\nextern "C++"\n{\nexter'
[#] parse_declaration, is_constructor=False, meet line: 'char *rindex (char *__s, int __c)\n     throw () __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));\nextern const char *rindex (const char *__s, int __c)\n     throw () __asm '
[#] parse_declaration, is_constructor=False, meet line: 'const char *rindex (const char *__s, int __c)\n     throw () __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));\n# 94 "/usr/include/strings.h" 3 4\n}\n# 104 "/usr/include/strin'
[#] parse_declaration, is_constructor=False, meet line: 'int ffs (int __i) throw () __attribute__ ((__const__));\n\n\n\n\n\nextern int ffsl (long int __l) throw () __attribute__ ((__const__));\n__extension__ extern int ffsll (long long int __ll)\n     throw () __at'
[#] parse_declaration, is_constructor=False, meet line: 'int ffsl (long int __l) throw () __attribute__ ((__const__));\n__extension__ extern int ffsll (long long int __ll)\n     throw () __attribute__ ((__const__));\n\n\n\nextern int strcasecmp (const char *__s1,'
[#] parse_declaration, is_constructor=False, meet line: 'int ffsll (long long int __ll)\n     throw () __attribute__ ((__const__));\n\n\n\nextern int strcasecmp (const char *__s1, const char *__s2)\n     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnu'
[#] parse_declaration, is_constructor=False, meet line: 'int strcasecmp (const char *__s1, const char *__s2)\n     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));\n\n\nextern int strncasecmp (const char *__s1, const char *__s2, size_t '
[#] parse_declaration, is_constructor=False, meet line: 'int strncasecmp (const char *__s1, const char *__s2, size_t __n)\n     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));\n\n\n\n\n\n\nextern int strcasecmp_l (const char *__s1, const c'
[#] parse_declaration, is_constructor=False, meet line: 'int strcasecmp_l (const char *__s1, const char *__s2, locale_t __loc)\n     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));\n\n\n\nextern int strncasecmp_l (const char *__s1, c'
[#] parse_declaration, is_constructor=False, meet line: 'int strncasecmp_l (const char *__s1, const char *__s2,\n     size_t __n, locale_t __loc)\n     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));\n\n\n}\n# 432 "/usr/include/string'
[#] parse_declaration, is_constructor=False, meet line: 'void explicit_bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));\n\n\n\nextern char *strsep (char **__restrict __stringp,\n       const char *__restrict __delim)\n     throw () __attr'
[#] parse_declaration, is_constructor=False, meet line: 'char *strsep (char **__restrict __stringp,\n       const char *__restrict __delim)\n     throw () __attribute__ ((__nonnull__ (1, 2)));\n\n\n\n\nextern char *strsignal (int __sig) throw ();\n\n\nextern char *__'
[#] parse_declaration, is_constructor=False, meet line: 'char *strsignal (int __sig) throw ();\n\n\nextern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)\n     throw () __attribute__ ((__nonnull__ (1, 2)));\nextern char *stpcpy (char *__r'
[#] parse_declaration, is_constructor=False, meet line: 'char *__stpcpy (char *__restrict __dest, const char *__restrict __src)\n     throw () __attribute__ ((__nonnull__ (1, 2)));\nextern char *stpcpy (char *__restrict __dest, const char *__restrict __src)\n '
[#] parse_declaration, is_constructor=False, meet line: 'char *stpcpy (char *__restrict __dest, const char *__restrict __src)\n     throw () __attribute__ ((__nonnull__ (1, 2)));\n\n\n\nextern char *__stpncpy (char *__restrict __dest,\n   const char *__restrict _'
[#] parse_declaration, is_constructor=False, meet line: 'char *__stpncpy (char *__restrict __dest,\n   const char *__restrict __src, size_t __n)\n     throw () __attribute__ ((__nonnull__ (1, 2)));\nextern char *stpncpy (char *__restrict __dest,\n        const '
[#] parse_declaration, is_constructor=False, meet line: 'char *stpncpy (char *__restrict __dest,\n        const char *__restrict __src, size_t __n)\n     throw () __attribute__ ((__nonnull__ (1, 2)));\n\n\n\n\nextern int strverscmp (const char *__s1, const char *_'
[#] parse_declaration, is_constructor=False, meet line: 'int strverscmp (const char *__s1, const char *__s2)\n     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));\n\n\nextern char *strfry (char *__string) throw () __attribute__ ((__non'
[#] parse_declaration, is_constructor=False, meet line: 'char *strfry (char *__string) throw () __attribute__ ((__nonnull__ (1)));\n\n\nextern void *memfrob (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));\n\n\n\n\n\n\n\nextern "C++" char *basename '
[#] parse_declaration, is_constructor=False, meet line: 'void *memfrob (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));\n\n\n\n\n\n\n\nextern "C++" char *basename (char *__filename)\n     throw () __asm ("basename") __attribute__ ((__nonnull__ (1)'
[#] parse_declaration, is_constructor=False, meet line: ' char *basename (char *__filename)\n     throw () __asm ("basename") __attribute__ ((__nonnull__ (1)));\nextern "C++" const char *basename (const char *__filename)\n     throw () __asm ("basename") __att'
[#] parse_declaration, is_constructor=False, meet line: ' const char *basename (const char *__filename)\n     throw () __asm ("basename") __attribute__ ((__nonnull__ (1)));\n# 498 "/usr/include/string.h" 3 4\n}\n# 43 "/usr/include/c++/7/cstring" 2 3\n# 71 "/usr/'
[#] parse_declaration, is_constructor=True, meet line: 'bad_function_call() noexcept;\n\n    const char* what() const noexcept;\n  };\n\n\n\n\n\n\n\n  template<typename _Tp>\n    struct __is_location_invariant\n    : is_trivially_copyable<_Tp>::type\n    { };\n\n  class _'
[#] parse_declaration, is_constructor=False, meet line: 'char* what() const noexcept;\n  };\n\n\n\n\n\n\n\n  template<typename _Tp>\n    struct __is_location_invariant\n    : is_trivially_copyable<_Tp>::type\n    { };\n\n  class _Undefined_class;\n\n  union _Nocopy_types\n '
[#] parse_declaration, is_constructor=False, meet line: 'void* _M_object;\n    const void* _M_const_object;\n    void (*_M_function_pointer)();\n    void (_Undefined_class::*_M_member_pointer)();\n  };\n\n  union [[gnu::may_alias]] _Any_data\n  {\n    void* _M_acce'
[#] parse_declaration, is_constructor=False, meet line: 'void* _M_const_object;\n    void (*_M_function_pointer)();\n    void (_Undefined_class::*_M_member_pointer)();\n  };\n\n  union [[gnu::may_alias]] _Any_data\n  {\n    void* _M_access() { return &_M_pod_data['
[#] parse_declaration, is_constructor=False, meet line: 'void (*_M_function_pointer)();\n    void (_Undefined_class::*_M_member_pointer)();\n  };\n\n  union [[gnu::may_alias]] _Any_data\n  {\n    void* _M_access() { return &_M_pod_data[0]; }\n    const void* _M_ac'
[#] parse_declaration, is_constructor=False, meet line: 'void (_Undefined_class::*_M_member_pointer)();\n  };\n\n  union [[gnu::may_alias]] _Any_data\n  {\n    void* _M_access() { return &_M_pod_data[0]; }\n    const void* _M_access() const { return &_M_pod_data['
[#] parse_declaration, is_constructor=False, meet line: 'void* _M_access() { return &_M_pod_data[0]; }\n    const void* _M_access() const { return &_M_pod_data[0]; }\n\n    template<typename _Tp>\n      _Tp&\n      _M_access()\n      { return *static_cast<_Tp*>(_'
[#] parse_declaration, is_constructor=False, meet line: 'void* _M_access() const { return &_M_pod_data[0]; }\n\n    template<typename _Tp>\n      _Tp&\n      _M_access()\n      { return *static_cast<_Tp*>(_M_access()); }\n\n    template<typename _Tp>\n      const _'
[#] parse_declaration, is_constructor=False, meet line: '_Tp&\n      _M_access()\n      { return *static_cast<_Tp*>(_M_access()); }\n\n    template<typename _Tp>\n      const _Tp&\n      _M_access() const\n      { return *static_cast<const _Tp*>(_M_access()); }\n\n '
[#] parse_declaration, is_constructor=False, meet line: '_Tp&\n      _M_access() const\n      { return *static_cast<const _Tp*>(_M_access()); }\n\n    _Nocopy_types _M_unused;\n    char _M_pod_data[sizeof(_Nocopy_types)];\n  };\n\n  enum _Manager_operation\n  {\n    '
[#] parse_declaration, is_constructor=False, meet line: '_Nocopy_types _M_unused;\n    char _M_pod_data[sizeof(_Nocopy_types)];\n  };\n\n  enum _Manager_operation\n  {\n    __get_type_info,\n    __get_functor_ptr,\n    __clone_functor,\n    __destroy_functor\n  };\n\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'char _M_pod_data[sizeof(_Nocopy_types)];\n  };\n\n  enum _Manager_operation\n  {\n    __get_type_info,\n    __get_functor_ptr,\n    __clone_functor,\n    __destroy_functor\n  };\n\n\n\n  template<typename _Tp>\n   '
[#] parse_declaration, is_constructor=True, meet line: '_Simple_type_wrapper(_Tp __value) : __value(__value) { }\n\n      _Tp __value;\n    };\n\n  template<typename _Tp>\n    struct __is_location_invariant<_Simple_type_wrapper<_Tp> >\n    : __is_location_invaria'
[#] parse_declaration, is_constructor=False, meet line: '_Tp __value;\n    };\n\n  template<typename _Tp>\n    struct __is_location_invariant<_Simple_type_wrapper<_Tp> >\n    : __is_location_invariant<_Tp>\n    { };\n\n  template<typename _Signature>\n    class func'
[#] parse_declaration, is_constructor=False, meet line: 'std::size_t _M_max_size = sizeof(_Nocopy_types);\n    static const std::size_t _M_max_align = __alignof__(_Nocopy_types);\n\n    template<typename _Functor>\n      class _Base_manager\n      {\n      protec'
[#] parse_declaration, is_constructor=False, meet line: 'std::size_t _M_max_align = __alignof__(_Nocopy_types);\n\n    template<typename _Functor>\n      class _Base_manager\n      {\n      protected:\n static const bool __stored_locally =\n (__is_location_invaria'
[#] parse_declaration, is_constructor=False, meet line: 'bool __stored_locally =\n (__is_location_invariant<_Functor>::value\n  && sizeof(_Functor) <= _M_max_size\n  && __alignof__(_Functor) <= _M_max_align\n  && (_M_max_align % __alignof__(_Functor) == 0));\n\n '
[#] parse_declaration, is_constructor=False, meet line: '_Functor*\n _M_get_pointer(const _Any_data& __source)\n {\n   const _Functor* __ptr =\n     __stored_locally? std::__addressof(__source._M_access<_Functor>())\n                                 : __source._'
[#] parse_declaration, is_constructor=False, meet line: 'void\n _M_clone(_Any_data& __dest, const _Any_data& __source, true_type)\n {\n   ::new (__dest._M_access()) _Functor(__source._M_access<_Functor>());\n }\n\n\n\n static void\n _M_clone(_Any_data& __dest, const'
[#] parse_declaration, is_constructor=False, meet line: 'void\n _M_clone(_Any_data& __dest, const _Any_data& __source, false_type)\n {\n   __dest._M_access<_Functor*>() =\n     new _Functor(*__source._M_access<_Functor*>());\n }\n\n\n\n static void\n _M_destroy(_Any_'
[#] parse_declaration, is_constructor=False, meet line: 'void\n _M_destroy(_Any_data& __victim, true_type)\n {\n   __victim._M_access<_Functor>().~_Functor();\n }\n\n\n static void\n _M_destroy(_Any_data& __victim, false_type)\n {\n   delete __victim._M_access<_Funct'
[#] parse_declaration, is_constructor=False, meet line: 'void\n _M_destroy(_Any_data& __victim, false_type)\n {\n   delete __victim._M_access<_Functor*>();\n }\n\n      public:\n static bool\n _M_manager(_Any_data& __dest, const _Any_data& __source,\n     _Manager_o'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n _M_manager(_Any_data& __dest, const _Any_data& __source,\n     _Manager_operation __op)\n {\n   switch (__op)\n     {\n\n     case __get_type_info:\n       __dest._M_access<const type_info*>() = &typei'
[#] parse_declaration, is_constructor=False, meet line: 'void\n _M_init_functor(_Any_data& __functor, _Functor&& __f)\n { _M_init_functor(__functor, std::move(__f), _Local_storage()); }\n\n template<typename _Signature>\n   static bool\n   _M_not_empty_function(c'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n   _M_not_empty_function(const function<_Signature>& __f)\n   { return static_cast<bool>(__f); }\n\n template<typename _Tp>\n   static bool\n   _M_not_empty_function(_Tp* __fp)\n   { return __fp != nul'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n   _M_not_empty_function(_Tp* __fp)\n   { return __fp != nullptr; }\n\n template<typename _Class, typename _Tp>\n   static bool\n   _M_not_empty_function(_Tp _Class::* __mp)\n   { return __mp != nullpt'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n   _M_not_empty_function(_Tp _Class::* __mp)\n   { return __mp != nullptr; }\n\n template<typename _Tp>\n   static bool\n   _M_not_empty_function(const _Tp&)\n   { return true; }\n\n      private:\n stati'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n   _M_not_empty_function(const _Tp&)\n   { return true; }\n\n      private:\n static void\n _M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)\n { ::new (__functor._M_access()) _Functor(s'
[#] parse_declaration, is_constructor=False, meet line: 'void\n _M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)\n { ::new (__functor._M_access()) _Functor(std::move(__f)); }\n\n static void\n _M_init_functor(_Any_data& __functor, _Functor&& __f,'
[#] parse_declaration, is_constructor=False, meet line: 'void\n _M_init_functor(_Any_data& __functor, _Functor&& __f, false_type)\n { __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }\n      };\n\n    _Function_base() : _M_manager(nullptr) { }\n\n'
[#] parse_declaration, is_constructor=True, meet line: '_Function_base() : _M_manager(nullptr) { }\n\n    ~_Function_base()\n    {\n      if (_M_manager)\n _M_manager(_M_functor, _M_functor, __destroy_functor);\n    }\n\n    bool _M_empty() const { return !_M_mana'
[#] parse_declaration, is_constructor=True, meet line: '_Function_base()\n    {\n      if (_M_manager)\n _M_manager(_M_functor, _M_functor, __destroy_functor);\n    }\n\n    bool _M_empty() const { return !_M_manager; }\n\n    typedef bool (*_Manager_type)(_Any_da'
[#] parse_declaration, is_constructor=False, meet line: 'bool _M_empty() const { return !_M_manager; }\n\n    typedef bool (*_Manager_type)(_Any_data&, const _Any_data&,\n      _Manager_operation);\n\n    _Any_data _M_functor;\n    _Manager_type _M_manager;\n  };\n'
[#] parse_declaration, is_constructor=False, meet line: '_Any_data _M_functor;\n    _Manager_type _M_manager;\n  };\n\n  template<typename _Signature, typename _Functor>\n    class _Function_handler;\n\n  template<typename _Res, typename _Functor, typename... _Arg'
[#] parse_declaration, is_constructor=False, meet line: '_Manager_type _M_manager;\n  };\n\n  template<typename _Signature, typename _Functor>\n    class _Function_handler;\n\n  template<typename _Res, typename _Functor, typename... _ArgTypes>\n    class _Function'
[#] parse_declaration, is_constructor=False, meet line: '_Res\n      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)\n      {\n return (*_Base::_M_get_pointer(__functor))(\n     std::forward<_ArgTypes>(__args)...);\n      }\n    };\n\n  template<typena'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)\n      {\n (*_Base::_M_get_pointer(__functor))(\n     std::forward<_ArgTypes>(__args)...);\n      }\n    };\n\n  template<typename _Cla'
[#] parse_declaration, is_constructor=False, meet line: '_Res\n      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)\n      {\n return std::__invoke(_Base::_M_get_pointer(__functor)->__value,\n        std::forward<_ArgTypes>(__args)...);\n      }\n  '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      _M_manager(_Any_data& __dest, const _Any_data& __source,\n   _Manager_operation __op)\n      {\n switch (__op)\n   {\n\n   case __get_type_info:\n     __dest._M_access<const type_info*>() = &typei'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)\n      {\n std::__invoke(_Base::_M_get_pointer(__functor)->__value,\n        std::forward<_ArgTypes>(__args)...);\n      }\n    };\n\n '
[#] parse_declaration, is_constructor=True, meet line: 'function() noexcept\n      : _Function_base() { }\n\n\n\n\n\n      function(nullptr_t) noexcept\n      : _Function_base() { }\n# 432 "/usr/include/c++/7/bits/std_function.h" 3\n      function(const function& __'
[#] parse_declaration, is_constructor=True, meet line: 'function(nullptr_t) noexcept\n      : _Function_base() { }\n# 432 "/usr/include/c++/7/bits/std_function.h" 3\n      function(const function& __x);\n# 441 "/usr/include/c++/7/bits/std_function.h" 3\n      f'
[#] parse_declaration, is_constructor=True, meet line: 'function(const function& __x);\n# 441 "/usr/include/c++/7/bits/std_function.h" 3\n      function(function&& __x) noexcept : _Function_base()\n      {\n __x.swap(*this);\n      }\n# 462 "/usr/include/c++/7/b'
[#] parse_declaration, is_constructor=True, meet line: 'function(function&& __x) noexcept : _Function_base()\n      {\n __x.swap(*this);\n      }\n# 462 "/usr/include/c++/7/bits/std_function.h" 3\n      template<typename _Functor,\n        typename = _Requires<_'
[#] parse_declaration, is_constructor=True, meet line: 'function(_Functor);\n# 479 "/usr/include/c++/7/bits/std_function.h" 3\n      function&\n      operator=(const function& __x)\n      {\n function(__x).swap(*this);\n return *this;\n      }\n# 497 "/usr/include'
[#] parse_declaration, is_constructor=True, meet line: 'function&\n      operator=(const function& __x)\n      {\n function(__x).swap(*this);\n return *this;\n      }\n# 497 "/usr/include/c++/7/bits/std_function.h" 3\n      function&\n      operator=(function&& __'
[#] parse_declaration, is_constructor=True, meet line: 'function&\n      operator=(function&& __x) noexcept\n      {\n function(std::move(__x)).swap(*this);\n return *this;\n      }\n# 511 "/usr/include/c++/7/bits/std_function.h" 3\n      function&\n      operator'
[#] parse_declaration, is_constructor=True, meet line: 'function&\n      operator=(nullptr_t) noexcept\n      {\n if (_M_manager)\n   {\n     _M_manager(_M_functor, _M_functor, __destroy_functor);\n     _M_manager = nullptr;\n     _M_invoker = nullptr;\n   }\n retu'
[#] parse_declaration, is_constructor=False, meet line: '_Requires<_Callable<typename decay<_Functor>::type>, function&>\n operator=(_Functor&& __f)\n {\n   function(std::forward<_Functor>(__f)).swap(*this);\n   return *this;\n }\n\n\n      template<typename _Funct'
[#] parse_declaration, is_constructor=True, meet line: 'function&\n operator=(reference_wrapper<_Functor> __f) noexcept\n {\n   function(__f).swap(*this);\n   return *this;\n }\n# 565 "/usr/include/c++/7/bits/std_function.h" 3\n      void swap(function& __x) noex'
[#] parse_declaration, is_constructor=False, meet line: 'void swap(function& __x) noexcept\n      {\n std::swap(_M_functor, __x._M_functor);\n std::swap(_M_manager, __x._M_manager);\n std::swap(_M_invoker, __x._M_invoker);\n      }\n# 582 "/usr/include/c++/7/bits'
[#] parse_declaration, is_constructor=False, meet line: 'operator bool() const noexcept\n      { return !_M_empty(); }\n# 595 "/usr/include/c++/7/bits/std_function.h" 3\n      _Res operator()(_ArgTypes... __args) const;\n# 608 "/usr/include/c++/7/bits/std_funct'
[#] parse_declaration, is_constructor=False, meet line: '_Res operator()(_ArgTypes... __args) const;\n# 608 "/usr/include/c++/7/bits/std_function.h" 3\n      const type_info& target_type() const noexcept;\n# 621 "/usr/include/c++/7/bits/std_function.h" 3\n     '
[#] parse_declaration, is_constructor=False, meet line: 'type_info& target_type() const noexcept;\n# 621 "/usr/include/c++/7/bits/std_function.h" 3\n      template<typename _Functor> _Functor* target() noexcept;\n\n      template<typename _Functor> const _Funct'
[#] parse_declaration, is_constructor=False, meet line: '_Functor* target() noexcept;\n\n      template<typename _Functor> const _Functor* target() const noexcept;\n\n\n\n    private:\n      using _Invoker_type = _Res (*)(const _Any_data&, _ArgTypes&&...);\n      _'
[#] parse_declaration, is_constructor=False, meet line: '_Functor* target() const noexcept;\n\n\n\n    private:\n      using _Invoker_type = _Res (*)(const _Any_data&, _ArgTypes&&...);\n      _Invoker_type _M_invoker;\n  };\n# 670 "/usr/include/c++/7/bits/std_funct'
[#] parse_declaration, is_constructor=False, meet line: '_Invoker_type _M_invoker;\n  };\n# 670 "/usr/include/c++/7/bits/std_function.h" 3\n  template<typename _Res, typename... _ArgTypes>\n    function<_Res(_ArgTypes...)>::\n    function(const function& __x)\n  '
[#] parse_declaration, is_constructor=False, meet line: 'function<_Res(_ArgTypes...)>::\n    function(const function& __x)\n    : _Function_base()\n    {\n      if (static_cast<bool>(__x))\n {\n   __x._M_manager(_M_functor, __x._M_functor, __clone_functor);\n   _M'
[#] parse_declaration, is_constructor=False, meet line: 'function<_Res(_ArgTypes...)>::\n      function(_Functor __f)\n      : _Function_base()\n      {\n typedef _Function_handler<_Res(_ArgTypes...), _Functor> _My_handler;\n\n if (_My_handler::_M_not_empty_funct'
[#] parse_declaration, is_constructor=False, meet line: '_Res\n    function<_Res(_ArgTypes...)>::\n    operator()(_ArgTypes... __args) const\n    {\n      if (_M_empty())\n __throw_bad_function_call();\n      return _M_invoker(_M_functor, std::forward<_ArgTypes>('
[#] parse_declaration, is_constructor=False, meet line: 'type_info&\n    function<_Res(_ArgTypes...)>::\n    target_type() const noexcept\n    {\n      if (_M_manager)\n {\n   _Any_data __typeinfo_result;\n   _M_manager(__typeinfo_result, _M_functor, __get_type_in'
[#] parse_declaration, is_constructor=False, meet line: '_Functor*\n      function<_Res(_ArgTypes...)>::\n      target() noexcept\n      {\n const function* __const_this = this;\n const _Functor* __func = __const_this->template target<_Functor>();\n return const_'
[#] parse_declaration, is_constructor=False, meet line: '_Functor*\n      function<_Res(_ArgTypes...)>::\n      target() const noexcept\n      {\n if (typeid(_Functor) == target_type() && _M_manager)\n   {\n     _Any_data __ptr;\n     _M_manager(__ptr, _M_functor,'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator==(const function<_Res(_Args...)>& __f, nullptr_t) noexcept\n    { return !static_cast<bool>(__f); }\n\n\n  template<typename _Res, typename... _Args>\n    inline bool\n    operator==(nullp'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator==(nullptr_t, const function<_Res(_Args...)>& __f) noexcept\n    { return !static_cast<bool>(__f); }\n# 780 "/usr/include/c++/7/bits/std_function.h" 3\n  template<typename _Res, typename'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator!=(const function<_Res(_Args...)>& __f, nullptr_t) noexcept\n    { return static_cast<bool>(__f); }\n\n\n  template<typename _Res, typename... _Args>\n    inline bool\n    operator!=(nullpt'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator!=(nullptr_t, const function<_Res(_Args...)>& __f) noexcept\n    { return static_cast<bool>(__f); }\n# 801 "/usr/include/c++/7/bits/std_function.h" 3\n  template<typename _Res, typename.'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    swap(function<_Res(_Args...)>& __x, function<_Res(_Args...)>& __y) noexcept\n    { __x.swap(__y); }\n\n\n}\n# 57 "/usr/include/c++/7/regex" 2 3\n# 1 "/usr/include/c++/7/bits/regex_constants.h" 1 3\n'
[#] parse_declaration, is_constructor=False, meet line: 'syntax_option_type icase =\n    static_cast<syntax_option_type>(1 << _S_icase);\n\n\n\n\n\n\n  constexpr syntax_option_type nosubs =\n    static_cast<syntax_option_type>(1 << _S_nosubs);\n\n\n\n\n\n\n\n  constexpr syn'
[#] parse_declaration, is_constructor=False, meet line: 'syntax_option_type nosubs =\n    static_cast<syntax_option_type>(1 << _S_nosubs);\n\n\n\n\n\n\n\n  constexpr syntax_option_type optimize =\n    static_cast<syntax_option_type>(1 << _S_optimize);\n\n\n\n\n\n  constexp'
[#] parse_declaration, is_constructor=False, meet line: 'syntax_option_type optimize =\n    static_cast<syntax_option_type>(1 << _S_optimize);\n\n\n\n\n\n  constexpr syntax_option_type collate =\n    static_cast<syntax_option_type>(1 << _S_collate);\n# 122 "/usr/inc'
[#] parse_declaration, is_constructor=False, meet line: 'syntax_option_type collate =\n    static_cast<syntax_option_type>(1 << _S_collate);\n# 122 "/usr/include/c++/7/bits/regex_constants.h" 3\n  constexpr syntax_option_type ECMAScript =\n    static_cast<synta'
[#] parse_declaration, is_constructor=False, meet line: 'syntax_option_type ECMAScript =\n    static_cast<syntax_option_type>(1 << _S_ECMAScript);\n# 132 "/usr/include/c++/7/bits/regex_constants.h" 3\n  constexpr syntax_option_type basic =\n    static_cast<synt'
[#] parse_declaration, is_constructor=False, meet line: 'syntax_option_type basic =\n    static_cast<syntax_option_type>(1 << _S_basic);\n\n\n\n\n\n\n\n  constexpr syntax_option_type extended =\n    static_cast<syntax_option_type>(1 << _S_extended);\n# 152 "/usr/inclu'
[#] parse_declaration, is_constructor=False, meet line: 'syntax_option_type extended =\n    static_cast<syntax_option_type>(1 << _S_extended);\n# 152 "/usr/include/c++/7/bits/regex_constants.h" 3\n  constexpr syntax_option_type awk =\n    static_cast<syntax_opt'
[#] parse_declaration, is_constructor=False, meet line: 'syntax_option_type awk =\n    static_cast<syntax_option_type>(1 << _S_awk);\n\n\n\n\n\n\n\n  constexpr syntax_option_type grep =\n    static_cast<syntax_option_type>(1 << _S_grep);\n\n\n\n\n\n\n\n  constexpr syntax_opt'
[#] parse_declaration, is_constructor=False, meet line: 'syntax_option_type grep =\n    static_cast<syntax_option_type>(1 << _S_grep);\n\n\n\n\n\n\n\n  constexpr syntax_option_type egrep =\n    static_cast<syntax_option_type>(1 << _S_egrep);\n\n\n\n\n\n\n\n  constexpr syntax'
[#] parse_declaration, is_constructor=False, meet line: 'syntax_option_type egrep =\n    static_cast<syntax_option_type>(1 << _S_egrep);\n\n\n\n\n\n\n\n  constexpr syntax_option_type __polynomial =\n    static_cast<syntax_option_type>(1 << _S_polynomial);\n\n  constexp'
[#] parse_declaration, is_constructor=False, meet line: 'syntax_option_type __polynomial =\n    static_cast<syntax_option_type>(1 << _S_polynomial);\n\n  constexpr inline syntax_option_type\n  operator&(syntax_option_type __a, syntax_option_type __b)\n  {\n    re'
[#] parse_declaration, is_constructor=False, meet line: 'syntax_option_type\n  operator&(syntax_option_type __a, syntax_option_type __b)\n  {\n    return (syntax_option_type)(static_cast<unsigned int>(__a)\n    & static_cast<unsigned int>(__b));\n  }\n\n  constexp'
[#] parse_declaration, is_constructor=False, meet line: 'syntax_option_type\n  operator|(syntax_option_type __a, syntax_option_type __b)\n  {\n    return (syntax_option_type)(static_cast<unsigned int>(__a)\n    | static_cast<unsigned int>(__b));\n  }\n\n  constexp'
[#] parse_declaration, is_constructor=False, meet line: 'syntax_option_type\n  operator^(syntax_option_type __a, syntax_option_type __b)\n  {\n    return (syntax_option_type)(static_cast<unsigned int>(__a)\n    ^ static_cast<unsigned int>(__b));\n  }\n\n  constexp'
[#] parse_declaration, is_constructor=False, meet line: 'syntax_option_type\n  operator~(syntax_option_type __a)\n  { return (syntax_option_type)(~static_cast<unsigned int>(__a)); }\n\n  inline syntax_option_type&\n  operator&=(syntax_option_type& __a, syntax_op'
[#] parse_declaration, is_constructor=False, meet line: 'syntax_option_type&\n  operator&=(syntax_option_type& __a, syntax_option_type __b)\n  { return __a = __a & __b; }\n\n  inline syntax_option_type&\n  operator|=(syntax_option_type& __a, syntax_option_type _'
[#] parse_declaration, is_constructor=False, meet line: 'syntax_option_type&\n  operator|=(syntax_option_type& __a, syntax_option_type __b)\n  { return __a = __a | __b; }\n\n  inline syntax_option_type&\n  operator^=(syntax_option_type& __a, syntax_option_type _'
[#] parse_declaration, is_constructor=False, meet line: 'syntax_option_type&\n  operator^=(syntax_option_type& __a, syntax_option_type __b)\n  { return __a = __a ^ __b; }\n# 232 "/usr/include/c++/7/bits/regex_constants.h" 3\n  enum __match_flag\n  {\n    _S_not_b'
[#] parse_declaration, is_constructor=False, meet line: 'match_flag_type match_default =\n    static_cast<match_flag_type>(0);\n\n\n\n\n\n\n  constexpr match_flag_type match_not_bol =\n    static_cast<match_flag_type>(1 << _S_not_bol);\n\n\n\n\n\n\n  constexpr match_flag_t'
[#] parse_declaration, is_constructor=False, meet line: 'match_flag_type match_not_bol =\n    static_cast<match_flag_type>(1 << _S_not_bol);\n\n\n\n\n\n\n  constexpr match_flag_type match_not_eol =\n    static_cast<match_flag_type>(1 << _S_not_eol);\n\n\n\n\n\n  constexpr'
[#] parse_declaration, is_constructor=False, meet line: 'match_flag_type match_not_eol =\n    static_cast<match_flag_type>(1 << _S_not_eol);\n\n\n\n\n\n  constexpr match_flag_type match_not_bow =\n    static_cast<match_flag_type>(1 << _S_not_bow);\n\n\n\n\n\n  constexpr '
[#] parse_declaration, is_constructor=False, meet line: 'match_flag_type match_not_bow =\n    static_cast<match_flag_type>(1 << _S_not_bow);\n\n\n\n\n\n  constexpr match_flag_type match_not_eow =\n    static_cast<match_flag_type>(1 << _S_not_eow);\n\n\n\n\n\n  constexpr '
[#] parse_declaration, is_constructor=False, meet line: 'match_flag_type match_not_eow =\n    static_cast<match_flag_type>(1 << _S_not_eow);\n\n\n\n\n\n  constexpr match_flag_type match_any =\n    static_cast<match_flag_type>(1 << _S_any);\n\n\n\n\n  constexpr match_fla'
[#] parse_declaration, is_constructor=False, meet line: 'match_flag_type match_any =\n    static_cast<match_flag_type>(1 << _S_any);\n\n\n\n\n  constexpr match_flag_type match_not_null =\n    static_cast<match_flag_type>(1 << _S_not_null);\n\n\n\n\n  constexpr match_fl'
[#] parse_declaration, is_constructor=False, meet line: 'match_flag_type match_not_null =\n    static_cast<match_flag_type>(1 << _S_not_null);\n\n\n\n\n  constexpr match_flag_type match_continuous =\n    static_cast<match_flag_type>(1 << _S_continuous);\n\n\n\n\n\n\n  co'
[#] parse_declaration, is_constructor=False, meet line: 'match_flag_type match_continuous =\n    static_cast<match_flag_type>(1 << _S_continuous);\n\n\n\n\n\n\n  constexpr match_flag_type match_prev_avail =\n    static_cast<match_flag_type>(1 << _S_prev_avail);\n# 34'
[#] parse_declaration, is_constructor=False, meet line: 'match_flag_type match_prev_avail =\n    static_cast<match_flag_type>(1 << _S_prev_avail);\n# 346 "/usr/include/c++/7/bits/regex_constants.h" 3\n  constexpr match_flag_type format_default =\n    static_cas'
[#] parse_declaration, is_constructor=False, meet line: 'match_flag_type format_default =\n    static_cast<match_flag_type>(0);\n\n\n\n\n\n\n\n  constexpr match_flag_type format_sed =\n    static_cast<match_flag_type>(1 << _S_sed);\n\n\n\n\n\n\n  constexpr match_flag_type f'
[#] parse_declaration, is_constructor=False, meet line: 'match_flag_type format_sed =\n    static_cast<match_flag_type>(1 << _S_sed);\n\n\n\n\n\n\n  constexpr match_flag_type format_no_copy =\n    static_cast<match_flag_type>(1 << _S_no_copy);\n\n\n\n\n\n  constexpr match'
[#] parse_declaration, is_constructor=False, meet line: 'match_flag_type format_no_copy =\n    static_cast<match_flag_type>(1 << _S_no_copy);\n\n\n\n\n\n  constexpr match_flag_type format_first_only =\n    static_cast<match_flag_type>(1 << _S_first_only);\n\n  conste'
[#] parse_declaration, is_constructor=False, meet line: 'match_flag_type format_first_only =\n    static_cast<match_flag_type>(1 << _S_first_only);\n\n  constexpr inline match_flag_type\n  operator&(match_flag_type __a, match_flag_type __b)\n  {\n    return (matc'
[#] parse_declaration, is_constructor=False, meet line: 'match_flag_type\n  operator&(match_flag_type __a, match_flag_type __b)\n  {\n    return (match_flag_type)(static_cast<unsigned int>(__a)\n    & static_cast<unsigned int>(__b));\n  }\n\n  constexpr inline mat'
[#] parse_declaration, is_constructor=False, meet line: 'match_flag_type\n  operator|(match_flag_type __a, match_flag_type __b)\n  {\n    return (match_flag_type)(static_cast<unsigned int>(__a)\n    | static_cast<unsigned int>(__b));\n  }\n\n  constexpr inline mat'
[#] parse_declaration, is_constructor=False, meet line: 'match_flag_type\n  operator^(match_flag_type __a, match_flag_type __b)\n  {\n    return (match_flag_type)(static_cast<unsigned int>(__a)\n    ^ static_cast<unsigned int>(__b));\n  }\n\n  constexpr inline mat'
[#] parse_declaration, is_constructor=False, meet line: 'match_flag_type\n  operator~(match_flag_type __a)\n  { return (match_flag_type)(~static_cast<unsigned int>(__a)); }\n\n  inline match_flag_type&\n  operator&=(match_flag_type& __a, match_flag_type __b)\n  {'
[#] parse_declaration, is_constructor=False, meet line: 'match_flag_type&\n  operator&=(match_flag_type& __a, match_flag_type __b)\n  { return __a = __a & __b; }\n\n  inline match_flag_type&\n  operator|=(match_flag_type& __a, match_flag_type __b)\n  { return __a'
[#] parse_declaration, is_constructor=False, meet line: 'match_flag_type&\n  operator|=(match_flag_type& __a, match_flag_type __b)\n  { return __a = __a | __b; }\n\n  inline match_flag_type&\n  operator^=(match_flag_type& __a, match_flag_type __b)\n  { return __a'
[#] parse_declaration, is_constructor=False, meet line: 'match_flag_type&\n  operator^=(match_flag_type& __a, match_flag_type __b)\n  { return __a = __a ^ __b; }\n\n\n\n\n}\n\n\n}\n# 58 "/usr/include/c++/7/regex" 2 3\n# 1 "/usr/include/c++/7/bits/regex_error.h" 1 3\n# 3'
[#] parse_declaration, is_constructor=False, meet line: 'error_type error_collate(_S_error_collate);\n\n\n  constexpr error_type error_ctype(_S_error_ctype);\n\n\n\n\n\n  constexpr error_type error_escape(_S_error_escape);\n\n\n  constexpr error_type error_backref(_S_e'
[#] parse_declaration, is_constructor=False, meet line: 'error_type error_ctype(_S_error_ctype);\n\n\n\n\n\n  constexpr error_type error_escape(_S_error_escape);\n\n\n  constexpr error_type error_backref(_S_error_backref);\n\n\n  constexpr error_type error_brack(_S_err'
[#] parse_declaration, is_constructor=False, meet line: 'error_type error_escape(_S_error_escape);\n\n\n  constexpr error_type error_backref(_S_error_backref);\n\n\n  constexpr error_type error_brack(_S_error_brack);\n\n\n  constexpr error_type error_paren(_S_error_'
[#] parse_declaration, is_constructor=False, meet line: 'error_type error_backref(_S_error_backref);\n\n\n  constexpr error_type error_brack(_S_error_brack);\n\n\n  constexpr error_type error_paren(_S_error_paren);\n\n\n  constexpr error_type error_brace(_S_error_br'
[#] parse_declaration, is_constructor=False, meet line: 'error_type error_brack(_S_error_brack);\n\n\n  constexpr error_type error_paren(_S_error_paren);\n\n\n  constexpr error_type error_brace(_S_error_brace);\n\n\n  constexpr error_type error_badbrace(_S_error_bad'
[#] parse_declaration, is_constructor=False, meet line: 'error_type error_paren(_S_error_paren);\n\n\n  constexpr error_type error_brace(_S_error_brace);\n\n\n  constexpr error_type error_badbrace(_S_error_badbrace);\n\n\n\n\n\n  constexpr error_type error_range(_S_err'
[#] parse_declaration, is_constructor=False, meet line: 'error_type error_brace(_S_error_brace);\n\n\n  constexpr error_type error_badbrace(_S_error_badbrace);\n\n\n\n\n\n  constexpr error_type error_range(_S_error_range);\n\n\n\n\n\n  constexpr error_type error_space(_S_'
[#] parse_declaration, is_constructor=False, meet line: 'error_type error_badbrace(_S_error_badbrace);\n\n\n\n\n\n  constexpr error_type error_range(_S_error_range);\n\n\n\n\n\n  constexpr error_type error_space(_S_error_space);\n\n\n\n\n  constexpr error_type error_badrepe'
[#] parse_declaration, is_constructor=False, meet line: 'error_type error_range(_S_error_range);\n\n\n\n\n\n  constexpr error_type error_space(_S_error_space);\n\n\n\n\n  constexpr error_type error_badrepeat(_S_error_badrepeat);\n\n\n\n\n\n  constexpr error_type error_compl'
[#] parse_declaration, is_constructor=False, meet line: 'error_type error_space(_S_error_space);\n\n\n\n\n  constexpr error_type error_badrepeat(_S_error_badrepeat);\n\n\n\n\n\n  constexpr error_type error_complexity(_S_error_complexity);\n\n\n\n\n\n  constexpr error_type e'
[#] parse_declaration, is_constructor=False, meet line: 'error_type error_badrepeat(_S_error_badrepeat);\n\n\n\n\n\n  constexpr error_type error_complexity(_S_error_complexity);\n\n\n\n\n\n  constexpr error_type error_stack(_S_error_stack);\n\n\n\n}\n\n\n# 135 "/usr/include/c'
[#] parse_declaration, is_constructor=False, meet line: 'error_type error_complexity(_S_error_complexity);\n\n\n\n\n\n  constexpr error_type error_stack(_S_error_stack);\n\n\n\n}\n\n\n# 135 "/usr/include/c++/7/bits/regex_error.h" 3\n  class regex_error : public std::runt'
[#] parse_declaration, is_constructor=False, meet line: 'error_type error_stack(_S_error_stack);\n\n\n\n}\n\n\n# 135 "/usr/include/c++/7/bits/regex_error.h" 3\n  class regex_error : public std::runtime_error\n  {\n    regex_constants::error_type _M_code;\n\n  public:\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'regex_constants::error_type _M_code;\n\n  public:\n\n\n\n\n\n    explicit\n    regex_error(regex_constants::error_type __ecode);\n\n    virtual ~regex_error() throw();\n\n\n\n\n\n\n    regex_constants::error_type\n    c'
[#] parse_declaration, is_constructor=True, meet line: 'regex_error(regex_constants::error_type __ecode);\n\n    virtual ~regex_error() throw();\n\n\n\n\n\n\n    regex_constants::error_type\n    code() const\n    { return _M_code; }\n\n  private:\n    regex_error(regex_'
[#] parse_declaration, is_constructor=True, meet line: 'regex_error() throw();\n\n\n\n\n\n\n    regex_constants::error_type\n    code() const\n    { return _M_code; }\n\n  private:\n    regex_error(regex_constants::error_type __ecode, const char* __what)\n    : std::ru'
[#] parse_declaration, is_constructor=False, meet line: 'regex_constants::error_type\n    code() const\n    { return _M_code; }\n\n  private:\n    regex_error(regex_constants::error_type __ecode, const char* __what)\n    : std::runtime_error(__what), _M_code(__ec'
[#] parse_declaration, is_constructor=True, meet line: 'regex_error(regex_constants::error_type __ecode, const char* __what)\n    : std::runtime_error(__what), _M_code(__ecode)\n    { }\n\n    friend void __throw_regex_error(regex_constants::error_type, const '
[#] parse_declaration, is_constructor=False, meet line: 'void __throw_regex_error(regex_constants::error_type, const char*);\n  };\n\n\n\n  void\n  __throw_regex_error(regex_constants::error_type __ecode);\n\n  inline void\n  __throw_regex_error(regex_constants::err'
[#] parse_declaration, is_constructor=False, meet line: 'void\n  __throw_regex_error(regex_constants::error_type __ecode);\n\n  inline void\n  __throw_regex_error(regex_constants::error_type __ecode, const char* __what)\n  { (throw (regex_error(__ecode, __what))'
[#] parse_declaration, is_constructor=False, meet line: 'void\n  __throw_regex_error(regex_constants::error_type __ecode, const char* __what)\n  { (throw (regex_error(__ecode, __what))); }\n\n\n}\n# 59 "/usr/include/c++/7/regex" 2 3\n# 1 "/usr/include/c++/7/bits/r'
[#] parse_declaration, is_constructor=False, meet line: '_StateIdT _S_invalid_state_id = -1;\n\n  template<typename _CharT>\n    using _Matcher = std::function<bool (_CharT)>;\n\n\n\n  enum _Opcode : int\n  {\n      _S_opcode_unknown,\n      _S_opcode_alternative,\n  '
[#] parse_declaration, is_constructor=False, meet line: '_Opcode _M_opcode;\n\n  public:\n    _StateIdT _M_next;\n    union\n    {\n      size_t _M_subexpr;\n      size_t _M_backref_index;\n      struct\n      {\n\n\n _StateIdT _M_alt;\n\n\n bool _M_neg;\n      };\n\n      _'
[#] parse_declaration, is_constructor=False, meet line: '_StateIdT _M_next;\n    union\n    {\n      size_t _M_subexpr;\n      size_t _M_backref_index;\n      struct\n      {\n\n\n _StateIdT _M_alt;\n\n\n bool _M_neg;\n      };\n\n      __gnu_cxx::__aligned_membuf<_Matche'
[#] parse_declaration, is_constructor=False, meet line: 'size_t _M_subexpr;\n      size_t _M_backref_index;\n      struct\n      {\n\n\n _StateIdT _M_alt;\n\n\n bool _M_neg;\n      };\n\n      __gnu_cxx::__aligned_membuf<_Matcher<char>> _M_matcher_storage;\n    };\n\n  pr'
[#] parse_declaration, is_constructor=False, meet line: 'size_t _M_backref_index;\n      struct\n      {\n\n\n _StateIdT _M_alt;\n\n\n bool _M_neg;\n      };\n\n      __gnu_cxx::__aligned_membuf<_Matcher<char>> _M_matcher_storage;\n    };\n\n  protected:\n    explicit _St'
[#] parse_declaration, is_constructor=False, meet line: '_StateIdT _M_alt;\n\n\n bool _M_neg;\n      };\n\n      __gnu_cxx::__aligned_membuf<_Matcher<char>> _M_matcher_storage;\n    };\n\n  protected:\n    explicit _State_base(_Opcode __opcode)\n    : _M_opcode(__opco'
[#] parse_declaration, is_constructor=False, meet line: 'bool _M_neg;\n      };\n\n      __gnu_cxx::__aligned_membuf<_Matcher<char>> _M_matcher_storage;\n    };\n\n  protected:\n    explicit _State_base(_Opcode __opcode)\n    : _M_opcode(__opcode), _M_next(_S_inval'
[#] parse_declaration, is_constructor=False, meet line: '__gnu_cxx::__aligned_membuf<_Matcher<char>> _M_matcher_storage;\n    };\n\n  protected:\n    explicit _State_base(_Opcode __opcode)\n    : _M_opcode(__opcode), _M_next(_S_invalid_state_id)\n    { }\n\n  publi'
[#] parse_declaration, is_constructor=True, meet line: '_State_base(_Opcode __opcode)\n    : _M_opcode(__opcode), _M_next(_S_invalid_state_id)\n    { }\n\n  public:\n    bool\n    _M_has_alt()\n    {\n      return _M_opcode == _S_opcode_alternative\n || _M_opcode ='
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    _M_has_alt()\n    {\n      return _M_opcode == _S_opcode_alternative\n || _M_opcode == _S_opcode_repeat\n || _M_opcode == _S_opcode_subexpr_lookahead;\n    }\n# 119 "/usr/include/c++/7/bits/regex_a'
[#] parse_declaration, is_constructor=True, meet line: '_State(_Opcode __opcode) : _State_base(__opcode)\n      {\n if (_M_opcode() == _S_opcode_match)\n   new (this->_M_matcher_storage._M_addr()) _MatcherT();\n      }\n\n      _State(const _State& __rhs) : _Sta'
[#] parse_declaration, is_constructor=True, meet line: '_State(const _State& __rhs) : _State_base(__rhs)\n      {\n if (__rhs._M_opcode() == _S_opcode_match)\n   new (this->_M_matcher_storage._M_addr())\n     _MatcherT(__rhs._M_get_matcher());\n      }\n\n      _'
[#] parse_declaration, is_constructor=True, meet line: '_State(_State&& __rhs) : _State_base(__rhs)\n      {\n if (__rhs._M_opcode() == _S_opcode_match)\n   new (this->_M_matcher_storage._M_addr())\n     _MatcherT(std::move(__rhs._M_get_matcher()));\n      }\n\n '
[#] parse_declaration, is_constructor=True, meet line: '_State&\n      operator=(const _State&) = delete;\n\n      ~_State()\n      {\n if (_M_opcode() == _S_opcode_match)\n   _M_get_matcher().~_MatcherT();\n      }\n\n\n\n      _Opcode\n      _M_opcode() const\n      '
[#] parse_declaration, is_constructor=True, meet line: '_State()\n      {\n if (_M_opcode() == _S_opcode_match)\n   _M_get_matcher().~_MatcherT();\n      }\n\n\n\n      _Opcode\n      _M_opcode() const\n      { return _State_base::_M_opcode; }\n\n      bool\n      _M_m'
[#] parse_declaration, is_constructor=False, meet line: '_Opcode\n      _M_opcode() const\n      { return _State_base::_M_opcode; }\n\n      bool\n      _M_matches(_Char_type __char) const\n      { return _M_get_matcher()(__char); }\n\n      _MatcherT&\n      _M_get'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      _M_matches(_Char_type __char) const\n      { return _M_get_matcher()(__char); }\n\n      _MatcherT&\n      _M_get_matcher()\n      { return *static_cast<_MatcherT*>(this->_M_matcher_storage._M_a'
[#] parse_declaration, is_constructor=False, meet line: '_MatcherT&\n      _M_get_matcher()\n      { return *static_cast<_MatcherT*>(this->_M_matcher_storage._M_addr()); }\n\n      const _MatcherT&\n      _M_get_matcher() const\n      {\n return *static_cast<const'
[#] parse_declaration, is_constructor=False, meet line: '_MatcherT&\n      _M_get_matcher() const\n      {\n return *static_cast<const _MatcherT*>(\n     this->_M_matcher_storage._M_addr());\n      }\n    };\n\n  struct _NFA_base\n  {\n    typedef size_t _SizeT;\n    '
[#] parse_declaration, is_constructor=True, meet line: '_NFA_base(_FlagT __f)\n    : _M_flags(__f), _M_start_state(0), _M_subexpr_count(0),\n    _M_has_backref(false)\n    { }\n\n    _NFA_base(_NFA_base&&) = default;\n\n  protected:\n    ~_NFA_base() = default;\n\n '
[#] parse_declaration, is_constructor=True, meet line: '_NFA_base(_NFA_base&&) = default;\n\n  protected:\n    ~_NFA_base() = default;\n\n  public:\n    _FlagT\n    _M_options() const\n    { return _M_flags; }\n\n    _StateIdT\n    _M_start() const\n    { return _M_st'
[#] parse_declaration, is_constructor=True, meet line: '_NFA_base() = default;\n\n  public:\n    _FlagT\n    _M_options() const\n    { return _M_flags; }\n\n    _StateIdT\n    _M_start() const\n    { return _M_start_state; }\n\n    _SizeT\n    _M_sub_count() const\n   '
[#] parse_declaration, is_constructor=False, meet line: '_FlagT\n    _M_options() const\n    { return _M_flags; }\n\n    _StateIdT\n    _M_start() const\n    { return _M_start_state; }\n\n    _SizeT\n    _M_sub_count() const\n    { return _M_subexpr_count; }\n\n    std'
[#] parse_declaration, is_constructor=False, meet line: '_StateIdT\n    _M_start() const\n    { return _M_start_state; }\n\n    _SizeT\n    _M_sub_count() const\n    { return _M_subexpr_count; }\n\n    std::vector<size_t> _M_paren_stack;\n    _FlagT _M_flags;\n    _S'
[#] parse_declaration, is_constructor=False, meet line: '_SizeT\n    _M_sub_count() const\n    { return _M_subexpr_count; }\n\n    std::vector<size_t> _M_paren_stack;\n    _FlagT _M_flags;\n    _StateIdT _M_start_state;\n    _SizeT _M_subexpr_count;\n    bool _M_ha'
[#] parse_declaration, is_constructor=False, meet line: 'std::vector<size_t> _M_paren_stack;\n    _FlagT _M_flags;\n    _StateIdT _M_start_state;\n    _SizeT _M_subexpr_count;\n    bool _M_has_backref;\n  };\n\n  template<typename _TraitsT>\n    struct _NFA\n    : _'
[#] parse_declaration, is_constructor=False, meet line: '_FlagT _M_flags;\n    _StateIdT _M_start_state;\n    _SizeT _M_subexpr_count;\n    bool _M_has_backref;\n  };\n\n  template<typename _TraitsT>\n    struct _NFA\n    : _NFA_base, std::vector<_State<typename _T'
[#] parse_declaration, is_constructor=False, meet line: '_StateIdT _M_start_state;\n    _SizeT _M_subexpr_count;\n    bool _M_has_backref;\n  };\n\n  template<typename _TraitsT>\n    struct _NFA\n    : _NFA_base, std::vector<_State<typename _TraitsT::char_type>>\n '
[#] parse_declaration, is_constructor=False, meet line: '_SizeT _M_subexpr_count;\n    bool _M_has_backref;\n  };\n\n  template<typename _TraitsT>\n    struct _NFA\n    : _NFA_base, std::vector<_State<typename _TraitsT::char_type>>\n    {\n      typedef typename _T'
[#] parse_declaration, is_constructor=False, meet line: 'bool _M_has_backref;\n  };\n\n  template<typename _TraitsT>\n    struct _NFA\n    : _NFA_base, std::vector<_State<typename _TraitsT::char_type>>\n    {\n      typedef typename _TraitsT::char_type _Char_type;'
[#] parse_declaration, is_constructor=True, meet line: '_NFA(const typename _TraitsT::locale_type& __loc, _FlagT __flags)\n      : _NFA_base(__flags)\n      { _M_traits.imbue(__loc); }\n\n\n      _NFA(const _NFA&) = delete;\n      _NFA(_NFA&&) = default;\n\n      '
[#] parse_declaration, is_constructor=True, meet line: '_NFA(const _NFA&) = delete;\n      _NFA(_NFA&&) = default;\n\n      _StateIdT\n      _M_insert_accept()\n      {\n auto __ret = _M_insert_state(_StateT(_S_opcode_accept));\n return __ret;\n      }\n\n      _Sta'
[#] parse_declaration, is_constructor=True, meet line: '_NFA(_NFA&&) = default;\n\n      _StateIdT\n      _M_insert_accept()\n      {\n auto __ret = _M_insert_state(_StateT(_S_opcode_accept));\n return __ret;\n      }\n\n      _StateIdT\n      _M_insert_alt(_StateId'
[#] parse_declaration, is_constructor=False, meet line: '_StateIdT\n      _M_insert_accept()\n      {\n auto __ret = _M_insert_state(_StateT(_S_opcode_accept));\n return __ret;\n      }\n\n      _StateIdT\n      _M_insert_alt(_StateIdT __next, _StateIdT __alt,\n    '
[#] parse_declaration, is_constructor=False, meet line: '_StateIdT\n      _M_insert_alt(_StateIdT __next, _StateIdT __alt,\n      bool __neg __attribute__((__unused__)))\n      {\n _StateT __tmp(_S_opcode_alternative);\n\n\n __tmp._M_next = __next;\n __tmp._M_alt ='
[#] parse_declaration, is_constructor=False, meet line: '_StateIdT\n      _M_insert_repeat(_StateIdT __next, _StateIdT __alt, bool __neg)\n      {\n _StateT __tmp(_S_opcode_repeat);\n\n\n __tmp._M_next = __next;\n __tmp._M_alt = __alt;\n __tmp._M_neg = __neg;\n retu'
[#] parse_declaration, is_constructor=False, meet line: '_StateIdT\n      _M_insert_matcher(_MatcherT __m)\n      {\n _StateT __tmp(_S_opcode_match);\n __tmp._M_get_matcher() = std::move(__m);\n return _M_insert_state(std::move(__tmp));\n      }\n\n      _StateIdT\n'
[#] parse_declaration, is_constructor=False, meet line: '_StateIdT\n      _M_insert_subexpr_begin()\n      {\n auto __id = this->_M_subexpr_count++;\n this->_M_paren_stack.push_back(__id);\n _StateT __tmp(_S_opcode_subexpr_begin);\n __tmp._M_subexpr = __id;\n retu'
[#] parse_declaration, is_constructor=False, meet line: '_StateIdT\n      _M_insert_subexpr_end()\n      {\n _StateT __tmp(_S_opcode_subexpr_end);\n __tmp._M_subexpr = this->_M_paren_stack.back();\n this->_M_paren_stack.pop_back();\n return _M_insert_state(std::m'
[#] parse_declaration, is_constructor=False, meet line: '_StateIdT\n      _M_insert_backref(size_t __index);\n\n      _StateIdT\n      _M_insert_line_begin()\n      { return _M_insert_state(_StateT(_S_opcode_line_begin_assertion)); }\n\n      _StateIdT\n      _M_in'
[#] parse_declaration, is_constructor=False, meet line: '_StateIdT\n      _M_insert_line_begin()\n      { return _M_insert_state(_StateT(_S_opcode_line_begin_assertion)); }\n\n      _StateIdT\n      _M_insert_line_end()\n      { return _M_insert_state(_StateT(_S_'
[#] parse_declaration, is_constructor=False, meet line: '_StateIdT\n      _M_insert_line_end()\n      { return _M_insert_state(_StateT(_S_opcode_line_end_assertion)); }\n\n      _StateIdT\n      _M_insert_word_bound(bool __neg)\n      {\n _StateT __tmp(_S_opcode_w'
[#] parse_declaration, is_constructor=False, meet line: '_StateIdT\n      _M_insert_word_bound(bool __neg)\n      {\n _StateT __tmp(_S_opcode_word_boundary);\n __tmp._M_neg = __neg;\n return _M_insert_state(std::move(__tmp));\n      }\n\n      _StateIdT\n      _M_in'
[#] parse_declaration, is_constructor=False, meet line: '_StateIdT\n      _M_insert_lookahead(_StateIdT __alt, bool __neg)\n      {\n _StateT __tmp(_S_opcode_subexpr_lookahead);\n __tmp._M_alt = __alt;\n __tmp._M_neg = __neg;\n return _M_insert_state(std::move(__'
[#] parse_declaration, is_constructor=False, meet line: '_StateIdT\n      _M_insert_dummy()\n      { return _M_insert_state(_StateT(_S_opcode_dummy)); }\n\n      _StateIdT\n      _M_insert_state(_StateT __s)\n      {\n this->push_back(std::move(__s));\n if (this->s'
[#] parse_declaration, is_constructor=False, meet line: '_StateIdT\n      _M_insert_state(_StateT __s)\n      {\n this->push_back(std::move(__s));\n if (this->size() > 100000)\n   __throw_regex_error(\n     regex_constants::error_space,\n     "Number of NFA states'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_eliminate_dummy();\n\n\n\n\n\n    public:\n      _TraitsT _M_traits;\n    };\n\n\n\n\n  template<typename _TraitsT>\n    class _StateSeq\n    {\n    public:\n      typedef _NFA<_TraitsT> _RegexT;\n\n    pu'
[#] parse_declaration, is_constructor=False, meet line: '_TraitsT _M_traits;\n    };\n\n\n\n\n  template<typename _TraitsT>\n    class _StateSeq\n    {\n    public:\n      typedef _NFA<_TraitsT> _RegexT;\n\n    public:\n      _StateSeq(_RegexT& __nfa, _StateIdT __s)\n   '
[#] parse_declaration, is_constructor=True, meet line: '_StateSeq(_RegexT& __nfa, _StateIdT __s)\n      : _M_nfa(__nfa), _M_start(__s), _M_end(__s)\n      { }\n\n      _StateSeq(_RegexT& __nfa, _StateIdT __s, _StateIdT __end)\n      : _M_nfa(__nfa), _M_start(__'
[#] parse_declaration, is_constructor=True, meet line: '_StateSeq(_RegexT& __nfa, _StateIdT __s, _StateIdT __end)\n      : _M_nfa(__nfa), _M_start(__s), _M_end(__end)\n      { }\n\n\n      void\n      _M_append(_StateIdT __id)\n      {\n _M_nfa[_M_end]._M_next = _'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_append(_StateIdT __id)\n      {\n _M_nfa[_M_end]._M_next = __id;\n _M_end = __id;\n      }\n\n\n      void\n      _M_append(const _StateSeq& __s)\n      {\n _M_nfa[_M_end]._M_next = __s._M_start;\n'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_append(const _StateSeq& __s)\n      {\n _M_nfa[_M_end]._M_next = __s._M_start;\n _M_end = __s._M_end;\n      }\n\n\n      _StateSeq\n      _M_clone();\n\n    public:\n      _RegexT& _M_nfa;\n      _'
[#] parse_declaration, is_constructor=True, meet line: '_StateSeq\n      _M_clone();\n\n    public:\n      _RegexT& _M_nfa;\n      _StateIdT _M_start;\n      _StateIdT _M_end;\n    };\n\n\n\n}\n}\n\n# 1 "/usr/include/c++/7/bits/regex_automaton.tcc" 1 3\n# 31 "/usr/includ'
[#] parse_declaration, is_constructor=False, meet line: '_RegexT& _M_nfa;\n      _StateIdT _M_start;\n      _StateIdT _M_end;\n    };\n\n\n\n}\n}\n\n# 1 "/usr/include/c++/7/bits/regex_automaton.tcc" 1 3\n# 31 "/usr/include/c++/7/bits/regex_automaton.tcc" 3\nnamespace s'
[#] parse_declaration, is_constructor=False, meet line: '_StateIdT _M_start;\n      _StateIdT _M_end;\n    };\n\n\n\n}\n}\n\n# 1 "/usr/include/c++/7/bits/regex_automaton.tcc" 1 3\n# 31 "/usr/include/c++/7/bits/regex_automaton.tcc" 3\nnamespace std __attribute__ ((__vi'
[#] parse_declaration, is_constructor=False, meet line: '_StateIdT _M_end;\n    };\n\n\n\n}\n}\n\n# 1 "/usr/include/c++/7/bits/regex_automaton.tcc" 1 3\n# 31 "/usr/include/c++/7/bits/regex_automaton.tcc" 3\nnamespace std __attribute__ ((__visibility__ ("default")))\n{'
[#] parse_declaration, is_constructor=False, meet line: '_StateIdT\n    _NFA<_TraitsT>::_M_insert_backref(size_t __index)\n    {\n      if (this->_M_flags & regex_constants::__polynomial)\n __throw_regex_error(regex_constants::error_complexity,\n       "Unexpect'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _NFA<_TraitsT>::_M_eliminate_dummy()\n    {\n      for (auto& __it : *this)\n {\n   while (__it._M_next >= 0 && (*this)[__it._M_next]._M_opcode()\n   == _S_opcode_dummy)\n     __it._M_next = (*this'
[#] parse_declaration, is_constructor=False, meet line: '_StateSeq<_TraitsT>\n    _StateSeq<_TraitsT>::_M_clone()\n    {\n      std::map<_StateIdT, _StateIdT> __m;\n      std::stack<_StateIdT> __stack;\n      __stack.push(_M_start);\n      while (!__stack.empty()'
[#] parse_declaration, is_constructor=True, meet line: '_ScannerBase(_FlagT __flags)\n    : _M_state(_S_state_normal),\n    _M_flags(__flags),\n    _M_escape_tbl(_M_is_ecma()\n    ? _M_ecma_escape_tbl\n    : _M_awk_escape_tbl),\n    _M_spec_char(_M_is_ecma()\n   '
[#] parse_declaration, is_constructor=False, meet line: "char*\n    _M_find_escape(char __c)\n    {\n      auto __it = _M_escape_tbl;\n      for (; __it->first != '\\0'; ++__it)\n if (__it->first == __c)\n   return &__it->second;\n      return nullptr;\n    }\n\n    b"
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    _M_is_ecma() const\n    { return _M_flags & regex_constants::ECMAScript; }\n\n    bool\n    _M_is_basic() const\n    { return _M_flags & (regex_constants::basic | regex_constants::grep); }\n\n    bo'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    _M_is_basic() const\n    { return _M_flags & (regex_constants::basic | regex_constants::grep); }\n\n    bool\n    _M_is_extended() const\n    {\n      return _M_flags & (regex_constants::extended\n '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    _M_is_extended() const\n    {\n      return _M_flags & (regex_constants::extended\n    | regex_constants::egrep\n    | regex_constants::awk);\n    }\n\n    bool\n    _M_is_grep() const\n    { return _'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    _M_is_grep() const\n    { return _M_flags & (regex_constants::grep | regex_constants::egrep); }\n\n    bool\n    _M_is_awk() const\n    { return _M_flags & regex_constants::awk; }\n\n  protected:\n\n '
[#] parse_declaration, is_constructor=False, meet line: "bool\n    _M_is_awk() const\n    { return _M_flags & regex_constants::awk; }\n\n  protected:\n\n    const std::pair<char, _TokenT> _M_token_tbl[9] =\n      {\n {'^', _S_token_line_begin},\n {'$', _S_token_line"
[#] parse_declaration, is_constructor=False, meet line: "std::pair<char, _TokenT> _M_token_tbl[9] =\n      {\n {'^', _S_token_line_begin},\n {'$', _S_token_line_end},\n {'.', _S_token_anychar},\n {'*', _S_token_closure0},\n {'+', _S_token_closure1},\n {'?', _S_tok"
[#] parse_declaration, is_constructor=False, meet line: "std::pair<char, char> _M_ecma_escape_tbl[8] =\n      {\n {'0', '\\0'},\n {'b', '\\b'},\n {'f', '\\f'},\n {'n', '\\n'},\n {'r', '\\r'},\n {'t', '\\t'},\n {'v', '\\v'},\n {'\\0', '\\0'},\n      };\n    const std::pair<char"
[#] parse_declaration, is_constructor=False, meet line: 'std::pair<char, char> _M_awk_escape_tbl[11] =\n      {\n {\'"\', \'"\'},\n {\'/\', \'/\'},\n {\'\\\\\', \'\\\\\'},\n {\'a\', \'\\a\'},\n {\'b\', \'\\b\'},\n {\'f\', \'\\f\'},\n {\'n\', \'\\n\'},\n {\'r\', \'\\r\'},\n {\'t\', \'\\t\'},\n {\'v\', \'\\v\'},\n {\'\\0\','
[#] parse_declaration, is_constructor=False, meet line: 'char* _M_ecma_spec_char = "^$\\\\.*+?()[]{}|";\n    const char* _M_basic_spec_char = ".[\\\\*^$";\n    const char* _M_extended_spec_char = ".[\\\\()*+?{|^$";\n\n    _StateT _M_state;\n    _FlagT _M_flags;\n    _T'
[#] parse_declaration, is_constructor=False, meet line: 'char* _M_basic_spec_char = ".[\\\\*^$";\n    const char* _M_extended_spec_char = ".[\\\\()*+?{|^$";\n\n    _StateT _M_state;\n    _FlagT _M_flags;\n    _TokenT _M_token;\n    const std::pair<char, char>* _M_esc'
[#] parse_declaration, is_constructor=False, meet line: 'char* _M_extended_spec_char = ".[\\\\()*+?{|^$";\n\n    _StateT _M_state;\n    _FlagT _M_flags;\n    _TokenT _M_token;\n    const std::pair<char, char>* _M_escape_tbl;\n    const char* _M_spec_char;\n    bool '
[#] parse_declaration, is_constructor=False, meet line: '_StateT _M_state;\n    _FlagT _M_flags;\n    _TokenT _M_token;\n    const std::pair<char, char>* _M_escape_tbl;\n    const char* _M_spec_char;\n    bool _M_at_bracket_start;\n  };\n# 209 "/usr/include/c++/7/'
[#] parse_declaration, is_constructor=False, meet line: '_FlagT _M_flags;\n    _TokenT _M_token;\n    const std::pair<char, char>* _M_escape_tbl;\n    const char* _M_spec_char;\n    bool _M_at_bracket_start;\n  };\n# 209 "/usr/include/c++/7/bits/regex_scanner.h" '
[#] parse_declaration, is_constructor=False, meet line: '_TokenT _M_token;\n    const std::pair<char, char>* _M_escape_tbl;\n    const char* _M_spec_char;\n    bool _M_at_bracket_start;\n  };\n# 209 "/usr/include/c++/7/bits/regex_scanner.h" 3\n  template<typename'
[#] parse_declaration, is_constructor=False, meet line: 'std::pair<char, char>* _M_escape_tbl;\n    const char* _M_spec_char;\n    bool _M_at_bracket_start;\n  };\n# 209 "/usr/include/c++/7/bits/regex_scanner.h" 3\n  template<typename _CharT>\n    class _Scanner\n'
[#] parse_declaration, is_constructor=False, meet line: 'char* _M_spec_char;\n    bool _M_at_bracket_start;\n  };\n# 209 "/usr/include/c++/7/bits/regex_scanner.h" 3\n  template<typename _CharT>\n    class _Scanner\n    : public _ScannerBase\n    {\n    public:\n    '
[#] parse_declaration, is_constructor=False, meet line: 'bool _M_at_bracket_start;\n  };\n# 209 "/usr/include/c++/7/bits/regex_scanner.h" 3\n  template<typename _CharT>\n    class _Scanner\n    : public _ScannerBase\n    {\n    public:\n      typedef const _CharT* '
[#] parse_declaration, is_constructor=True, meet line: '_Scanner(_IterT __begin, _IterT __end,\n        _FlagT __flags, std::locale __loc);\n\n      void\n      _M_advance();\n\n      _TokenT\n      _M_get_token() const\n      { return _M_token; }\n\n      const _St'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_advance();\n\n      _TokenT\n      _M_get_token() const\n      { return _M_token; }\n\n      const _StringT&\n      _M_get_value() const\n      { return _M_value; }\n\n\n\n\n\n\n    private:\n      void'
[#] parse_declaration, is_constructor=False, meet line: '_TokenT\n      _M_get_token() const\n      { return _M_token; }\n\n      const _StringT&\n      _M_get_value() const\n      { return _M_value; }\n\n\n\n\n\n\n    private:\n      void\n      _M_scan_normal();\n\n      '
[#] parse_declaration, is_constructor=False, meet line: '_StringT&\n      _M_get_value() const\n      { return _M_value; }\n\n\n\n\n\n\n    private:\n      void\n      _M_scan_normal();\n\n      void\n      _M_scan_in_bracket();\n\n      void\n      _M_scan_in_brace();\n\n   '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_scan_normal();\n\n      void\n      _M_scan_in_bracket();\n\n      void\n      _M_scan_in_brace();\n\n      void\n      _M_eat_escape_ecma();\n\n      void\n      _M_eat_escape_posix();\n\n      void\n'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_scan_in_bracket();\n\n      void\n      _M_scan_in_brace();\n\n      void\n      _M_eat_escape_ecma();\n\n      void\n      _M_eat_escape_posix();\n\n      void\n      _M_eat_escape_awk();\n\n      vo'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_scan_in_brace();\n\n      void\n      _M_eat_escape_ecma();\n\n      void\n      _M_eat_escape_posix();\n\n      void\n      _M_eat_escape_awk();\n\n      void\n      _M_eat_class(char);\n\n      _Ite'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_eat_escape_ecma();\n\n      void\n      _M_eat_escape_posix();\n\n      void\n      _M_eat_escape_awk();\n\n      void\n      _M_eat_class(char);\n\n      _IterT _M_current;\n      _IterT _M_end;\n  '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_eat_escape_posix();\n\n      void\n      _M_eat_escape_awk();\n\n      void\n      _M_eat_class(char);\n\n      _IterT _M_current;\n      _IterT _M_end;\n      _CtypeT& _M_ctype;\n      _StringT _M'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_eat_escape_awk();\n\n      void\n      _M_eat_class(char);\n\n      _IterT _M_current;\n      _IterT _M_end;\n      _CtypeT& _M_ctype;\n      _StringT _M_value;\n      void (_Scanner::* _M_eat_es'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_eat_class(char);\n\n      _IterT _M_current;\n      _IterT _M_end;\n      _CtypeT& _M_ctype;\n      _StringT _M_value;\n      void (_Scanner::* _M_eat_escape)();\n    };\n\n\n\n}\n}\n\n# 1 "/usr/inclu'
[#] parse_declaration, is_constructor=False, meet line: '_IterT _M_current;\n      _IterT _M_end;\n      _CtypeT& _M_ctype;\n      _StringT _M_value;\n      void (_Scanner::* _M_eat_escape)();\n    };\n\n\n\n}\n}\n\n# 1 "/usr/include/c++/7/bits/regex_scanner.tcc" 1 3\n#'
[#] parse_declaration, is_constructor=False, meet line: '_IterT _M_end;\n      _CtypeT& _M_ctype;\n      _StringT _M_value;\n      void (_Scanner::* _M_eat_escape)();\n    };\n\n\n\n}\n}\n\n# 1 "/usr/include/c++/7/bits/regex_scanner.tcc" 1 3\n# 49 "/usr/include/c++/7/b'
[#] parse_declaration, is_constructor=False, meet line: '_CtypeT& _M_ctype;\n      _StringT _M_value;\n      void (_Scanner::* _M_eat_escape)();\n    };\n\n\n\n}\n}\n\n# 1 "/usr/include/c++/7/bits/regex_scanner.tcc" 1 3\n# 49 "/usr/include/c++/7/bits/regex_scanner.tcc'
[#] parse_declaration, is_constructor=False, meet line: '_StringT _M_value;\n      void (_Scanner::* _M_eat_escape)();\n    };\n\n\n\n}\n}\n\n# 1 "/usr/include/c++/7/bits/regex_scanner.tcc" 1 3\n# 49 "/usr/include/c++/7/bits/regex_scanner.tcc" 3\nnamespace std __attri'
[#] parse_declaration, is_constructor=False, meet line: 'void (_Scanner::* _M_eat_escape)();\n    };\n\n\n\n}\n}\n\n# 1 "/usr/include/c++/7/bits/regex_scanner.tcc" 1 3\n# 49 "/usr/include/c++/7/bits/regex_scanner.tcc" 3\nnamespace std __attribute__ ((__visibility__ ('
[#] parse_declaration, is_constructor=False, meet line: '_Scanner<_CharT>::\n    _Scanner(typename _Scanner::_IterT __begin,\n      typename _Scanner::_IterT __end,\n      _FlagT __flags, std::locale __loc)\n    : _ScannerBase(__flags),\n      _M_current(__begin'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _Scanner<_CharT>::\n    _M_advance()\n    {\n      if (_M_current == _M_end)\n {\n   _M_token = _S_token_eof;\n   return;\n }\n\n      if (_M_state == _S_state_normal)\n _M_scan_normal();\n      else if'
[#] parse_declaration, is_constructor=False, meet line: "void\n    _Scanner<_CharT>::\n    _M_scan_normal()\n    {\n      auto __c = *_M_current++;\n\n      if (std::strchr(_M_spec_char, _M_ctype.narrow(__c, ' ')) == nullptr)\n {\n   _M_token = _S_token_ord_char;\n "
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _Scanner<_CharT>::\n    _M_scan_in_bracket()\n    {\n      if (_M_current == _M_end)\n __throw_regex_error(\n   regex_constants::error_brack,\n   "Unexpected end of regex when in bracket expression'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _Scanner<_CharT>::\n    _M_scan_in_brace()\n    {\n      if (_M_current == _M_end)\n __throw_regex_error(\n   regex_constants::error_brace,\n   "Unexpected end of regex when in brace expression.");'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _Scanner<_CharT>::\n    _M_eat_escape_ecma()\n    {\n      if (_M_current == _M_end)\n __throw_regex_error(regex_constants::error_escape,\n       "Unexpected end of regex when escaping.");\n\n      '
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _Scanner<_CharT>::\n    _M_eat_escape_posix()\n    {\n      if (_M_current == _M_end)\n __throw_regex_error(regex_constants::error_escape,\n       "Unexpected end of regex when escaping.");\n\n     '
[#] parse_declaration, is_constructor=False, meet line: "void\n    _Scanner<_CharT>::\n    _M_eat_escape_awk()\n    {\n      auto __c = *_M_current++;\n      auto __pos = _M_find_escape(_M_ctype.narrow(__c, '\\0'));\n\n      if (__pos != nullptr)\n {\n   _M_token = _"
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _Scanner<_CharT>::\n    _M_eat_class(char __ch)\n    {\n      for (_M_value.clear(); _M_current != _M_end && *_M_current != __ch;)\n _M_value += *_M_current++;\n      if (_M_current == _M_end\n   |'
[#] parse_declaration, is_constructor=True, meet line: '_Compiler(_IterT __b, _IterT __e,\n  const typename _TraitsT::locale_type& __traits, _FlagT __flags);\n\n      shared_ptr<const _RegexT>\n      _M_get_nfa()\n      { return std::move(_M_nfa); }\n\n    privat'
[#] parse_declaration, is_constructor=False, meet line: 'shared_ptr<const _RegexT>\n      _M_get_nfa()\n      { return std::move(_M_nfa); }\n\n    private:\n      typedef _Scanner<_CharT> _ScannerT;\n      typedef typename _TraitsT::string_type _StringT;\n      ty'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      _M_match_token(_TokenT __token);\n\n      void\n      _M_disjunction();\n\n      void\n      _M_alternative();\n\n      bool\n      _M_term();\n\n      bool\n      _M_assertion();\n\n      bool\n      _M_'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_disjunction();\n\n      void\n      _M_alternative();\n\n      bool\n      _M_term();\n\n      bool\n      _M_assertion();\n\n      bool\n      _M_quantifier();\n\n      bool\n      _M_atom();\n\n      b'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_alternative();\n\n      bool\n      _M_term();\n\n      bool\n      _M_assertion();\n\n      bool\n      _M_quantifier();\n\n      bool\n      _M_atom();\n\n      bool\n      _M_bracket_expression();\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      _M_term();\n\n      bool\n      _M_assertion();\n\n      bool\n      _M_quantifier();\n\n      bool\n      _M_atom();\n\n      bool\n      _M_bracket_expression();\n\n      template<bool __icase, bool __'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      _M_assertion();\n\n      bool\n      _M_quantifier();\n\n      bool\n      _M_atom();\n\n      bool\n      _M_bracket_expression();\n\n      template<bool __icase, bool __collate>\n void\n _M_insert_any'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      _M_quantifier();\n\n      bool\n      _M_atom();\n\n      bool\n      _M_bracket_expression();\n\n      template<bool __icase, bool __collate>\n void\n _M_insert_any_matcher_ecma();\n\n      template<b'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      _M_atom();\n\n      bool\n      _M_bracket_expression();\n\n      template<bool __icase, bool __collate>\n void\n _M_insert_any_matcher_ecma();\n\n      template<bool __icase, bool __collate>\n void\n'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      _M_bracket_expression();\n\n      template<bool __icase, bool __collate>\n void\n _M_insert_any_matcher_ecma();\n\n      template<bool __icase, bool __collate>\n void\n _M_insert_any_matcher_posix('
[#] parse_declaration, is_constructor=False, meet line: 'void\n _M_insert_any_matcher_ecma();\n\n      template<bool __icase, bool __collate>\n void\n _M_insert_any_matcher_posix();\n\n      template<bool __icase, bool __collate>\n void\n _M_insert_char_matcher();\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'void\n _M_insert_any_matcher_posix();\n\n      template<bool __icase, bool __collate>\n void\n _M_insert_char_matcher();\n\n      template<bool __icase, bool __collate>\n void\n _M_insert_character_class_match'
[#] parse_declaration, is_constructor=False, meet line: 'void\n _M_insert_char_matcher();\n\n      template<bool __icase, bool __collate>\n void\n _M_insert_character_class_matcher();\n\n      template<bool __icase, bool __collate>\n void\n _M_insert_bracket_matcher'
[#] parse_declaration, is_constructor=False, meet line: 'void\n _M_insert_character_class_matcher();\n\n      template<bool __icase, bool __collate>\n void\n _M_insert_bracket_matcher(bool __neg);\n\n\n\n      template<bool __icase, bool __collate>\n bool\n _M_express'
[#] parse_declaration, is_constructor=False, meet line: 'void\n _M_insert_bracket_matcher(bool __neg);\n\n\n\n      template<bool __icase, bool __collate>\n bool\n _M_expression_term(pair<bool, _CharT>& __last_char,\n      _BracketMatcher<_TraitsT, __icase, __colla'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n _M_expression_term(pair<bool, _CharT>& __last_char,\n      _BracketMatcher<_TraitsT, __icase, __collate>&\n      __matcher);\n\n      int\n      _M_cur_int_value(int __radix);\n\n      bool\n      _M_tr'
[#] parse_declaration, is_constructor=False, meet line: 'int\n      _M_cur_int_value(int __radix);\n\n      bool\n      _M_try_char();\n\n      _StateSeqT\n      _M_pop()\n      {\n auto ret = _M_stack.top();\n _M_stack.pop();\n return ret;\n      }\n\n      _FlagT _M_fl'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      _M_try_char();\n\n      _StateSeqT\n      _M_pop()\n      {\n auto ret = _M_stack.top();\n _M_stack.pop();\n return ret;\n      }\n\n      _FlagT _M_flags;\n      _ScannerT _M_scanner;\n      shared_pt'
[#] parse_declaration, is_constructor=False, meet line: '_StateSeqT\n      _M_pop()\n      {\n auto ret = _M_stack.top();\n _M_stack.pop();\n return ret;\n      }\n\n      _FlagT _M_flags;\n      _ScannerT _M_scanner;\n      shared_ptr<_RegexT> _M_nfa;\n      _StringT'
[#] parse_declaration, is_constructor=False, meet line: '_FlagT _M_flags;\n      _ScannerT _M_scanner;\n      shared_ptr<_RegexT> _M_nfa;\n      _StringT _M_value;\n      _StackT _M_stack;\n      const _TraitsT& _M_traits;\n      const _CtypeT& _M_ctype;\n    };\n\n'
[#] parse_declaration, is_constructor=False, meet line: '_ScannerT _M_scanner;\n      shared_ptr<_RegexT> _M_nfa;\n      _StringT _M_value;\n      _StackT _M_stack;\n      const _TraitsT& _M_traits;\n      const _CtypeT& _M_ctype;\n    };\n\n  template<typename _Tp'
[#] parse_declaration, is_constructor=False, meet line: 'shared_ptr<_RegexT> _M_nfa;\n      _StringT _M_value;\n      _StackT _M_stack;\n      const _TraitsT& _M_traits;\n      const _CtypeT& _M_ctype;\n    };\n\n  template<typename _Tp>\n    struct __has_contiguou'
[#] parse_declaration, is_constructor=False, meet line: '_StringT _M_value;\n      _StackT _M_stack;\n      const _TraitsT& _M_traits;\n      const _CtypeT& _M_ctype;\n    };\n\n  template<typename _Tp>\n    struct __has_contiguous_iter : std::false_type { };\n\n  t'
[#] parse_declaration, is_constructor=False, meet line: '_StackT _M_stack;\n      const _TraitsT& _M_traits;\n      const _CtypeT& _M_ctype;\n    };\n\n  template<typename _Tp>\n    struct __has_contiguous_iter : std::false_type { };\n\n  template<typename _Ch, typ'
[#] parse_declaration, is_constructor=False, meet line: '_TraitsT& _M_traits;\n      const _CtypeT& _M_ctype;\n    };\n\n  template<typename _Tp>\n    struct __has_contiguous_iter : std::false_type { };\n\n  template<typename _Ch, typename _Tr, typename _Alloc>\n  '
[#] parse_declaration, is_constructor=False, meet line: '_CtypeT& _M_ctype;\n    };\n\n  template<typename _Tp>\n    struct __has_contiguous_iter : std::false_type { };\n\n  template<typename _Ch, typename _Tr, typename _Alloc>\n    struct __has_contiguous_iter<st'
[#] parse_declaration, is_constructor=False, meet line: '__enable_if_contiguous_normal_iter<_FwdIter, _TraitsT>\n    __compile_nfa(_FwdIter __first, _FwdIter __last,\n    const typename _TraitsT::locale_type& __loc,\n    regex_constants::syntax_option_type __f'
[#] parse_declaration, is_constructor=False, meet line: '__disable_if_contiguous_normal_iter<_FwdIter, _TraitsT>\n    __compile_nfa(_FwdIter __first, _FwdIter __last,\n    const typename _TraitsT::locale_type& __loc,\n    regex_constants::syntax_option_type __'
[#] parse_declaration, is_constructor=True, meet line: '_RegexTranslatorBase(const _TraitsT& __traits)\n      : _M_traits(__traits)\n      { }\n\n      _CharT\n      _M_translate(_CharT __ch) const\n      {\n if (__icase)\n   return _M_traits.translate_nocase(__ch'
[#] parse_declaration, is_constructor=False, meet line: '_CharT\n      _M_translate(_CharT __ch) const\n      {\n if (__icase)\n   return _M_traits.translate_nocase(__ch);\n else if (__collate)\n   return _M_traits.translate(__ch);\n else\n   return __ch;\n      }\n\n'
[#] parse_declaration, is_constructor=False, meet line: '_StrTransT\n      _M_transform(_CharT __ch) const\n      {\n _StrTransT __str(1, __ch);\n return _M_traits.transform(__str.begin(), __str.end());\n      }\n\n\n\n\n      bool\n      _M_match_range(const _StrTran'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      _M_match_range(const _StrTransT& __first, const _StrTransT& __last,\n       const _StrTransT& __s) const\n      { return __first <= __s && __s <= __last; }\n\n    protected:\n      bool _M_in_ra'
[#] parse_declaration, is_constructor=False, meet line: 'bool _M_in_range_icase(_CharT __first, _CharT __last, _CharT __ch) const\n      {\n typedef std::ctype<_CharT> __ctype_type;\n const auto& __fctyp = use_facet<__ctype_type>(this->_M_traits.getloc());\n au'
[#] parse_declaration, is_constructor=False, meet line: '_TraitsT& _M_traits;\n    };\n\n  template<typename _TraitsT, bool __icase, bool __collate>\n    class _RegexTranslator\n    : public _RegexTranslatorBase<_TraitsT, __icase, __collate>\n    {\n    public:\n  '
[#] parse_declaration, is_constructor=False, meet line: '_StrTransT\n      _M_transform(_CharT __ch) const\n      { return __ch; }\n\n      bool\n      _M_match_range(_CharT __first, _CharT __last, _CharT __ch) const\n      {\n if (!__icase)\n   return __first <= _'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      _M_match_range(_CharT __first, _CharT __last, _CharT __ch) const\n      {\n if (!__icase)\n   return __first <= __ch && __ch <= __last;\n return this->_M_in_range_icase(__first, __last, __ch);\n'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      _M_match_range(const _StrTransT& __first, const _StrTransT& __last,\n       const _StrTransT& __str) const\n      {\n ;\n ;\n ;\n return this->_M_in_range_icase(__first[0], __last[0], __str[0]);\n'
[#] parse_declaration, is_constructor=True, meet line: '_RegexTranslator(const _TraitsT&)\n      { }\n\n      _CharT\n      _M_translate(_CharT __ch) const\n      { return __ch; }\n\n      _StrTransT\n      _M_transform(_CharT __ch) const\n      { return __ch; }\n\n '
[#] parse_declaration, is_constructor=False, meet line: '_CharT\n      _M_translate(_CharT __ch) const\n      { return __ch; }\n\n      _StrTransT\n      _M_transform(_CharT __ch) const\n      { return __ch; }\n\n      bool\n      _M_match_range(_CharT __first, _Cha'
[#] parse_declaration, is_constructor=False, meet line: '_StrTransT\n      _M_transform(_CharT __ch) const\n      { return __ch; }\n\n      bool\n      _M_match_range(_CharT __first, _CharT __last, _CharT __ch) const\n      { return __first <= __ch && __ch <= __l'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      _M_match_range(_CharT __first, _CharT __last, _CharT __ch) const\n      { return __first <= __ch && __ch <= __last; }\n    };\n\n  template<typename _TraitsT, bool __is_ecma, bool __icase, bool'
[#] parse_declaration, is_constructor=True, meet line: "_AnyMatcher(const _TraitsT& __traits)\n      : _M_translator(__traits)\n      { }\n\n      bool\n      operator()(_CharT __ch) const\n      {\n static auto __nul = _M_translator._M_translate('\\0');\n return _"
[#] parse_declaration, is_constructor=False, meet line: "bool\n      operator()(_CharT __ch) const\n      {\n static auto __nul = _M_translator._M_translate('\\0');\n return _M_translator._M_translate(__ch) != __nul;\n      }\n\n      _TransT _M_translator;\n    };\n"
[#] parse_declaration, is_constructor=False, meet line: '_TransT _M_translator;\n    };\n\n  template<typename _TraitsT, bool __icase, bool __collate>\n    struct _AnyMatcher<_TraitsT, true, __icase, __collate>\n    {\n      typedef _RegexTranslator<_TraitsT, __i'
[#] parse_declaration, is_constructor=True, meet line: '_AnyMatcher(const _TraitsT& __traits)\n      : _M_translator(__traits)\n      { }\n\n      bool\n      operator()(_CharT __ch) const\n      { return _M_apply(__ch, typename is_same<_CharT, char>::type()); }'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      operator()(_CharT __ch) const\n      { return _M_apply(__ch, typename is_same<_CharT, char>::type()); }\n\n      bool\n      _M_apply(_CharT __ch, true_type) const\n      {\n auto __c = _M_transl'
[#] parse_declaration, is_constructor=False, meet line: "bool\n      _M_apply(_CharT __ch, true_type) const\n      {\n auto __c = _M_translator._M_translate(__ch);\n auto __n = _M_translator._M_translate('\\n');\n auto __r = _M_translator._M_translate('\\r');\n ret"
[#] parse_declaration, is_constructor=False, meet line: "bool\n      _M_apply(_CharT __ch, false_type) const\n      {\n auto __c = _M_translator._M_translate(__ch);\n auto __n = _M_translator._M_translate('\\n');\n auto __r = _M_translator._M_translate('\\r');\n au"
[#] parse_declaration, is_constructor=False, meet line: '_TransT _M_translator;\n    };\n\n  template<typename _TraitsT, bool __icase, bool __collate>\n    struct _CharMatcher\n    {\n      typedef _RegexTranslator<_TraitsT, __icase, __collate> _TransT;\n      typ'
[#] parse_declaration, is_constructor=True, meet line: '_CharMatcher(_CharT __ch, const _TraitsT& __traits)\n      : _M_translator(__traits), _M_ch(_M_translator._M_translate(__ch))\n      { }\n\n      bool\n      operator()(_CharT __ch) const\n      { return _M'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      operator()(_CharT __ch) const\n      { return _M_ch == _M_translator._M_translate(__ch); }\n\n      _TransT _M_translator;\n      _CharT _M_ch;\n    };\n\n\n  template<typename _TraitsT, bool __ica'
[#] parse_declaration, is_constructor=False, meet line: '_TransT _M_translator;\n      _CharT _M_ch;\n    };\n\n\n  template<typename _TraitsT, bool __icase, bool __collate>\n    struct _BracketMatcher\n    {\n    public:\n      typedef _RegexTranslator<_TraitsT, __'
[#] parse_declaration, is_constructor=False, meet line: '_CharT _M_ch;\n    };\n\n\n  template<typename _TraitsT, bool __icase, bool __collate>\n    struct _BracketMatcher\n    {\n    public:\n      typedef _RegexTranslator<_TraitsT, __icase, __collate> _TransT;\n  '
[#] parse_declaration, is_constructor=True, meet line: '_BracketMatcher(bool __is_non_matching,\n        const _TraitsT& __traits)\n      : _M_class_set(0), _M_translator(__traits), _M_traits(__traits),\n      _M_is_non_matching(__is_non_matching)\n      { }\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      operator()(_CharT __ch) const\n      {\n ;\n return _M_apply(__ch, _UseCache());\n      }\n\n      void\n      _M_add_char(_CharT __c)\n      {\n _M_char_set.push_back(_M_translator._M_translate(__c'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_add_char(_CharT __c)\n      {\n _M_char_set.push_back(_M_translator._M_translate(__c));\n ;\n      }\n\n      _StringT\n      _M_add_collate_element(const _StringT& __s)\n      {\n auto __st = _M'
[#] parse_declaration, is_constructor=False, meet line: '_StringT\n      _M_add_collate_element(const _StringT& __s)\n      {\n auto __st = _M_traits.lookup_collatename(__s.data(),\n       __s.data() + __s.size());\n if (__st.empty())\n   __throw_regex_error(rege'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_add_equivalence_class(const _StringT& __s)\n      {\n auto __st = _M_traits.lookup_collatename(__s.data(),\n       __s.data() + __s.size());\n if (__st.empty())\n   __throw_regex_error(regex_'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_add_character_class(const _StringT& __s, bool __neg)\n      {\n auto __mask = _M_traits.lookup_classname(__s.data(),\n       __s.data() + __s.size(),\n       __icase);\n if (__mask == 0)\n   _'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_make_range(_CharT __l, _CharT __r)\n      {\n if (__l > __r)\n   __throw_regex_error(regex_constants::error_range,\n         "Invalid range in bracket expression.");\n _M_range_set.push_back('
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_ready()\n      {\n std::sort(_M_char_set.begin(), _M_char_set.end());\n auto __end = std::unique(_M_char_set.begin(), _M_char_set.end());\n _M_char_set.erase(__end, _M_char_set.end());\n _M_m'
[#] parse_declaration, is_constructor=False, meet line: 'size_t\n      _S_cache_size()\n      {\n return 1ul << (sizeof(_CharT) * 8 * int(_UseCache::value));\n      }\n\n      struct _Dummy { };\n      typedef typename std::conditional<_UseCache::value,\n     std::'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      _M_apply(_CharT __ch, false_type) const;\n\n      bool\n      _M_apply(_CharT __ch, true_type) const\n      { return _M_cache[static_cast<_UnsignedCharT>(__ch)]; }\n\n      void\n      _M_make_cac'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      _M_apply(_CharT __ch, true_type) const\n      { return _M_cache[static_cast<_UnsignedCharT>(__ch)]; }\n\n      void\n      _M_make_cache(true_type)\n      {\n for (unsigned __i = 0; __i < _M_cach'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_make_cache(true_type)\n      {\n for (unsigned __i = 0; __i < _M_cache.size(); __i++)\n   _M_cache[__i] = _M_apply(static_cast<_CharT>(__i), false_type());\n      }\n\n      void\n      _M_make'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_make_cache(false_type)\n      { }\n\n    private:\n      std::vector<_CharT> _M_char_set;\n      std::vector<_StringT> _M_equiv_set;\n      std::vector<pair<_StrTransT, _StrTransT>> _M_range_s'
[#] parse_declaration, is_constructor=False, meet line: 'std::vector<_CharT> _M_char_set;\n      std::vector<_StringT> _M_equiv_set;\n      std::vector<pair<_StrTransT, _StrTransT>> _M_range_set;\n      std::vector<_CharClassT> _M_neg_class_set;\n      _CharCla'
[#] parse_declaration, is_constructor=False, meet line: 'std::vector<_StringT> _M_equiv_set;\n      std::vector<pair<_StrTransT, _StrTransT>> _M_range_set;\n      std::vector<_CharClassT> _M_neg_class_set;\n      _CharClassT _M_class_set;\n      _TransT _M_tran'
[#] parse_declaration, is_constructor=False, meet line: 'std::vector<pair<_StrTransT, _StrTransT>> _M_range_set;\n      std::vector<_CharClassT> _M_neg_class_set;\n      _CharClassT _M_class_set;\n      _TransT _M_translator;\n      const _TraitsT& _M_traits;\n '
[#] parse_declaration, is_constructor=False, meet line: 'std::vector<_CharClassT> _M_neg_class_set;\n      _CharClassT _M_class_set;\n      _TransT _M_translator;\n      const _TraitsT& _M_traits;\n      bool _M_is_non_matching;\n      _CacheT _M_cache;\n\n\n\n    }'
[#] parse_declaration, is_constructor=False, meet line: '_CharClassT _M_class_set;\n      _TransT _M_translator;\n      const _TraitsT& _M_traits;\n      bool _M_is_non_matching;\n      _CacheT _M_cache;\n\n\n\n    };\n\n\n\n}\n}\n\n# 1 "/usr/include/c++/7/bits/regex_comp'
[#] parse_declaration, is_constructor=False, meet line: '_TransT _M_translator;\n      const _TraitsT& _M_traits;\n      bool _M_is_non_matching;\n      _CacheT _M_cache;\n\n\n\n    };\n\n\n\n}\n}\n\n# 1 "/usr/include/c++/7/bits/regex_compiler.tcc" 1 3\n# 56 "/usr/include'
[#] parse_declaration, is_constructor=False, meet line: '_TraitsT& _M_traits;\n      bool _M_is_non_matching;\n      _CacheT _M_cache;\n\n\n\n    };\n\n\n\n}\n}\n\n# 1 "/usr/include/c++/7/bits/regex_compiler.tcc" 1 3\n# 56 "/usr/include/c++/7/bits/regex_compiler.tcc" 3\nn'
[#] parse_declaration, is_constructor=False, meet line: 'bool _M_is_non_matching;\n      _CacheT _M_cache;\n\n\n\n    };\n\n\n\n}\n}\n\n# 1 "/usr/include/c++/7/bits/regex_compiler.tcc" 1 3\n# 56 "/usr/include/c++/7/bits/regex_compiler.tcc" 3\nnamespace std __attribute__ '
[#] parse_declaration, is_constructor=False, meet line: '_CacheT _M_cache;\n\n\n\n    };\n\n\n\n}\n}\n\n# 1 "/usr/include/c++/7/bits/regex_compiler.tcc" 1 3\n# 56 "/usr/include/c++/7/bits/regex_compiler.tcc" 3\nnamespace std __attribute__ ((__visibility__ ("default")))\n'
[#] parse_declaration, is_constructor=False, meet line: '_Compiler<_TraitsT>::\n    _Compiler(_IterT __b, _IterT __e,\n       const typename _TraitsT::locale_type& __loc, _FlagT __flags)\n    : _M_flags((__flags\n  & (regex_constants::ECMAScript\n     | regex_co'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _Compiler<_TraitsT>::\n    _M_disjunction()\n    {\n      this->_M_alternative();\n      while (_M_match_token(_ScannerT::_S_token_or))\n {\n   _StateSeqT __alt1 = _M_pop();\n   this->_M_alternative'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _Compiler<_TraitsT>::\n    _M_alternative()\n    {\n      if (this->_M_term())\n {\n   _StateSeqT __re = _M_pop();\n   this->_M_alternative();\n   __re._M_append(_M_pop());\n   _M_stack.push(__re);\n '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    _Compiler<_TraitsT>::\n    _M_term()\n    {\n      if (this->_M_assertion())\n return true;\n      if (this->_M_atom())\n {\n   while (this->_M_quantifier());\n   return true;\n }\n      return false;\n'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    _Compiler<_TraitsT>::\n    _M_assertion()\n    {\n      if (_M_match_token(_ScannerT::_S_token_line_begin))\n _M_stack.push(_StateSeqT(*_M_nfa, _M_nfa->_M_insert_line_begin()));\n      else if (_M'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    _Compiler<_TraitsT>::\n    _M_quantifier()\n    {\n      bool __neg = (_M_flags & regex_constants::ECMAScript);\n      auto __init = [this, &__neg]()\n {\n   if (_M_stack.empty())\n     __throw_rege'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    _Compiler<_TraitsT>::\n    _M_atom()\n    {\n      if (_M_match_token(_ScannerT::_S_token_anychar))\n {\n   if (!(_M_flags & regex_constants::ECMAScript))\n     do if (!(_M_flags & regex_constants:'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    _Compiler<_TraitsT>::\n    _M_bracket_expression()\n    {\n      bool __neg =\n _M_match_token(_ScannerT::_S_token_bracket_neg_begin);\n      if (!(__neg || _M_match_token(_ScannerT::_S_token_brac'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _Compiler<_TraitsT>::\n    _M_insert_any_matcher_ecma()\n    {\n      _M_stack.push(_StateSeqT(*_M_nfa,\n _M_nfa->_M_insert_matcher\n   (_AnyMatcher<_TraitsT, true, __icase, __collate>\n     (_M_tr'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _Compiler<_TraitsT>::\n    _M_insert_any_matcher_posix()\n    {\n      _M_stack.push(_StateSeqT(*_M_nfa,\n _M_nfa->_M_insert_matcher\n   (_AnyMatcher<_TraitsT, false, __icase, __collate>\n     (_M_'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _Compiler<_TraitsT>::\n    _M_insert_char_matcher()\n    {\n      _M_stack.push(_StateSeqT(*_M_nfa,\n _M_nfa->_M_insert_matcher\n   (_CharMatcher<_TraitsT, __icase, __collate>\n     (_M_value[0], _'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _Compiler<_TraitsT>::\n    _M_insert_character_class_matcher()\n    {\n      ;\n      _BracketMatcher<_TraitsT, __icase, __collate> __matcher\n (_M_ctype.is(_CtypeT::upper, _M_value[0]), _M_traits'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    _Compiler<_TraitsT>::\n    _M_insert_bracket_matcher(bool __neg)\n    {\n      _BracketMatcher<_TraitsT, __icase, __collate> __matcher(__neg, _M_traits);\n      pair<bool, _CharT> __last_char;\n  '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    _Compiler<_TraitsT>::\n    _M_expression_term(pair<bool, _CharT>& __last_char,\n         _BracketMatcher<_TraitsT, __icase, __collate>& __matcher)\n    {\n      if (_M_match_token(_ScannerT::_S_t'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    _Compiler<_TraitsT>::\n    _M_try_char()\n    {\n      bool __is_char = false;\n      if (_M_match_token(_ScannerT::_S_token_oct_num))\n {\n   __is_char = true;\n   _M_value.assign(1, _M_cur_int_val'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    _Compiler<_TraitsT>::\n    _M_match_token(_TokenT token)\n    {\n      if (token == _M_scanner._M_get_token())\n {\n   _M_value = _M_scanner._M_get_value();\n   _M_scanner._M_advance();\n   return t'
[#] parse_declaration, is_constructor=False, meet line: 'int\n    _Compiler<_TraitsT>::\n    _M_cur_int_value(int __radix)\n    {\n      long __v = 0;\n      for (typename _StringT::size_type __i = 0;\n    __i < _M_value.length(); ++__i)\n __v =__v * __radix + _M_'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    _BracketMatcher<_TraitsT, __icase, __collate>::\n    _M_apply(_CharT __ch, false_type) const\n    {\n      return [this, __ch]\n      {\n if (std::binary_search(_M_char_set.begin(), _M_char_set.en'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    __regex_algo_impl(_BiIter __s,\n        _BiIter __e,\n        match_results<_BiIter, _Alloc>& __m,\n        const basic_regex<_CharT, _TraitsT>& __re,\n        regex_constants::match_flag_type __'
[#] parse_declaration, is_constructor=False, meet line: '_BaseType _M_base;\n   unsigned char _M_extended;\n   static constexpr unsigned char _S_under = 1 << 0;\n   static constexpr unsigned char _S_valid_mask = 0x1;\n\n   constexpr _RegexMask(_BaseType __base ='
[#] parse_declaration, is_constructor=False, meet line: 'unsigned char _M_extended;\n   static constexpr unsigned char _S_under = 1 << 0;\n   static constexpr unsigned char _S_valid_mask = 0x1;\n\n   constexpr _RegexMask(_BaseType __base = 0,\n          unsigned'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned char _S_under = 1 << 0;\n   static constexpr unsigned char _S_valid_mask = 0x1;\n\n   constexpr _RegexMask(_BaseType __base = 0,\n          unsigned char __extended = 0)\n   : _M_base(__base), _M_'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned char _S_valid_mask = 0x1;\n\n   constexpr _RegexMask(_BaseType __base = 0,\n          unsigned char __extended = 0)\n   : _M_base(__base), _M_extended(__extended)\n   { }\n\n   constexpr _RegexMask\n'
[#] parse_declaration, is_constructor=True, meet line: '_RegexMask(_BaseType __base = 0,\n          unsigned char __extended = 0)\n   : _M_base(__base), _M_extended(__extended)\n   { }\n\n   constexpr _RegexMask\n   operator&(_RegexMask __other) const\n   {\n     '
[#] parse_declaration, is_constructor=True, meet line: '_RegexMask\n   operator&(_RegexMask __other) const\n   {\n     return _RegexMask(_M_base & __other._M_base,\n         _M_extended & __other._M_extended);\n   }\n\n   constexpr _RegexMask\n   operator|(_RegexM'
[#] parse_declaration, is_constructor=True, meet line: '_RegexMask\n   operator|(_RegexMask __other) const\n   {\n     return _RegexMask(_M_base | __other._M_base,\n         _M_extended | __other._M_extended);\n   }\n\n   constexpr _RegexMask\n   operator^(_RegexM'
[#] parse_declaration, is_constructor=True, meet line: '_RegexMask\n   operator^(_RegexMask __other) const\n   {\n     return _RegexMask(_M_base ^ __other._M_base,\n         _M_extended ^ __other._M_extended);\n   }\n\n   constexpr _RegexMask\n   operator~() const'
[#] parse_declaration, is_constructor=True, meet line: '_RegexMask\n   operator~() const\n   { return _RegexMask(~_M_base, ~_M_extended); }\n\n   _RegexMask&\n   operator&=(_RegexMask __other)\n   { return *this = (*this) & __other; }\n\n   _RegexMask&\n   operator'
[#] parse_declaration, is_constructor=True, meet line: '_RegexMask&\n   operator&=(_RegexMask __other)\n   { return *this = (*this) & __other; }\n\n   _RegexMask&\n   operator|=(_RegexMask __other)\n   { return *this = (*this) | __other; }\n\n   _RegexMask&\n   ope'
[#] parse_declaration, is_constructor=True, meet line: '_RegexMask&\n   operator|=(_RegexMask __other)\n   { return *this = (*this) | __other; }\n\n   _RegexMask&\n   operator^=(_RegexMask __other)\n   { return *this = (*this) ^ __other; }\n\n   constexpr bool\n   '
[#] parse_declaration, is_constructor=True, meet line: '_RegexMask&\n   operator^=(_RegexMask __other)\n   { return *this = (*this) ^ __other; }\n\n   constexpr bool\n   operator==(_RegexMask __other) const\n   {\n     return (_M_extended & _S_valid_mask)\n     =='
[#] parse_declaration, is_constructor=False, meet line: 'bool\n   operator==(_RegexMask __other) const\n   {\n     return (_M_extended & _S_valid_mask)\n     == (__other._M_extended & _S_valid_mask)\n       && _M_base == __other._M_base;\n   }\n\n   constexpr bool\n'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n   operator!=(_RegexMask __other) const\n   { return !((*this) == __other); }\n\n };\n    public:\n      typedef _RegexMask char_class_type;\n\n    public:\n\n\n\n      regex_traits() { }\n# 176 "/usr/includ'
[#] parse_declaration, is_constructor=True, meet line: 'regex_traits() { }\n# 176 "/usr/include/c++/7/bits/regex.h" 3\n      static std::size_t\n      length(const char_type* __p)\n      { return string_type::traits_type::length(__p); }\n# 187 "/usr/include/c++'
[#] parse_declaration, is_constructor=False, meet line: 'std::size_t\n      length(const char_type* __p)\n      { return string_type::traits_type::length(__p); }\n# 187 "/usr/include/c++/7/bits/regex.h" 3\n      char_type\n      translate(char_type __c) const\n  '
[#] parse_declaration, is_constructor=False, meet line: 'char_type\n      translate(char_type __c) const\n      { return __c; }\n# 200 "/usr/include/c++/7/bits/regex.h" 3\n      char_type\n      translate_nocase(char_type __c) const\n      {\n typedef std::ctype<c'
[#] parse_declaration, is_constructor=False, meet line: 'char_type\n      translate_nocase(char_type __c) const\n      {\n typedef std::ctype<char_type> __ctype_type;\n const __ctype_type& __fctyp(use_facet<__ctype_type>(_M_locale));\n return __fctyp.tolower(__c'
[#] parse_declaration, is_constructor=False, meet line: 'string_type\n transform(_Fwd_iter __first, _Fwd_iter __last) const\n {\n   typedef std::collate<char_type> __collate_type;\n   const __collate_type& __fclt(use_facet<__collate_type>(_M_locale));\n   string'
[#] parse_declaration, is_constructor=False, meet line: 'string_type\n transform_primary(_Fwd_iter __first, _Fwd_iter __last) const\n {\n\n\n\n\n\n\n   typedef std::ctype<char_type> __ctype_type;\n   const __ctype_type& __fctyp(use_facet<__ctype_type>(_M_locale));\n  '
[#] parse_declaration, is_constructor=False, meet line: 'string_type\n lookup_collatename(_Fwd_iter __first, _Fwd_iter __last) const;\n# 321 "/usr/include/c++/7/bits/regex.h" 3\n      template<typename _Fwd_iter>\n char_class_type\n lookup_classname(_Fwd_iter __'
[#] parse_declaration, is_constructor=False, meet line: 'char_class_type\n lookup_classname(_Fwd_iter __first, _Fwd_iter __last,\n    bool __icase = false) const;\n# 338 "/usr/include/c++/7/bits/regex.h" 3\n      bool\n      isctype(_Ch_type __c, char_class_type'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      isctype(_Ch_type __c, char_class_type __f) const;\n# 351 "/usr/include/c++/7/bits/regex.h" 3\n      int\n      value(_Ch_type __ch, int __radix) const;\n# 365 "/usr/include/c++/7/bits/regex.h" '
[#] parse_declaration, is_constructor=False, meet line: 'int\n      value(_Ch_type __ch, int __radix) const;\n# 365 "/usr/include/c++/7/bits/regex.h" 3\n      locale_type\n      imbue(locale_type __loc)\n      {\n std::swap(_M_locale, __loc);\n return __loc;\n     '
[#] parse_declaration, is_constructor=False, meet line: 'locale_type\n      imbue(locale_type __loc)\n      {\n std::swap(_M_locale, __loc);\n return __loc;\n      }\n\n\n\n\n\n      locale_type\n      getloc() const\n      { return _M_locale; }\n\n    protected:\n      lo'
[#] parse_declaration, is_constructor=False, meet line: 'locale_type\n      getloc() const\n      { return _M_locale; }\n\n    protected:\n      locale_type _M_locale;\n    };\n# 392 "/usr/include/c++/7/bits/regex.h" 3\n  template<typename _Ch_type, typename _Rx_tr'
[#] parse_declaration, is_constructor=False, meet line: 'locale_type _M_locale;\n    };\n# 392 "/usr/include/c++/7/bits/regex.h" 3\n  template<typename _Ch_type, typename _Rx_traits = regex_traits<_Ch_type>>\n    class basic_regex\n    {\n    public:\n      static'
[#] parse_declaration, is_constructor=False, meet line: 'flag_type icase = regex_constants::icase;\n      static constexpr flag_type nosubs = regex_constants::nosubs;\n      static constexpr flag_type optimize = regex_constants::optimize;\n      static constex'
[#] parse_declaration, is_constructor=False, meet line: 'flag_type nosubs = regex_constants::nosubs;\n      static constexpr flag_type optimize = regex_constants::optimize;\n      static constexpr flag_type collate = regex_constants::collate;\n      static con'
[#] parse_declaration, is_constructor=False, meet line: 'flag_type optimize = regex_constants::optimize;\n      static constexpr flag_type collate = regex_constants::collate;\n      static constexpr flag_type ECMAScript = regex_constants::ECMAScript;\n      st'
[#] parse_declaration, is_constructor=False, meet line: 'flag_type collate = regex_constants::collate;\n      static constexpr flag_type ECMAScript = regex_constants::ECMAScript;\n      static constexpr flag_type basic = regex_constants::basic;\n      static c'
[#] parse_declaration, is_constructor=False, meet line: 'flag_type ECMAScript = regex_constants::ECMAScript;\n      static constexpr flag_type basic = regex_constants::basic;\n      static constexpr flag_type extended = regex_constants::extended;\n      static'
[#] parse_declaration, is_constructor=False, meet line: 'flag_type basic = regex_constants::basic;\n      static constexpr flag_type extended = regex_constants::extended;\n      static constexpr flag_type awk = regex_constants::awk;\n      static constexpr fla'
[#] parse_declaration, is_constructor=False, meet line: 'flag_type extended = regex_constants::extended;\n      static constexpr flag_type awk = regex_constants::awk;\n      static constexpr flag_type grep = regex_constants::grep;\n      static constexpr flag_'
[#] parse_declaration, is_constructor=False, meet line: 'flag_type awk = regex_constants::awk;\n      static constexpr flag_type grep = regex_constants::grep;\n      static constexpr flag_type egrep = regex_constants::egrep;\n\n\n\n\n\n\n\n      basic_regex()\n      :'
[#] parse_declaration, is_constructor=False, meet line: 'flag_type grep = regex_constants::grep;\n      static constexpr flag_type egrep = regex_constants::egrep;\n\n\n\n\n\n\n\n      basic_regex()\n      : _M_flags(ECMAScript), _M_loc(), _M_automaton(nullptr)\n      '
[#] parse_declaration, is_constructor=False, meet line: 'flag_type egrep = regex_constants::egrep;\n\n\n\n\n\n\n\n      basic_regex()\n      : _M_flags(ECMAScript), _M_loc(), _M_automaton(nullptr)\n      { }\n# 443 "/usr/include/c++/7/bits/regex.h" 3\n      explicit\n  '
[#] parse_declaration, is_constructor=True, meet line: 'basic_regex()\n      : _M_flags(ECMAScript), _M_loc(), _M_automaton(nullptr)\n      { }\n# 443 "/usr/include/c++/7/bits/regex.h" 3\n      explicit\n      basic_regex(const _Ch_type* __p, flag_type __f = EC'
[#] parse_declaration, is_constructor=True, meet line: 'basic_regex(const _Ch_type* __p, flag_type __f = ECMAScript)\n      : basic_regex(__p, __p + char_traits<_Ch_type>::length(__p), __f)\n      { }\n# 460 "/usr/include/c++/7/bits/regex.h" 3\n      basic_reg'
[#] parse_declaration, is_constructor=True, meet line: 'basic_regex(const _Ch_type* __p, std::size_t __len,\n    flag_type __f = ECMAScript)\n      : basic_regex(__p, __p + __len, __f)\n      { }\n\n\n\n\n\n\n      basic_regex(const basic_regex& __rhs) = default;\n\n\n'
[#] parse_declaration, is_constructor=True, meet line: 'basic_regex(const basic_regex& __rhs) = default;\n\n\n\n\n\n\n      basic_regex(basic_regex&& __rhs) noexcept = default;\n# 488 "/usr/include/c++/7/bits/regex.h" 3\n      template<typename _Ch_traits, typename'
[#] parse_declaration, is_constructor=True, meet line: 'basic_regex(basic_regex&& __rhs) noexcept = default;\n# 488 "/usr/include/c++/7/bits/regex.h" 3\n      template<typename _Ch_traits, typename _Ch_alloc>\n explicit\n basic_regex(const std::basic_string<_C'
[#] parse_declaration, is_constructor=True, meet line: 'basic_regex(const std::basic_string<_Ch_type, _Ch_traits,\n         _Ch_alloc>& __s,\n      flag_type __f = ECMAScript)\n : basic_regex(__s.data(), __s.data() + __s.size(), __f)\n { }\n# 509 "/usr/include/'
[#] parse_declaration, is_constructor=True, meet line: 'basic_regex(_FwdIter __first, _FwdIter __last,\n      flag_type __f = ECMAScript)\n : basic_regex(std::move(__first), std::move(__last), locale_type(), __f)\n { }\n# 523 "/usr/include/c++/7/bits/regex.h" '
[#] parse_declaration, is_constructor=True, meet line: 'basic_regex(initializer_list<_Ch_type> __l, flag_type __f = ECMAScript)\n      : basic_regex(__l.begin(), __l.end(), __f)\n      { }\n\n\n\n\n      ~basic_regex()\n      { }\n\n\n\n\n      basic_regex&\n      opera'
[#] parse_declaration, is_constructor=True, meet line: 'basic_regex()\n      { }\n\n\n\n\n      basic_regex&\n      operator=(const basic_regex& __rhs)\n      { return this->assign(__rhs); }\n\n\n\n\n      basic_regex&\n      operator=(basic_regex&& __rhs) noexcept\n    '
[#] parse_declaration, is_constructor=True, meet line: 'basic_regex&\n      operator=(const basic_regex& __rhs)\n      { return this->assign(__rhs); }\n\n\n\n\n      basic_regex&\n      operator=(basic_regex&& __rhs) noexcept\n      { return this->assign(std::move('
[#] parse_declaration, is_constructor=True, meet line: 'basic_regex&\n      operator=(basic_regex&& __rhs) noexcept\n      { return this->assign(std::move(__rhs)); }\n# 554 "/usr/include/c++/7/bits/regex.h" 3\n      basic_regex&\n      operator=(const _Ch_type*'
[#] parse_declaration, is_constructor=True, meet line: 'basic_regex&\n      operator=(const _Ch_type* __p)\n      { return this->assign(__p); }\n# 566 "/usr/include/c++/7/bits/regex.h" 3\n      basic_regex&\n      operator=(initializer_list<_Ch_type> __l)\n     '
[#] parse_declaration, is_constructor=True, meet line: 'basic_regex&\n      operator=(initializer_list<_Ch_type> __l)\n      { return this->assign(__l.begin(), __l.end()); }\n\n\n\n\n\n\n\n      template<typename _Ch_traits, typename _Alloc>\n basic_regex&\n operator='
[#] parse_declaration, is_constructor=True, meet line: 'basic_regex&\n operator=(const basic_string<_Ch_type, _Ch_traits, _Alloc>& __s)\n { return this->assign(__s); }\n\n\n\n\n\n\n\n      basic_regex&\n      assign(const basic_regex& __rhs)\n      {\n basic_regex __tm'
[#] parse_declaration, is_constructor=True, meet line: 'basic_regex&\n      assign(const basic_regex& __rhs)\n      {\n basic_regex __tmp(__rhs);\n this->swap(__tmp);\n return *this;\n      }\n\n\n\n\n\n\n      basic_regex&\n      assign(basic_regex&& __rhs) noexcept\n  '
[#] parse_declaration, is_constructor=True, meet line: 'basic_regex&\n      assign(basic_regex&& __rhs) noexcept\n      {\n basic_regex __tmp(std::move(__rhs));\n this->swap(__tmp);\n return *this;\n      }\n# 621 "/usr/include/c++/7/bits/regex.h" 3\n      basic_r'
[#] parse_declaration, is_constructor=True, meet line: 'basic_regex&\n      assign(const _Ch_type* __p, flag_type __flags = ECMAScript)\n      { return this->assign(string_type(__p), __flags); }\n# 638 "/usr/include/c++/7/bits/regex.h" 3\n      basic_regex&\n  '
[#] parse_declaration, is_constructor=True, meet line: 'basic_regex&\n      assign(const _Ch_type* __p, std::size_t __len, flag_type __flags)\n      { return this->assign(string_type(__p, __len), __flags); }\n# 653 "/usr/include/c++/7/bits/regex.h" 3\n      te'
[#] parse_declaration, is_constructor=True, meet line: 'basic_regex&\n assign(const basic_string<_Ch_type, _Ch_traits, _Alloc>& __s,\n        flag_type __flags = ECMAScript)\n {\n   return this->assign(basic_regex(__s.data(), __s.data() + __s.size(),\n       _M'
[#] parse_declaration, is_constructor=True, meet line: 'basic_regex&\n assign(_InputIterator __first, _InputIterator __last,\n        flag_type __flags = ECMAScript)\n { return this->assign(string_type(__first, __last), __flags); }\n# 692 "/usr/include/c++/7/b'
[#] parse_declaration, is_constructor=True, meet line: 'basic_regex&\n      assign(initializer_list<_Ch_type> __l, flag_type __flags = ECMAScript)\n      { return this->assign(__l.begin(), __l.end(), __flags); }\n\n\n\n\n\n\n      unsigned int\n      mark_count() co'
[#] parse_declaration, is_constructor=False, meet line: 'unsigned int\n      mark_count() const\n      {\n if (_M_automaton)\n   return _M_automaton->_M_sub_count() - 1;\n return 0;\n      }\n\n\n\n\n\n      flag_type\n      flags() const\n      { return _M_flags; }\n\n\n\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'flag_type\n      flags() const\n      { return _M_flags; }\n\n\n\n\n\n\n\n      locale_type\n      imbue(locale_type __loc)\n      {\n std::swap(__loc, _M_loc);\n _M_automaton.reset();\n return __loc;\n      }\n\n\n\n\n\n '
[#] parse_declaration, is_constructor=False, meet line: 'locale_type\n      imbue(locale_type __loc)\n      {\n std::swap(__loc, _M_loc);\n _M_automaton.reset();\n return __loc;\n      }\n\n\n\n\n\n      locale_type\n      getloc() const\n      { return _M_loc; }\n\n\n\n\n\n\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'locale_type\n      getloc() const\n      { return _M_loc; }\n\n\n\n\n\n\n\n      void\n      swap(basic_regex& __rhs)\n      {\n std::swap(_M_flags, __rhs._M_flags);\n std::swap(_M_loc, __rhs._M_loc);\n std::swap(_M'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      swap(basic_regex& __rhs)\n      {\n std::swap(_M_flags, __rhs._M_flags);\n std::swap(_M_loc, __rhs._M_loc);\n std::swap(_M_automaton, __rhs._M_automaton);\n      }\n\n\n\n\n\n\n\n    private:\n      type'
[#] parse_declaration, is_constructor=True, meet line: 'basic_regex(_FwdIter __first, _FwdIter __last, locale_type __loc,\n      flag_type __f)\n : _M_flags(__f), _M_loc(std::move(__loc)),\n _M_automaton(__detail::__compile_nfa<_FwdIter, _Rx_traits>(\n   std::'
[#] parse_declaration, is_constructor=False, meet line: 'bool __detail::\n\n\n\n __regex_algo_impl(_Bp, _Bp, match_results<_Bp, _Ap>&,\n                          const basic_regex<_Cp, _Rp>&,\n                          regex_constants::match_flag_type);\n\n      te'
[#] parse_declaration, is_constructor=False, meet line: 'flag_type _M_flags;\n      locale_type _M_loc;\n      _AutomatonPtr _M_automaton;\n    };\n\n\n  template<typename _Ch, typename _Tr>\n    constexpr regex_constants::syntax_option_type\n    basic_regex<_Ch, _'
[#] parse_declaration, is_constructor=False, meet line: 'locale_type _M_loc;\n      _AutomatonPtr _M_automaton;\n    };\n\n\n  template<typename _Ch, typename _Tr>\n    constexpr regex_constants::syntax_option_type\n    basic_regex<_Ch, _Tr>::icase;\n\n  template<ty'
[#] parse_declaration, is_constructor=False, meet line: '_AutomatonPtr _M_automaton;\n    };\n\n\n  template<typename _Ch, typename _Tr>\n    constexpr regex_constants::syntax_option_type\n    basic_regex<_Ch, _Tr>::icase;\n\n  template<typename _Ch, typename _Tr>\n'
[#] parse_declaration, is_constructor=False, meet line: 'regex_constants::syntax_option_type\n    basic_regex<_Ch, _Tr>::icase;\n\n  template<typename _Ch, typename _Tr>\n    constexpr regex_constants::syntax_option_type\n    basic_regex<_Ch, _Tr>::nosubs;\n\n  te'
[#] parse_declaration, is_constructor=False, meet line: 'regex_constants::syntax_option_type\n    basic_regex<_Ch, _Tr>::nosubs;\n\n  template<typename _Ch, typename _Tr>\n    constexpr regex_constants::syntax_option_type\n    basic_regex<_Ch, _Tr>::optimize;\n\n '
[#] parse_declaration, is_constructor=False, meet line: 'regex_constants::syntax_option_type\n    basic_regex<_Ch, _Tr>::optimize;\n\n  template<typename _Ch, typename _Tr>\n    constexpr regex_constants::syntax_option_type\n    basic_regex<_Ch, _Tr>::collate;\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'regex_constants::syntax_option_type\n    basic_regex<_Ch, _Tr>::collate;\n\n  template<typename _Ch, typename _Tr>\n    constexpr regex_constants::syntax_option_type\n    basic_regex<_Ch, _Tr>::ECMAScript;'
[#] parse_declaration, is_constructor=False, meet line: 'regex_constants::syntax_option_type\n    basic_regex<_Ch, _Tr>::ECMAScript;\n\n  template<typename _Ch, typename _Tr>\n    constexpr regex_constants::syntax_option_type\n    basic_regex<_Ch, _Tr>::basic;\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'regex_constants::syntax_option_type\n    basic_regex<_Ch, _Tr>::basic;\n\n  template<typename _Ch, typename _Tr>\n    constexpr regex_constants::syntax_option_type\n    basic_regex<_Ch, _Tr>::extended;\n\n  '
[#] parse_declaration, is_constructor=False, meet line: 'regex_constants::syntax_option_type\n    basic_regex<_Ch, _Tr>::extended;\n\n  template<typename _Ch, typename _Tr>\n    constexpr regex_constants::syntax_option_type\n    basic_regex<_Ch, _Tr>::awk;\n\n  te'
[#] parse_declaration, is_constructor=False, meet line: 'regex_constants::syntax_option_type\n    basic_regex<_Ch, _Tr>::awk;\n\n  template<typename _Ch, typename _Tr>\n    constexpr regex_constants::syntax_option_type\n    basic_regex<_Ch, _Tr>::grep;\n\n  templa'
[#] parse_declaration, is_constructor=False, meet line: 'regex_constants::syntax_option_type\n    basic_regex<_Ch, _Tr>::grep;\n\n  template<typename _Ch, typename _Tr>\n    constexpr regex_constants::syntax_option_type\n    basic_regex<_Ch, _Tr>::egrep;\n\n\n\n  ty'
[#] parse_declaration, is_constructor=False, meet line: 'regex_constants::syntax_option_type\n    basic_regex<_Ch, _Tr>::egrep;\n\n\n\n  typedef basic_regex<char> regex;\n\n\n\n  typedef basic_regex<wchar_t> wregex;\n# 845 "/usr/include/c++/7/bits/regex.h" 3\n  templa'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    swap(basic_regex<_Ch_type, _Rx_traits>& __lhs,\n  basic_regex<_Ch_type, _Rx_traits>& __rhs)\n    { __lhs.swap(__rhs); }\n# 865 "/usr/include/c++/7/bits/regex.h" 3\n  template<typename _BiIter>\n  '
[#] parse_declaration, is_constructor=False, meet line: 'bool matched;\n\n      constexpr sub_match() : matched() { }\n\n\n\n\n      difference_type\n      length() const\n      { return this->matched ? std::distance(this->first, this->second) : 0; }\n# 897 "/usr/inc'
[#] parse_declaration, is_constructor=True, meet line: 'sub_match() : matched() { }\n\n\n\n\n      difference_type\n      length() const\n      { return this->matched ? std::distance(this->first, this->second) : 0; }\n# 897 "/usr/include/c++/7/bits/regex.h" 3\n    '
[#] parse_declaration, is_constructor=False, meet line: 'difference_type\n      length() const\n      { return this->matched ? std::distance(this->first, this->second) : 0; }\n# 897 "/usr/include/c++/7/bits/regex.h" 3\n      operator string_type() const\n      {'
[#] parse_declaration, is_constructor=False, meet line: 'operator string_type() const\n      {\n return this->matched\n   ? string_type(this->first, this->second)\n   : string_type();\n      }\n\n\n\n\n\n\n      string_type\n      str() const\n      {\n return this->match'
[#] parse_declaration, is_constructor=False, meet line: 'string_type\n      str() const\n      {\n return this->matched\n   ? string_type(this->first, this->second)\n   : string_type();\n      }\n# 926 "/usr/include/c++/7/bits/regex.h" 3\n      int\n      compare(co'
[#] parse_declaration, is_constructor=False, meet line: 'int\n      compare(const sub_match& __s) const\n      { return this->str().compare(__s.str()); }\n# 939 "/usr/include/c++/7/bits/regex.h" 3\n      int\n      compare(const string_type& __s) const\n      { r'
[#] parse_declaration, is_constructor=False, meet line: 'int\n      compare(const string_type& __s) const\n      { return this->str().compare(__s); }\n# 952 "/usr/include/c++/7/bits/regex.h" 3\n      int\n      compare(const value_type* __s) const\n      { return'
[#] parse_declaration, is_constructor=False, meet line: 'int\n      compare(const value_type* __s) const\n      { return this->str().compare(__s); }\n    };\n\n\n\n  typedef sub_match<const char*> csub_match;\n\n\n  typedef sub_match<string::const_iterator> ssub_matc'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>& __rhs)\n    { return __lhs.compare(__rhs) == 0; }\n\n\n\n\n\n\n\n  template<typename _BiIter>\n    inline bool\n    operator!=(const'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator!=(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>& __rhs)\n    { return __lhs.compare(__rhs) != 0; }\n\n\n\n\n\n\n\n  template<typename _BiIter>\n    inline bool\n    operator<(const '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>& __rhs)\n    { return __lhs.compare(__rhs) < 0; }\n\n\n\n\n\n\n\n  template<typename _BiIter>\n    inline bool\n    operator<=(const s'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<=(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>& __rhs)\n    { return __lhs.compare(__rhs) <= 0; }\n\n\n\n\n\n\n\n  template<typename _BiIter>\n    inline bool\n    operator>=(const'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>=(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>& __rhs)\n    { return __lhs.compare(__rhs) >= 0; }\n\n\n\n\n\n\n\n  template<typename _BiIter>\n    inline bool\n    operator>(const '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>& __rhs)\n    { return __lhs.compare(__rhs) > 0; }\n\n\n  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>\n '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator==(const __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n        const sub_match<_Bi_iter>& __rhs)\n    {\n      typedef typename sub_match<_Bi_iter>::string_type string_typ'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator!=(const __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n        const sub_match<_Bi_iter>& __rhs)\n    { return !(__lhs == __rhs); }\n\n\n\n\n\n\n\n  template<typename _Bi_iter, t'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<(const __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n       const sub_match<_Bi_iter>& __rhs)\n    {\n      typedef typename sub_match<_Bi_iter>::string_type string_type;'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>(const __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n       const sub_match<_Bi_iter>& __rhs)\n    { return __rhs < __lhs; }\n\n\n\n\n\n\n\n  template<typename _Bi_iter, typenam'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>=(const __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n        const sub_match<_Bi_iter>& __rhs)\n    { return !(__lhs < __rhs); }\n\n\n\n\n\n\n\n  template<typename _Bi_iter, ty'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<=(const __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n        const sub_match<_Bi_iter>& __rhs)\n    { return !(__rhs < __lhs); }\n# 1133 "/usr/include/c++/7/bits/regex.h'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator==(const sub_match<_Bi_iter>& __lhs,\n        const __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __rhs)\n    {\n      typedef typename sub_match<_Bi_iter>::string_type string_typ'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator!=(const sub_match<_Bi_iter>& __lhs,\n        const __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __rhs)\n    { return !(__lhs == __rhs); }\n\n\n\n\n\n\n\n  template<typename _Bi_iter, c'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<(const sub_match<_Bi_iter>& __lhs,\n       const __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __rhs)\n    {\n      typedef typename sub_match<_Bi_iter>::string_type string_type;'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>(const sub_match<_Bi_iter>& __lhs,\n       const __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __rhs)\n    { return __rhs < __lhs; }\n\n\n\n\n\n\n\n  template<typename _Bi_iter, class _'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>=(const sub_match<_Bi_iter>& __lhs,\n        const __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __rhs)\n    { return !(__lhs < __rhs); }\n\n\n\n\n\n\n\n  template<typename _Bi_iter, cl'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<=(const sub_match<_Bi_iter>& __lhs,\n        const __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __rhs)\n    { return !(__rhs < __lhs); }\n# 1213 "/usr/include/c++/7/bits/regex.h'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator==(typename iterator_traits<_Bi_iter>::value_type const* __lhs,\n        const sub_match<_Bi_iter>& __rhs)\n    { return __rhs.compare(__lhs) == 0; }\n# 1226 "/usr/include/c++/7/bits/reg'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator!=(typename iterator_traits<_Bi_iter>::value_type const* __lhs,\n        const sub_match<_Bi_iter>& __rhs)\n    { return !(__lhs == __rhs); }\n\n\n\n\n\n\n\n  template<typename _Bi_iter>\n    in'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<(typename iterator_traits<_Bi_iter>::value_type const* __lhs,\n       const sub_match<_Bi_iter>& __rhs)\n    { return __rhs.compare(__lhs) > 0; }\n\n\n\n\n\n\n\n  template<typename _Bi_iter>\n '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>(typename iterator_traits<_Bi_iter>::value_type const* __lhs,\n       const sub_match<_Bi_iter>& __rhs)\n    { return __rhs < __lhs; }\n\n\n\n\n\n\n\n  template<typename _Bi_iter>\n    inline b'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>=(typename iterator_traits<_Bi_iter>::value_type const* __lhs,\n        const sub_match<_Bi_iter>& __rhs)\n    { return !(__lhs < __rhs); }\n\n\n\n\n\n\n\n  template<typename _Bi_iter>\n    inl'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<=(typename iterator_traits<_Bi_iter>::value_type const* __lhs,\n        const sub_match<_Bi_iter>& __rhs)\n    { return !(__rhs < __lhs); }\n# 1287 "/usr/include/c++/7/bits/regex.h" 3\n '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator==(const sub_match<_Bi_iter>& __lhs,\n        typename iterator_traits<_Bi_iter>::value_type const* __rhs)\n    { return __lhs.compare(__rhs) == 0; }\n# 1300 "/usr/include/c++/7/bits/reg'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator!=(const sub_match<_Bi_iter>& __lhs,\n        typename iterator_traits<_Bi_iter>::value_type const* __rhs)\n    { return !(__lhs == __rhs); }\n\n\n\n\n\n\n\n  template<typename _Bi_iter>\n    in'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<(const sub_match<_Bi_iter>& __lhs,\n       typename iterator_traits<_Bi_iter>::value_type const* __rhs)\n    { return __lhs.compare(__rhs) < 0; }\n\n\n\n\n\n\n\n  template<typename _Bi_iter>\n '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>(const sub_match<_Bi_iter>& __lhs,\n       typename iterator_traits<_Bi_iter>::value_type const* __rhs)\n    { return __rhs < __lhs; }\n\n\n\n\n\n\n\n  template<typename _Bi_iter>\n    inline b'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>=(const sub_match<_Bi_iter>& __lhs,\n        typename iterator_traits<_Bi_iter>::value_type const* __rhs)\n    { return !(__lhs < __rhs); }\n\n\n\n\n\n\n\n  template<typename _Bi_iter>\n    inl'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<=(const sub_match<_Bi_iter>& __lhs,\n        typename iterator_traits<_Bi_iter>::value_type const* __rhs)\n    { return !(__rhs < __lhs); }\n# 1361 "/usr/include/c++/7/bits/regex.h" 3\n '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator==(typename iterator_traits<_Bi_iter>::value_type const& __lhs,\n        const sub_match<_Bi_iter>& __rhs)\n    {\n      typedef typename sub_match<_Bi_iter>::string_type string_type;\n  '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator!=(typename iterator_traits<_Bi_iter>::value_type const& __lhs,\n        const sub_match<_Bi_iter>& __rhs)\n    { return !(__lhs == __rhs); }\n\n\n\n\n\n\n\n  template<typename _Bi_iter>\n    in'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<(typename iterator_traits<_Bi_iter>::value_type const& __lhs,\n       const sub_match<_Bi_iter>& __rhs)\n    {\n      typedef typename sub_match<_Bi_iter>::string_type string_type;\n    '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>(typename iterator_traits<_Bi_iter>::value_type const& __lhs,\n       const sub_match<_Bi_iter>& __rhs)\n    { return __rhs < __lhs; }\n\n\n\n\n\n\n\n  template<typename _Bi_iter>\n    inline b'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>=(typename iterator_traits<_Bi_iter>::value_type const& __lhs,\n        const sub_match<_Bi_iter>& __rhs)\n    { return !(__lhs < __rhs); }\n\n\n\n\n\n\n\n  template<typename _Bi_iter>\n    inl'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<=(typename iterator_traits<_Bi_iter>::value_type const& __lhs,\n        const sub_match<_Bi_iter>& __rhs)\n    { return !(__rhs < __lhs); }\n# 1441 "/usr/include/c++/7/bits/regex.h" 3\n '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator==(const sub_match<_Bi_iter>& __lhs,\n        typename iterator_traits<_Bi_iter>::value_type const& __rhs)\n    {\n      typedef typename sub_match<_Bi_iter>::string_type string_type;\n  '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator!=(const sub_match<_Bi_iter>& __lhs,\n        typename iterator_traits<_Bi_iter>::value_type const& __rhs)\n    { return !(__lhs == __rhs); }\n\n\n\n\n\n\n\n  template<typename _Bi_iter>\n    in'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<(const sub_match<_Bi_iter>& __lhs,\n       typename iterator_traits<_Bi_iter>::value_type const& __rhs)\n    {\n      typedef typename sub_match<_Bi_iter>::string_type string_type;\n    '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>(const sub_match<_Bi_iter>& __lhs,\n       typename iterator_traits<_Bi_iter>::value_type const& __rhs)\n    { return __rhs < __lhs; }\n\n\n\n\n\n\n\n  template<typename _Bi_iter>\n    inline b'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator>=(const sub_match<_Bi_iter>& __lhs,\n        typename iterator_traits<_Bi_iter>::value_type const& __rhs)\n    { return !(__lhs < __rhs); }\n\n\n\n\n\n\n\n  template<typename _Bi_iter>\n    inl'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator<=(const sub_match<_Bi_iter>& __lhs,\n        typename iterator_traits<_Bi_iter>::value_type const& __rhs)\n    { return !(__rhs < __lhs); }\n# 1522 "/usr/include/c++/7/bits/regex.h" 3\n '
[#] parse_declaration, is_constructor=False, meet line: 'basic_ostream<_Ch_type, _Ch_traits>&\n    operator<<(basic_ostream<_Ch_type, _Ch_traits>& __os,\n        const sub_match<_Bi_iter>& __m)\n    { return __os << __m.str(); }\n# 1553 "/usr/include/c++/7/bits'
[#] parse_declaration, is_constructor=True, meet line: 'match_results(const _Alloc& __a = _Alloc())\n      : _Base_type(__a)\n      { }\n\n\n\n\n      match_results(const match_results& __rhs) = default;\n\n\n\n\n      match_results(match_results&& __rhs) noexcept = d'
[#] parse_declaration, is_constructor=True, meet line: 'match_results(const match_results& __rhs) = default;\n\n\n\n\n      match_results(match_results&& __rhs) noexcept = default;\n\n\n\n\n      match_results&\n      operator=(const match_results& __rhs) = default;\n'
[#] parse_declaration, is_constructor=True, meet line: 'match_results(match_results&& __rhs) noexcept = default;\n\n\n\n\n      match_results&\n      operator=(const match_results& __rhs) = default;\n\n\n\n\n      match_results&\n      operator=(match_results&& __rhs)'
[#] parse_declaration, is_constructor=True, meet line: 'match_results&\n      operator=(const match_results& __rhs) = default;\n\n\n\n\n      match_results&\n      operator=(match_results&& __rhs) = default;\n\n\n\n\n      ~match_results()\n      { }\n# 1647 "/usr/inclu'
[#] parse_declaration, is_constructor=True, meet line: 'match_results&\n      operator=(match_results&& __rhs) = default;\n\n\n\n\n      ~match_results()\n      { }\n# 1647 "/usr/include/c++/7/bits/regex.h" 3\n      bool ready() const { return !_Base_type::empty();'
[#] parse_declaration, is_constructor=True, meet line: 'match_results()\n      { }\n# 1647 "/usr/include/c++/7/bits/regex.h" 3\n      bool ready() const { return !_Base_type::empty(); }\n# 1663 "/usr/include/c++/7/bits/regex.h" 3\n      size_type\n      size() c'
[#] parse_declaration, is_constructor=False, meet line: 'bool ready() const { return !_Base_type::empty(); }\n# 1663 "/usr/include/c++/7/bits/regex.h" 3\n      size_type\n      size() const\n      { return _Base_type::empty() ? 0 : _Base_type::size() - 3; }\n\n  '
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      size() const\n      { return _Base_type::empty() ? 0 : _Base_type::size() - 3; }\n\n      size_type\n      max_size() const\n      { return _Base_type::max_size(); }\n\n\n\n\n\n\n      bool\n      '
[#] parse_declaration, is_constructor=False, meet line: 'size_type\n      max_size() const\n      { return _Base_type::max_size(); }\n\n\n\n\n\n\n      bool\n      empty() const\n      { return size() == 0; }\n# 1695 "/usr/include/c++/7/bits/regex.h" 3\n      difference'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      empty() const\n      { return size() == 0; }\n# 1695 "/usr/include/c++/7/bits/regex.h" 3\n      difference_type\n      length(size_type __sub = 0) const\n      { return (*this)[__sub].length(); '
[#] parse_declaration, is_constructor=False, meet line: 'difference_type\n      length(size_type __sub = 0) const\n      { return (*this)[__sub].length(); }\n# 1710 "/usr/include/c++/7/bits/regex.h" 3\n      difference_type\n      position(size_type __sub = 0) c'
[#] parse_declaration, is_constructor=False, meet line: 'difference_type\n      position(size_type __sub = 0) const\n      { return std::distance(_M_begin, (*this)[__sub].first); }\n# 1723 "/usr/include/c++/7/bits/regex.h" 3\n      string_type\n      str(size_ty'
[#] parse_declaration, is_constructor=False, meet line: 'string_type\n      str(size_type __sub = 0) const\n      { return string_type((*this)[__sub]); }\n# 1738 "/usr/include/c++/7/bits/regex.h" 3\n      const_reference\n      operator[](size_type __sub) const\n'
[#] parse_declaration, is_constructor=False, meet line: 'const_reference\n      operator[](size_type __sub) const\n      {\n ;\n return __sub < size()\n        ? _Base_type::operator[](__sub)\n        : _M_unmatched_sub();\n      }\n# 1755 "/usr/include/c++/7/bits/'
[#] parse_declaration, is_constructor=False, meet line: 'const_reference\n      prefix() const\n      {\n ;\n return !empty() ? _M_prefix() : _M_unmatched_sub();\n      }\n# 1770 "/usr/include/c++/7/bits/regex.h" 3\n      const_reference\n      suffix() const\n     '
[#] parse_declaration, is_constructor=False, meet line: 'const_reference\n      suffix() const\n      {\n ;\n return !empty() ? _M_suffix() : _M_unmatched_sub();\n      }\n\n\n\n\n      const_iterator\n      begin() const\n      { return _Base_type::begin(); }\n\n\n\n\n    '
[#] parse_declaration, is_constructor=False, meet line: 'const_iterator\n      begin() const\n      { return _Base_type::begin(); }\n\n\n\n\n      const_iterator\n      cbegin() const\n      { return this->begin(); }\n\n\n\n\n      const_iterator\n      end() const\n      '
[#] parse_declaration, is_constructor=False, meet line: 'const_iterator\n      cbegin() const\n      { return this->begin(); }\n\n\n\n\n      const_iterator\n      end() const\n      { return _Base_type::end() - (empty() ? 0 : 3); }\n\n\n\n\n      const_iterator\n      ce'
[#] parse_declaration, is_constructor=False, meet line: 'const_iterator\n      end() const\n      { return _Base_type::end() - (empty() ? 0 : 3); }\n\n\n\n\n      const_iterator\n      cend() const\n      { return this->end(); }\n# 1820 "/usr/include/c++/7/bits/regex'
[#] parse_declaration, is_constructor=False, meet line: 'const_iterator\n      cend() const\n      { return this->end(); }\n# 1820 "/usr/include/c++/7/bits/regex.h" 3\n      template<typename _Out_iter>\n _Out_iter\n format(_Out_iter __out, const char_type* __fmt'
[#] parse_declaration, is_constructor=False, meet line: '_Out_iter\n format(_Out_iter __out, const char_type* __fmt_first,\n        const char_type* __fmt_last,\n        match_flag_type __flags = regex_constants::format_default) const;\n\n\n\n\n      template<typen'
[#] parse_declaration, is_constructor=False, meet line: '_Out_iter\n format(_Out_iter __out, const basic_string<char_type, _St, _Sa>& __fmt,\n        match_flag_type __flags = regex_constants::format_default) const\n {\n   return format(__out, __fmt.data(), __f'
[#] parse_declaration, is_constructor=False, meet line: 'basic_string<char_type, _St, _Sa>\n format(const basic_string<char_type, _St, _Sa>& __fmt,\n        match_flag_type __flags = regex_constants::format_default) const\n {\n   basic_string<char_type, _St, _S'
[#] parse_declaration, is_constructor=False, meet line: 'string_type\n      format(const char_type* __fmt,\n      match_flag_type __flags = regex_constants::format_default) const\n      {\n string_type __result;\n format(std::back_inserter(__result),\n        __f'
[#] parse_declaration, is_constructor=False, meet line: 'allocator_type\n      get_allocator() const\n      { return _Base_type::get_allocator(); }\n# 1890 "/usr/include/c++/7/bits/regex.h" 3\n      void\n      swap(match_results& __that)\n      {\n using std::swa'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      swap(match_results& __that)\n      {\n using std::swap;\n _Base_type::swap(__that);\n swap(_M_begin, __that._M_begin);\n      }\n\n\n    private:\n      template<typename, typename, typename, bool>\n'
[#] parse_declaration, is_constructor=False, meet line: 'bool __detail::\n\n\n\n __regex_algo_impl(_Bp, _Bp, match_results<_Bp, _Ap>&,\n                          const basic_regex<_Cp, _Rp>&,\n                          regex_constants::match_flag_type);\n\n      vo'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_resize(unsigned int __size)\n      { _Base_type::resize(__size + 3); }\n\n      const_reference\n      _M_unmatched_sub() const\n      { return _Base_type::operator[](_Base_type::size() - 3);'
[#] parse_declaration, is_constructor=False, meet line: 'const_reference\n      _M_unmatched_sub() const\n      { return _Base_type::operator[](_Base_type::size() - 3); }\n\n      sub_match<_Bi_iter>&\n      _M_unmatched_sub()\n      { return _Base_type::operator'
[#] parse_declaration, is_constructor=False, meet line: 'sub_match<_Bi_iter>&\n      _M_unmatched_sub()\n      { return _Base_type::operator[](_Base_type::size() - 3); }\n\n      const_reference\n      _M_prefix() const\n      { return _Base_type::operator[](_Bas'
[#] parse_declaration, is_constructor=False, meet line: 'const_reference\n      _M_prefix() const\n      { return _Base_type::operator[](_Base_type::size() - 2); }\n\n      sub_match<_Bi_iter>&\n      _M_prefix()\n      { return _Base_type::operator[](_Base_type:'
[#] parse_declaration, is_constructor=False, meet line: 'sub_match<_Bi_iter>&\n      _M_prefix()\n      { return _Base_type::operator[](_Base_type::size() - 2); }\n\n      const_reference\n      _M_suffix() const\n      { return _Base_type::operator[](_Base_type:'
[#] parse_declaration, is_constructor=False, meet line: 'const_reference\n      _M_suffix() const\n      { return _Base_type::operator[](_Base_type::size() - 1); }\n\n      sub_match<_Bi_iter>&\n      _M_suffix()\n      { return _Base_type::operator[](_Base_type:'
[#] parse_declaration, is_constructor=False, meet line: 'sub_match<_Bi_iter>&\n      _M_suffix()\n      { return _Base_type::operator[](_Base_type::size() - 1); }\n\n      _Bi_iter _M_begin;\n    };\n\n  typedef match_results<const char*> cmatch;\n  typedef match_r'
[#] parse_declaration, is_constructor=False, meet line: '_Bi_iter _M_begin;\n    };\n\n  typedef match_results<const char*> cmatch;\n  typedef match_results<string::const_iterator> smatch;\n\n  typedef match_results<const wchar_t*> wcmatch;\n  typedef match_result'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator==(const match_results<_Bi_iter, _Alloc>& __m1,\n        const match_results<_Bi_iter, _Alloc>& __m2)\n    {\n      if (__m1.ready() != __m2.ready())\n return false;\n      if (!__m1.ready'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    operator!=(const match_results<_Bi_iter, _Alloc>& __m1,\n        const match_results<_Bi_iter, _Alloc>& __m2)\n    { return !(__m1 == __m2); }\n# 1998 "/usr/include/c++/7/bits/regex.h" 3\n  templ'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    swap(match_results<_Bi_iter, _Alloc>& __lhs,\n  match_results<_Bi_iter, _Alloc>& __rhs)\n    { __lhs.swap(__rhs); }\n\n}\n# 2027 "/usr/include/c++/7/bits/regex.h" 3\n  template<typename _Bi_iter, t'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    regex_match(_Bi_iter __s,\n  _Bi_iter __e,\n  match_results<_Bi_iter, _Alloc>& __m,\n  const basic_regex<_Ch_type, _Rx_traits>& __re,\n  regex_constants::match_flag_type __flags\n          = regex'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    regex_match(_Bi_iter __first, _Bi_iter __last,\n  const basic_regex<_Ch_type, _Rx_traits>& __re,\n  regex_constants::match_flag_type __flags\n  = regex_constants::match_default)\n    {\n      matc'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    regex_match(const _Ch_type* __s,\n  match_results<const _Ch_type*, _Alloc>& __m,\n  const basic_regex<_Ch_type, _Rx_traits>& __re,\n  regex_constants::match_flag_type __f\n  = regex_constants::ma'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    regex_match(const basic_string<_Ch_type, _Ch_traits, _Ch_alloc>& __s,\n  match_results<typename basic_string<_Ch_type,\n  _Ch_traits, _Ch_alloc>::const_iterator, _Alloc>& __m,\n  const basic_reg'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    regex_match(const basic_string<_Ch_type, _Ch_traits, _Ch_alloc>&&,\n  match_results<typename basic_string<_Ch_type,\n  _Ch_traits, _Ch_alloc>::const_iterator, _Alloc>&,\n  const basic_regex<_Ch_'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    regex_match(const _Ch_type* __s,\n  const basic_regex<_Ch_type, _Rx_traits>& __re,\n  regex_constants::match_flag_type __f\n  = regex_constants::match_default)\n    { return regex_match(__s, __s '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    regex_match(const basic_string<_Ch_type, _Ch_traits, _Str_allocator>& __s,\n  const basic_regex<_Ch_type, _Rx_traits>& __re,\n  regex_constants::match_flag_type __flags\n  = regex_constants::mat'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    regex_search(_Bi_iter __s, _Bi_iter __e,\n   match_results<_Bi_iter, _Alloc>& __m,\n   const basic_regex<_Ch_type, _Rx_traits>& __re,\n   regex_constants::match_flag_type __flags\n   = regex_cons'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    regex_search(_Bi_iter __first, _Bi_iter __last,\n   const basic_regex<_Ch_type, _Rx_traits>& __re,\n   regex_constants::match_flag_type __flags\n   = regex_constants::match_default)\n    {\n      '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    regex_search(const _Ch_type* __s,\n   match_results<const _Ch_type*, _Alloc>& __m,\n   const basic_regex<_Ch_type, _Rx_traits>& __e,\n   regex_constants::match_flag_type __f\n   = regex_constants'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    regex_search(const _Ch_type* __s,\n   const basic_regex<_Ch_type, _Rx_traits>& __e,\n   regex_constants::match_flag_type __f\n   = regex_constants::match_default)\n    { return regex_search(__s, '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    regex_search(const basic_string<_Ch_type, _Ch_traits,\n   _String_allocator>& __s,\n   const basic_regex<_Ch_type, _Rx_traits>& __e,\n   regex_constants::match_flag_type __flags\n   = regex_const'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    regex_search(const basic_string<_Ch_type, _Ch_traits, _Ch_alloc>& __s,\n   match_results<typename basic_string<_Ch_type,\n   _Ch_traits, _Ch_alloc>::const_iterator, _Alloc>& __m,\n   const basic'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    regex_search(const basic_string<_Ch_type, _Ch_traits, _Ch_alloc>&&,\n   match_results<typename basic_string<_Ch_type,\n   _Ch_traits, _Ch_alloc>::const_iterator, _Alloc>&,\n   const basic_regex<'
[#] parse_declaration, is_constructor=False, meet line: '_Out_iter\n    regex_replace(_Out_iter __out, _Bi_iter __first, _Bi_iter __last,\n    const basic_regex<_Ch_type, _Rx_traits>& __e,\n    const basic_string<_Ch_type, _St, _Sa>& __fmt,\n    regex_constants'
[#] parse_declaration, is_constructor=False, meet line: '_Out_iter\n    regex_replace(_Out_iter __out, _Bi_iter __first, _Bi_iter __last,\n    const basic_regex<_Ch_type, _Rx_traits>& __e,\n    const _Ch_type* __fmt,\n    regex_constants::match_flag_type __flag'
[#] parse_declaration, is_constructor=False, meet line: 'basic_string<_Ch_type, _St, _Sa>\n    regex_replace(const basic_string<_Ch_type, _St, _Sa>& __s,\n    const basic_regex<_Ch_type, _Rx_traits>& __e,\n    const basic_string<_Ch_type, _Fst, _Fsa>& __fmt,\n '
[#] parse_declaration, is_constructor=False, meet line: 'basic_string<_Ch_type, _St, _Sa>\n    regex_replace(const basic_string<_Ch_type, _St, _Sa>& __s,\n    const basic_regex<_Ch_type, _Rx_traits>& __e,\n    const _Ch_type* __fmt,\n    regex_constants::match_'
[#] parse_declaration, is_constructor=False, meet line: 'basic_string<_Ch_type>\n    regex_replace(const _Ch_type* __s,\n    const basic_regex<_Ch_type, _Rx_traits>& __e,\n    const basic_string<_Ch_type, _St, _Sa>& __fmt,\n    regex_constants::match_flag_type '
[#] parse_declaration, is_constructor=False, meet line: 'basic_string<_Ch_type>\n    regex_replace(const _Ch_type* __s,\n    const basic_regex<_Ch_type, _Rx_traits>& __e,\n    const _Ch_type* __fmt,\n    regex_constants::match_flag_type __flags\n    = regex_cons'
[#] parse_declaration, is_constructor=True, meet line: 'regex_iterator()\n      : _M_pregex()\n      { }\n# 2509 "/usr/include/c++/7/bits/regex.h" 3\n      regex_iterator(_Bi_iter __a, _Bi_iter __b, const regex_type& __re,\n       regex_constants::match_flag_ty'
[#] parse_declaration, is_constructor=True, meet line: 'regex_iterator(_Bi_iter __a, _Bi_iter __b, const regex_type& __re,\n       regex_constants::match_flag_type __m\n       = regex_constants::match_default)\n      : _M_begin(__a), _M_end(__b), _M_pregex(&_'
[#] parse_declaration, is_constructor=True, meet line: 'regex_iterator(_Bi_iter, _Bi_iter, const regex_type&&,\n       regex_constants::match_flag_type\n       = regex_constants::match_default) = delete;\n\n\n\n      regex_iterator(const regex_iterator& __rhs) ='
[#] parse_declaration, is_constructor=True, meet line: 'regex_iterator(const regex_iterator& __rhs) = default;\n\n\n\n\n      regex_iterator&\n      operator=(const regex_iterator& __rhs) = default;\n\n\n\n\n      bool\n      operator==(const regex_iterator& __rhs) co'
[#] parse_declaration, is_constructor=True, meet line: 'regex_iterator&\n      operator=(const regex_iterator& __rhs) = default;\n\n\n\n\n      bool\n      operator==(const regex_iterator& __rhs) const;\n\n\n\n\n      bool\n      operator!=(const regex_iterator& __rhs)'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      operator==(const regex_iterator& __rhs) const;\n\n\n\n\n      bool\n      operator!=(const regex_iterator& __rhs) const\n      { return !(*this == __rhs); }\n\n\n\n\n      const value_type&\n      opera'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      operator!=(const regex_iterator& __rhs) const\n      { return !(*this == __rhs); }\n\n\n\n\n      const value_type&\n      operator*() const\n      { return _M_match; }\n\n\n\n\n      const value_type*\n'
[#] parse_declaration, is_constructor=False, meet line: 'value_type&\n      operator*() const\n      { return _M_match; }\n\n\n\n\n      const value_type*\n      operator->() const\n      { return &_M_match; }\n\n\n\n\n      regex_iterator&\n      operator++();\n\n\n\n\n      '
[#] parse_declaration, is_constructor=False, meet line: 'value_type*\n      operator->() const\n      { return &_M_match; }\n\n\n\n\n      regex_iterator&\n      operator++();\n\n\n\n\n      regex_iterator\n      operator++(int)\n      {\n auto __tmp = *this;\n ++(*this);\n '
[#] parse_declaration, is_constructor=True, meet line: 'regex_iterator&\n      operator++();\n\n\n\n\n      regex_iterator\n      operator++(int)\n      {\n auto __tmp = *this;\n ++(*this);\n return __tmp;\n      }\n\n    private:\n      _Bi_iter _M_begin;\n      _Bi_iter'
[#] parse_declaration, is_constructor=True, meet line: 'regex_iterator\n      operator++(int)\n      {\n auto __tmp = *this;\n ++(*this);\n return __tmp;\n      }\n\n    private:\n      _Bi_iter _M_begin;\n      _Bi_iter _M_end;\n      const regex_type* _M_pregex;\n  '
[#] parse_declaration, is_constructor=False, meet line: '_Bi_iter _M_begin;\n      _Bi_iter _M_end;\n      const regex_type* _M_pregex;\n      regex_constants::match_flag_type _M_flags;\n      match_results<_Bi_iter> _M_match;\n    };\n\n  typedef regex_iterator<c'
[#] parse_declaration, is_constructor=False, meet line: '_Bi_iter _M_end;\n      const regex_type* _M_pregex;\n      regex_constants::match_flag_type _M_flags;\n      match_results<_Bi_iter> _M_match;\n    };\n\n  typedef regex_iterator<const char*> cregex_iterat'
[#] parse_declaration, is_constructor=False, meet line: 'regex_type* _M_pregex;\n      regex_constants::match_flag_type _M_flags;\n      match_results<_Bi_iter> _M_match;\n    };\n\n  typedef regex_iterator<const char*> cregex_iterator;\n  typedef regex_iterator<'
[#] parse_declaration, is_constructor=False, meet line: 'regex_constants::match_flag_type _M_flags;\n      match_results<_Bi_iter> _M_match;\n    };\n\n  typedef regex_iterator<const char*> cregex_iterator;\n  typedef regex_iterator<string::const_iterator> srege'
[#] parse_declaration, is_constructor=False, meet line: 'match_results<_Bi_iter> _M_match;\n    };\n\n  typedef regex_iterator<const char*> cregex_iterator;\n  typedef regex_iterator<string::const_iterator> sregex_iterator;\n\n  typedef regex_iterator<const wchar'
[#] parse_declaration, is_constructor=True, meet line: 'regex_token_iterator()\n      : _M_position(), _M_subs(), _M_suffix(), _M_n(0), _M_result(nullptr),\n      _M_has_m1(false)\n      { }\n# 2644 "/usr/include/c++/7/bits/regex.h" 3\n      regex_token_iterato'
[#] parse_declaration, is_constructor=True, meet line: 'regex_token_iterator(_Bi_iter __a, _Bi_iter __b, const regex_type& __re,\n      int __submatch = 0,\n      regex_constants::match_flag_type __m\n      = regex_constants::match_default)\n      : _M_positio'
[#] parse_declaration, is_constructor=True, meet line: 'regex_token_iterator(_Bi_iter __a, _Bi_iter __b,\n      const regex_type& __re,\n      const std::vector<int>& __submatches,\n      regex_constants::match_flag_type __m\n        = regex_constants::match_d'
[#] parse_declaration, is_constructor=True, meet line: 'regex_token_iterator(_Bi_iter __a, _Bi_iter __b,\n      const regex_type& __re,\n      initializer_list<int> __submatches,\n      regex_constants::match_flag_type __m\n        = regex_constants::match_def'
[#] parse_declaration, is_constructor=True, meet line: 'regex_token_iterator(_Bi_iter __a, _Bi_iter __b,\n        const regex_type& __re,\n        const int (&__submatches)[_Nm],\n        regex_constants::match_flag_type __m\n        = regex_constants::match_d'
[#] parse_declaration, is_constructor=True, meet line: 'regex_token_iterator(_Bi_iter, _Bi_iter, const regex_type&&, int = 0,\n      regex_constants::match_flag_type =\n      regex_constants::match_default) = delete;\n      regex_token_iterator(_Bi_iter, _Bi_'
[#] parse_declaration, is_constructor=True, meet line: 'regex_token_iterator(_Bi_iter, _Bi_iter, const regex_type&&,\n      const std::vector<int>&,\n      regex_constants::match_flag_type =\n      regex_constants::match_default) = delete;\n      regex_token_i'
[#] parse_declaration, is_constructor=True, meet line: 'regex_token_iterator(_Bi_iter, _Bi_iter, const regex_type&&,\n      initializer_list<int>,\n      regex_constants::match_flag_type =\n      regex_constants::match_default) = delete;\n      template <std::'
[#] parse_declaration, is_constructor=True, meet line: 'regex_token_iterator(_Bi_iter, _Bi_iter, const regex_type&&,\n        const int (&)[_Nm],\n        regex_constants::match_flag_type =\n        regex_constants::match_default) = delete;\n\n\n\n\n\n      regex_t'
[#] parse_declaration, is_constructor=True, meet line: 'regex_token_iterator(const regex_token_iterator& __rhs)\n      : _M_position(__rhs._M_position), _M_subs(__rhs._M_subs),\n      _M_suffix(__rhs._M_suffix), _M_n(__rhs._M_n), _M_has_m1(__rhs._M_has_m1)\n '
[#] parse_declaration, is_constructor=True, meet line: 'regex_token_iterator&\n      operator=(const regex_token_iterator& __rhs);\n\n\n\n\n      bool\n      operator==(const regex_token_iterator& __rhs) const;\n\n\n\n\n      bool\n      operator!=(const regex_token_it'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      operator==(const regex_token_iterator& __rhs) const;\n\n\n\n\n      bool\n      operator!=(const regex_token_iterator& __rhs) const\n      { return !(*this == __rhs); }\n\n\n\n\n      const value_type&'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      operator!=(const regex_token_iterator& __rhs) const\n      { return !(*this == __rhs); }\n\n\n\n\n      const value_type&\n      operator*() const\n      { return *_M_result; }\n\n\n\n\n      const valu'
[#] parse_declaration, is_constructor=False, meet line: 'value_type&\n      operator*() const\n      { return *_M_result; }\n\n\n\n\n      const value_type*\n      operator->() const\n      { return _M_result; }\n\n\n\n\n      regex_token_iterator&\n      operator++();\n\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'value_type*\n      operator->() const\n      { return _M_result; }\n\n\n\n\n      regex_token_iterator&\n      operator++();\n\n\n\n\n      regex_token_iterator\n      operator++(int)\n      {\n auto __tmp = *this;\n '
[#] parse_declaration, is_constructor=True, meet line: 'regex_token_iterator&\n      operator++();\n\n\n\n\n      regex_token_iterator\n      operator++(int)\n      {\n auto __tmp = *this;\n ++(*this);\n return __tmp;\n      }\n\n    private:\n      typedef regex_iterato'
[#] parse_declaration, is_constructor=True, meet line: 'regex_token_iterator\n      operator++(int)\n      {\n auto __tmp = *this;\n ++(*this);\n return __tmp;\n      }\n\n    private:\n      typedef regex_iterator<_Bi_iter, _Ch_type, _Rx_traits> _Position;\n\n      '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_init(_Bi_iter __a, _Bi_iter __b);\n\n      const value_type&\n      _M_current_match() const\n      {\n if (_M_subs[_M_n] == -1)\n   return (*_M_position).prefix();\n else\n   return (*_M_positi'
[#] parse_declaration, is_constructor=False, meet line: 'value_type&\n      _M_current_match() const\n      {\n if (_M_subs[_M_n] == -1)\n   return (*_M_position).prefix();\n else\n   return (*_M_position)[_M_subs[_M_n]];\n      }\n\n      constexpr bool\n      _M_en'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      _M_end_of_seq() const\n      { return _M_result == nullptr; }\n\n\n      void\n      _M_normalize_result()\n      {\n if (_M_position != _Position())\n   _M_result = &_M_current_match();\n else if ('
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_normalize_result()\n      {\n if (_M_position != _Position())\n   _M_result = &_M_current_match();\n else if (_M_has_m1)\n   _M_result = &_M_suffix;\n else\n   _M_result = nullptr;\n      }\n\n   '
[#] parse_declaration, is_constructor=False, meet line: '_Position _M_position;\n      std::vector<int> _M_subs;\n      value_type _M_suffix;\n      std::size_t _M_n;\n      const value_type* _M_result;\n\n\n      bool _M_has_m1;\n    };\n\n\n  typedef regex_token_ite'
[#] parse_declaration, is_constructor=False, meet line: 'std::vector<int> _M_subs;\n      value_type _M_suffix;\n      std::size_t _M_n;\n      const value_type* _M_result;\n\n\n      bool _M_has_m1;\n    };\n\n\n  typedef regex_token_iterator<const char*> cregex_tok'
[#] parse_declaration, is_constructor=False, meet line: 'value_type _M_suffix;\n      std::size_t _M_n;\n      const value_type* _M_result;\n\n\n      bool _M_has_m1;\n    };\n\n\n  typedef regex_token_iterator<const char*> cregex_token_iterator;\n\n\n  typedef regex_t'
[#] parse_declaration, is_constructor=False, meet line: 'std::size_t _M_n;\n      const value_type* _M_result;\n\n\n      bool _M_has_m1;\n    };\n\n\n  typedef regex_token_iterator<const char*> cregex_token_iterator;\n\n\n  typedef regex_token_iterator<string::const_'
[#] parse_declaration, is_constructor=False, meet line: 'value_type* _M_result;\n\n\n      bool _M_has_m1;\n    };\n\n\n  typedef regex_token_iterator<const char*> cregex_token_iterator;\n\n\n  typedef regex_token_iterator<string::const_iterator> sregex_token_iterato'
[#] parse_declaration, is_constructor=False, meet line: 'bool _M_has_m1;\n    };\n\n\n  typedef regex_token_iterator<const char*> cregex_token_iterator;\n\n\n  typedef regex_token_iterator<string::const_iterator> sregex_token_iterator;\n\n\n\n  typedef regex_token_ite'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    __regex_algo_impl(_BiIter __s,\n        _BiIter __e,\n        match_results<_BiIter, _Alloc>& __m,\n        const basic_regex<_CharT, _TraitsT>& __re,\n        regex_constants::match_flag_type __'
[#] parse_declaration, is_constructor=False, meet line: 'regex_traits<_Ch_type>::string_type\n    regex_traits<_Ch_type>::\n    lookup_collatename(_Fwd_iter __first, _Fwd_iter __last) const\n    {\n      typedef std::ctype<char_type> __ctype_type;\n      const _'
[#] parse_declaration, is_constructor=False, meet line: 'regex_traits<_Ch_type>::char_class_type\n    regex_traits<_Ch_type>::\n    lookup_classname(_Fwd_iter __first, _Fwd_iter __last, bool __icase) const\n    {\n      typedef std::ctype<char_type> __ctype_typ'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    regex_traits<_Ch_type>::\n    isctype(_Ch_type __c, char_class_type __f) const\n    {\n      typedef std::ctype<char_type> __ctype_type;\n      const __ctype_type& __fctyp(use_facet<__ctype_type>'
[#] parse_declaration, is_constructor=False, meet line: 'int\n    regex_traits<_Ch_type>::\n    value(_Ch_type __ch, int __radix) const\n    {\n      std::basic_istringstream<char_type> __is(string_type(1, __ch));\n      long __v;\n      if (__radix == 8)\n __is >'
[#] parse_declaration, is_constructor=False, meet line: '_Out_iter match_results<_Bi_iter, _Alloc>::\n    format(_Out_iter __out,\n    const match_results<_Bi_iter, _Alloc>::char_type* __fmt_first,\n    const match_results<_Bi_iter, _Alloc>::char_type* __fmt_l'
[#] parse_declaration, is_constructor=False, meet line: '_Out_iter\n    regex_replace(_Out_iter __out, _Bi_iter __first, _Bi_iter __last,\n    const basic_regex<_Ch_type, _Rx_traits>& __e,\n    const _Ch_type* __fmt,\n    regex_constants::match_flag_type __flag'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    regex_iterator<_Bi_iter, _Ch_type, _Rx_traits>::\n    operator==(const regex_iterator& __rhs) const\n    {\n      if (_M_pregex == nullptr && __rhs._M_pregex == nullptr)\n return true;\n      retu'
[#] parse_declaration, is_constructor=False, meet line: 'regex_iterator<_Bi_iter, _Ch_type, _Rx_traits>&\n    regex_iterator<_Bi_iter, _Ch_type, _Rx_traits>::\n    operator++()\n    {\n\n\n\n\n\n\n      if (_M_match[0].matched)\n {\n   auto __start = _M_match[0].second'
[#] parse_declaration, is_constructor=False, meet line: 'regex_token_iterator<_Bi_iter, _Ch_type, _Rx_traits>&\n    regex_token_iterator<_Bi_iter, _Ch_type, _Rx_traits>::\n    operator=(const regex_token_iterator& __rhs)\n    {\n      _M_position = __rhs._M_pos'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n    regex_token_iterator<_Bi_iter, _Ch_type, _Rx_traits>::\n    operator==(const regex_token_iterator& __rhs) const\n    {\n      if (_M_end_of_seq() && __rhs._M_end_of_seq())\n return true;\n      if'
[#] parse_declaration, is_constructor=False, meet line: 'regex_token_iterator<_Bi_iter, _Ch_type, _Rx_traits>&\n    regex_token_iterator<_Bi_iter, _Ch_type, _Rx_traits>::\n    operator++()\n    {\n      _Position __prev = _M_position;\n      if (_M_suffix.matche'
[#] parse_declaration, is_constructor=False, meet line: 'void\n    regex_token_iterator<_Bi_iter, _Ch_type, _Rx_traits>::\n    _M_init(_Bi_iter __a, _Bi_iter __b)\n    {\n      _M_has_m1 = false;\n      for (auto __it : _M_subs)\n if (__it == -1)\n   {\n     _M_has'
[#] parse_declaration, is_constructor=True, meet line: '_Executor(_BiIter __begin,\n  _BiIter __end,\n  _ResultsVec& __results,\n  const _RegexT& __re,\n  _FlagT __flags)\n      : _M_begin(__begin),\n      _M_end(__end),\n      _M_re(__re),\n      _M_nfa(*__re._M_'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      _M_match()\n      {\n _M_current = _M_begin;\n return _M_main(_Match_mode::_Exact);\n      }\n\n\n      bool\n      _M_search_from_first()\n      {\n _M_current = _M_begin;\n return _M_main(_Match_mod'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      _M_search_from_first()\n      {\n _M_current = _M_begin;\n return _M_main(_Match_mode::_Prefix);\n      }\n\n      bool\n      _M_search();\n\n    private:\n      void\n      _M_rep_once_more(_Match_m'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      _M_search();\n\n    private:\n      void\n      _M_rep_once_more(_Match_mode __match_mode, _StateIdT);\n\n      void\n      _M_handle_repeat(_Match_mode, _StateIdT);\n\n      void\n      _M_handle_su'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_rep_once_more(_Match_mode __match_mode, _StateIdT);\n\n      void\n      _M_handle_repeat(_Match_mode, _StateIdT);\n\n      void\n      _M_handle_subexpr_begin(_Match_mode, _StateIdT);\n\n      '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_handle_repeat(_Match_mode, _StateIdT);\n\n      void\n      _M_handle_subexpr_begin(_Match_mode, _StateIdT);\n\n      void\n      _M_handle_subexpr_end(_Match_mode, _StateIdT);\n\n      void\n   '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_handle_subexpr_begin(_Match_mode, _StateIdT);\n\n      void\n      _M_handle_subexpr_end(_Match_mode, _StateIdT);\n\n      void\n      _M_handle_line_begin_assertion(_Match_mode, _StateIdT);\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_handle_subexpr_end(_Match_mode, _StateIdT);\n\n      void\n      _M_handle_line_begin_assertion(_Match_mode, _StateIdT);\n\n      void\n      _M_handle_line_end_assertion(_Match_mode, _StateId'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_handle_line_begin_assertion(_Match_mode, _StateIdT);\n\n      void\n      _M_handle_line_end_assertion(_Match_mode, _StateIdT);\n\n      void\n      _M_handle_word_boundary(_Match_mode, _State'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_handle_line_end_assertion(_Match_mode, _StateIdT);\n\n      void\n      _M_handle_word_boundary(_Match_mode, _StateIdT);\n\n      void\n      _M_handle_subexpr_lookahead(_Match_mode, _StateIdT'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_handle_word_boundary(_Match_mode, _StateIdT);\n\n      void\n      _M_handle_subexpr_lookahead(_Match_mode, _StateIdT);\n\n      void\n      _M_handle_match(_Match_mode, _StateIdT);\n\n      voi'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_handle_subexpr_lookahead(_Match_mode, _StateIdT);\n\n      void\n      _M_handle_match(_Match_mode, _StateIdT);\n\n      void\n      _M_handle_backref(_Match_mode, _StateIdT);\n\n      void\n    '
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_handle_match(_Match_mode, _StateIdT);\n\n      void\n      _M_handle_backref(_Match_mode, _StateIdT);\n\n      void\n      _M_handle_accept(_Match_mode, _StateIdT);\n\n      void\n      _M_handle'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_handle_backref(_Match_mode, _StateIdT);\n\n      void\n      _M_handle_accept(_Match_mode, _StateIdT);\n\n      void\n      _M_handle_alternative(_Match_mode, _StateIdT);\n\n      void\n      _M_'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_handle_accept(_Match_mode, _StateIdT);\n\n      void\n      _M_handle_alternative(_Match_mode, _StateIdT);\n\n      void\n      _M_dfs(_Match_mode __match_mode, _StateIdT __start);\n\n      bool'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_handle_alternative(_Match_mode, _StateIdT);\n\n      void\n      _M_dfs(_Match_mode __match_mode, _StateIdT __start);\n\n      bool\n      _M_main(_Match_mode __match_mode)\n      { return _M_m'
[#] parse_declaration, is_constructor=False, meet line: 'void\n      _M_dfs(_Match_mode __match_mode, _StateIdT __start);\n\n      bool\n      _M_main(_Match_mode __match_mode)\n      { return _M_main_dispatch(__match_mode, __search_mode{}); }\n\n      bool\n      '
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      _M_main(_Match_mode __match_mode)\n      { return _M_main_dispatch(__match_mode, __search_mode{}); }\n\n      bool\n      _M_main_dispatch(_Match_mode __match_mode, __dfs);\n\n      bool\n      _M'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      _M_main_dispatch(_Match_mode __match_mode, __dfs);\n\n      bool\n      _M_main_dispatch(_Match_mode __match_mode, __bfs);\n\n      bool\n      _M_is_word(_CharT __ch) const\n      {\n static const'
[#] parse_declaration, is_constructor=False, meet line: "bool\n      _M_main_dispatch(_Match_mode __match_mode, __bfs);\n\n      bool\n      _M_is_word(_CharT __ch) const\n      {\n static const _CharT __s[2] = { 'w' };\n return _M_re._M_automaton->_M_traits.iscty"
[#] parse_declaration, is_constructor=False, meet line: "bool\n      _M_is_word(_CharT __ch) const\n      {\n static const _CharT __s[2] = { 'w' };\n return _M_re._M_automaton->_M_traits.isctype\n   (__ch, _M_re._M_automaton->_M_traits.lookup_classname(__s, __s+"
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      _M_at_begin() const\n      {\n return _M_current == _M_begin\n   && !(_M_flags & (regex_constants::match_not_bol\n      | regex_constants::match_prev_avail));\n      }\n\n      bool\n      _M_at_en'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      _M_at_end() const\n      {\n return _M_current == _M_end\n   && !(_M_flags & regex_constants::match_not_eol);\n      }\n\n      bool\n      _M_word_boundary() const;\n\n      bool\n      _M_lookahead'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      _M_word_boundary() const;\n\n      bool\n      _M_lookahead(_StateIdT __next);\n\n\n      template<typename _SearchMode, typename _ResultsVec>\n struct _State_info;\n\n      template<typename _Resul'
[#] parse_declaration, is_constructor=False, meet line: 'bool\n      _M_lookahead(_StateIdT __next);\n\n\n      template<typename _SearchMode, typename _ResultsVec>\n struct _State_info;\n\n      template<typename _ResultsVec>\n struct _State_info<__bfs, _ResultsVe'
[#] parse_declaration, is_constructor=True, meet line: '_State_info(_StateIdT __start, size_t __n)\n   : _M_visited_states(new bool[__n]()), _M_start(__start)\n   { }\n\n   bool _M_visited(_StateIdT __i)\n   {\n     if (_M_visited_states[__i])\n       return true'
[#] parse_declaration, is_constructor=False, meet line: 'bool _M_visited(_StateIdT __i)\n   {\n     if (_M_visited_states[__i])\n       return true;\n     _M_visited_states[__i] = true;\n     return false;\n   }\n\n   void _M_queue(_StateIdT __i, const _ResultsVec&'
[#] parse_declaration, is_constructor=False, meet line: 'void _M_queue(_StateIdT __i, const _ResultsVec& __res)\n   { _M_match_queue.emplace_back(__i, __res); }\n\n\n   _BiIter* _M_get_sol_pos() { return nullptr; }\n\n\n   vector<pair<_StateIdT, _ResultsVec>> _M_m'
[#] parse_declaration, is_constructor=False, meet line: '_BiIter* _M_get_sol_pos() { return nullptr; }\n\n\n   vector<pair<_StateIdT, _ResultsVec>> _M_match_queue;\n\n   unique_ptr<bool[]> _M_visited_states;\n\n   _StateIdT _M_start;\n };\n\n      template<typename _'
[#] parse_declaration, is_constructor=False, meet line: 'vector<pair<_StateIdT, _ResultsVec>> _M_match_queue;\n\n   unique_ptr<bool[]> _M_visited_states;\n\n   _StateIdT _M_start;\n };\n\n      template<typename _ResultsVec>\n struct _State_info<__dfs, _ResultsVec>'
[#] parse_declaration, is_constructor=False, meet line: 'unique_ptr<bool[]> _M_visited_states;\n\n   _StateIdT _M_start;\n };\n\n      template<typename _ResultsVec>\n struct _State_info<__dfs, _ResultsVec>\n {\n   explicit\n   _State_info(_StateIdT __start, size_t)'
[#] parse_declaration, is_constructor=False, meet line: '_StateIdT _M_start;\n };\n\n      template<typename _ResultsVec>\n struct _State_info<__dfs, _ResultsVec>\n {\n   explicit\n   _State_info(_StateIdT __start, size_t) : _M_start(__start)\n   { }\n\n\n   bool _M_v'
[#] parse_declaration, is_constructor=True, meet line: '_State_info(_StateIdT __start, size_t) : _M_start(__start)\n   { }\n\n\n   bool _M_visited(_StateIdT) const { return false; }\n   void _M_queue(_StateIdT, const _ResultsVec&) { }\n\n   _BiIter* _M_get_sol_po'
[#] parse_declaration, is_constructor=False, meet line: 'bool _M_visited(_StateIdT) const { return false; }\n   void _M_queue(_StateIdT, const _ResultsVec&) { }\n\n   _BiIter* _M_get_sol_pos() { return &_M_sol_pos; }\n\n\n   _StateIdT _M_start;\n   _BiIter _M_sol_'
[#] parse_declaration, is_constructor=False, meet line: 'void _M_queue(_StateIdT, const _ResultsVec&) { }\n\n   _BiIter* _M_get_sol_pos() { return &_M_sol_pos; }\n\n\n   _StateIdT _M_start;\n   _BiIter _M_sol_pos;\n };\n\n    public:\n      _ResultsVec _M_cur_results'
[#] parse_declaration, is_constructor=False, meet line: '_BiIter* _M_get_sol_pos() { return &_M_sol_pos; }\n\n\n   _StateIdT _M_start;\n   _BiIter _M_sol_pos;\n };\n\n    public:\n      _ResultsVec _M_cur_results;\n      _BiIter _M_current;\n      _BiIter _M_begin;\n '
[#] parse_declaration, is_constructor=False, meet line: '_StateIdT _M_start;\n   _BiIter _M_sol_pos;\n };\n\n    public:\n      _ResultsVec _M_cur_results;\n      _BiIter _M_current;\n      _BiIter _M_begin;\n      const _BiIter _M_end;\n      const _RegexT& _M_re;\n'
[#] parse_declaration, is_constructor=False, meet line: '_BiIter _M_sol_pos;\n };\n\n    public:\n      _ResultsVec _M_cur_results;\n      _BiIter _M_current;\n      _BiIter _M_begin;\n      const _BiIter _M_end;\n      const _RegexT& _M_re;\n      const _NFAT& _M_n'
[#] parse_declaration, is_constructor=False, meet line: '_ResultsVec _M_cur_results;\n      _BiIter _M_current;\n      _BiIter _M_begin;\n      const _BiIter _M_end;\n      const _RegexT& _M_re;\n      const _NFAT& _M_nfa;\n      _ResultsVec& _M_results;\n      ve'
[#] parse_declaration, is_constructor=False, meet line: '_BiIter _M_current;\n      _BiIter _M_begin;\n      const _BiIter _M_end;\n      const _RegexT& _M_re;\n      const _NFAT& _M_nfa;\n      _ResultsVec& _M_results;\n      vector<pair<_BiIter, int>> _M_rep_co'
[#] parse_declaration, is_constructor=False, meet line: '_BiIter _M_begin;\n      const _BiIter _M_end;\n      const _RegexT& _M_re;\n      const _NFAT& _M_nfa;\n      _ResultsVec& _M_results;\n      vector<pair<_BiIter, int>> _M_rep_count;\n      _State_info<__s'
[#] parse_declaration, is_constructor=False, meet line: '_BiIter _M_end;\n      const _RegexT& _M_re;\n      const _NFAT& _M_nfa;\n      _ResultsVec& _M_results;\n      vector<pair<_BiIter, int>> _M_rep_count;\n      _State_info<__search_mode, _ResultsVec> _M_st'
[#] parse_declaration, is_constructor=False, meet line: '_RegexT& _M_re;\n      const _NFAT& _M_nfa;\n      _ResultsVec& _M_results;\n      vector<pair<_BiIter, int>> _M_rep_count;\n      _State_info<__search_mode, _ResultsVec> _M_states;\n      _FlagT _M_flags;'
[#] parse_declaration, is_constructor=False, meet line: '_NFAT& _M_nfa;\n      _ResultsVec& _M_results;\n      vector<pair<_BiIter, int>> _M_rep_count;\n      _State_info<__search_mode, _ResultsVec> _M_states;\n      _FlagT _M_flags;\n\n      bool _M_has_sol;\n   '
[#] parse_declaration, is_constructor=False, meet line: '_ResultsVec& _M_results;\n      vector<pair<_BiIter, int>> _M_rep_count;\n      _State_info<__search_mode, _ResultsVec> _M_states;\n      _FlagT _M_flags;\n\n      bool _M_has_sol;\n    };\n\n\n\n}\n}\n\n# 1 "/usr'
[#] parse_declaration, is_constructor=False, meet line: 'vector<pair<_BiIter, int>> _M_rep_count;\n      _State_info<__search_mode, _ResultsVec> _M_states;\n      _FlagT _M_flags;\n\n      bool _M_has_sol;\n    };\n\n\n\n}\n}\n\n# 1 "/usr/include/c++/7/bits/regex_execu'
[#] parse_declaration, is_constructor=False, meet line: '_State_info<__search_mode, _ResultsVec> _M_states;\n      _FlagT _M_flags;\n\n      bool _M_has_sol;\n    };\n\n\n\n}\n}\n\n# 1 "/usr/include/c++/7/bits/regex_executor.tcc" 1 3\n# 31 "/usr/include/c++/7/bits/rege'
[#] parse_declaration, is_constructor=False, meet line: '_FlagT _M_flags;\n\n      bool _M_has_sol;\n    };\n\n\n\n}\n}\n\n# 1 "/usr/include/c++/7/bits/regex_executor.tcc" 1 3\n# 31 "/usr/include/c++/7/bits/regex_executor.tcc" 3\nnamespace std __attribute__ ((__visibil'
[#] parse_declaration, is_constructor=False, meet line: 'bool _M_has_sol;\n    };\n\n\n\n}\n}\n\n# 1 "/usr/include/c++/7/bits/regex_executor.tcc" 1 3\n# 31 "/usr/include/c++/7/bits/regex_executor.tcc" 3\nnamespace std __attribute__ ((__visibility__ ("default")))\n{\nna'
[#] parse_declaration, is_constructor=False, meet line: 'bool _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::\n    _M_search()\n    {\n      if (_M_search_from_first())\n return true;\n      if (_M_flags & regex_constants::match_continuous)\n return false;\n   '
[#] parse_declaration, is_constructor=False, meet line: 'bool _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::\n    _M_main_dispatch(_Match_mode __match_mode, __dfs)\n    {\n      _M_has_sol = false;\n      *_M_states._M_get_sol_pos() = _BiIter();\n      _M_cu'
[#] parse_declaration, is_constructor=False, meet line: 'bool _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::\n    _M_main_dispatch(_Match_mode __match_mode, __bfs)\n    {\n      _M_states._M_queue(_M_states._M_start, _M_results);\n      bool __ret = false;\n'
[#] parse_declaration, is_constructor=False, meet line: 'bool _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::\n    _M_lookahead(_StateIdT __next)\n    {\n\n\n\n      _ResultsVec __what(_M_cur_results);\n      _Executor __sub(_M_current, _M_end, __what, _M_re, _'
[#] parse_declaration, is_constructor=False, meet line: 'void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::\n    _M_rep_once_more(_Match_mode __match_mode, _StateIdT __i)\n    {\n      const auto& __state = _M_nfa[__i];\n      auto& __rep_count = _M_rep_co'
[#] parse_declaration, is_constructor=False, meet line: 'void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::\n    _M_handle_repeat(_Match_mode __match_mode, _StateIdT __i)\n    {\n      const auto& __state = _M_nfa[__i];\n\n\n      if (!__state._M_neg)\n {\n   '
[#] parse_declaration, is_constructor=False, meet line: 'void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::\n    _M_handle_subexpr_begin(_Match_mode __match_mode, _StateIdT __i)\n    {\n      const auto& __state = _M_nfa[__i];\n\n      auto& __res = _M_cur_'
[#] parse_declaration, is_constructor=False, meet line: 'void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::\n    _M_handle_subexpr_end(_Match_mode __match_mode, _StateIdT __i)\n    {\n      const auto& __state = _M_nfa[__i];\n\n      auto& __res = _M_cur_re'
[#] parse_declaration, is_constructor=False, meet line: 'void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::\n    _M_handle_line_begin_assertion(_Match_mode __match_mode, _StateIdT __i)\n    {\n      const auto& __state = _M_nfa[__i];\n      if (_M_at_begin'
[#] parse_declaration, is_constructor=False, meet line: 'void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::\n    _M_handle_line_end_assertion(_Match_mode __match_mode, _StateIdT __i)\n    {\n      const auto& __state = _M_nfa[__i];\n      if (_M_at_end())\n'
[#] parse_declaration, is_constructor=False, meet line: 'void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::\n    _M_handle_word_boundary(_Match_mode __match_mode, _StateIdT __i)\n    {\n      const auto& __state = _M_nfa[__i];\n      if (_M_word_boundary()'
[#] parse_declaration, is_constructor=False, meet line: 'void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::\n    _M_handle_subexpr_lookahead(_Match_mode __match_mode, _StateIdT __i)\n    {\n      const auto& __state = _M_nfa[__i];\n      if (_M_lookahead(_'
[#] parse_declaration, is_constructor=False, meet line: 'void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::\n    _M_handle_match(_Match_mode __match_mode, _StateIdT __i)\n    {\n      const auto& __state = _M_nfa[__i];\n\n      if (_M_current == _M_end)\n re'
[#] parse_declaration, is_constructor=False, meet line: 'void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::\n    _M_handle_backref(_Match_mode __match_mode, _StateIdT __i)\n    {\n      ;\n\n      const auto& __state = _M_nfa[__i];\n      auto& __submatch = '
[#] parse_declaration, is_constructor=False, meet line: 'void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::\n    _M_handle_accept(_Match_mode __match_mode, _StateIdT __i)\n    {\n      if (__dfs_mode)\n {\n   ;\n   if (__match_mode == _Match_mode::_Exact)\n  '
[#] parse_declaration, is_constructor=False, meet line: 'void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::\n    _M_handle_alternative(_Match_mode __match_mode, _StateIdT __i)\n    {\n      const auto& __state = _M_nfa[__i];\n\n      if (_M_nfa._M_flags & r'
[#] parse_declaration, is_constructor=False, meet line: 'void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::\n    _M_dfs(_Match_mode __match_mode, _StateIdT __i)\n    {\n      if (_M_states._M_visited(__i))\n return;\n\n      switch (_M_nfa[__i]._M_opcode())\n'
[#] parse_declaration, is_constructor=False, meet line: 'bool _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::\n    _M_word_boundary() const\n    {\n      if (_M_current == _M_begin && (_M_flags & regex_constants::match_not_bow))\n return false;\n      if (_M_'
[#] parse_declaration, is_constructor=False, meet line: 'istream cin;\n  extern ostream cout;\n  extern ostream cerr;\n  extern ostream clog;\n\n\n  extern wistream wcin;\n  extern wostream wcout;\n  extern wostream wcerr;\n  extern wostream wclog;\n\n\n\n\n  static ios_'
[#] parse_declaration, is_constructor=False, meet line: 'ostream cout;\n  extern ostream cerr;\n  extern ostream clog;\n\n\n  extern wistream wcin;\n  extern wostream wcout;\n  extern wostream wcerr;\n  extern wostream wclog;\n\n\n\n\n  static ios_base::Init __ioinit;\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'ostream cerr;\n  extern ostream clog;\n\n\n  extern wistream wcin;\n  extern wostream wcout;\n  extern wostream wcerr;\n  extern wostream wclog;\n\n\n\n\n  static ios_base::Init __ioinit;\n\n\n}\n# 4 "test_re.cc" 2\n\n'
[#] parse_declaration, is_constructor=False, meet line: 'ostream clog;\n\n\n  extern wistream wcin;\n  extern wostream wcout;\n  extern wostream wcerr;\n  extern wostream wclog;\n\n\n\n\n  static ios_base::Init __ioinit;\n\n\n}\n# 4 "test_re.cc" 2\n\n\n# 5 "test_re.cc"\nusing'
[#] parse_declaration, is_constructor=False, meet line: 'wistream wcin;\n  extern wostream wcout;\n  extern wostream wcerr;\n  extern wostream wclog;\n\n\n\n\n  static ios_base::Init __ioinit;\n\n\n}\n# 4 "test_re.cc" 2\n\n\n# 5 "test_re.cc"\nusing namespace std;\nint Clean'
[#] parse_declaration, is_constructor=False, meet line: 'wostream wcout;\n  extern wostream wcerr;\n  extern wostream wclog;\n\n\n\n\n  static ios_base::Init __ioinit;\n\n\n}\n# 4 "test_re.cc" 2\n\n\n# 5 "test_re.cc"\nusing namespace std;\nint CleanHtmlTag(const std::strin'
[#] parse_declaration, is_constructor=False, meet line: 'wostream wcerr;\n  extern wostream wclog;\n\n\n\n\n  static ios_base::Init __ioinit;\n\n\n}\n# 4 "test_re.cc" 2\n\n\n# 5 "test_re.cc"\nusing namespace std;\nint CleanHtmlTag(const std::string& s, std::string* out);\n'
[#] parse_declaration, is_constructor=False, meet line: 'wostream wclog;\n\n\n\n\n  static ios_base::Init __ioinit;\n\n\n}\n# 4 "test_re.cc" 2\n\n\n# 5 "test_re.cc"\nusing namespace std;\nint CleanHtmlTag(const std::string& s, std::string* out);\nint CleanWhite(const std:'
[#] parse_declaration, is_constructor=False, meet line: 'ios_base::Init __ioinit;\n\n\n}\n# 4 "test_re.cc" 2\n\n\n# 5 "test_re.cc"\nusing namespace std;\nint CleanHtmlTag(const std::string& s, std::string* out);\nint CleanWhite(const std::string& s, std::string* out)'
[#] parse_declaration, is_constructor=False, meet line: 'int CleanHtmlTag(const std::string& s, std::string* out);\nint CleanWhite(const std::string& s, std::string* out);\nint main()\n{\n  string s;\n  getline(cin, s);\n  CleanHtmlTag(s, &s);\n  CleanWhite(s, &s)'
[#] parse_declaration, is_constructor=False, meet line: 'int CleanWhite(const std::string& s, std::string* out);\nint main()\n{\n  string s;\n  getline(cin, s);\n  CleanHtmlTag(s, &s);\n  CleanWhite(s, &s);\n  cout << s << endl;\n\n}\nint CleanHtmlTag(const std::stri'
[#] parse_declaration, is_constructor=False, meet line: 'int main()\n{\n  string s;\n  getline(cin, s);\n  CleanHtmlTag(s, &s);\n  CleanWhite(s, &s);\n  cout << s << endl;\n\n}\nint CleanHtmlTag(const std::string& s, std::string* out) {\n\n    static std::regex expr{"'
[#] parse_declaration, is_constructor=False, meet line: 'int CleanHtmlTag(const std::string& s, std::string* out) {\n\n    static std::regex expr{"<.*?>|\\\\$Dyn\\\\@miC\\\\$"};\n    static std::string fmt{""};\n    *out = std::regex_replace(s, expr, fmt);\n    return'
[#] parse_declaration, is_constructor=False, meet line: 'int CleanWhite(const std::string& s, std::string* out) {\n    static std::regex expr{"(\\\\s|&nbsp;|&quot;)+"};\n    static std::string fmt{" "};\n    *out = std::regex_replace(s, expr, fmt);\n    return 0;'
